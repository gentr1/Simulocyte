<div class='container'>
<br><br>
	<h1>Metabolic network Editor</h1>
	<hr>
	<h2>Name: <%= mtn.name %> </h2>
	
	<h2>Comment: </h2>
	
	<%= mtn.comment %>
	<hr>
	<a href="/metabolic_net/show/<%= mtn.id %>" class="btn btn-sm btn-success">Back to Metabolic Network</a>
	<hr>
	<%var data=[];
	_.each(mtn.file, function(compartment) {
		data.push(compartment);
	%>
		
	<%});
	
	%>

	<nav>
		<a href="" id="menuToggle" title="show menu">
		<span class="navClosed"><i>show menu</i></span>
		</a>
		<a href="#" title="Item 1">Hide/Show</a>
		<button class="btn btn-default btn-xs" title="Make metabolic network lines invisible/visible" id="view4" style="position: relative;left: 20px;">Lines</button>
		<button class="btn btn-default btn-xs" title="Hide/show tokens (if problem, just refresh the page)" id="view5" style="position: relative;left: 20px;">Token</button>
		<br><p style="position: relative;left: 20px;color:white">Line Opacity: <input id="defaultSlider" type="range" min="0" max="100" value="25" onchange="updateSlider(this.value)" style="position: relative;left: 20px"/></p>
		
		
		<a href="#" title="Item 2">Layout</a>
		<p style="position: relative;left: 20px;color:white">Choose Layout: <select name="select" id="selectLayout" onchange="selectValue(this)">
		  <option value="default" selected>Default</option> 
		  <option value="kegg map">Kegg Map</option> 
		</select></p>
		<button class="btn btn-default btn-xs" title="Explode metabolic network by compartment (if problem, just refresh the page)" id="view2" style="position: relative;left: 20px;">explode</button>
		<button class="btn btn-default btn-xs" title="Put back initial view (if problem, just refresh the page)" id="view1" style="position: relative;left: 20px;">flatten</button>
	</nav>
	
	<div id="menu" >
	
	
	
	
	
	
	
	
	
	</div>
	<div id="container"  style="position: absolute;left: 0px; overflow: inherit">  </div>
	
	<div id="compTable" style="position: absolute;left: 20px;"></div>	
	<div id="layout1menu" class="btn-group-vertical" role="group" aria-label="..." style="position: absolute;left: 0px;">
		<button class="btn btn-default btn-xs" title="Merge" id="b_merge" style="position: relative;left: 20px;">Merge</button>
		<button class="btn btn-default btn-xs" title="Stack above" id="b_above" style="position: relative;left: 20px;">Place Above</button>
		<button class="btn btn-default btn-xs" title="Stack below" id="b_below" style="position: relative;left: 20px;">Place Below</button>
		<button class="btn btn-default btn-xs" title="Add as Inner Circle" id="b_inner" style="position: relative;left: 20px;">Add as Inner</button>
		<button class="btn btn-default btn-xs" title="Add as Outer Circle" id="b_outer" style="position: relative;left: 20px;">Add as Outer</button>
		<button class="btn btn-default btn-xs" title="Add as Satellite" id="b_satellite" style="position: relative;left: 20px;">Add as Satellite</button>
		<button class="btn btn-default btn-xs" title="Add as Subset" id="b_subset" style="position: relative;left: 20px;">Add as Subset</button>
		<button class="btn btn-warning btn-xs" title="Cancel" id="b_cancel" style="position: relative;left: 20px;">Cancel</button>
	</div>
	<script id="fragmentShader" type="x-shader/x-fragment">
			
			varying vec2 vUv;

			#define FB_ZOOM 0.075
			#define BEAM_WIDTH 0.0005

			void main(void)
			{
				float t = 0.0;
				float intensity = BEAM_WIDTH;
				vec2 unit = vec2(cos(t), sin(t));
				float aspect = 0.5;
				vec2 position = vUv;
				//position.y *= resolution.y / resolution.x;
				vec2 ms = vec2(0.5, 0.5);
				//ms.y *= resolution.y / resolution.x;
				vec2 uv = ((gl_FragCoord.xy ) - vec2(0.5)) * FB_ZOOM + vec2(0.5);
				float f = 0.0;

				f += intensity / abs(dot(position - ms, unit));
				f += intensity / abs(dot(position - ms, vec2(unit.y, -unit.x)));
				f += intensity / abs(dot(position - ms, vec2(2.0*ms.x, -unit.x)));
				f += intensity / abs(dot(position - ms, vec2(-2.0*ms.x, -unit.x)));
				f += intensity / abs(0.3 - length(position - ms));
				f += intensity / abs(0.2 - length(position - ms));
				f += intensity / abs(0.1 - length(position - ms));
				
				gl_FragColor = vec4(f * 1.0, f * 0.0, f * 0., 0.3);
			}

	</script>
	
	<script id="vertexShader" type="x-shader/x-vertex">

			varying vec2 vUv;

			void main()
			{
				vUv = uv;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
			}

		</script>
	
	<script>
		
		(function($){
			$(document).ready(function(){
			$('#menuToggle').click(function(e){
			var $parent = $(this).parent('nav');
			$parent.toggleClass("open");
			var navState = $parent.hasClass('open') ? "hide" : "show";
			$(this).attr("title", navState + " navigation");
			// Set the timeout to the animation length in the CSS.
			setTimeout(function(){
			//console.log("timeout set");
			$('#menuToggle > span').toggleClass("navClosed").toggleClass("navOpen");
			}, 200);
			e.preventDefault();
			});
			});
			})(jQuery);
		
		$('#layout1menu').hide();
		$('#layout1menu').zIndex(2000);
		var stopThreeJsMouseEvent = false;	
		var initialPos=new THREE.Vector3( 0, 0, 0 );
		var initialName="";
		var spacing=100;
		var radiusComp=40;
		
		var selectedMetabolicData = <%-JSON.stringify(data)%>
		//console.log("getting metabolic data from default file recon2");
		var listCompartments=selectedMetabolicData[0];
		var txtComp=[]
		var maxNbComp=20;
		var compLayout={"merged":[],"above":[], "outer":[], "satellite":[], "in":[]};
		
		//console.log(listCompartments.length)
		for (var i=0;i<maxNbComp;i++){
			txtComp[i] = document.createElement('div');
			txtComp[i].style.position = 'absolute';
			txtComp[i].style.width = 100;
			txtComp[i].style.height = 100;
			txtComp[i].style.color = "black";
			txtComp[i].style.fontSize="xx-small";
			txtComp[i].id = "txt"+i;
			//txtComp[i].style.fontWeight="1900";
			txtComp[i].style.backgroundColor = "#99FFCC";
			txtComp[i].style.opacity = 0.5;
			//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
			txtComp[i].innerHTML = 'hello ';
			txtComp[i].style.top = 4000 + 'px';
			txtComp[i].style.left = 4000 + 'px';
			txtComp[i].style.zIndex = 1000;
			txtComp[i].className="disabled";
			//txtComp[i].style="cursor: none"
			//txtComp[i].pointer-events:none;
			document.body.appendChild(txtComp[i]);
			
		}
		
		var container, stats;
			var camera, controls, scene, renderer, uniforms;
			var objects = [], plane;

			var mouse = new THREE.Vector2(),
			offset = new THREE.Vector3(),
			INTERSECTED,INTERSECTED2, SELECTED;

			init();
			animate();
			function toXYCoords (pos) {
				//var vector = projector.projectVector(pos.clone(), camera);
				
				var vector = pos.clone().project(camera);//projector.projectVector(pos.clone(), camera);
				vector.x = (vector.x + 1)/2 * window.innerWidth;
				vector.y = -(vector.y - 1)/2 * window.innerHeight;
				return vector;
			}
			function init() {

				container = document.getElementById( 'container' );
				//document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = -800;
				camera.position.y = 500;
				//camera.position.x = -800;
				
				
				

				scene = new THREE.Scene();

				scene.add( new THREE.AmbientLight( 0xffffff,2.5 ) );

				var light = new THREE.SpotLight( 0xffffff, 2.5 );
				light.position.set( 0, 500, 2000 );
				light.castShadow = true;

				light.shadowCameraNear = 200;
				light.shadowCameraFar = camera.far;
				light.shadowCameraFov = 50;

				light.shadowBias = -0.00022;
				light.shadowDarkness = 0.5;

				light.shadowMapWidth = 2048;
				light.shadowMapHeight = 2048;

				scene.add( light );

				//var geometry = new THREE.BoxGeometry( 40, 40, 40 );
				var geometry = new THREE.SphereGeometry( radiusComp, 50, 15 );

				for ( var i = 0; i < maxNbComp; i ++ ) {
					var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x777777, side: THREE.BackSide}));//, transparent: true, opacity: 0.5} ) );
					//var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: (1.0-((i/maxNbComp)*0.5)) * 0xffffff, side: THREE.BackSide}));
					object.material.ambient = object.material.color;
					object.position.x = -9999999;
					object.position.y = -9999999;
					object.position.z = -9999999;
					object.scale.y = 0.5;
					//object.position.x = 0;
					//object.position.y = i*100;
					//object.position.z = 0;
					//object.name=listCompartments[i][0]+" "+listCompartments[i][1];
					//object.castShadow = true;
					//object.receiveShadow = true;
					scene.add( object );
					objects.push( object );
				}
				for ( var i = 0; i < listCompartments.length; i ++ ) {
					objects[i].position.x = 0;
					objects[i].position.y = 0;
					objects[i].position.z = 0;
					objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
					//objects[i].castShadow = true;
					//objects[i].receiveShadow = true;	
				}
				
				
				

				
				uniforms = {
					time: { type: "f", value: 1.0 },
					resolution: { type: "v2", value: new THREE.Vector2() }
				};

				var smaterial = new THREE.ShaderMaterial( {

					uniforms: uniforms,
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
					 opacity: 0.15, transparent: true ,
					side: THREE.DoubleSide 
				} );
				
				
				plane = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( 2000, 2000, 8, 8 ),
					smaterial
					//new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.45, transparent: true } )
				);
				plane.rotation.x -= (90*(Math.PI / 180));
				//KeggMapPlan.rotation.z += (90*(Math.PI / 180));
				plane.visible = true;
				scene.add( plane );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				//renderer.setClearColor( 0xf5f5f5 );
				renderer.setClearColor( 0xe0e0e0 );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.sortObjects = false;

				renderer.shadowMapEnabled = true;
				renderer.shadowMapType = THREE.PCFShadowMap;

				container.appendChild( renderer.domElement );

				controls = new THREE.OrbitControls( camera, renderer.domElement) ;
				
				controls.damping = 0.2;
				//controls.rotateSpeed = 1.0;
				//controls.zoomSpeed = 1.2;
				//controls.panSpeed = 0.8;
				//controls.noZoom = false;
				//controls.noPan = false;
				//controls.staticMoving = true;
				//controls.dynamicDampingFactor = 0.3;
				
				//controls = new THREE.TrackballControls( camera, renderer.domElement) ;
				//controls.rotateSpeed = 1.0;
				//controls.zoomSpeed = 1.2;
				//controls.panSpeed = 0.8;

				controls.noZoom = false;
				controls.noPan = false;

				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
				renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
				renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}
			
		var list_merged_chains={};	
		var generalLayout ={'merged':{},'above':{},'outer':{},'satellite':{},'in':{}};
		//generalLayout['merged']
		
		function isMerged(comp,cType) {
			var result ="";
			if (generalLayout[cType].hasOwnProperty(comp)){
				result=comp;
			}
			else {
				for (var elem in generalLayout[cType]){
					if (generalLayout[cType].hasOwnProperty(elem)){
						for (var i=0;i<generalLayout[cType][elem].length;i++ ){
							if (generalLayout[cType][elem][i]==comp){
								result=elem;
							}
						}
					} 
				}
			}
			return result;
		}
		
		function isCenterMerged(comp,cType) {
			var result ="";
			if (generalLayout[cType].hasOwnProperty(comp)){
				result=comp;
			}
			
			return result;
		}
		function isPeripheralMerged(comp,cType) {
			var result ="";
			for (var elem in generalLayout[cType]){
				if (generalLayout[cType].hasOwnProperty(elem)){
					for (var i=0;i<generalLayout[cType][elem].length;i++ ){
						if (generalLayout[cType][elem][i]==comp){
							result=elem;
						}
					}
				} 
			}
			
			return result;
		}
			
		var button1 = document.getElementById( 'b_merge' );
			button1.addEventListener( 'click', function ( event ) {
		
			stopThreeJsMouseEvent=false;
			
			
			var targetContainer=isMerged(INTERSECTED.name,'merged');
			var refContainer=isMerged(INTERSECTED2.name,'merged');
			// target and ref items dont exist in the merged list
			if ((targetContainer=="") && (refContainer=="")){
				generalLayout['merged'][INTERSECTED2.name]=[];
				generalLayout['merged'][INTERSECTED2.name].push(INTERSECTED.name)
			}
			// target doesnt exist in the merged list while ref exists
			else if ((targetContainer=="") && (refContainer!="")){
				if (generalLayout['merged'][refContainer].indexOf(INTERSECTED.name)==-1){
					generalLayout['merged'][refContainer].push(INTERSECTED.name)
				}
			}
			// target doesnt exist in the merged list while ref exists
			else if ((targetContainer!="") && (refContainer=="")){
				if (generalLayout['merged'][targetContainer].indexOf(INTERSECTED2.name)==-1){
					generalLayout['merged'][targetContainer].push(INTERSECTED2.name)
				}
			}
			// we want to merge two existing merged groups already
			else{
				var newcontent=$.unique(generalLayout['merged'][targetContainer].concat(generalLayout['merged'][refContainer]));
				if (newcontent.length<listCompartments.length-1){
					newcontent.push(targetContainer);
					generalLayout['merged'][refContainer]=newcontent;
					delete generalLayout['merged'][targetContainer];
				}
				
			}
			
			//compLayout["merged"]=[];
			//for (el in generalLayout['merged']){
			//	if (generalLayout['merged'].hasOwnProperty(el)){
			//		for (var i=0; i<generalLayout['merged'][el].length;i++){
			//			compLayout["merged"].push([generalLayout['merged'][el][i], el])
			//		}
			//	}
			//}
			
			
			//generalLayout['merged']=list_merged_chains;
			placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name, 'merged');
			$('#layout1menu').hide();
			
		});
			
		var button2 = document.getElementById( 'b_above' );
		button2.addEventListener( 'click', function ( event ) {
			//console.log("above");
			stopThreeJsMouseEvent=false;
			
			var targetContainer=isMerged(INTERSECTED.name,'above');
			var refContainer=isMerged(INTERSECTED2.name,'above');
			// target and ref items dont exist in the merged list
			if ((targetContainer=="") && (refContainer=="")){
				generalLayout['above'][INTERSECTED2.name]=[];
				generalLayout['above'][INTERSECTED2.name].push(INTERSECTED.name)
			}
			// target doesnt exist in the merged list while ref exists
			else if ((targetContainer=="") && (refContainer!="")){
				if (generalLayout['above'][refContainer].indexOf(INTERSECTED.name)==-1){
					generalLayout['above'][refContainer].push(INTERSECTED.name)
				}
			}
			// target doesnt exist in the merged list while ref exists
			else if ((targetContainer!="") && (refContainer=="")){
				if (generalLayout['above'][targetContainer].indexOf(INTERSECTED2.name)==-1){
					generalLayout['above'][targetContainer].push(INTERSECTED2.name)
				}
			}
			// we want to merge two existing merged groups already
			else{
				var newcontent=$.unique(generalLayout['above'][targetContainer].concat(generalLayout['above'][refContainer]));
				if (newcontent.length<listCompartments.length-1){
					newcontent.push(targetContainer);
					generalLayout['above'][refContainer]=newcontent;
					delete generalLayout['above'][targetContainer];
				}
				
			}
			
			
			
			//compLayout["above"].push([INTERSECTED.name, INTERSECTED2.name] );
			//console.log(compLayout);
			placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name,'above');
			$('#layout1menu').hide();
		});
		var button3 = document.getElementById( 'b_below' );
		button3.addEventListener( 'click', function ( event ) {
			//console.log("below");
			stopThreeJsMouseEvent=false;
			
			var targetContainer=isMerged(INTERSECTED.name,'above');
			var refContainer=isMerged(INTERSECTED2.name,'above');
			// target and ref items dont exist in the merged list
			if ((targetContainer=="") && (refContainer=="")){
				generalLayout['above'][INTERSECTED.name]=[];
				generalLayout['above'][INTERSECTED.name].push(INTERSECTED2.name)
			}
			// target doesnt exist in the merged list while ref exists
			else if ((targetContainer=="") && (refContainer!="")){
				var newcontent=generalLayout['above'][refContainer].slice();
				
				if (newcontent.length<listCompartments.length-1){
					newcontent.unshift(refContainer);
					generalLayout['above'][INTERSECTED.name]=newcontent
					delete generalLayout['above'][refContainer];
				}
			}
			// target does exist in the merged list while ref doesnt exist
			else if ((targetContainer!="") && (refContainer=="")){
				if (generalLayout['above'][targetContainer].indexOf(INTERSECTED2.name)==-1){
					generalLayout['above'][targetContainer].push(INTERSECTED2.name)
				}
			}
			// we want to merge two existing merged groups already
			else{
				var newcontent=$.unique(generalLayout['above'][targetContainer].concat(generalLayout['above'][refContainer]));
				if (newcontent.length<listCompartments.length-1){
					newcontent.unshift(refContainer);
					generalLayout['above'][targetContainer]=newcontent;
					delete generalLayout['above'][refContainer];
				}
				
			}
			
			
			//compLayout["above"].push([INTERSECTED2.name, INTERSECTED.name] );
			//console.log(compLayout);
			placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name,'below');
			$('#layout1menu').hide();
		});
		var button4 = document.getElementById( 'b_inner' );
		button4.addEventListener( 'click', function ( event ) {
			//console.log("inner");
			stopThreeJsMouseEvent=false;
			
			var targetContainer=isMerged(INTERSECTED.name,'outer');
			var refContainer=isMerged(INTERSECTED2.name,'outer');
			// target and ref items dont exist in the merged list
			if ((targetContainer=="") && (refContainer=="")){
				generalLayout['outer'][INTERSECTED.name]=[];
				generalLayout['outer'][INTERSECTED.name].push(INTERSECTED2.name)
			}
			// target doesnt exist in the merged list while ref exists
			else if ((targetContainer=="") && (refContainer!="")){
				var newcontent=generalLayout['outer'][refContainer].slice();
				
				if (newcontent.length<listCompartments.length-1){
					newcontent.unshift(refContainer);
					generalLayout['outer'][INTERSECTED.name]=newcontent
					delete generalLayout['outer'][refContainer];
				}
			}
			// target does exist in the merged list while ref doesnt exist
			else if ((targetContainer!="") && (refContainer=="")){
				if (generalLayout['outer'][targetContainer].indexOf(INTERSECTED2.name)==-1){
					generalLayout['outer'][targetContainer].push(INTERSECTED2.name)
				}
			}
			// we want to merge two existing merged groups already
			else{
				var newcontent=$.unique(generalLayout['outer'][targetContainer].concat(generalLayout['outer'][refContainer]));
				if (newcontent.length<listCompartments.length-1){
					newcontent.unshift(refContainer);
					generalLayout['outer'][targetContainer]=newcontent;
					delete generalLayout['outer'][refContainer];
				}
				
			}
			
			
			//compLayout["outer"].push([INTERSECTED2.name, INTERSECTED.name] );
			//console.log(compLayout);
			placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name,'outer');
			$('#layout1menu').hide();
		});
		var button5 = document.getElementById( 'b_outer' );
		button5.addEventListener( 'click', function ( event ) {
			//console.log("outer");
			stopThreeJsMouseEvent=false;
			
			var targetContainer=isMerged(INTERSECTED.name,'outer');
			var refContainer=isMerged(INTERSECTED2.name,'outer');
			// target and ref items dont exist in the merged list
			if ((targetContainer=="") && (refContainer=="")){
				generalLayout['outer'][INTERSECTED2.name]=[];
				generalLayout['outer'][INTERSECTED2.name].push(INTERSECTED.name)
			}
			// target doesnt exist in the merged list while ref exists
			else if ((targetContainer=="") && (refContainer!="")){
				if (generalLayout['outer'][refContainer].indexOf(INTERSECTED.name)==-1){
					generalLayout['outer'][refContainer].push(INTERSECTED.name)
				}
			}
			// target doesnt exist in the merged list while ref exists
			else if ((targetContainer!="") && (refContainer=="")){
				if (generalLayout['outer'][targetContainer].indexOf(INTERSECTED2.name)==-1){
					generalLayout['outer'][targetContainer].push(INTERSECTED2.name)
				}
			}
			// we want to merge two existing merged groups already
			else{
				var newcontent=$.unique(generalLayout['outer'][targetContainer].concat(generalLayout['outer'][refContainer]));
				if (newcontent.length<listCompartments.length-1){
					newcontent.push(targetContainer);
					generalLayout['outer'][refContainer]=newcontent;
					delete generalLayout['outer'][targetContainer];
				}
				
			}
			
			//compLayout["outer"].push([INTERSECTED.name, INTERSECTED2.name] );
			//console.log(compLayout);
			placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name,'outer');
			$('#layout1menu').hide();
		});
		var button6 = document.getElementById( 'b_satellite' );
		button6.addEventListener( 'click', function ( event ) {
			//console.log("satellite");
			stopThreeJsMouseEvent=false;
			
			var targetContainer=isCenterMerged(INTERSECTED.name,'satellite');
			var targetContainer2=isPeripheralMerged(INTERSECTED.name,'satellite');
			var refContainer=isCenterMerged(INTERSECTED2.name,'satellite');
			var refContainer2=isPeripheralMerged(INTERSECTED2.name,'satellite');
			if (!(targetContainer2!="")){
				if((targetContainer=="") && (refContainer=="")){
					generalLayout['satellite'][INTERSECTED2.name]=[];
					generalLayout['satellite'][INTERSECTED2.name].push(INTERSECTED.name)
				}
				else if ((targetContainer=="") && !(refContainer=="")){
					if (generalLayout['satellite'][INTERSECTED2.name].indexOf(INTERSECTED.name)==-1){
						generalLayout['satellite'][INTERSECTED2.name].push(INTERSECTED.name);
					}
				}
				else if (!(targetContainer=="") && (refContainer=="")){
					generalLayout['satellite'][INTERSECTED2.name]=[];
					if (generalLayout['satellite'][INTERSECTED2.name].indexOf(INTERSECTED.name)==-1){
						generalLayout['satellite'][INTERSECTED2.name].push(INTERSECTED.name);
					}
				}
				else{
					if (generalLayout['satellite'][INTERSECTED2.name].indexOf(INTERSECTED.name)==-1){
						generalLayout['satellite'][INTERSECTED2.name].push(INTERSECTED.name);
					}
				}
				
				
			}
			
			//compLayout["satellite"].push([INTERSECTED.name, INTERSECTED2.name] );
			//console.log(compLayout);
			placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name,'satellite');
			$('#layout1menu').hide();
		});
		var button7 = document.getElementById( 'b_subset' );
		button7.addEventListener( 'click', function ( event ) {
			//console.log("subset");
			stopThreeJsMouseEvent=false;
			
			var targetContainer=isCenterMerged(INTERSECTED.name,'in');
			var targetContainer2=isPeripheralMerged(INTERSECTED.name,'in');
			var refContainer=isCenterMerged(INTERSECTED2.name,'in');
			var refContainer2=isPeripheralMerged(INTERSECTED2.name,'in');
			if (!(targetContainer2!="")){
				if((targetContainer=="") && (refContainer=="")){
					generalLayout['in'][INTERSECTED2.name]=[];
					generalLayout['in'][INTERSECTED2.name].push(INTERSECTED.name)
				}
				else if ((targetContainer=="") && !(refContainer=="")){
					if (generalLayout['in'][INTERSECTED2.name].indexOf(INTERSECTED.name)==-1){
						generalLayout['in'][INTERSECTED2.name].push(INTERSECTED.name);
					}
				}
				else if (!(targetContainer=="") && (refContainer=="")){
					generalLayout['in'][INTERSECTED2.name]=[];
					if (generalLayout['in'][INTERSECTED2.name].indexOf(INTERSECTED.name)==-1){
						generalLayout['in'][INTERSECTED2.name].push(INTERSECTED.name);
					}
				}
				else{
					if (generalLayout['in'][INTERSECTED2.name].indexOf(INTERSECTED.name)==-1){
						generalLayout['in'][INTERSECTED2.name].push(INTERSECTED.name);
					}
				}
				
				
			}
			
			//compLayout["in"].push([INTERSECTED.name,INTERSECTED2.name] );
			//console.log(compLayout);
			placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name,'in');
			$('#layout1menu').hide();
		});
		var button8 = document.getElementById( 'b_cancel' );
		button8.addEventListener( 'click', function ( event ) {
			//console.log("cancel");
			stopThreeJsMouseEvent=false;
			for ( var i = 0; i < listCompartments.length; i ++ ) {
				if (objects[i].name==initialName){
					objects[i].position.x=initialPos.x;
					objects[i].position.y=initialPos.y;
					objects[i].position.z=initialPos.z;
					SELECTED = null;
					SELECTED2=null;
				}
			}
			
			
			
			$('#layout1menu').hide();
		});
			

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {
				if (stopThreeJsMouseEvent==false){
					event.preventDefault();
					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( (event.clientY-$("#container").position().top+window.pageYOffset) / window.innerHeight ) * 2 + 1;
					var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );
					var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
					if ( SELECTED ) {
						var intersects2 = raycaster.intersectObjects( objects );
						if ( intersects2.length > 1 ) {
							if (SELECTED.name==intersects2[0].object.name)
								INTERSECTED2=intersects2[1].object;
							else
								INTERSECTED2=intersects2[0].object;
						}
						else{
							INTERSECTED2=null;
						}
						//plane.position.y=SELECTED.position.y;
						var intersects = raycaster.intersectObject( plane );						
						var mustMove=true;
						
						for (var ref in generalLayout["merged"]){
							if (generalLayout["merged"].hasOwnProperty(ref)){
								if (SELECTED.name==ref || generalLayout["merged"][ref].indexOf(SELECTED.name)!=-1 ){
									mustMove=true;
									for (var j=0; j<listCompartments.length;j++ ){
										if (objects[j].name==ref || generalLayout["merged"][ref].indexOf(objects[j].name)!=-1){
											objects[j].position.copy( SELECTED.position );
										}
									}
								}
							}
						}
						for (var ref in generalLayout["outer"]){
							if (generalLayout["outer"].hasOwnProperty(ref)){
								if (SELECTED.name==ref || generalLayout["outer"][ref].indexOf(SELECTED.name)!=-1 ){
									mustMove=true;
									for (var j=0; j<listCompartments.length;j++ ){
										if (objects[j].name==ref || generalLayout["outer"][ref].indexOf(objects[j].name)!=-1){
											objects[j].position.copy( SELECTED.position );
										}
									}
								}
							}
						}
						for (var ref in generalLayout["above"]){
							if (generalLayout["above"].hasOwnProperty(ref)){
								if (SELECTED.name==ref || generalLayout["above"][ref].indexOf(SELECTED.name)!=-1 ){
									
									mustMove=true;
									var ind=generalLayout["above"][ref].indexOf(SELECTED.name);
									
									if (SELECTED.name==ref ){
										var tmpRef;
										for (var j=0; j<listCompartments.length;j++ ){
											if (objects[j].name==ref){
												tmpRef=j;
												objects[j].position.setX(SELECTED.position.x);
												objects[j].position.setZ(SELECTED.position.z);
												//console.log(ref)
											}
										}
										for (var j=0; j<generalLayout["above"][ref].length;j++ ){
											var tmpNode= generalLayout["above"][ref][j];
											for (var j1=0; j1<listCompartments.length;j1++ ){
												if (objects[j1].name==tmpNode && objects[j1].name!=""){
													objects[j1].position.setX(objects[tmpRef].position.x);
													objects[j1].position.setZ(objects[tmpRef].position.z);
													objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
												}
											}
										}
									}
									
									if (ind!=-1){
										var tmpRef;
										for (var j=0; j<listCompartments.length;j++ ){
											if (objects[j].name==ref){
												tmpRef=j;
												objects[j].position.setX(SELECTED.position.x);
												objects[j].position.setZ(SELECTED.position.z);
												//objects[j].position.setZ(SELECTED.position.z);
											}
										}
										for (var j=0; j<generalLayout["above"][ref].length;j++ ){
											var tmpNode= generalLayout["above"][ref][j];
											for (var j1=0; j1<listCompartments.length;j1++ ){
												if (objects[j1].name==tmpNode && objects[j1].name!=""){
													objects[j1].position.setX(objects[tmpRef].position.x);
													objects[j1].position.setZ(objects[tmpRef].position.z);
													objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
												}
											}
										}
									}
									
									
										
											
								}
							}
						}
						
						for (var ref in generalLayout["satellite"]){
							if (generalLayout["satellite"].hasOwnProperty(ref)){
								if (SELECTED.name==ref || generalLayout["satellite"][ref].indexOf(SELECTED.name)!=-1 ){
									
									mustMove=true;
									var ind=generalLayout["satellite"][ref].indexOf(SELECTED.name);
									
									if (SELECTED.name==ref ){
										var tmpRef;
										for (var j=0; j<listCompartments.length;j++ ){
											if (objects[j].name==ref){
												tmpRef=j;
												objects[j].position.setX(SELECTED.position.x);
												objects[j].position.setZ(SELECTED.position.z);
												//console.log(ref)
											}
										}
										for (var j=0; j<generalLayout["satellite"][ref].length;j++ ){
											var max_rotation_count=generalLayout["satellite"][ref].length;
											var dilation_count=0;
											var tmpNode= generalLayout["satellite"][ref][j];
											for (var j1=0; j1<listCompartments.length;j1++ ){
												if (objects[j1].name==tmpNode && objects[j1].name!=""){
												objects[j1].position.x=SELECTED.position.x+Math.cos(((2 * Math.PI)*(1/max_rotation_count))*j)*(spacing+(dilation_count*spacing/2));
												objects[j1].position.y=SELECTED.position.y;
												objects[j1].position.z=SELECTED.position.z+Math.sin(((2 * Math.PI)*(1/max_rotation_count))*j)*(spacing+(dilation_count*spacing/2));
													//objects[j1].position.setX(objects[tmpRef].position.x);
													//objects[j1].position.setZ(objects[tmpRef].position.z);
													//objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
												}
											}
										}
									}
								}
							}
						}
						for (var ref in generalLayout["in"]){
							if (generalLayout["in"].hasOwnProperty(ref)){
								if (SELECTED.name==ref || generalLayout["in"][ref].indexOf(SELECTED.name)!=-1 ){
									
									mustMove=true;
									var ind=generalLayout["in"][ref].indexOf(SELECTED.name);
									
									if (SELECTED.name==ref ){
										var tmpRef;
										for (var j=0; j<listCompartments.length;j++ ){
											if (objects[j].name==ref){
												tmpRef=j;
												objects[j].position.setX(SELECTED.position.x);
												objects[j].position.setZ(SELECTED.position.z);
												//console.log(ref)
											}
										}
										for (var j=0; j<generalLayout["in"][ref].length;j++ ){
											var max_rotation_count=generalLayout["in"][ref].length;
											var dilation_count=0;
											var tmpNode= generalLayout["in"][ref][j];
											for (var j1=0; j1<listCompartments.length;j1++ ){
												if (objects[j1].name==tmpNode && objects[j1].name!=""){
												objects[j1].position.x=SELECTED.position.x+Math.cos(((2 * Math.PI)*(1/max_rotation_count))*j)*(radiusComp*objects[tmpRef].scale.x*0.7);
												objects[j1].position.y=SELECTED.position.y;
												objects[j1].position.z=SELECTED.position.z+Math.sin(((2 * Math.PI)*(1/max_rotation_count))*j)*(radiusComp*objects[tmpRef].scale.x*0.7);
												objects[j1].scale.x=0.3;
												objects[j1].scale.y=0.15;
												objects[j1].scale.z=0.3;
													//objects[j1].position.setX(objects[tmpRef].position.x);
													//objects[j1].position.setZ(objects[tmpRef].position.z);
													//objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
												}
											}
										}
									}
								}
							}
						}
						// for (var i=0; i<compLayout["outer"].length;i++){
							// if (SELECTED.name==compLayout["outer"][i][0] ){
								// mustMove=true;
								// for (var j=0; j<listCompartments.length;j++ ){
								
									// if (objects[j].name==compLayout["outer"][i][1]){
										// objects[j].position.copy( SELECTED.position );
									// }
								// }
							// }
							// if (SELECTED.name==compLayout["outer"][i][1] ){
								// mustMove=true;
								// for (var j=0; j<listCompartments.length;j++ ){
								
									// if (objects[j].name==compLayout["outer"][i][0]){
										// objects[j].position.copy( SELECTED.position );
									// }
								// }
							// }
						// }
						
						
						// var aboveToTranslate=[];
						// for (var i=0; i<compLayout["above"].length;i++){
							// if(compLayout["above"][i][1]==SELECTED.name || compLayout["above"][i][0]==SELECTED.name){
								// if (aboveToTranslate.indexOf(compLayout["above"][i][0])==-1){
									// aboveToTranslate.push(compLayout["above"][i][0]);
								// }
								// if (aboveToTranslate.indexOf(compLayout["above"][i][1])==-1){
									// aboveToTranslate.push(compLayout["above"][i][1]);
								// }
							// }			
						// }
						// var finished=false;
						// while (finished==false){
							// finished = true;
							// for (var i=0; i<compLayout["above"].length;i++){
								// if (aboveToTranslate.indexOf(compLayout["above"][i][0])!=-1 || aboveToTranslate.indexOf(compLayout["above"][i][1])!=-1){
									// if (aboveToTranslate.indexOf(compLayout["above"][i][0])==-1){
										// aboveToTranslate.push(compLayout["above"][i][0]);
										// finished = false;
									// }
									// if (aboveToTranslate.indexOf(compLayout["above"][i][1])==-1){
										// aboveToTranslate.push(compLayout["above"][i][1]);
										// finished = false;
									// }
									
								// }
							// }
						// }
						// if (aboveToTranslate.length>0){
							// mustMove=true;
							// for (var i=0; i<listCompartments.length;i++ ){
								// if (aboveToTranslate.indexOf(objects[i].name)!=-1 && SELECTED.name != objects[i].name){
									// var centerPosition=new THREE.Vector3();
									// centerPosition.copy(objects[i].position);
									// objects[i].position.setX(SELECTED.position.x)
									// objects[i].position.setZ(SELECTED.position.z)
								// }
							// }
						// }
						
						
						
						
						// for (var i=0; i<compLayout["satellite"].length;i++){
							// if (SELECTED.name==compLayout["satellite"][i][0] ){
							 // mustMove=false;
							// }
							// if (SELECTED.name==compLayout["satellite"][i][1] ){
								// mustMove=true;
								// var satellitesToTranslate=[];
								// var max_rotation_count=0;
								// for (var i1=0; i1<compLayout["satellite"].length;i1++){
									// if(compLayout["satellite"][i1][1]==SELECTED.name){
										// satellitesToTranslate.push(compLayout["satellite"][i1][0]);
										// max_rotation_count++;
									// }
								// }
								// var dilation_count=0;
								// for (var j1=0; j1<compLayout["outer"].length;j1++){
									// if (compLayout["outer"][j1][1]==SELECTED.name){
										// dilation_count++;
									// }
								// }
								// var cnt=0;
								// for (var i2=0; i2<listCompartments.length;i2++ ){
									// var ind =satellitesToTranslate.indexOf(objects[i2].name);
									// if (ind!=-1){					
										// objects[i2].position.x=SELECTED.position.x+Math.cos(((2 * Math.PI)*(1/max_rotation_count))*cnt)*(spacing+(dilation_count*spacing/2));
										// objects[i2].position.y=SELECTED.position.y;
										// objects[i2].position.z=SELECTED.position.z+Math.sin(((2 * Math.PI)*(1/max_rotation_count))*cnt)*(spacing+(dilation_count*spacing/2));
										// cnt++;
									// }
								// }
								
								
							// }
						// }
						// for (var i=0; i<compLayout["in"].length;i++){
							// if (SELECTED.name==compLayout["in"][i][0] ){
							 // mustMove=false;
							// }
							// if (SELECTED.name==compLayout["in"][i][1] ){
								// mustMove=true;
								// var satellitesToTranslate=[];
								// var max_rotation_count=0;
								// for (var i1=0; i1<compLayout["in"].length;i1++){
									// if(compLayout["in"][i1][1]==SELECTED.name){
										// satellitesToTranslate.push(compLayout["in"][i1][0]);
										// max_rotation_count++;
									// }
								// }
								
								// var cnt=0;
								// for (var i2=0; i2<listCompartments.length;i2++ ){
									// var ind =satellitesToTranslate.indexOf(objects[i2].name);
									// if (ind!=-1){		
										
										// objects[i2].position.x=SELECTED.position.x+Math.cos(((2 * Math.PI)*(1/max_rotation_count))*cnt)*((SELECTED.scale.x*spacing*0.3));
										// objects[i2].position.y=SELECTED.position.y;
										// objects[i2].position.z=SELECTED.position.z+Math.sin(((2 * Math.PI)*(1/max_rotation_count))*cnt)*((SELECTED.scale.x*spacing*0.3));
										
										// cnt++;
									// }
								// }
								
								
								
							// }
						// }
						if( mustMove==true){
						SELECTED.position.copy( intersects[ 0 ].point.sub( offset ) );
						}
						//plane.position.copy( intersects[ 0 ].point);						
						return;
					}
					var intersects = raycaster.intersectObjects( objects );
					if ( intersects.length > 0 ) {						
							if ( INTERSECTED != intersects[ 0 ].object ) {
								if ( INTERSECTED ) {
									INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
								}
								INTERSECTED = intersects[ 0 ].object;
								INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
								console.log(generalLayout);
								//plane.rotation.x -= (90*(Math.PI / 180));
							}
							container.style.cursor = 'pointer';						
					} else {

						if ( INTERSECTED ) {
							INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
						}
						INTERSECTED = null;
						INTERSECTED2 = null;
						container.style.cursor = 'auto';
					}
				}
			}

			function onDocumentMouseDown( event ) {				
				event.preventDefault();
				switch ( event.button ) {
					case 0: // left 
						var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );
						var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
						var intersects = raycaster.intersectObjects( objects );
						if ( intersects.length > 0 ) {							
								controls.enabled = false;
								if(SELECTED==null){
									initialPos.x=intersects[ 0 ].object.position.x;
									initialPos.y=intersects[ 0 ].object.position.y;
									initialPos.z=intersects[ 0 ].object.position.z;
									initialName = intersects[ 0 ].object.name;
									//console.log(initialPos)
								}
								SELECTED = intersects[ 0 ].object;
								plane.position.y=SELECTED.position.y;
								//var intersects = raycaster.intersectObject( plane );
								//offset.copy( intersects[ 0 ].point ).sub( plane.position );
								container.style.cursor = 'move';							
						}
					case 1: // middle
						break;
					case 2: // right
						break;
				}
			}
			function onDocumentMouseUp( event ) {
			//console.log("up")
				switch ( event.button ) {
					case 0: // left 						
						event.preventDefault();
						controls.enabled = true;
						if ( INTERSECTED ) {							
							if ( INTERSECTED2!=null ) {								
								var prevent =false;								
								for (var typeLink in generalLayout){
									if (generalLayout.hasOwnProperty(typeLink)){
										for (var ref in generalLayout[typeLink]){
											if (generalLayout[typeLink].hasOwnProperty(ref)){
												if ((INTERSECTED2.name==ref && generalLayout[typeLink][ref].indexOf(INTERSECTED.name)!=-1)||
												(INTERSECTED.name==ref && generalLayout[typeLink][ref].indexOf(INTERSECTED2.name)!=-1) ||
												(generalLayout[typeLink][ref].indexOf(INTERSECTED.name)!=-1 && generalLayout[typeLink][ref].indexOf(INTERSECTED2.name)!=-1)
												){
													prevent =true;
												}
											}
										}
									}
								}
								if (prevent ==false){
								
								
								
								
								//console.log(INTERSECTED.name+" dragged and dropped on :"+INTERSECTED2.name)
								$('#layout1menu').show();
								var vector = new THREE.Vector3(INTERSECTED2.position.x,INTERSECTED2.position.y,INTERSECTED2.position.z);
								var pp = toXYCoords(vector	);
					
					
								document.getElementById("layout1menu").style.top = (pp.y+$('#container').position().top) + 'px';
								document.getElementById("layout1menu").style.left = (pp.x)+ 'px';
								stopThreeJsMouseEvent=true;
								}
							}
							SELECTED = null;
						}						
						container.style.cursor = 'auto';
					case 1: // middle
						break;
					case 2: // right
						break;
				}
			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {
				controls.update();
				var poscont = $("#container");
				//var cnt_merged=0;
				var cnt_merged_comp={};
				for ( var i = 0; i < listCompartments.length; i ++ ) {
					//cnt_merged=0;
					var vector = new THREE.Vector3( objects[i].position.x+(-radiusComp*objects[i].scale.x),objects[i].position.y,objects[i].position.z);
					var pp = toXYCoords(vector	);
					
					if (pp.x >=0 && pp.y >=0 && pp.x <=poscont.width()-10 && pp.y <=poscont.height()-10){
						document.getElementById("txt"+i).style.top = (pp.y+poscont.position().top+(0*12)) + 'px';
						document.getElementById("txt"+i).style.left = (pp.x +20)+ 'px';
					}
					else{
						document.getElementById("txt"+i).style.top = 4000 + 'px';
						document.getElementById("txt"+i).style.left = 4000+ 'px';
					}
					for (el in list_merged_chains){
						if (list_merged_chains.hasOwnProperty(el)){
							if (objects[i].name==el){
								document.getElementById("txt"+i).style.top = (pp.y+poscont.position().top+(0*12)) + 'px';
								document.getElementById("txt"+i).style.left = (pp.x +20)+ 'px';
							}
							for (var j=0;j<list_merged_chains[el].length;j++){
								if (objects[i].name==list_merged_chains[el][j]){
									document.getElementById("txt"+i).style.top = (pp.y+poscont.position().top+((j+1)*12)) + 'px';
									document.getElementById("txt"+i).style.left = (pp.x +20)+ 'px';
								}
								
							}
						}
					}
					
					
					//cnt_merged_comp[objects[i].name]=0;
					//var link_Val="";
					// for (var j=0; j<compLayout["merged"].length;j++){
						
						// if (objects[i].name==compLayout["merged"][j][1]){
							// cnt_merged_comp[objects[i].name]=0;
						// }
						// else if (objects[i].name==compLayout["merged"][j][0]){
							// if (compLayout["merged"][j][1]==link_Val){
							// cnt_merged_comp[objects[i].name]+=1;
							// }
							
						// }
						// //if (link_Val==compLayout["merged"][j][0]){
						// //	
						// //	link_Val=compLayout["merged"][j][1];
						// //	cnt_merged_comp[objects[i].name]+=1;
						// //}
						
						
							// //if (objects[i].name==compLayout["merged"][j][1]){
							// //	cnt_merged++;
							// //}
					// }
					
					//console.log(cnt_merged_comp)
					
					document.getElementById("txt"+i).innerHTML = objects[i].name;
					
					//console.log(pp)
					//console.log(pp.x + " " +pp.y)
					//console.log(poscont.position().top + " " +poscont.height()+ " "+poscont.position().left+" "+poscont.width() )
					
				}
				

				renderer.render( scene, camera );

			}

	var $container1 = $("#compTable");
	$container1.handsontable({
	  data: [],
	  width: 400,
	  height:200,
	  dataSchema: {c_id: null, c_name: null},
	  startRows: 1,
	  startCols: 2,
	  contextMenu: ['remove_row'],
	  //maxRows: 1,
	  colHeaders: ['Comp. id', 'Comp. name'],
	  columns: [
		{data: "c_id"},
		{data: "c_name"}
	  ],
	  beforeRemoveRow: function(ind, numb){
		var dt = this.getData();
		
		if (dt[0]['c_id']!=null){
			
			var id_removed = dt[ind]['c_id']+" "+dt[ind]['c_name'];
			//console.log(id_removed)
			var listL = Object.keys(compLayout);
			for (var i=0; i<listL.length;i++){
				var listI=[];
				for (var j=0; j<compLayout[listL[i]].length;j++){
					
					if ((compLayout[listL[i]][j][0]==id_removed) || (compLayout[listL[i]][j][1]==id_removed)){
						
					}
					else{
						listI.push(compLayout[listL[i]][j])
					}
				}
				compLayout[listL[i]]=listI;
			}
			
			//console.log(compLayout);
			//console.log(dt.length);
			
			
		}
	  },
	  afterRemoveRow: function(ind, numb){
		var dt = this.getData();
		
		if (dt[0]['c_id']!=null){
			listCompartments=[];
			for (var i=0, j= dt.length;i<j-1;i++){
				listCompartments.push([dt[i]['c_id'],dt[i]['c_name']]);
				
			}
			// delete meshes
			for ( var i = 0; i < maxNbComp; i ++ ) {
					objects[i].position.x = -9999999;
					objects[i].position.y = -9999999;
					objects[i].position.z = -9999999;
					objects[i].name="";
					txtComp[i].innerHTML = 'hello ';
					txtComp[i].style.top = 4000 + 'px';
					txtComp[i].style.left = 4000 + 'px';
			}
			for ( var i = 0; i < listCompartments.length; i ++ ) {
			
				objects[i].position.x = 0;
				objects[i].position.y = 0;
				objects[i].position.z = 0;
				
				objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
				objects[i].castShadow = true;
				objects[i].receiveShadow = true;	
				
			}
			
			//console.log(dt.length);
			
			
		}
	  },
	  afterChange: function(changes, source) {
		var dt = this.getData();
		
		if (dt[0]['c_id']!=null){
			listCompartments=[];
			for (var i=0, j= dt.length;i<j-1;i++){
				listCompartments.push([dt[i]['c_id'],dt[i]['c_name']]);
				
			}
			// delete meshes
			for ( var i = 0; i < maxNbComp; i ++ ) {
					objects[i].position.x = -9999999;
					objects[i].position.y = -9999999;
					objects[i].position.z = -9999999;
					objects[i].name="";
					txtComp[i].innerHTML = 'hello ';
					txtComp[i].style.top = 4000 + 'px';
					txtComp[i].style.left = 4000 + 'px';
			}
			for ( var i = 0; i < listCompartments.length; i ++ ) {
				objects[i].position.x = 0;
				objects[i].position.y = 0;
				objects[i].position.z = 0;
				objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
				objects[i].castShadow = true;
				objects[i].receiveShadow = true;	
				
			}
			//console.log(listCompartments);
			//console.log(dt.length);
			
			
		}
		
	  },
	  minSpareRows: 1
	});
	var tempdata1=listCompartments;

	var ht = $('#compTable').handsontable('getInstance');
	if ($.isArray(tempdata1) && tempdata1[0] && $.isArray(tempdata1[0])){
		ht.populateFromArray (0, 0, tempdata1,tempdata1.length-1, 1);
	}
	$("#compTable").css({top:  $("#container").position().top + $("#container").height()+40});
	
	function placeCompFromLayout(cName, cRef, dropType){
		if (dropType=='merged'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			for (var ref in generalLayout["merged"]){
				if (generalLayout["merged"].hasOwnProperty(ref)){
					if (cName==ref || generalLayout["merged"][ref].indexOf(cName)!=-1 ){
						
						for (var j=0; j<listCompartments.length;j++ ){
							if (objects[j].name==ref || generalLayout["merged"][ref].indexOf(objects[j].name)!=-1){
								objects[j].position.copy( objects[indRef].position );
							}
						}
					}
				}
			}
		}
		if (dropType=='outer'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			for (var ref in generalLayout["outer"]){
				if (generalLayout["outer"].hasOwnProperty(ref)){
					if (cName==ref || generalLayout["outer"][ref].indexOf(cName)!=-1 ){
						mustMove=true;
						for (var j=0; j<listCompartments.length;j++ ){
							var indPos = generalLayout["outer"][ref].indexOf(objects[j].name);
							if (objects[j].name==ref ){
								objects[j].position.copy( objects[indRef].position );
							}
							else if (indPos!=-1){
								objects[j].position.copy( objects[indRef].position );
								console.log(indPos)
								objects[j].scale.x = 2+indPos;
								objects[j].scale.z = 2+indPos;
							}
							else{}
						}
					}
				}
			}
		}
		if (dropType=='above'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			var indCname;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cName){
					indCname=j;
				}
			}
			for (var ref in generalLayout["above"]){
				if (generalLayout["above"].hasOwnProperty(ref)){
					if (cName==ref || generalLayout["above"][ref].indexOf(cName)!=-1 ){
						
						
						var ind=generalLayout["above"][ref].indexOf(cName);
						
						if (cName==ref ){
							var tmpRef;
							for (var j=0; j<listCompartments.length;j++ ){
								if (objects[j].name==ref){
									tmpRef=j;
									objects[j].position.setX(objects[indRef].position.x);
									objects[j].position.setZ(objects[indRef].position.z);
									//console.log(ref)
								}
							}
							for (var j=0; j<generalLayout["above"][ref].length;j++ ){
								var tmpNode= generalLayout["above"][ref][j];
								for (var j1=0; j1<listCompartments.length;j1++ ){
									if (objects[j1].name==tmpNode && objects[j1].name!=""){
										objects[j1].position.setX(objects[tmpRef].position.x);
										objects[j1].position.setZ(objects[tmpRef].position.z);
										objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
									}
								}
							}
						}
						
						if (ind!=-1){
							var tmpRef;
							for (var j=0; j<listCompartments.length;j++ ){
								if (objects[j].name==ref){
									tmpRef=j;
									objects[j].position.setX(objects[indRef].position.x);
									objects[j].position.setZ(objects[indRef].position.z);
									//objects[j].position.setZ(SELECTED.position.z);
								}
							}
							for (var j=0; j<generalLayout["above"][ref].length;j++ ){
								var tmpNode= generalLayout["above"][ref][j];
								for (var j1=0; j1<listCompartments.length;j1++ ){
									if (objects[j1].name==tmpNode && objects[j1].name!=""){
										objects[j1].position.setX(objects[tmpRef].position.x);
										objects[j1].position.setZ(objects[tmpRef].position.z);
										objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
									}
								}
							}
						}
						
						
							
								
					}
				}
			}
		}
		
		if (dropType=='below'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			
			var indCname;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cName){
					indCname=j;
				}
			}
			for (var ref in generalLayout["above"]){
			
				if (generalLayout["above"].hasOwnProperty(ref)){
					if (cName==ref || generalLayout["above"][ref].indexOf(cName)!=-1 ){
						
						
						var ind=generalLayout["above"][ref].indexOf(cName);
						
						if (cName==ref ){
							var tmpRef;
							for (var j=0; j<listCompartments.length;j++ ){
								if (objects[j].name==ref){
									tmpRef=j;
									objects[indRef].position.y-=spacing;
									objects[j].position.setX(objects[indRef].position.x);
									objects[j].position.setZ(objects[indRef].position.z);
									objects[j].position.setY(objects[indRef].position.y);
									//console.log(ref)
								}
							}
							for (var j=0; j<generalLayout["above"][ref].length;j++ ){
								var tmpNode= generalLayout["above"][ref][j];
								for (var j1=0; j1<listCompartments.length;j1++ ){
									if (objects[j1].name==tmpNode && objects[j1].name!=""){
										objects[j1].position.setX(objects[tmpRef].position.x);
										objects[j1].position.setZ(objects[tmpRef].position.z);
										objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
									}
								}
							}
						}
						
						if (ind!=-1){
							var tmpRef;
							for (var j=0; j<listCompartments.length;j++ ){
								if (objects[j].name==ref){
									tmpRef=j;
									objects[j].position.setX(objects[indRef].position.x);
									objects[j].position.setZ(objects[indRef].position.z);
									//objects[j].position.setZ(SELECTED.position.z);
								}
							}
							for (var j=0; j<generalLayout["above"][ref].length;j++ ){
								var tmpNode= generalLayout["above"][ref][j];
								for (var j1=0; j1<listCompartments.length;j1++ ){
									if (objects[j1].name==tmpNode && objects[j1].name!=""){
										objects[j1].position.setX(objects[tmpRef].position.x);
										objects[j1].position.setZ(objects[tmpRef].position.z);
										objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
									}
								}
							}
						}
						
						
							
								
					}
				}
			}
		}
		
					
						/*for (var ref in generalLayout["merged"]){
							if (generalLayout["merged"].hasOwnProperty(ref)){
								if (SELECTED.name==ref || generalLayout["merged"][ref].indexOf(SELECTED.name)!=-1 ){
									mustMove=true;
									for (var j=0; j<listCompartments.length;j++ ){
										if (objects[j].name==ref || generalLayout["merged"][ref].indexOf(objects[j].name)!=-1){
											objects[j].position.copy( SELECTED.position );
										}
									}
								}
							}
						}
						for (var ref in generalLayout["outer"]){
							if (generalLayout["outer"].hasOwnProperty(ref)){
								if (SELECTED.name==ref || generalLayout["outer"][ref].indexOf(SELECTED.name)!=-1 ){
									mustMove=true;
									for (var j=0; j<listCompartments.length;j++ ){
										if (objects[j].name==ref || generalLayout["outer"][ref].indexOf(objects[j].name)!=-1){
											objects[j].position.copy( SELECTED.position );
										}
									}
								}
							}
						}
						for (var ref in generalLayout["above"]){
							if (generalLayout["above"].hasOwnProperty(ref)){
								if (SELECTED.name==ref || generalLayout["above"][ref].indexOf(SELECTED.name)!=-1 ){
									
									mustMove=true;
									var ind=generalLayout["above"][ref].indexOf(SELECTED.name);
									
									if (SELECTED.name==ref ){
										var tmpRef;
										for (var j=0; j<listCompartments.length;j++ ){
											if (objects[j].name==ref){
												tmpRef=j;
												objects[j].position.setX(SELECTED.position.x);
												objects[j].position.setZ(SELECTED.position.z);
												//console.log(ref)
											}
										}
										for (var j=0; j<generalLayout["above"][ref].length;j++ ){
											var tmpNode= generalLayout["above"][ref][j];
											for (var j1=0; j1<listCompartments.length;j1++ ){
												if (objects[j1].name==tmpNode && objects[j1].name!=""){
													objects[j1].position.setX(objects[tmpRef].position.x);
													objects[j1].position.setZ(objects[tmpRef].position.z);
													objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
												}
											}
										}
									}
									
									if (ind!=-1){
										var tmpRef;
										for (var j=0; j<listCompartments.length;j++ ){
											if (objects[j].name==ref){
												tmpRef=j;
												objects[j].position.setX(SELECTED.position.x);
												objects[j].position.setZ(SELECTED.position.z);
												//objects[j].position.setZ(SELECTED.position.z);
											}
										}
										for (var j=0; j<generalLayout["above"][ref].length;j++ ){
											var tmpNode= generalLayout["above"][ref][j];
											for (var j1=0; j1<listCompartments.length;j1++ ){
												if (objects[j1].name==tmpNode && objects[j1].name!=""){
													objects[j1].position.setX(objects[tmpRef].position.x);
													objects[j1].position.setZ(objects[tmpRef].position.z);
													objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
												}
											}
										}
									}
									
									
										
											
								}
							}
						}
						
						for (var ref in generalLayout["satellite"]){
							if (generalLayout["satellite"].hasOwnProperty(ref)){
								if (SELECTED.name==ref || generalLayout["satellite"][ref].indexOf(SELECTED.name)!=-1 ){
									
									mustMove=true;
									var ind=generalLayout["satellite"][ref].indexOf(SELECTED.name);
									
									if (SELECTED.name==ref ){
										var tmpRef;
										for (var j=0; j<listCompartments.length;j++ ){
											if (objects[j].name==ref){
												tmpRef=j;
												objects[j].position.setX(SELECTED.position.x);
												objects[j].position.setZ(SELECTED.position.z);
												//console.log(ref)
											}
										}
										for (var j=0; j<generalLayout["satellite"][ref].length;j++ ){
											var max_rotation_count=generalLayout["satellite"][ref].length;
											var dilation_count=0;
											var tmpNode= generalLayout["satellite"][ref][j];
											for (var j1=0; j1<listCompartments.length;j1++ ){
												if (objects[j1].name==tmpNode && objects[j1].name!=""){
												objects[j1].position.x=SELECTED.position.x+Math.cos(((2 * Math.PI)*(1/max_rotation_count))*j)*(spacing+(dilation_count*spacing/2));
												objects[j1].position.y=SELECTED.position.y;
												objects[j1].position.z=SELECTED.position.z+Math.sin(((2 * Math.PI)*(1/max_rotation_count))*j)*(spacing+(dilation_count*spacing/2));
													//objects[j1].position.setX(objects[tmpRef].position.x);
													//objects[j1].position.setZ(objects[tmpRef].position.z);
													//objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
												}
											}
										}
									}
									
									
									
									
										
											
								}
							}
						}*/
		
		// var listL = Object.keys(compLayout);
		// var indexTarget=-1;
		// var indexRef=-1;
		// for ( var i = 0; i < listCompartments.length; i ++ ) {
			// if (objects[i].name==cName)
				// indexTarget=i;
			// if (objects[i].name==cRef)
				// indexRef=i;
		// }
		
		// for (var i=0; i<listL.length;i++){
			// // var compLayout={"merged":[],"above":[], "outer":[], "satellite":[], "in":[]};
			// if (listL[i]=="merged"){
				
				// for (var j=0; j<compLayout[listL[i]].length;j++){
					// if (compLayout[listL[i]][j][0]==cName && compLayout[listL[i]][j][1]==cRef){
						// objects[indexTarget].position.x=objects[indexRef].position.x;
						// objects[indexTarget].position.y=objects[indexRef].position.y;
						// objects[indexTarget].position.z=objects[indexRef].position.z;
						// objects[indexTarget].scale.x=objects[indexRef].scale.x;
						// objects[indexTarget].scale.z=objects[indexRef].scale.z;
					// }
					// if (compLayout[listL[i]][j][1]==cName && compLayout[listL[i]][j][0]==cRef){
						// objects[indexTarget].position.x=objects[indexRef].position.x;
						// objects[indexTarget].position.y=objects[indexRef].position.y;
						// objects[indexTarget].position.z=objects[indexRef].position.z;
						// objects[indexTarget].scale.x=objects[indexRef].scale.x;
						// objects[indexTarget].scale.z=objects[indexRef].scale.z;
					// }
				// }
			// }
			// else if (listL[i]=="above"){
				
				// for (var j=0; j<compLayout[listL[i]].length;j++){
					// if (compLayout[listL[i]][j][0]==cName && compLayout[listL[i]][j][1]==cRef){
						// objects[indexTarget].position.x=objects[indexRef].position.x;
						// objects[indexTarget].position.y=objects[indexRef].position.y+spacing;
						// objects[indexTarget].position.z=objects[indexRef].position.z;
					// }
					// if (compLayout[listL[i]][j][1]==cName && compLayout[listL[i]][j][0]==cRef){
						// objects[indexTarget].position.x=objects[indexRef].position.x;
						// objects[indexTarget].position.y=objects[indexRef].position.y-spacing;
						// objects[indexTarget].position.z=objects[indexRef].position.z;
					// }
				// }
			// }
			// else if (listL[i]=="outer"){
				// var dilation_count=0;
				// for (var j=0; j<compLayout[listL[i]].length;j++){
					// if (compLayout[listL[i]][j][1]==cRef){
						// var mindexTarget=-1;
						// for ( var i2 = 0; i2 < listCompartments.length; i2 ++ ) {
							// if (objects[i2].name==compLayout[listL[i]][j][0])
								// mindexTarget=i2;
						// }
						// objects[mindexTarget].position.x=objects[indexRef].position.x;
						// objects[mindexTarget].position.y=objects[indexRef].position.y;
						// objects[mindexTarget].position.z=objects[indexRef].position.z;
						// dilation_count++;
						// objects[mindexTarget].scale.x = 1+dilation_count
						// objects[mindexTarget].scale.z = 1+dilation_count
					// }
					
				// }
			
			// }
			// else if (listL[i]=="satellite"){
				// var max_rotation_count=0;
				// for (var j=0; j<compLayout[listL[i]].length;j++){
					// if (compLayout[listL[i]][j][1]==cRef){ 
							// max_rotation_count++;
					// }
				// }
				// var rotation_count=0;
				// for (var j=0; j<compLayout[listL[i]].length;j++){
					// if (compLayout[listL[i]][j][1]==cRef){
						// var mindexTarget=-1;
						// for ( var i2 = 0; i2 < listCompartments.length; i2 ++ ) {
							// if (objects[i2].name==compLayout[listL[i]][j][0])
								// mindexTarget=i2;
						// }
						// var dilation_count=0;
						// for (var j1=0; j1<compLayout["outer"].length;j1++){
							// if (compLayout["outer"][j1][1]==cRef){
								// dilation_count++;
							// }
						// }
						// objects[mindexTarget].position.x=objects[indexRef].position.x+Math.cos(((2 * Math.PI)*(1/max_rotation_count))*rotation_count)*(spacing+(dilation_count*spacing/2));
						// objects[mindexTarget].position.y=objects[indexRef].position.y;
						// objects[mindexTarget].position.z=objects[indexRef].position.z+Math.sin(((2 * Math.PI)*(1/max_rotation_count))*rotation_count)*(spacing+(dilation_count*spacing/2));
						// rotation_count++;
					// }
					
				// }
			// }
			// else if (listL[i]=="in"){
				// var max_rotation_count=0;
				// for (var j=0; j<compLayout[listL[i]].length;j++){
					// if (compLayout[listL[i]][j][1]==cRef){ 
							// max_rotation_count++;
					// }
				// }
				// var rotation_count=0;
				// for (var j=0; j<compLayout[listL[i]].length;j++){
					// if (compLayout[listL[i]][j][1]==cRef){
						// var mindexTarget=-1;
						// for ( var i2 = 0; i2 < listCompartments.length; i2 ++ ) {
							// if (objects[i2].name==compLayout[listL[i]][j][0])
								// mindexTarget=i2;
						// }
						// //console.log(((2 * Math.PI)*objects[indexRef].scale.x*radiusComp))
						// objects[mindexTarget].scale.x=0.25;
						// objects[mindexTarget].scale.y=0.125;
						// objects[mindexTarget].scale.z=0.25;
						// var maxDiameter=((2 * Math.PI)*objects[indexRef].scale.x*radiusComp)*(1/max_rotation_count);
						// var presentDiameter=(objects[mindexTarget].scale.x*radiusComp);
						// if (maxDiameter<=presentDiameter){
							// objects[mindexTarget].scale.x=objects[mindexTarget].scale.x*((maxDiameter/presentDiameter)*1.1)
							// objects[mindexTarget].scale.y=objects[mindexTarget].scale.x/2;
							// objects[mindexTarget].scale.z=objects[mindexTarget].scale.x;
						// }
						
						// objects[mindexTarget].position.x=objects[indexRef].position.x+Math.cos(((2 * Math.PI)*(1/max_rotation_count))*rotation_count)*((objects[indexRef].scale.x*spacing*0.3));
						// objects[mindexTarget].position.y=objects[indexRef].position.y;
						// objects[mindexTarget].position.z=objects[indexRef].position.z+Math.sin(((2 * Math.PI)*(1/max_rotation_count))*rotation_count)*((objects[indexRef].scale.x*spacing*0.3));
						// rotation_count++;
					// }
					
				// }
			
			// }
			// else{}
			// // for (var j=0; j<compLayout[listL[i]].length;j++){
				// // if ((compLayout[listL[i]][j][0]==id_removed) || (compLayout[listL[i]][j][1]==id_removed)){
					
				// // }
				// // else{
					// // listI.push(compLayout[listL[i]][j])
				// // }
			// // }
			// // compLayout[listL[i]]=listI;
		// }
	}
	
	</script>	
		
</div>

