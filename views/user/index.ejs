<div class="container">
	<h3>User Administration</h3>
	<table class='table'>
		<tr>
			<th></th>
			<th>ID</th>
			<th>Name</th>
			<th>Title</th>
			<th>Email</th>
			<th></th>
			<th></th>
			<th></th>
		</tr>
		
		
		<%
		var dataU =[];
		
		//_.each(labs, function(lab) {
		//	dataL.push(lab.name)
		//}
		_.each(users, function(user,ind) { %>
		<tr data-id="<%= user.id %>" data-model="user">
			<% if (user.online) { %>
				<td><img src="/images/icon-online.png"></td>
			<% } else { %>
				<td> <img src="/images/icon-offline.png"></td>
			<% } %>
			<td><%= user.id %></td>
			<%dataU.push(user.name)%>
			<td><%= user.name %></td>
			<td><%= user.title %></td>
			<td><%= user.email %></td>
			<% if (user.admin) { %>
				<td> <img src="/images/admin.png"></td>
			<% } else { %>
				<td> <img src="/images/pawn.png"></td>
			<% } %>	
			<td><a href="/user/show/<%= user.id %>" class="btn btn-sm btn-primary">Show</a></td>
			<td><a href="/user/edit/<%= user.id %>" class="btn btn-sm btn-warning">Edit</a></td>

			<td><form action="/user/destroy/<%= user.id %>" method="POST">
				<input type="hidden" name="_method" value="delete"/>
				<input type="submit" class="btn btn-sm btn-danger" value="Delete"/>
				<input type="hidden" name="_csrf" value="<%= _csrf %>" />
			</form></td>
		</tr> 

		<% }) %>
	</table>
	
	
	<!--<svg class="chart"></svg>-->
	<div id="container"></div>
	
		<script id="fragmentShader" type="x-shader/x-fragment">
		
		uniform float time;
			uniform vec2 resolution;
			varying vec2 vUv;

			void main() {
				
				
				vec2 position = -1.0 + 2.0 * vUv;
				//vec2 p = ( gl_FragCoord.xy / resolution.xy ) - 0.50;
				float sx = 0.2 * (position.x + 0.01) * sin( 100.0 * position.x - 1. * time);
				float dy = 1./ ( 50. * abs(position.y - sx));
				dy += 1./ (20. * length(position - vec2(position.x, 0.)));
				gl_FragColor = vec4( (position.x + 0.50) * dy, 0.23 * dy, dy, 1.0 );
			}
			/*uniform float time;
			uniform vec2 resolution;
			varying vec2 vUv;
			void main( void ) {
				//vec2 position = (gl_FragCoord.xy / resolution.xy) - 5.0;
				vec2 position = -1.0 + 2.0 * vUv;
				vec3 color = vec3(0.0, 0.0, 0.0);
				float px = 1.0 * (position.x+0.3*sin(1.0*pow(time, 1.0)*1.0));				
				float py = 4.0/(500.0*abs(position.y - px));
				float py2 = 4.0/(200.0*abs(position.y - px));				
				float px1 = 1.0 * (position.x+0.3*sin(1.0*pow(time, 1.0)*1.0));				
				float py3 = 5.0/(500.0*abs(position.y+0.2 - px1));
				float py4 = 5.0/(200.0*abs(position.y+0.2 - px1));				
				color.x = (position.x-py)*0.4;
				color.y = py*0.3;
				color.z = py;				
				color.x += (position.x-py2)*0.4;
				color.z += py2;				
				color.x += (position.x-py3)*0.4;
				color.y += py3*1.0;
				color.z += py3;				
				color.x += (position.x-py4)*0.4;
				color.z += py4;					
				gl_FragColor = vec4(color, 1.0);
			}
		
		/*
		uniform float time;
		uniform vec2 mouse;
		uniform vec2 resolution;
		varying vec2 vUv;
		#define PI 3.1415926535

		void main( void ) {
			//vec2 p = (2.0*gl_FragCoord.xy - resolution.xy)/resolution.y;
			vec2 p = -1.0 + 2.0 * vUv;
			//vec2 p = (2.0*gl_FragCoord.xy - resolution.xy)/resolution.y;
			//p = floor(p)+fract(p*4.0);
			vec3 col = vec3(0.2);
			for(int i=0; i<20; i++) {
				float a = 2.0*PI*float(i)/12.0 + time*0.02;
				float x = mod(a,1.)*time*0.001-2.;
				float y = -1.+float(i)/10.0;
				vec2 q = vec2(x,y);
				float r = fract(a);
				float g = 1.0-r;
				col += 0.01/length(p-q)*vec3(r, g, 0.01);
			}
			gl_FragColor = vec4(vec3(col), 1.0);
		}*/
		/*uniform float time;
		uniform vec2 mouse;
		uniform vec2 resolution;
		varying vec2 vUv;

		float length2(vec2 p) { return dot(p, p); }

		float noise(vec2 p){
			return fract(sin(fract(sin(p.x) * (43.13311)) + p.y) * 31.0011);
		}

		float worley(vec2 p) {
			float d = 1e30;
			for (int xo = -1; xo <= 1; ++xo) {
				for (int yo = -1; yo <= 1; ++yo) {
					vec2 tp = floor(p) + vec2(xo, yo);
					d = min(d, length2(p - tp - vec2(noise(tp))));
				}
			}
			return 3.0*exp(-4.0*abs(2.0*d - 1.0));
		}

		float fworley(vec2 p) {
			return sqrt(sqrt(sqrt(
				1.1 * // light
				worley(p*5. + .3 + 0.01*time*.0525) *
				sqrt(worley(p * 50. + 0.3 + 0.01*time * -0.15)) *
				sqrt(sqrt(worley(p * -10. + 9.3))))));
		}

		void main() {
			//vec2 uv = gl_FragCoord.xy / resolution.xy;
			vec2 uv = -1.0 + 2.0 * vUv;
			float t = fworley(uv * resolution.xy / 1500.0);
			t *= exp(-length2(abs(0.7*uv - 1.0)));
			gl_FragColor = vec4(t * vec3(0.1, 1.5*t, 1.2*t + pow(t, 0.5-t)), 1.0);
		}*/
		
		/*uniform float time;
		uniform vec2 mouse;
		uniform vec2 resolution;
		varying vec2 vUv;
		// Created by inigo quilez - iq/2013 : https://www.shadertoy.com/view/4dl3zn
		// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
		// Messed up by Weyland

		void main(void)
		{
			//vec2 uv = -1.0 + 2.0*gl_FragCoord.xy / resolution.xy;
			//uv.x *= resolution.x / resolution.y;
			vec2 uv = -1.0 + 2.0 * vUv;
			
			// background	 
		//	vec3 color = vec3(0.9 + 0.2*uv.y);
			vec3 color = vec3(1.0);

			// bubbles	
			for( int i=0; i<64; i++ )
			{
				// bubble seeds
				float pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;
				float siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );
				float pox =      sin(float(i)*321.55+4.1) * resolution.x / resolution.y;

				// buble size, position and color
				float rad = 0.1 + 0.5*siz+sin(time/6.+pha*500.+siz)/20.;
				vec2  pos = vec2( pox+sin(time/10.+pha+siz), -1.0-rad + (2.0+2.0*rad)
								 *mod(pha+0.1*(time/5.)*(0.2+0.8*siz),1.0));
				float dis = length( uv - pos );
				vec3  col = mix( vec3(0.194*sin(time/6.0),0.3,0.0), 
								vec3(1.1*sin(time/9.0),0.4,0.8), 
								0.5+0.5*sin(float(i)*1.2+1.9));
					  //col+= 8.0*smoothstep( rad*0.95, rad, dis );
				
				// render
				float f = length(uv-pos)/rad;
				f = sqrt(clamp(1.0-f*f,0.0,1.0));
				color -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;
			}

			// vigneting	
			color *= sqrt(1.5-0.5*length(uv));

			gl_FragColor = vec4(color,1.0);
		}*/
		/*uniform float time;
		uniform vec2 mouse;
		uniform vec2 resolution;
		varying vec2 vUv;
		float pi = atan(1.0)*4.0;
		float tau = atan(1.0)*8.0;
		vec2 res = vec2(resolution.x/resolution.y,1.0);

		mat3 rotate(vec3 ang)
		{
			mat3 rX = mat3(1,0,0,
					   0,cos(ang.x),-sin(ang.x),
					   0,sin(ang.x),cos(ang.x));
			mat3 rY = mat3(cos(ang.y),0,sin(ang.y),
					   0,1,0,
					   -sin(ang.y),0,cos(ang.y));
			mat3 rZ = mat3(cos(ang.z),-sin(ang.z),0,
					   sin(ang.z),cos(ang.z),0,
					   0,0,1);
			return rX*rY*rZ;
					   
		}

		vec3 cylNorm(vec3 v)
		{
			return v / max(length(v.xz),length(v.y*2.0));
		}

		float bar(float x,float width,float h,vec2 uv)
		{
			float hw = width/2.0;
			float edges = smoothstep(-hw-0.001,-hw,uv.x-x) * smoothstep(hw+0.001,hw,uv.x-x);
			x -= res.x;
			edges += smoothstep(-hw-0.005,-hw,uv.x-x) * smoothstep(hw+0.005,hw,uv.x-x);
			x += res.x;
			edges += smoothstep(-hw-0.005,-hw,uv.x-x) * smoothstep(hw+0.005,hw,uv.x-x);
			
			return ((1.0-uv.y)-h) * edges * step(-3.999,uv.y);
		}

		float rand(float n)
		{
			return fract(sin(n) * 43758.5453123);
		}

		float backdrop(vec2 uv)
		{
			float col = 0.0; //srsly
			for(int i = 0;i < 32;i++)
			{
				float x = float(i);
				float off = mod(time * rand(x+0.4)*0.01,1.0);
				col += bar(off,0.01+rand(x+4.5)*0.05,rand(x+0.5),uv)*rand(x+5.)*0.02;
			}
			return col;
		}

		void main( void ) 
		{
			//vec2 p = ( gl_FragCoord.xy / resolution.y ) - res/2.0;
			vec2 position = -1.0 + 2.0 * vUv;
				
			vec3 cang = vec3(mouse.yx-0.5,0)*pi;
			cang = vec3(0,tau*(2./4.),0);
			
			vec3 cdir = normalize(vec3(position.xy,0.7));
			
			cdir *= rotate(cang);
			cdir = cylNorm(cdir);
			
			vec3 col;
			
			float horizon = min(length(cdir.xz),(0.5-cdir.y));
			
			col = vec3(0,0.5,1)*pow(horizon,3.) + pow(horizon,16.);
			
			vec2 backuv = vec2(atan(cdir.z,cdir.x)/tau + 0.5,cdir.y*8.0);
			
			col += backdrop(backuv);
			
			gl_FragColor = vec4( col , 1.0 );

		}*/
		/*
		const float VELOCITY        = 20.0  ;           // speed of lines [ 0.5  .. 1.5  ] =  1.0
		const float HEIGHT          = 0.5    ;           // height of the lines  [ 0    .. 1.0  ] =  0.5
		const float FREQUENCY       = 32.5 ;           // frequency  [ 1.0  .. 14.0 ] =  9.0
		const float AMPLITUDE       = 0.3 ;           // amplitude  [ 0.1  .. 0.5  ] =  0.2
		const int   NUMBER          = 10    ;           // lines      [ 0    .. 20   ] = 10.0
		const float INVERSE         = 1.0 / float(10);  // inverse
		uniform vec2 resolution;
		uniform float time;
		varying vec2 vUv;
		
		void main()
		{
		   vec3 col = vec3( 1.);
		   
		   float rColMod;
		   float gColMod;
		   float bColMod;
		   
		   float offset;
		   float t;
		   
		   float color;
		   float colora;
		   
		   float tsin;
				   
		   for (int i = 0; i < NUMBER; ++i)
		   {
			  vec2 pos= vUv+0.5;//gl_FragCoord.xy/resolution.xy;
			  
			  offset = float(i) * INVERSE;
					
			  t      = time + VELOCITY *(offset * offset * 2.);
			  
			  tsin   = sin( t +pos.y*33.);
			  
			  pos.y -= HEIGHT;
			  pos.y+=sin(pos.x * FREQUENCY + t ) * AMPLITUDE * tsin;
			  
			  color  = 1.0 - pow( abs( pos.y) , 0.2 );
			  colora = pow( 1. , 0.2 * abs( pos.y ) );
			  
			  rColMod = (2. - (offset * .5) + .5) * colora ;
			  gColMod = ((offset * .5) + .65) * colora ;
			  bColMod = ((offset * .5) + .35) * colora ;
				   
			  col -= exp(color) *color* INVERSE * vec3( mix(rColMod, gColMod, tsin), mix(gColMod, bColMod, tsin) , sin(bColMod*rColMod*tsin)*mix(bColMod, rColMod, tsin)) ;      
		   }
		   
		   gl_FragColor=vec4(col.x, col.y, col.y ,1.0);
			 
		}*/
		/*uniform float time;
		uniform vec2 resolution;
		varying vec2 vUv;
		void main( void ) 
		{
			//vec2 p = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;
			vec2 position = -1.0 + 2.0 * vUv;
			vec3 c = vec3( 0.0 );
			
			float amplitude = 0.30; 
			float glowT = sin(0.01*time) * 0.5 + 0.5;
			float glowFactor = mix( 0.15, 0.35, glowT );
			c += vec3(0.02, 0.03, 0.13) * ( glowFactor * abs( 1.0 / sin(position.x + sin( position.y + 0.01*time ) * amplitude ) ));
			c += vec3(0.02, 0.10, 0.03) * ( glowFactor * abs( 1.0 / sin(position.x + sin( position.y + 0.01*time+1.00 ) * amplitude+0.1 ) ));

			gl_FragColor = vec4( c, 1.0 );

		}*/
		
		/*uniform float time;
		uniform vec2 resolution;
		varying vec2 vUv;
		void main( void ) 
		{
			//vec2 k; 
			//k.x = resolution.y; k.y = resolution.y;
			//vec2 p = ( gl_FragCoord.xy / k.xy ) ; 
			vec2 position = -1.0 + 2.0 * vUv;
			
			vec3 c = vec3( 0.0 );
			
			c += vec3(1.0, 0.5, 1.0) * fract( (              position.x + position.y + fract(time*0.05) ) * 5.0 ) ;
			c *= vec3(1.0, 2.0, 2.0) * fract( (sin(time*0.05)*position.x - position.y + fract(time*0.005) ) * 5.0 ) ;
			c *= ( position.x * position.y );
			
			gl_FragColor = vec4( c, 1.0 );
		}*/
		/*uniform float time;
		varying vec2 vUv;
		uniform vec2 resolution;

		void main( void ) {

			//this is me deconstructing http://glsl.heroku.com/e#19344.0 to try and figure out how it works
			
			vec2 position = -1.0 + 2.0 * vUv;
			vec3 colour = vec3(0.0);
			
			float density = 0.09;
			float amplitude = 0.3;
			float frequency = 10.0;
			float scroll = 0.01;


				colour += vec3	(0.1, 0.05, 0.05) * (1.0 / abs((position.y + (amplitude * sin((position.x + time * scroll) *frequency)))) * density);
				
			
			gl_FragColor = vec4( colour, 1.0 );

		}*/
			/*uniform float time;		
			uniform vec2 resolution;
			varying vec2 vUv;
			void main( void ) 
			{
				//vec2 p = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;
				vec2 position = -1.0 + 2.0 * vUv;
				
				position.y += 0.1*position.x;//sin(time*0.5)*0.1*position.x;
				
				vec3 c = vec3( 0.0 );
				
				float amplitude = 0.005; 
				float glowT = sin(time*0.01) * 0.5 + 10.5;
				float glowFactor = mix( 0.15, 0.35, glowT );
				c += vec3(0.02, 0.03, 0.13) * ( glowFactor * abs(1.0 /(position.y)));

				gl_FragColor = vec4( c, 1.0);

			}*/
			/*uniform float time;
			uniform vec2 resolution;
			varying vec2 vUv;
			void main( void ) 
			{
				//vec2 p = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;
				vec2 position = -1.0 + 2.0 * vUv;
				
				vec3 c = vec3( 0.0 );
				
				float amplitude = 3.05; 
				float glowT = sin(time) * 0.6 + 0.1;
				float glowFactor = mix( 0.15, 0.35, glowT );
				
				c += vec3(0.02, 0.03, 0.13) * ( glowFactor * abs( 1.0 / sin(position.x + sin( position.y + 0.01*time ) * amplitude ) ));
				c += vec3(0.02, 0.10, 0.03) * ( glowFactor * abs( 1.0 / sin(position.x + cos( position.y + 0.01*time+1.00 ) * amplitude+0.1 ) ));
				c += vec3(0.15, 0.05, 0.20) * ( glowFactor * abs( 1.0 / sin(position.y + sin( position.x + 0.01*time+1.30 ) * amplitude+0.15 ) ));
				c += vec3(0.20, 0.05, 0.05) * ( glowFactor * abs( 1.0 / sin(position.y + cos( position.x + 0.01*time+3.00 ) * amplitude+0.3 ) ));
				c += vec3(0.17, 0.17, 0.05) * ( glowFactor * abs( 1.0 / sin(position.y + cos( position.x + 0.01*time+5.00 ) * amplitude+0.2 ) ));
				
				gl_FragColor = vec4( c, 400.0 );

			}*/
			/*uniform float time;
			uniform vec2 resolution;
			varying vec2 vUv;
			float deg2rad=3.141592/180.0;
			float angle=60.0;
			vec2 normal=vec2(cos(angle*deg2rad),sin(angle*deg2rad));
			void main( void ) {
				
				float freq=5.0;
				float rahmda=5.0;
				
				float len=dot(gl_FragCoord.xy,normal);
				
				float factor=sin(time*freq - len/rahmda)*0.4 + 1.0;
				
				gl_FragColor=vec4(0.4*factor,0.3*factor,0.9*factor,1.0);

			}*/
			/*uniform float time;
			uniform vec2 resolution;
			varying vec2 vUv;
			void main( void ) {
				//vec2 position = (gl_FragCoord.xy / resolution.xy) - 5.0;
				vec2 position = -1.0 + 2.0 * vUv;
				vec3 color = vec3(0.0, 0.0, 0.0);
				float px = 1.0 * (position.x+0.3*sin(1.0*pow(time, 1.0)*1.0));				
				float py = 4.0/(500.0*abs(position.y - px));
				float py2 = 4.0/(200.0*abs(position.y - px));				
				float px1 = 1.0 * (position.x+0.3*sin(1.0*pow(time, 1.0)*1.0));				
				float py3 = 5.0/(500.0*abs(position.y+0.2 - px1));
				float py4 = 5.0/(200.0*abs(position.y+0.2 - px1));				
				color.x = (position.x-py)*0.4;
				color.y = py*0.3;
				color.z = py;				
				color.x += (position.x-py2)*0.4;
				color.z += py2;				
				color.x += (position.x-py3)*0.4;
				color.y += py3*1.0;
				color.z += py3;				
				color.x += (position.x-py4)*0.4;
				color.z += py4;					
				gl_FragColor = vec4(color, 1.0);
			}*/
		
			/*uniform float time;
			uniform vec2 resolution;
			varying vec2 vUv;

			void main() {
				
				
				vec2 position = -1.0 + 2.0 * vUv;
				//vec2 p = ( gl_FragCoord.xy / resolution.xy ) - 0.50;
				float sx = 0.2 * (position.x + 0.01) * sin( 100.0 * position.x - 1. * time);
				float dy = 1./ ( 50. * abs(position.y - sx));
				dy += 1./ (20. * length(position - vec2(position.x, 0.)));
				gl_FragColor = vec4( (position.x + 0.50) * dy, 0.23 * dy, dy, 1.0 );
			}*/
		
			/*uniform float time;
			uniform vec2 resolution;

			varying vec2 vUv;

			void main( void ) {

				vec2 position = -1.0 + 2.0 * vUv;

				float red = abs( sin( position.x * position.y + time / 5.0 ) );
				float green = abs( sin( position.x * position.y + time / 4.0 ) );
				float blue = abs( sin( position.x * position.y + time / 3.0 ) );
				gl_FragColor = vec4( red, green, blue, 1.0 );

			}*/
			/*uniform float time;
			uniform vec2 resolution;

			varying vec2 vUv;

			void main( void ) {

				vec2 position = vUv;

				float color = 0.0;
				//color += sin( position.x * cos( time / 15.0 ) * 80.0 ) + cos( position.y * cos( time / 15.0 ) * 10.0 );
				//color += sin( position.y * sin( time / 10.0 ) * 40.0 ) + cos( position.x * sin( time / 25.0 ) * 40.0 );
				//color += sin( position.x * sin( time / 5.0 ) * 10.0 ) + sin( position.y * sin( time / 35.0 ) * 80.0 );
				color += sin( position.x * cos( time / 15.0 ) * 80.0 ) + cos( position.y * cos( time / 15.0 ) * 10.0 );
				color += sin( position.y * sin( time / 10.0 ) * 40.0 ) + cos( position.x * sin( time / 25.0 ) * 40.0 );
				color += sin( position.x * sin( time / 5.0 ) * 10.0 ) + sin( position.y * sin( time / 35.0 ) * 80.0 );
				color *= sin( time / 10.0 ) * 0.5;
				color *= sin( time / 10.0 ) * 0.5;

				//gl_FragColor = vec4( vec3( color, color * 0.5, sin( color + time / 3.0 ) * 0.75 ), 1.0 );
				gl_FragColor = vec4( vec3( color, color * 0.7, sin( color + time / 3.0 ) * 0.75 ), 1.0 );
			}*/
			/*
			varying vec2 vUv;
		uniform float time;

		uniform vec2 resolution;

		void main( void ) {
			//vec2 position = ( gl_FragCoord.xy / resolution.xy ) - 0.5;
			vec2 position = vUv-0.5;
			vec3 colour = vec3(0.0);		
			float density = (1.5 - (abs(sin(0.1*time)))) * 0.5;
			float amplitude = 0.01;
			float frequency = 5.0;
			colour += vec3(0.1, 0.05, 0.07) * (1.0 / abs((position.y + (amplitude * tan((position.x - 1.0) *frequency)))) * density);
			colour += vec3(0.1, 0.05, 0.07) * (1.0 / abs(((position.y) + (amplitude * tan((1.0 - position.x) *frequency)))) * density);		
			gl_FragColor = vec4( colour, 1.0 );
		}
		*/
		/*
		varying vec2 vUv;
		uniform float time;
		uniform vec2 resolution;

		void main(void)
		{
			//vec2 uv = -1.0 + 2.0*gl_FragCoord.xy / resolution.xy;
			vec2 muv = -1.0 + 2.0 * vUv;
			//muv.x *=  resolution.x / resolution.y;
			
			// background	 
			vec3 color = vec3(0.8 + 0.2*muv.y);

			// bubbles	
			for( int i=0; i<20; i++ )
			{
				// bubble seeds
				float pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;
				float siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );
				float pox =      sin(float(i)*321.55+4.1) ;
				
				// buble size, position and color
				float rad = 0.1 + 0.5*siz;
				vec2  pos = vec2( pox, -1.0-rad + (2.0+2.0*rad)*mod(pha+0.1*time*(0.2+0.8*siz),1.0));
				float dis = length( muv - pos );
				vec3  col = mix( vec3(0.94,0.3,0.0), vec3(0.1,0.4,0.8), 0.5+0.5*sin(float(i)*1.2+1.9));
				
				// render
				float f = length(muv-pos)/rad;
				f = sqrt(clamp(1.0-f*f,0.0,1.0));
				color -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;
			}

			// vigneting	
			color *= sqrt(1.5-0.5*length(muv));

			gl_FragColor = vec4(color,1.0);
		}
		*/

		</script>
		
		
		
		<script id="vertexShader" type="x-shader/x-vertex">

			varying vec2 vUv;

			void main()
			{
				vUv = uv;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
			}

		</script>
		
		
	
	<script id="fragmentShader2" type="x-shader/x-fragment">
		
		varying vec2 vUv;
		uniform float time;

	uniform vec2 resolution;

	float length2(vec2 p) { return dot(p, p); }

	float noise(vec2 p){
		return fract(sin(fract(sin(p.x) * (43.13311)) + p.y) * 31.0011);
	}

	float worley(vec2 p) {
		float d = 1e30;
		for (int xo = -1; xo <= 1; ++xo) {
			for (int yo = -1; yo <= 1; ++yo) {
				vec2 tp = floor(p) + vec2(xo, yo);
				d = min(d, length2(p - tp - vec2(noise(tp))));
			}
		}
		return 3.0*exp(-4.0*abs(2.0*d - 1.0));
	}

	float fworley(vec2 p) {
		return sqrt(sqrt(sqrt(
			0.01 * // light
			worley(p*5. + .3 + time*.0225) *
			sqrt(worley(p * 50. + 0.3 + 0.2*time * -0.15)) *
			sqrt(sqrt(worley(p * -10. + 9.3))))));
	}

	void main() {
		vec2 uv = vUv;
		float t = fworley(uv  / 1.0);
		t *= exp(-length2(abs(uv - 0.5)));//t *= exp(-length2(abs(0.7*uv - 1.0)));
		gl_FragColor = vec4(t * vec3(1.0, t, t ), 0.0);
	}
	
	
	</script>
	<script id="vertexShader2" type="x-shader/x-vertex">

			varying vec2 vUv;

			void main()
			{
				vUv = uv;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
			}

		</script>	
		
		
<script>
/*var data = [4, 8, 15, 16, 23, 42];

var width = 420,
    barHeight = 20;

var x = d3.scale.linear()
    .domain([0, d3.max(data)])
    .range([0, width]);

var chart = d3.select(".chart")
    .attr("width", width)
    .attr("height", barHeight * data.length);

var bar = chart.selectAll("g")
    .data(data)
  .enter().append("g")
    .attr("transform", function(d, i) { return "translate(0," + i * barHeight + ")"; });

bar.append("rect")
    .attr("width", x)
    .attr("height", barHeight - 1);

bar.append("text")
    .attr("x", function(d) { return x(d) - 3; })
    .attr("y", barHeight / 2)
    .attr("dy", ".35em")
    .text(function(d) { return d; });
	*/

/*var width = 960,
    height = 500;

var color = d3.scale.category20();

var force = d3.layout.force()
    .charge(-120)
    .linkDistance(30)
    .size([width, height]);

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

var data2= <%-JSON.stringify(dataU)%>;
console.log(data2);
	
d3.json("/models-json/miserables.json", function(error, graph) {
  force
      .nodes(graph.nodes)
      .links(graph.links)
      .start();

  var link = svg.selectAll(".link")
      .data(graph.links)
    .enter().append("line")
      .attr("class", "link")
      .style("stroke-width", function(d) { return Math.sqrt(d.value); });

  var node = svg.selectAll(".node")
      .data(graph.nodes)
    .enter().append("circle")
      .attr("class", "node")
      .attr("r", 5)
      .style("fill", function(d) { return color(d.group); })
      .call(force.drag);

  node.append("title")
      .text(function(d) { return d.name; });

  force.on("tick", function() {
    link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    node.attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });
  });
});
*/
var w = 960, h = 500;

			var labelDistance = 0;

			var vis = d3.select("body").append("svg:svg").attr("width", w).attr("height", h);

			var nodes = [];
			var labelAnchors = [];
			var labelAnchorLinks = [];
			var links = [];
			var list_users= <%-JSON.stringify(dataU)%>;
			var list_labs= <%-JSON.stringify(labs)%>;
			//console.log(list_labs);
			for(var i = 0; i < list_users.length; i++) {
				var node = {
					label : list_users[i]
				};
				nodes.push(node);
				labelAnchors.push({
					node : node
				});
				labelAnchors.push({
					node : node
				});
			};

			for(var i = 0; i < nodes.length; i++) {
				for(var j = 0; j < i; j++) {
					if(Math.random() >= 0.0)
						links.push({
							source : i,
							target : j,
							weight : Math.random()
						});
				}
				labelAnchorLinks.push({
					source : i * 2,
					target : i * 2 + 1,
					weight : 1
				});
			};

			var force = d3.layout.force().size([w, h]).nodes(nodes).links(links).gravity(1).linkDistance(50).charge(-3000).linkStrength(function(x) {
				return x.weight * 10
			});


			force.start();

			var force2 = d3.layout.force().nodes(labelAnchors).links(labelAnchorLinks).gravity(0).linkDistance(0).linkStrength(8).charge(-100).size([w, h]);
			force2.start();

			var link = vis.selectAll("line.link").data(links).enter().append("svg:line").attr("class", "link").style("stroke", "#CCC");

			var node = vis.selectAll("g.node").data(force.nodes()).enter().append("svg:g").attr("class", "node");
			node.append("svg:circle").attr("r", 5).style("fill", "#555").style("stroke", "#FFF").style("stroke-width", 3);
			node.call(force.drag);


			var anchorLink = vis.selectAll("line.anchorLink").data(labelAnchorLinks)//.enter().append("svg:line").attr("class", "anchorLink").style("stroke", "#999");

			var anchorNode = vis.selectAll("g.anchorNode").data(force2.nodes()).enter().append("svg:g").attr("class", "anchorNode");
			anchorNode.append("svg:circle").attr("r", 0).style("fill", "#FFF");
				anchorNode.append("svg:text").text(function(d, i) {
				return i % 2 == 0 ? "" : d.node.label
			}).style("fill", "#555").style("font-family", "Arial").style("font-size", 12);

			var updateLink = function() {
				this.attr("x1", function(d) {
					return d.source.x;
				}).attr("y1", function(d) {
					return d.source.y;
				}).attr("x2", function(d) {
					return d.target.x;
				}).attr("y2", function(d) {
					return d.target.y;
				});

			}

			var updateNode = function() {
				this.attr("transform", function(d) {
					return "translate(" + d.x + "," + d.y + ")";
				});

			}


			force.on("tick", function() {

				force2.start();

				node.call(updateNode);

				anchorNode.each(function(d, i) {
					if(i % 2 == 0) {
						d.x = d.node.x;
						d.y = d.node.y;
					} else {
						var b = this.childNodes[1].getBBox();

						var diffX = d.x - d.node.x;
						var diffY = d.y - d.node.y;

						var dist = Math.sqrt(diffX * diffX + diffY * diffY);

						var shiftX = b.width * (diffX - dist) / (dist * 2);
						shiftX = Math.max(-b.width, Math.min(0, shiftX));
						var shiftY = 5;
						this.childNodes[1].setAttribute("transform", "translate(" + shiftX + "," + shiftY + ")");
					}
				});


				anchorNode.call(updateNode);

				link.call(updateLink);
				anchorLink.call(updateLink);

			});
			
			
		if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
			var uniforms, uniforms2;
			var text0 = document.createElement('div');
			text0.style.position = 'absolute';
			text0.style.width = 100;
			text0.style.height = 100;
			text0.style.color = "white";
			text0.style.textAlign="left";
			//text0.style.backgroundColor = "#FFFFCC";
			//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
			text0.innerHTML = 'hello ';
			text0.style.top = 200 + 'px';
			text0.style.left = 200 + 'px';
			document.body.appendChild(text0);
		
			var effectFXAA;
			var selectedModelName="";
			var mouseX = 0, mouseY = 0,			
			windowHalfX = window.innerWidth / 2,
			windowHalfY = window.innerHeight / 2,
			camera, scene, renderer, material, composer;
			var mouse = new THREE.Vector2(), INTERSECTED;
			var select_mesh;
			//var projector = new THREE.Projector();
			var raycaster = new THREE.Raycaster();
			var directionalLight;
			var controls;
			var clock = new THREE.Clock();
			var bline;
			init();
			animate();

			function init() {

				var i, container;

				//container = document.createElement( 'div' );
				container = document.getElementById("container");
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 33, window.innerWidth / window.innerHeight, 1, 100000 );
				camera.position.z = 700;
				camera.position.y = 100;
				scene = new THREE.Scene();

				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.autoClear = false;

				container.appendChild( renderer.domElement );

				/*
				var geometry = new THREE.Geometry(),
					geometry2 = new THREE.Geometry(),
					geometry3 = new THREE.Geometry(),
					points = hilbert3D( new THREE.Vector3( 0,0,0 ), 200.0, 2, 0, 1, 2, 3, 4, 5, 6, 7 ),
					colors = [], colors2 = [], colors3 = [];

				for ( i = 0; i < points.length; i ++ ) {

					geometry.vertices.push( points[ i ] );

					colors[ i ] = new THREE.Color( 0xffffff );
					colors[ i ].setHSL( 0.6, 1.0, Math.max( 0, ( 200 - points[ i ].x ) / 400 ) * 0.5 + 0.5 );

					colors2[ i ] = new THREE.Color( 0xffffff );
					colors2[ i ].setHSL( 0.3, 1.0, Math.max( 0, ( 200 + points[ i ].x ) / 400 ) * 0.5 );

					colors3[ i ] = new THREE.Color( 0xffffff );
					colors3[ i ].setHSL( i / points.length, 1.0, 0.5 );

				}

				geometry2.vertices = geometry3.vertices = geometry.vertices;

				geometry.colors = colors;
				geometry2.colors = colors2;
				geometry3.colors = colors3;

				// lines

				material = new THREE.LineBasicMaterial( { color: 0xffffff, opacity: 1.0, linewidth: 1, vertexColors: THREE.VertexColors } );

				var line, p, scale = 0.3, d = 225;
				var parameters =  [
					[ material, scale*1.5, [-d,0,0],  geometry ],
					[ material, scale*1.5, [0,0,0],  geometry2 ],
					[ material, scale*1.5, [d,0,0],  geometry3 ]
				];

				for ( i = 0; i < parameters.length; ++i ) {

					p = parameters[ i ];
					line = new THREE.Line( p[ 3 ],  p[ 0 ] );
					line.scale.x = line.scale.y = line.scale.z =  p[ 1 ];
					line.position.x = p[ 2 ][ 0 ];
					line.position.y = p[ 2 ][ 1 ];
					line.position.z = p[ 2 ][ 2 ];
					scene.add( line );

				}*/
				
				uniforms = {
					time: { type: "f", value: 1.0 },
					resolution: { type: "v2", value: new THREE.Vector2() }
				};

				var smaterial = new THREE.ShaderMaterial( {

					uniforms: uniforms,
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
					side: THREE.BackSide 
				} );
				uniforms2 = {
					time: { type: "f", value: 1.0 },
					resolution: { type: "v2", value: new THREE.Vector2() }
				};

				var smaterial2 = new THREE.ShaderMaterial( {

					uniforms: uniforms2,
					vertexShader: document.getElementById( 'vertexShader2' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader2' ).textContent,
					side: THREE.BackSide 
				} );
				

				//
				//var geo = new THREE.TorusGeometry( 500, 450, 100, 100 );
				var geo = new THREE.SphereGeometry( 100, 32,32 );
				//var geo = new THREE.IcosahedronGeometry(90,3);
				//var material = new THREE.MeshPhongMaterial( {wireframe: true, shading: THREE.FlatShading} );
				//var omesh = new THREE.Mesh( geo, new THREE.MeshBasicMaterial( { color: 0xffaa00, wireframe: true } )  );
				var omesh = new THREE.Mesh( geo, new THREE.MeshPhongMaterial( { 
					color: 0xff0600, 
					ambient: 0xff0600, // should generally match color
					specular: 0xff0505,
					shininess: 1//,side: THREE.BackSide, //wireframe: true
				} ) );
				//var omesh = new THREE.Mesh( geo, smaterial2 );
				
				omesh.rotation.x = -Math.PI/2;
				omesh.name="isosun";
				//omesh.position.y = -100;
				scene.add(omesh);
				
				//var smesh = new THREE.Mesh( new THREE.SphereGeometry( 2000,32, 32), smaterial )
				//smesh.rotation.y = Math.PI/2;
				//scene.add(smesh );
				
				
				
				
				
				
				var smesh2 = new THREE.Mesh( new THREE.SphereGeometry( 20000,32, 32), smaterial2 )
				//var smesh2 = new THREE.Mesh( new THREE.BoxGeometry( 40000,40000, 40000), smaterial2 )
				smesh2.rotation.y = Math.PI/2;
				//smesh2.rotation.x = Math.PI/2;
				scene.add(smesh2 );
				
				// add subtle blue ambient lighting
				var ambientLight = new THREE.AmbientLight(0x000027);
				  
				scene.add(ambientLight);
				  
				// directional lighting
				directionalLight = new THREE.DirectionalLight(0x55ffff); 
				directionalLight.position.set(13, 1, 1).normalize();
				ambientLight.name="dlight"
				scene.add(directionalLight);
	  
				var geo2 = new THREE.IcosahedronGeometry(15,1);
				select_mesh= new THREE.Mesh( geo2, new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } )  );
				select_mesh.position.x =9999999;
				select_mesh.position.y = 9999999;
				select_mesh.position.z =-9999999;
				scene.add(select_mesh );
				
				var arrayUsers=[];
				for (var i=0,j=list_users.length ; i< j; i++){
					//var geo = new THREE.IcosahedronGeometry(10,2);
					var geo = new THREE.BoxGeometry(10,10,10);
					//var material = new THREE.MeshPhongMaterial( {wireframe: true, shading: THREE.FlatShading} );
					arrayUsers[i] = new THREE.Mesh( geo, new THREE.MeshBasicMaterial( { color: '#'+Math.floor(Math.random()*16777215).toString(16), wireframe: false,doubleSided: true} )  );
					var pos= Math.random(1)*2*Math.PI;
					arrayUsers[i].position.x = Math.cos(pos)*300;
					arrayUsers[i].position.y = Math.sin(Math.random(1))*150;
					arrayUsers[i].position.z = Math.sin(pos)*300;
					//arrayUsers[i].geometry.applyMatrix( new THREE.Matrix4().makeTranslation( Math.random(300), 0, 0 ) );
					arrayUsers[i].rotation.y = Math.random() * 2 * Math.PI;
					arrayUsers[i].rotation.x = Math.random() * 2 * Math.PI;
					arrayUsers[i].rotation.z = Math.random() * 2 * Math.PI;
					arrayUsers[i].material.side = THREE.DoubleSide;
					arrayUsers[i].name=list_users[i];
					scene.add(arrayUsers[i] );
					
					
					
				}
				
				
				
				//SUBDIVISIONS = 20;
				var bgeometry = new THREE.Geometry();
				
				//curve.v0 = new THREE.Vector3(arrayUsers[0].position.x, arrayUsers[0].position.y, 0);
				//curve.v1 = new THREE.Vector3(arrayUsers[0].position.x/2, arrayUsers[0].position.y/2-60, 0);
				
				
				for (j = 0; j < list_users.length; j++) {
				bgeometry.vertices.push( new THREE.Vector3(0, 0, 0))
				bgeometry.vertices.push( new THREE.Vector3(arrayUsers[j].position.x, arrayUsers[j].position.y,arrayUsers[j].position.z))
				}
				var bmaterial = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 1 ,opacity: 0.4, blending: THREE.AdditiveBlending, transparent: true} );
				bline = new THREE.Line(bgeometry, bmaterial,THREE.LinePieces);
				//scene.add(bline);
				
				//bline.geometry.verticesNeedUpdate=true;
				
				//console.log(bline.position)
				

				

				
				
				
				

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				//container.appendChild( stats.domElement );

				//

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );

				//

				var renderModel = new THREE.RenderPass( scene, camera );
				var effectBloom = new THREE.BloomPass( 1.3 );
				var effectCopy = new THREE.ShaderPass( THREE.CopyShader );

				effectFXAA = new THREE.ShaderPass( THREE.FXAAShader );

				var width = window.innerWidth || 2;
				var height = window.innerHeight || 2;

				effectFXAA.uniforms[ 'resolution' ].value.set( 1 / width, 1 / height );

				effectCopy.renderToScreen = true;

				composer = new THREE.EffectComposer( renderer );

				composer.addPass( renderModel );
				composer.addPass( effectFXAA );
				composer.addPass( effectBloom );
				composer.addPass( effectCopy );
				//projector = new THREE.Projector();
				raycaster = new THREE.Raycaster();
				//
				controls = new THREE.OrbitControls( camera, container  );
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;
				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;
				uniforms.resolution.value.x = window.innerWidth;
				uniforms.resolution.value.y = window.innerHeight;
				uniforms2.resolution.value.x = window.innerWidth;
				uniforms2.resolution.value.y = window.innerHeight;
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				effectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );

				composer.reset();

			}

			//

			function onDocumentMouseMove( event ) {

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					//mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
					mouse.y = - ( (event.clientY-$("#container").position().top+window.pageYOffset) / window.innerHeight ) * 2 + 1;
			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length > 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;
					
				}

			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;
				}

			}

			//

			function animate() {

				requestAnimationFrame( animate );
				render();

				stats.update();

			}

			function render() {
				controls.update();
				var delta = clock.getDelta();
				uniforms.time.value += delta * 5;
				uniforms2.time.value += delta * 5;
				//camera.position.x += ( mouseX - camera.position.x ) * .01;
				//camera.position.y += ( - mouseY + 200 - camera.position.y ) * .01;

				camera.lookAt( scene.position );
				var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
				//projector.unprojectVector( vector, camera );
				vector.unproject(camera);
				raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
	
				var intersects = raycaster.intersectObjects( scene.children );
				if ( intersects.length > 0 ) {
					
					
					if ( INTERSECTED != intersects[ 0 ].object) {

						

						INTERSECTED = intersects[ 0 ].object;
						//console.log(intersects)
						
						if ( INTERSECTED.name && INTERSECTED.name!="isosun") {
							//console.log(INTERSECTED)
							selectedModelName=INTERSECTED.name;
							//select_mesh.position.set(INTERSECTED.position.x,0.99, INTERSECTED.position.z );
							//select_mesh.scale.x=(INTERSECTED.geometry.vertices[1]-INTERSECTED.geometry.vertices[0]);
							
							//select_mesh.geometry.vertices[0]=INTERSECTED.geometry.vertices[0];
							
							//select_mesh.geometry.vertices[1]=INTERSECTED.geometry.vertices[1];
							
							//select_mesh.geometry.vertices[2]=INTERSECTED.geometry.vertices[2];
							//select_mesh.geometry.vertices[3]=INTERSECTED.geometry.vertices[3];
							//select_mesh.scale.x=1.15;
							//select_mesh.scale.y=1.05;
							//select_mesh.geometry.verticesNeedUpdate = true;
							
							//text0.style.top = $("#mcontainer").position().top+150 + 'px';								
							//text0.style.left = window.innerWidth*0.75+ 'px';
							//var nm=myListModels[parseInt(selectedModelName.substring(1))];
							//text0.innerHTML="<div style='width:400px;height:"+$("#mcontainer").css( "height" )*0.7+"px;border:1px solid #ffffff;'><h2 class='mytab1'>"+nm+"</h2><h3 class='mytab1'>"+listMTNs[nm][0]+"</h3><br><p class='mytab1'>"+results[nm][0].length+" model nodes linked to "+results[nm].length+" metabolic network nodes.</p><p class='mytab1'>Links between the model and the metabolic network are shown with an ("+results[nm][0].length+" x "+results[nm].length+") adjacency matrix.</p></div>";
							//document.getElementById("democ0").style.top=$("#mcontainer").position().top+150 + 'px';
							//document.getElementById("democ0").style.left=window.innerWidth*0.05+ 'px';
							//updateD3jsData();
							//console.log(INTERSECTED.name)
							select_mesh.position.x=INTERSECTED.position.x;
							select_mesh.position.y=INTERSECTED.position.y;
							select_mesh.position.z=INTERSECTED.position.z;
							//select_mesh.scale.y = INTERSECTED.scale.y*2;
							//areaLight4.position.set( INTERSECTED.position.x, 5, 24.001 );
							//areaLight4.rotation.set( Math.PI/2, 0.0001, 0.0001 );
							//areaLight4.width = 10;
							//areaLight4.height = 10;
							text0.style.top = $("#container").position().top+150 + 'px';								
							text0.style.left = window.innerWidth*0.75+ 'px';
							
							text0.innerHTML="<h2>User : </h2> <h3>"+selectedModelName+"</h3>";
						}
						//if ( INTERSECTED && INTERSECTED.name && INTERSECTED.name[0]=="m") {
							//console.log("model")
						//INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
						//INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						//INTERSECTED.material.emissive.setHex( 0xff0000 );
						//}
						//INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						//INTERSECTED.material.emissive.setHex( 0xff0000 );
						
					}

				} else {

					//if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

					INTERSECTED = null;
					//select_mesh.position.set(9999999,0.5, -9999999 );
					//text0.style.top = '8000px';								
					//text0.style.left = '8000px';
				}
				
				
				var time = Date.now() * 0.0005;

				for ( var i = 0; i < scene.children.length; i ++ ) {

					var object = scene.children[ i ];
					if ( object.name=="isosun" || object instanceof THREE.DirectionalLight) {//object.rotation.y = time * ( i % 2 ? 1 : -1 );}
					}
					else{
						//object.position.x += Math.cos(time )*300;
						var euler = new THREE.Euler( 0, delta/2, 0, 'XYZ' );
						object.position.applyEuler(euler);
						//bline.rotation.y+=( Math.sin(delta/14));
						
					}

				}
				
				renderer.clear();
				composer.render();

			}
			
		
			
			
			
</script>
		

		
</div>