
<br><br>

    

<div class='container' id="showresult" style="width:80%">
	<h1>Results of simulation : <%= nbRes %> - trajectory: <%= (tRes+1) %> from experiment : <%= exp.name %></h1>
	
	<div id="container"  style="position: absolute;left: 0px; overflow: inherit">  </div>
	
	

<svg id="visualisation" width="1000" height="500" style="position: absolute;overflow: inherit"></svg>
<div class="mag"></div>
<div id="select1text" style="position: absolute;left: 10px; overflow: inherit; height:250px">Select place(s)/transition(s) to observe: (maximum 200)
<select id="selectChannels1" name="selectChannels1" multiple="multiple"  style="position: relative;float:left">
		<% 
		_.each(headtitles.slice(3), function(channel) {%>
		   <option value="<%=channel%>"><%=channel%></option>
		<% }) %>
	</select>
	<select id="shuttle-dst" ></select>
</div>	
<div id="mygraph"  style="position: absolute;left: 0px; overflow: inherit"> 	 </div>	<br>
<div id="advert" ></div>

<div id="democ" style="position: absolute;left: 10px;overflow: auto">
	
		<div id="demo"></div>	
		
	</div>
</div>


<div id="democ3" style="position: absolute;left: 10px; overflow: inherit"> </div>
<div id="mtooltip" style="position: absolute;left: 10px ; overflow: inherit"> </div>
<div id="democ4" style="position: absolute;left: 0px; overflow: inherit" class="myborderclass2"></div>
<div id="mytooltip3"></div><br>
<div id="mytooltip" style="position: absolute;left: 10px"></div>
<div id="democ2" style="position: absolute;left: 10px; overflow: inherit"></div>
<br>
<div id="reactionCategoryTable" style="position: absolute;left: 0px;"></div><br>
<div id="sliderdiv" style="position: absolute;left: 0px; "><input id="slider2" type="range" min="0" max="500" step="1" value="0" onchange="updateSliderh(this.value)"/><input id="textslider2" type="text" onchange="updateSlidert(this.value)"/><button type="button" id="forward" onclick="forward()">Forward</button><button type="button" id="backward" onclick="backward()">Backward</button> Flux as axis position: <input id="checkslider2" type="checkbox" onchange="updateSliderc(this.checked)"/></div><br>
<div id="hiveplot" style="position: absolute;left: 0px; overflow: inherit" class="myborderclass2 Scrollable"></div>
<div id="mytooltip4"></div>

<nav>
		<a href="" id="menuToggle" title="show menu">
		<span class="navClosed"><i>show menu</i></span>
		</a>
		<a href="#" title="Item 1">Hide/Show</a>
		<button class="btn btn-default btn-xs" title="Make metabolic network lines invisible/visible" id="view4" style="position: relative;left: 20px;">Lines</button>
		<button class="btn btn-default btn-xs" title="Hide/show tokens (if problem, just refresh the page)" id="view5" style="position: relative;left: 20px;">Token</button>
		<br><p style="position: relative;left: 20px;color:white">Line Opacity: <input id="defaultSlider" type="range" min="0" max="100" value="25" onchange="updateSlider1(this.value)" style="position: relative;left: 20px"/></p>
		
		
		<a href="#" title="Item 2">Metabolic Layout</a>
		<form action="/experiment/showresult/<%= exp.id %>" id="layout-select-form" method="POST" style="position: relative;"><p style="position: relative;left: 20px;color:white;height:40px;">Choose Layout: 
			<input type="text" name="mtnl-id" id ="mtnl-id" style="visibility: hidden;" value=""/>
			<input type="text" name="qml-id" id ="qml-id" style="visibility: hidden;" value=""/>
			<select name="metabolic_net_layouts" id="layout-selector" onchange="selectMTNLayout(this)" style="position: relative;left: 0px;width:120px;color:black">
					<option value="">None</option>
					<% _.each(mtnls, function(mtnl) {%>
					   <option value=<%=mtnl[0]%>><%=mtnl[1]%></option>
					<% }) %>
				</select></p>
				
			
		<a href="#" title="Item 3">Model Layout</a>
			<p style="position: relative;left: 20px;color:white">Choose Layout: <br><select name="select" id="selectLayout" onchange="selectValue()" style="position: relative;left: 0px;color:black;width:120px">
			  <option value="0" selected>Default</option> 
			</select>
			
				<input type="hidden" name="r<%= nbRes %>" id="r<%= nbRes %>" value="<%= nbRes %>"/>
				<input type="hidden" name="t<%= nbRes %>" id="t<%= nbRes %>" value="<%= tRes %>"/>
				<input type="hidden" name="l<%= nbRes %>" id="l<%= nbRes %>" value="<%= lRes %>"/>
			
			<input type="submit" value="Select Layout:" class="btn btn-xs btn-success" style="position: relative;left: 20px;width:100px"/>
				<input type="hidden" name="_csrf" value="<%= _csrf %>" />
			</form>
			<br> <p style="color:white;position: relative;left: 20px;" />Select sub-graph from layout: <select name="select" id="selectsublayout" onchange="selectsublayout(this)" style="position: relative;left: 0px;color:black;width:120px"> 
			<option value="" selected>None</option>
			</select>
			<p style="color:white"/>Scale: <input id="defaultSlider2" type="range" min="0" max="100" value="25" onchange="updateSlider2(this.value)" style="position: relative;left: 20px"/>
			Separation between transition/places: <input id="defaultSlider3" type="range" min="0" max="100" value="25" onchange="updateSlider3(this.value)" style="position: relative;left: 20px"/>
			
			Slide up/down (horizontal plane): <input id="defaultSlider4" type="range" min="-2000" max="2000" value="0" onchange="updateSlider4(this.value)" style="position: relative;left: 20px"/>
			Slide Left/Right: <input id="defaultSlider5" type="range" min="-2000" max="2000" value="0" onchange="updateSlider5(this.value)" style="position: relative;left: 20px"/>
			Slide up/down: <input id="defaultSlider4" type="range" min="-1000" max="1000" value="0" onchange="updateSlider6(this.value)" style="position: relative;left: 20px"/>
			</p>
		
		<a href="#" title="Item 4">Simulation</a>
		
		<button class="btn btn-default btn-xs" title="Play a simulation trajectory" id="pauseSimulation" style="position: relative;left: 20px;" onclick="Pause();">Play/Pause</button><br><br>
		<input id="slider" type="range" min="0" max="500" step="1" value="0" onchange="updateSlider(this.value)" style="position: relative;left: 20px;"/><div id="timer" style="color:white;position: relative;left: 20px" >0.00</div>
		
		
		<select id="listSimModes" class="form-control-sm" title="Select a visualisation mode for the simulation." STYLE="font-size : 10pt; height: 25px;width: 140px; position: relative;left: 20px" onChange="change_simulationMode()" onkeydown="event.preventDefault();">
			<option value="0">Flux overview</option>
			<option value="1">Token game</option>
			<option value="2">Kegg activity</option>
			
		</select>
	</nav>

<div id="menu" >
<button id="rdat" value="<%=dataR%>" hidden="hidden" size="10" style="overflow-y: scroll;"/>

			
<%	var data=[];
	_.each(mtb.file, function(compartment) {
		data.push(compartment);
	});
%>	
	

<script type="x-shader/x-vertex" id="vertexshaderP1">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			//attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP1">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP2">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			//attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP2">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP3">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			//attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP3">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP4">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			//attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP4">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		
		<script type="x-shader/x-vertex" id="vertexshaderP5">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			//attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP5">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP6">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			//attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP6">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP7">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			//attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP7">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshader2">

			//uniform float amplitude;
			//attribute vec3 displacement;
			attribute vec3 ca;
			varying vec3 vColor;
			varying float opacity;
			attribute float op;
			void main() {
				//vec3 newPosition = position + amplitude * displacement;
				vColor = ca;
				opacity =op;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
			//uniform float amplitude;
			//attribute vec3 displacement;
			//attribute vec3 ca;
			//varying vec3 vColor;
			//void main() {
			//	vec3 newPosition = position + amplitude * displacement;
			//	vColor = ca;
			//	gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
			//}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader2">
			uniform vec3 color;
			varying float opacity;
			varying vec3 vColor;
			void main() {

				gl_FragColor = vec4( vColor * color, opacity );

			}
			//uniform vec3 color;
			//uniform float opacity;
			//varying vec3 vColor;
			//void main() {

			//	gl_FragColor = vec4( vColor * color, opacity );

			//}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshader3">

			attribute float size;
			attribute vec3 ca;
			//uniform float mixAmount;
			attribute float mixAmount;
			attribute vec3 endPosition;
			varying vec3 vColor;

			void main() {

				vColor = ca;
				vec3 newPosition = mix( position, endPosition, mixAmount );
				vec4 mvPosition = modelViewMatrix * vec4( newPosition, 1.0 );

				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader3">

			uniform vec3 color;
			uniform sampler2D texture;

			varying vec3 vColor;

			void main() {

				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );

			}

		</script>	
	
<script>
(function($){
			
	var methods = {
        init: function() {
            return this.each(function() {
                var $src = $(this);

                // Create the destination select box.
                var $dst = $('#shuttle-dst');
               
                var $attr = $src.prop("attributes");

                // Copy the settings of the source selection to the destination.
                $.each($attr, function() {
                    if (this.name != 'id') {
                        if (this.name == 'name') {
                            $dst.attr(this.name, this.value + '-dst');
                        }
                        else {
                            $dst.attr(this.name, this.value);
                        }
                    }
                });

                // Create the input field for regular expressions.
                var $input = $('<input/>', {
                    id: 'shuttle-filter',
                    name: 'shuttle-regex',
                    type: 'text'
                });

                // Provide button controls for transferring options between boxes.
                var $controls = $('<div id="shuttle-container-controls"/>').append('<button id="shuttle-control-src-dst">&raquo;</button>').append('<button id="shuttle-control-dst-src">&laquo;</button>');

                // Make the UI elements the same widths and heights.
                $input.css('width', $src.width());
                $dst.css('width', $src.width());
                $dst.attr('size', $src.attr('size'));

                // Organize the elements into a <div> hierarchy.
                $src.before($input).after($dst).after($controls);
                $src.wrap('<div id="shuttle-container-src" class="shuttle-container-src"/>');
                $dst.wrap('<div id="shuttle-container-dst" class="shuttle-container-dst"/>');
                $input.next().andSelf().wrapAll('<div id="shuttle-container-filter"/>');
                $('#shuttle-container-filter').nextUntil('#shuttle-container-dst').wrapAll('<div id="shuttle-container">');
                $('#shuttle-container-filter').
                prependTo('#shuttle-container');
                $('#shuttle-container-dst').
                appendTo('#shuttle-container');

                // Transfer all selected options from the source to the destination.
                $controls.find('#shuttle-control-src-dst').on('click', function(event) {
                    $.fn.shuttle.transfer($src, $dst);
                });

                // Transfer all selected options from the destionation to the source.
                $controls.find('#shuttle-control-dst-src').on('click', function(event) {
                    $.fn.shuttle.transfer($dst, $src);
                });

                // Create a copy of the source options to use when matching the regex.
                var $options = [];
                $src.find("option").each(function() {
                    $options.push({
                        value: $(this).val(),
                        text: $(this).text()
                    });
                });

                $src.data("options", $options);

                // Upon input changes, clear the source and then append regex matches.
                $input.on('input', function(event) {
                    var options = $src.empty().scrollTop(0).data("options");
                    var search = $.trim($input.val());
                    var regex = new RegExp(search, 'gi');

                    var len = options.length;
                    var $html = $(document.createElement('option'));

                    for (var i = 0; i < len; i++) {
                        var o = options[i];

                        if (o.text.dediacritics().match(regex) !== null) {
                            $src.append($html.clone().text(o.text).val(o.value));
                        }
                    }

                    $src.css('width', $input.width() + 4);
                });
				
            });
        }
    };

    $.fn.shuttle = function(method) {
        methods.init.apply(this);
    };

    $.fn.shuttle.transfer = function(src, dst) {
        dst.append($('option:selected', src).remove());
        var options = $("option", dst);
        options.sort(function(a, b) {
            return a.text.localeCompare(b.text);
        });
        dst.empty().append(options);
		selectLinePlotsChannels();
    };
			

			$(document).ready(function(){
				//$('#selectChannels1').multiSelect();
				//$('#selectChannels1').multiselect({maxHeight: 200,enableCaseInsensitiveFiltering: true, includeSelectAllOption: false});
				
				$('#menuToggle').click(function(e){
				var $parent = $(this).parent('nav');
				$parent.toggleClass("open");
				var navState = $parent.hasClass('open') ? "hide" : "show";
				$(this).attr("title", navState + " navigation");
				// Set the timeout to the animation length in the CSS.
				setTimeout(function(){
				console.log("timeout set");
				$('#menuToggle > span').toggleClass("navClosed").toggleClass("navOpen");
				}, 200);
				e.preventDefault();
				});
			});
			})(jQuery);
$(document).ready(function(){$('#selectChannels1').shuttle();
	
});

var diacritics = [
    {
    'base': 'A',
    'letters': /[\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F]/g},
{
    'base': 'AA',
    'letters': /[\uA732]/g},
{
    'base': 'AE',
    'letters': /[\u00C4\u00C6\u01FC\u01E2]/g},
{
    'base': 'AO',
    'letters': /[\uA734]/g},
{
    'base': 'AU',
    'letters': /[\uA736]/g},
{
    'base': 'AV',
    'letters': /[\uA738\uA73A]/g},
{
    'base': 'AY',
    'letters': /[\uA73C]/g},
{
    'base': 'B',
    'letters': /[\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181]/g},
{
    'base': 'C',
    'letters': /[\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E]/g},
{
    'base': 'D',
    'letters': /[\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779]/g},
{
    'base': 'DZ',
    'letters': /[\u01F1\u01C4]/g},
{
    'base': 'Dz',
    'letters': /[\u01F2\u01C5]/g},
{
    'base': 'E',
    'letters': /[\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E]/g},
{
    'base': 'F',
    'letters': /[\u0046\u24BB\uFF26\u1E1E\u0191\uA77B]/g},
{
    'base': 'G',
    'letters': /[\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E]/g},
{
    'base': 'H',
    'letters': /[\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D]/g},
{
    'base': 'I',
    'letters': /[\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197]/g},
{
    'base': 'J',
    'letters': /[\u004A\u24BF\uFF2A\u0134\u0248]/g},
{
    'base': 'K',
    'letters': /[\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2]/g},
{
    'base': 'L',
    'letters': /[\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780]/g},
{
    'base': 'LJ',
    'letters': /[\u01C7]/g},
{
    'base': 'Lj',
    'letters': /[\u01C8]/g},
{
    'base': 'M',
    'letters': /[\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C]/g},
{
    'base': 'N',
    'letters': /[\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4]/g},
{
    'base': 'NJ',
    'letters': /[\u01CA]/g},
{
    'base': 'Nj',
    'letters': /[\u01CB]/g},
{
    'base': 'O',
    'letters': /[\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C]/g},
{
    'base': 'OE',
    'letters': /[\u00D6\u0152]/g},
{
    'base': 'OI',
    'letters': /[\u01A2]/g},
{
    'base': 'OO',
    'letters': /[\uA74E]/g},
{
    'base': 'OU',
    'letters': /[\u0222]/g},
{
    'base': 'P',
    'letters': /[\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754]/g},
{
    'base': 'Q',
    'letters': /[\u0051\u24C6\uFF31\uA756\uA758\u024A]/g},
{
    'base': 'R',
    'letters': /[\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782]/g},
{
    'base': 'S',
    'letters': /[\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784]/g},
{
    'base': 'T',
    'letters': /[\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786]/g},
{
    'base': 'TZ',
    'letters': /[\uA728]/g},
{
    'base': 'U',
    'letters': /[\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244]/g},
{
    'base': 'UE',
    'letters': /[\u00DC]/g},
{
    'base': 'V',
    'letters': /[\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245]/g},
{
    'base': 'VY',
    'letters': /[\uA760]/g},
{
    'base': 'W',
    'letters': /[\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72]/g},
{
    'base': 'X',
    'letters': /[\u0058\u24CD\uFF38\u1E8A\u1E8C]/g},
{
    'base': 'Y',
    'letters': /[\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE]/g},
{
    'base': 'Z',
    'letters': /[\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762]/g},
{
    'base': 'a',
    'letters': /[\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250]/g},
{
    'base': 'aa',
    'letters': /[\uA733]/g},
{
    'base': 'ae',
    'letters': /[\u00E4\u00E6\u01FD\u01E3]/g},
{
    'base': 'ao',
    'letters': /[\uA735]/g},
{
    'base': 'au',
    'letters': /[\uA737]/g},
{
    'base': 'av',
    'letters': /[\uA739\uA73B]/g},
{
    'base': 'ay',
    'letters': /[\uA73D]/g},
{
    'base': 'b',
    'letters': /[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g},
{
    'base': 'c',
    'letters': /[\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184]/g},
{
    'base': 'd',
    'letters': /[\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A]/g},
{
    'base': 'dz',
    'letters': /[\u01F3\u01C6]/g},
{
    'base': 'e',
    'letters': /[\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD]/g},
{
    'base': 'f',
    'letters': /[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g},
{
    'base': 'g',
    'letters': /[\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F]/g},
{
    'base': 'h',
    'letters': /[\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265]/g},
{
    'base': 'hv',
    'letters': /[\u0195]/g},
{
    'base': 'i',
    'letters': /[\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131]/g},
{
    'base': 'j',
    'letters': /[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g},
{
    'base': 'k',
    'letters': /[\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3]/g},
{
    'base': 'l',
    'letters': /[\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747]/g},
{
    'base': 'lj',
    'letters': /[\u01C9]/g},
{
    'base': 'm',
    'letters': /[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g},
{
    'base': 'n',
    'letters': /[\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5]/g},
{
    'base': 'nj',
    'letters': /[\u01CC]/g},
{
    'base': 'o',
    'letters': /[\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275]/g},
{
    'base': 'oe',
    'letters': /[\u00F6\u0153]/g},
{
    'base': 'oi',
    'letters': /[\u01A3]/g},
{
    'base': 'ou',
    'letters': /[\u0223]/g},
{
    'base': 'oo',
    'letters': /[\uA74F]/g},
{
    'base': 'p',
    'letters': /[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g},
{
    'base': 'q',
    'letters': /[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g},
{
    'base': 'r',
    'letters': /[\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783]/g},
{
    'base': 's',
    'letters': /[\u0073\u24E2\uFF53\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B]/g},
{
    'base': 'ss',
    'letters': /[\u00DF]/g},
{
    'base': 't',
    'letters': /[\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787]/g},
{
    'base': 'tz',
    'letters': /[\uA729]/g},
{
    'base': 'u',
    'letters': /[\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289]/g},
{
    'base': 'ue',
    'letters': /[\u00FC]/g},
{
    'base': 'v',
    'letters': /[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g},
{
    'base': 'vy',
    'letters': /[\uA761]/g},
{
    'base': 'w',
    'letters': /[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g},
{
    'base': 'x',
    'letters': /[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g},
{
    'base': 'y',
    'letters': /[\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF]/g},
{
    'base': 'z',
    'letters': /[\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763]/g}
];

/**
 * Extends the String class to allow translation of accented characters into
 * their equivalent character without an accent. Example usage:
 *
 * alert( "açaí = " + "açaí".dediacritics() );
 */
String.prototype.dediacritics = function() {
    var result = this;

    for (var i = diacritics.length - 1; i >= 0; i--) {
        result = result.replace(diacritics[i].letters, diacritics[i].base);
    }

    return result;
};			
			
/*$(function() {
  $('#selectChannels1').filterByText($('#textbox'), true);
}); */


var headTitles = <%-JSON.stringify( headtitles) %>
var results=Papa.parse($('#rdat').val(),{	delimiter: "\t",
									header: false,
									dynamicTyping: true//,
									//worker: true,
									//complete: function(mresults) {
									//	console.log("Parsing complete:", mresults);
									//}
}).data;
var mtb= <%-JSON.stringify( mtb) %>
//console.log(results);
var qm= <%-JSON.stringify(exp.qsspn_model_instance) %>;

var stats = <%-JSON.stringify(stats)%>;
var nbRes=<%- nbRes %>;
//console.log(stats);



var names = Object.keys(stats);
var stats2 = [];
var lengthStats = 0;
if (stats.hasOwnProperty(names[0])){
	lengthStats =stats[names[0]].length;
}

for (var i=0; i< lengthStats; i++){
	stats2.push({data:[], name: "sample"+i});
}
for (var i=0; i< lengthStats; i++){
	for (var j=0, jj= names.length;j<jj; j++){
		stats2[i]['data'].push({'transition': names[j], 'nb_token':stats[names[j]][i]})
	}
}
//console.log(stats2);

var cbColModel, idsOfSelectedRows = [];
		var idsOfModelSelectedRows=[];

/*jQuery.fn.filterByText = function(textbox, selectSingleMatch) {
  return this.each(function() {
    var select = this;
    var options = [];
    $(select).find('option').each(function() {
      options.push({value: $(this).val(), text: $(this).text()});
    });
    $(select).data('options', options);
    $(textbox).bind('change keyup', function() {
      var options = $(select).empty().scrollTop(0).data('options');
      var search = $.trim($(this).val());
      var regex = new RegExp(search,'gi');
 
      $.each(options, function(i) {
        var option = options[i];
        if(option.text.match(regex) !== null) {
          $(select).append(
             $('<option>').text(option.text).val(option.value)
          );
        }
      });
      if (selectSingleMatch === true &&
          $(select).children().length === 1) {
        $(select).children().get(0).selected = true;
      }
    });
  });
};*/


var layouts = <%-JSON.stringify(mtnls)%>
var mtnl = <%-JSON.stringify(mtnl)%>
if (mtnl.hasOwnProperty("id")){
	document.getElementById("layout-selector").value=mtnl.id;
	//console.log(mtnl.id)
}

var qmlayouts = <%-JSON.stringify(qmls)%>
var mqml = <%-JSON.stringify(mqml)%>
//console.log(mqml)

//console.log(qmlayouts)
//console.log(mqml)
var mtnlLayout=mtnl.layout;
var generalLayout ={'merged':{},'above':{},'outer':{},'satellite':{},'in':{}};
var objects = [];
var spacing=1650;
var radiusComp=550;
var yStartDisplacement=100;
//var yStartDisplacement=400;
var nodeSize=5;
var lineOpacity=0.1;

if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
		
		var renderer, renderer2, scene,scene2,  camera, stats, controls, camera2,pip;
		var element1;
		var PointCloud1, uniforms, attributes;
		var mouse = new THREE.Vector2(), INTERSECTED;
		var projector;
		//var vc1;
		var camTween;
		var mtween=false;
		var animatorT1;
		var halfvis;
		var allFalse= true;
		var simModeValue=0;
		var simFlowChart=0;
		var cntLabels=0;
		
		var WIDTH = window.innerWidth;
		var HEIGHT = window.innerHeight;
		var geometry;
		var bgeometryP1;
		var bgeometryP2;
		var bgeometryP3;
		var bgeometryP4;
		var bgeometryP5;
		var bgeometryP6;
		var bgeometryP7;
		
		var bgeometry2;
		var tokenGeometry;
		var tvertices ;
		var tvalues_size ;
		var tvalues_color ;
		var tvalues_p ;
		
		var geometryKegg;
		var keggSegment = 1000;
		var keggSegmentPts = keggSegment*2;
		var keggPositions;
		var keggColors;
		var listChangingKeggCoordinates=[];
		var previousKeggLength=0;
		var cubesGeometry=[];
		var keggCubesProperties={};
		var noKeggCube=true;
		
		var simTimer=0;
		var reactionIsDone=false;
		var listReactionsDone=[]
		//var simTimerPrevious=0;
		var simEnd=0;
		var simulationIsOn=false;
		var simulationIsPaused=false;
		var simRow=[];
		var simDataTime={};
		
		var scaleExplosion=3000;
		var nbCompartments=8;
		
		var arraymaterial=[];
		
		
		
		var particleClass = {
					0: "DNA",
					1: "RNA",
					2: "Protein",
					3: "Degradation Product",
					4: "Standard Petri Net",
					5: "Logical Transition",
					6: "Coarse Transition"
					};
		
		var particles;
		
		
		var arrows =[];
		
		
		var b1values_size;
		var b1positions;
		var b1values_color;
		var b1values_compartment;
		var particle1ShaderMaterial ;
		
		var b2values_size;
		var b2positions;
		var b2values_color;
		var b2values_compartment;
		var particle2ShaderMaterial ;
		
		var b3values_size;
		var b3positions;
		var b3values_color;
		var b3values_compartment;
		var particle3ShaderMaterial ;
		
		var b4values_size;
		var b4positions;
		var b4values_color;
		var b4values_compartment;
		var particle4ShaderMaterial ;
		
		var b5values_size;
		var b5positions;
		var b5values_color;
		var b5values_compartment;
		var particle5ShaderMaterial ;
		
		var b6values_size;
		var b6positions;
		var b6values_color;
		var b6values_compartment;
		var particle6ShaderMaterial ;
		
		var b7values_size;
		var b7positions;
		var b7values_color;
		var b7values_compartment;
		var particle7ShaderMaterial ;
		var linesShaderMaterial;
		var tokenShaderMaterial;
		var marker=0;
		var sprite;
		
		var b2lpositions;
		var b2lcolors ;
		var b2lcompartments;
		var b2lopacity;
		// 
		var cssScene;
		var rendererCSS;
		var cssObjects=[];
		
		var cssScene2;
		var rendererCSS2;
		var cssObjects2=[];
		
		var cssScene3;
		var rendererCSS3;
		var cssObjects3=[];
		// 
		var flagPick=0;
		
			
		var outlineMaterial1;
		var outlineMesh1;
		var lineGeometry;
		var mesh;
		var tokenPS;
		// clock to animate particles
		var clock = new THREE.Clock();
		
		var parameters;
		var gui;
		
		var isOnParticle=0;
		var isOnLine=0;
		var keyboard = new KeyboardState();
		var goUp=false;
		var goDown=false;
		var goLeft=false;
		var goRight=false;
		var zoomIn=false;
		var zoomOut=false;
		var closest;
		var closestLine;
		var closestid;
		var closestType=-1;
		var hoveredType=-1;
		var sizeParticleGuiElem;
		var colorParticleGuiElem;
		var colorParticleGui = new THREE.Color( 0xffffff );
		
		var stopThreeJsMouseEvent=false;
		var spreadsheet1Visible=false
		
		var updatedListModels=false;
		var updatedModel=false;
		var resetSpreadsheet=false;
		var modelData;
		var simData;
		var simDataBounds=[];
		
		var stackTokenModel=[];
		startPositionTokenMap={};
		endPositionTokenMap={};
		
		function cameraGoTo(position, target) {
						TWEEN.removeAll();
						new TWEEN.Tween( camera.position ).delay(300)
						.to( { x: position.x, y: position.y, z: position.z }, 300 )
						.start();
						new TWEEN.Tween( controls.target )
						.to( { x: target.x, y: target.y, z: target.z }, 300 )
						.start();
						
					}
		var timerElement=document.getElementById("timer");
		var sliderElement=document.getElementById("slider");
		var listModels;
		
		
		var modelVisible=false;
		var selectedModel;
		var selectedMetabolicData;
		//var 
		//default metabolic network file is: recon2.v02.xml_metabolic_net
		//xhttp.open("GET","recon2.v02.xml_metabolic_net2.json",false);
		//xhttp.send();
		selectedMetabolicData = <%-JSON.stringify(data)%>
		console.log("getting metabolic data from default file recon2");
		// set list of edges and nodes from default metabolic data
		var metabolicEdges;
		var metabolicNodes;
		var metabolicCompartments;
		
		var listCompartments=[];
	
		if (!mtnlLayout){
			listCompartments=selectedMetabolicData[0];
			mtnlLayout={"list_compartments":[],"compartments_layout":{}, "nodes_layout":{},"nodes_compartments":{}};
		}
		else {
			if (mtnlLayout["list_compartments"] && mtnlLayout["list_compartments"].length==0){
				listCompartments=selectedMetabolicData[0];
			}
			else if (mtnlLayout["list_compartments"] && mtnlLayout["list_compartments"].length>0){
				listCompartments=mtnlLayout["list_compartments"];
				//console.log("initial existing list of compartments")
			}
		}
		mtnlLayout["list_compartments"]=listCompartments;
		
		//console.log(listCompartments)
		var nbCompartments=listCompartments.length
		var compIds=[];
		for (var i=0; i<listCompartments.length;i++){
			compIds.push(listCompartments[i][0]);
		}
		
		// change compartment nodes attribution from data
		if (mtnlLayout["nodes_compartments"]){
			var listChangedNodes = Object.keys(mtnlLayout["nodes_compartments"]);
			if (listChangedNodes.length>0){
			
				for(var i=0, ii= listChangedNodes.length;i<ii;i++){			
					//console.log(selectedMetabolicData[1][listChangedNodes[i]])
					selectedMetabolicData[1][listChangedNodes[i]][1]=mtnlLayout["nodes_compartments"][listChangedNodes[i]][0];
					selectedMetabolicData[1][listChangedNodes[i]][3]=mtnlLayout["nodes_compartments"][listChangedNodes[i]][1];
					//console.log(selectedMetabolicData[1][listChangedNodes[i]])
				}
			}
			
		}
		
		metabolicCompartments = listCompartments;
		nbCompartments=listCompartments.length
		
		var nameModel=<%- JSON.stringify(mtb.name) %>;
		
		var txtComp=[]
		var maxNbComp=20;
		
		
		var nameComp=[];
		var mapComp = {'-1':-1};
		
		for (var i=0;i<listCompartments.length;i++){
			mapComp[listCompartments[i][0]]=i;
			nameComp.push(listCompartments[i][1]);
		}
		
		metabolicNodes = selectedMetabolicData[1];
		metabolicEdges = selectedMetabolicData[2];
		
		var jsonObj1=metabolicNodes
		var jsonObj2=metabolicEdges
		//console.log(jsonObj1);
		//console.log(jsonObj2);
		
		// extract number of qsspn typed icons from lists of nodes...
		var mnbDNA=0;
		var mnbRNA=0;
		var mnbProt=0;
		var mnbDegProd=0;
		var mnbPN=0;
		var mnbLog=0;
		var mnbCoarse=0;
		
		var nbPlacesModel=0;
		var nbReactionsModel=0;
		var nbEdgesModel=0;
		/*for (var i = 0, ii= jsonObj1.length;i<ii;i++){
			if (jsonObj1[i]['typeQSSPN']==0){
				mnbDNA++;
			}
			if (jsonObj1[i]['typeQSSPN']==1){
				mnbRNA++;
			}
			if (jsonObj1[i]['typeQSSPN']==2){
				mnbProt++;
			}
			if (jsonObj1[i]['typeQSSPN']==3){
				mnbDegProd++;
			}
			if (jsonObj1[i]['typeQSSPN']==4){
				mnbPN++;
			}
			if (jsonObj1[i]['typeQSSPN']==5){
				mnbLog++;
			}
			if (jsonObj1[i]['typeQSSPN']==6){
				mnbCoarse++;
			}
			
			
		}*/
		
		for (var i = 0, ii= jsonObj1.length;i<ii;i++){
			if (jsonObj1[i][6]==0){
				mnbDNA++;
			}
			if (jsonObj1[i][6]==1){
				mnbRNA++;
			}
			if (jsonObj1[i][6]==2){
				mnbProt++;
			}
			if (jsonObj1[i][6]==3){
				mnbDegProd++;
			}
			if (jsonObj1[i][6]==4){
				mnbPN++;
			}
			if (jsonObj1[i][6]==5){
				mnbLog++;
			}
			if (jsonObj1[i][6]==6){
				mnbCoarse++;
			}
		}
		var selectedModelEdges;
		var selectedModelNodes;
		
		
		//console.log(mnbDNA);
		//console.log(mnbRNA);
		//console.log(mnbProt);
		//console.log(mnbDegProd);
		//console.log(mnbPN);
		//console.log(mnbLog);
		//console.log(mnbCoarse);
		var nbDNAParticles=mnbDNA; // nb of DNA elements
		var nbRNAParticles=mnbRNA; // nb of RNA elements
		var nbProtParticles=mnbProt+10000; // nb of proteins
		var nbDegradParticles=mnbDegProd; // nb of degradation products
		var nbPNParticles=mnbPN+10000; // nb of PN standard places
		var nbLogParticles=mnbLog; // nb of logical PN places
		var nbCoarseParticles=mnbCoarse; // nb of PN coarse transitions
		var maxNbTokenModel=20000;
		var idMap=[];
		var typesMap=[];
		for (var i=0;i<7;i++){
			typesMap[i]=[];
		};
		var reactionMap=[];
		
		var segments =jsonObj2.length;
		//var segments =0;
		var segmentPts =segments*2;
		
		
		var geometryLineChart;
		var chartSegment = 6000;
		var chartSegmentPts = chartSegment*2;
		var chartPositions ;
		var chartColors ;
		var meshLineChart ;
		var KeggMapPlan;
		
		//$.get( "slickgrid7.html", function( data ) {
  //alert( "Data Loaded: " + data );
//});
		
		var mselectedList=[];
		// element for spreadsheet selection
		spritesSelected=[];
		nbSpritesSelected=50;
		var modelspritesSelected=[];
		var modelnbSpritesSelected=50;
		
		var modelReactionLocators=[];
		var modelProductLocators=[];
		var modelReactantLocators=[];
		var modelModifierLocators=[];
		
		var nbModelReactionLocators=50;
		var nbModelPlanesFlow=500;
		var planeMesh=[];
		var stackModel2PlaneMesh=[];
		var flowsStack=[];
		var selectedNodesPaths=[];
		var selectedModelNodesPaths=[];
		var selectedLinesPaths=[];
		var selectedModelLinesPaths=[];
		var toggledLines=0
		var toggledToken=0
		var linesMap=[]
		var selectedLinesPathsIds=[];
		var extraLinesCnt=0;
		var startModelPlaces=0;
		var startModelReactions=0;
		var endModelPlaces=0;
		var endModelReactions=0;
		var myLink =[]
		var myLinkName=[]
		for (var ln =0;ln<10;ln++){
			myLink[ln]=""
			myLinkName[ln]=""
		}
		
		var tokenFlux=[];
		var tokenBounds=[];
		var indexDisabledToken=[];
		
		var tokenStackCount=0;
		var clearedTokenIndex=[]
		
		//var anim = document.getElementById("animload");
		//anim.style.visibility="hidden";
		
		
		
		//var announcementText= document.createElement('div');
		var announcementText= document.getElementById("advert");
		announcementText.style.position = 'absolute';
		
		announcementText.style.width = 100;
		announcementText.style.height = 100;
		//announcementText.setAttribute('animation', 'fadeOut');
		
		announcementText.style.color = "white";
		announcementText.style.textAlign="left";
		announcementText.style.border="3px solid";
		announcementText.style.font="italic bold 20px arial";
		announcementText.style.padding="5px";
		announcementText.style.background="#33AA33";
		//announcementText.style.cssText = 'border: 3px solid #FFF;border-radius: 5px;color: #FFF;font-family: arial;';
		//text0.style.backgroundColor = "#FFFFCC";
		//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
		announcementText.innerHTML = '<p>hello </p>';
		
		announcementText.style.top = 2000 + 'px';
		announcementText.style.left = 2000 + 'px';
		document.body.appendChild(announcementText);
		
		
		var text0 = document.createElement('div');
		text0.style.position = 'absolute';
		text0.style.width = 100;
		text0.style.height = 100;
		text0.style.color = "white";
		text0.style.textAlign="left";
		//text0.style.backgroundColor = "#FFFFCC";
		//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
		text0.innerHTML = 'hello ';
		text0.style.top = 2000 + 'px';
		text0.style.left = 2000 + 'px';
		//document.body.appendChild(text0);
		document.getElementById("container").appendChild(text0);
		var text1 = document.createElement('div');
		text1.style.position = 'absolute';
		text1.style.width = 100;
		text1.style.height = 100;
		text1.style.color = "black";
		text1.style.backgroundColor = "#FFFFCC";
		//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
		text1.innerHTML = 'hello ';
		text1.style.top = 2000 + 'px';
		text1.style.left = 2000 + 'px';
		//text1.style.zIndex = -1;
		document.body.appendChild(text1);
		
		var textk = document.createElement('div');
		textk.style.position = 'absolute';
		textk.style.width = 100;
		textk.style.height = 100;
		textk.style.color = "black";
		textk.style.backgroundColor = "#FFFFCC";
		//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
		textk.innerHTML = 'hello ';
		textk.style.top = 2000 + 'px';
		textk.style.left = 2000 + 'px';
		document.body.appendChild(textk);
		var textkPreviousPos= new THREE.Vector3( 2000, 2000, 1 );
		
		var text1PreviousPos= new THREE.Vector3( 2000, 2000, 1 );
		var text1PreviousString="";
		
		
		var listGenes = document.createElement('div');
		listGenes.id="listGenes";
		var listGenesTitle = document.createElement('div');
		listGenesTitle.innerHTML="Expressed by gene(s):";
		listGenesTitle.style.textAlign="left";
		var listGenesContent = document.createElement('div');
		listGenesContent.className="scroll-box";
		listGenes.style.color = "white";
		listGenesContent.style.color = "white";
		listGenesContent.innerHTML = '<ul style="margin-left:0em;padding-left:1.3em;height:50px;"><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li></ul>';
		listGenes.style.position = 'absolute';
		listGenes.style.top = 2000 + 'px';
		listGenes.style.left = 2000 + 'px';
		listGenes.appendChild(listGenesTitle);
		listGenes.appendChild(listGenesContent);
		//document.body.appendChild(listGenes);
		document.getElementById("container").appendChild(listGenes);
		
		var listLinks = document.createElement('div');
		listLinks.id="listLinks";
		var listLinksTitle = document.createElement('div');
		listLinksTitle.innerHTML="Connectivity:";
		listLinksTitle.style.color = "white";
		listLinksTitle.style.textAlign="left";
		var listLinksContent = document.createElement('div');
		listLinksContent.className="scroll-box";
		
		listLinksContent.style.color = "white";
		listLinksContent.innerHTML = '<ul style="margin-left:0em;padding-left:1.3em;height:150px;"><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li></ul>';
		listLinks.style.position = 'absolute';
		listLinks.style.top = 2000 + 'px';
		listLinks.style.left = 2000 + 'px';
		listLinks.appendChild(listLinksTitle);
		listLinks.appendChild(listLinksContent);
		//document.body.appendChild(listLinks);
		document.getElementById("container").appendChild(listLinks);
		
		var txtComp=[]
		for (var i=0;i<10;i++){
			txtComp[i] = document.createElement('div');
			txtComp[i].style.position = 'absolute';
			txtComp[i].style.width = 100;
			txtComp[i].style.height = 100;
			txtComp[i].style.color = "black";
			txtComp[i].style.fontSize="xx-small";
			txtComp[i].id = "txt"+i;
			//txtComp[i].style.fontWeight="1900";
			txtComp[i].style.backgroundColor = "#99FFCC";
			txtComp[i].style.opacity = 0.5;
			//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
			txtComp[i].innerHTML = '';
			txtComp[i].style.top = 2000 + 'px';
			txtComp[i].style.left = 2000 + 'px';
			//text1.style.zIndex = -1;
			document.body.appendChild(txtComp[i]);
			
		}
		var exploded=false;
		var focus_label=-1;
		var allDragged=[];
		for (var i=0;i<nbCompartments;i++){
			allDragged[i]=[]
		}
		
		
		var txtReactionActivation=[]
		var nbActivation=3000;
		var tokenIDStackCount={};
		for (var i=0;i<nbActivation;i++){
			txtReactionActivation[i] = document.createElement('div');
			txtReactionActivation[i].style.position = 'absolute';
			txtReactionActivation[i].style.width = 100;
			txtReactionActivation[i].style.height = 100;
			txtReactionActivation[i].style.color = "white";
			//txtComp[i].style.fontWeight="1900";
			//txtReactionActivation[i].style.backgroundColor = "#99FFCC";
			//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
			txtReactionActivation[i].innerHTML = 'hello ';
			txtReactionActivation[i].style.top = 2000 + 'px';
			txtReactionActivation[i].style.left = 2000 + 'px';
			//text1.style.zIndex = -1;
			document.body.appendChild(txtReactionActivation[i]);
			
		}
		var positionContainer;
		var yStartDisplacement=400;
		
		var contYPos;
		var halfHeight;
		
			simData=[headTitles, results,1];
			// get last simulation version of simdata
			var allEventNone=true;
			//console.log(simData)
			for ( var i=0;i<simData[1].length;i++){
				if(simData[1][i] && simData[1][i][2]!="none"){
					//console.log(simData[1][i][2]+ "  :"+i + " length"+simData[1][i].length);
					
					allEventNone=false;
				}
				for (var j=0;j<simData[1][i].length;j++){
					if(j!=0 && j!= 2){
					var trans = parseFloat(simData[1][i][j]);
						
						if (!isFinite(trans)){
							console.log("Cant't extract float number from "+simData[1][i][j]+ "  row "+i);
							simData[1][i][j]=0;
						}
						else{
							simData[1][i][j]=parseFloat(simData[1][i][j]);
						}
					}
				}
				simTimer=0;
				simEnd=simData[1][simData[1].length-1][1];
				sliderElement.setAttribute("min", simTimer);
				sliderElement.setAttribute("max", simData[1].length-1);
			}
			var tempDataBounds={};
			for(var i=3;i<simData[0].length-1;i++){
				tempDataBounds[simData[0][i]]=[];
			}
			//console.log(simDataBounds);
			for ( var i=0;i<simData[1].length;i++){
				for(var j=3;j<simData[0].length-1;j++){
					
					tempDataBounds[simData[0][j]].push(simData[1][i][j]);
				}
			}
			//console.log(tempDataBounds);
			simDataBounds=[];
			
			for(var j=3;j<simData[0].length-1;j++){
			var min = Math.min.apply(null, tempDataBounds[simData[0][j]]);
			var max = Math.max.apply(null, tempDataBounds[simData[0][j]]);
			//if (!isFinite(min) || !isFinite(max)){
			//	console.log("min max pb"+ min + " " + max + " " +j)
			//}
				simDataBounds.push( [ Math.min.apply(null, tempDataBounds[simData[0][j]]) , Math.max.apply(null, tempDataBounds[simData[0][j]]) ]);
			}
			//console.log (simDataBounds);
			
			if (allEventNone==true){
				console.log("start simulation without triggered events cascades")
			}
			else{
				console.log("start simulation with triggered events cascades")
			}
			//updatedListModels=true;

			// create an object data structure with unique time ids with a corresponding list of rows
			simDataTime={};
			var tmpQueue=[];
			for ( var i=0;i<simData[1].length;i++){
				if (tmpQueue.indexOf(simData[1][i][1])==-1){
					simDataTime[simData[1][i][1]]=[simData[1][i]];
					tmpQueue=[];
					tmpQueue.push(simData[1][i][1]);
				}
				else{
				//console.log("similar index "+simData[1][i][1])
					simDataTime[simData[1][i][1]].push(simData[1][i]);
				}
			}
		
		
		function change_simulationMode(){
		
			
			simModeValue = document.getElementById("listSimModes").value;
			console.log(simModeValue)
			if (simModeValue=="2"){
				KeggMapPlan.visible=true;
			}
			else{
				KeggMapPlan.visible=false;
			}
			
			tokenIDStackCount={};
			for (var i=0;i<nbActivation;i++){	
				txtReactionActivation[i].innerHTML = '';
				txtReactionActivation[i].style.top = 2000 + 'px';
				txtReactionActivation[i].style.left = 2000 + 'px';
			}
			for(var v=0;v<nbModelReactionLocators;v++){
				modelProductLocators[v].position.set(50000,50000,-50000);
				modelReactantLocators[v].position.set(50000,50000,-50000);
				modelModifierLocators[v].position.set(50000,50000,-50000);
			}
			simTimer=0;
			simulationIsPaused=false;
			simulationIsOn=false;
			//stackTokenModel=[];
			allFalse=true;
			
			//for(var i=0;i<nbModelPlanesFlow;i++){
			//	planeMesh[i].position.set(0,0,50000);
			//}
			//for ( var i = 0; i < 1000; i ++ ) {
			//	cubesGeometry[i].position.x=50000;
			//	cubesGeometry[i].position.y=200;
			//	cubesGeometry[i].position.z=-50000;
			//}
			//var iv=0;
			//for ( var i = 0; i < chartSegment; i ++ ) {
			//	chartPositions[ (iv * 3)+0 ] = 50400;
			//	chartPositions[ (iv * 3) + 1 ] = 0;
			//	chartPositions[ (iv * 3) + 2 ] = -50400;
				//chartColors[ iv * 3 ] = col.r;
				//chartColors[ iv * 3 + 1 ] = col.g;
				//chartColors[ iv * 3 + 2 ] = col.b;
			//	iv++;
			//	chartPositions[ (iv * 3)+0 ] = 50400;
			//	chartPositions[ (iv * 3) + 1 ] = 0;
			//	chartPositions[ (iv * 3) + 2 ] = -50400;
				//chartColors[ iv * 3 ] = col.r;
				//chartColors[ iv * 3 + 1 ] = col.g;
				//chartColors[ iv * 3 + 2 ] = col.b;
			//	iv++
			//}			
			//geometryLineChart.attributes.position.needsUpdate = true;
			//for (var i=segmentPts;i<b2lopacity.length;i++){	
			//	b2lopacity[i]=0.7;	
			//}
			//scene.children[7].geometry.attributes.op.needsUpdate = true;
			
			//stackTokenModel=[];
			//startPositionTokenMap={};
			//endPositionTokenMap={};
			//console.log(simModeValue);
		}
		
		function startTimer(){
			simTimer=0;
			simulationIsOn=true;
			for (var tkNb=0; tkNb< txtReactionActivation.length;tkNb++){
							
							txtReactionActivation[tkNb].innerHTML = '';
						}
		}
		function Pause(){
			//console.log(simData)
			if (simulationIsPaused){
				
				simulationIsPaused=false;
				if (simTimer==0){
					for (var tkNb=0; tkNb< txtReactionActivation.length;tkNb++){	
						txtReactionActivation[tkNb].innerHTML = '';
					}
				}
				
			}
			else if ( simulationIsOn==false && simulationIsPaused==false && simData){
				if (simTimer==0){
					for (var tkNb=0; tkNb< txtReactionActivation.length;tkNb++){	
						txtReactionActivation[tkNb].innerHTML = '';
					}
				}
				simulationIsPaused=false;
				simulationIsOn=true;
			}
			else{
				
				simulationIsPaused=true;
				for (var tkNb=0; tkNb< txtReactionActivation.length;tkNb++){
							
							txtReactionActivation[tkNb].innerHTML = '';
						}
			}
		}
		function change_simulationFlow(){
			simFlowChart = document.getElementById("listFlows").value;
			if (simFlowChart==0){
				pip.style.top = 2000 + 'px';
				pip.style.left = 2000 + 'px';
			}
			else{
				pip.style.top = 25 + 'px';
				pip.style.left = 25 + 'px';
			}
		}
		
		function updateSlider1(slideAmount){
			console.log(slideAmount/100);
			for (var i=0;i<segmentPts;i++){
				for (var i=0;i<b2lopacity.length;i++){
					
					b2lopacity[i]=(parseFloat(slideAmount)/100);
				}	
			}
			scene.children[7].geometry.attributes.op.needsUpdate = true;
		}
		
		
		function updateSlider(slideAmount){
			if (simData){
				if (simModeValue==0){
					//timerElement.innerHTML=""+slideAmount;
					timerElement.innerHTML=""+simData[1][slideAmount][1];
					//timerElement.innerHTML=""+simDataTime[Object.keys(simDataTime)[simTimer]][0][1];
					simTimer=slideAmount;
					simRow=simData[1][simTimer];
					
					//sliderElement.value=simTimer;
						simRow=simDataTime[Object.keys(simDataTime)[simTimer]];
						//console.log(simRow)
						
						//setAttribute("value", simTimer);
						// change property of model nodes to express flux
						
						// change nodes size according to flux values (take into account boundaries as min/max values)
						var ln1 = startModelPlaces;
						var ln2 = startModelReactions;
						var cnt1=0;
						var cnt2 = 0;
						for(var j=3;j<simData[1][simTimer].length-1;j++){
							var min = simDataBounds[j-3][0];
							var max = simDataBounds[j-3][1];
							var size=30;
							if ((max-min)!=0){
								size = 30+(50*(simData[1][simTimer][j]-min)/(max-min));
								if (!isFinite(size)){
									size =30;
								}
								for(var j1=0;j1<selectedModelNodes.length;j1++){
									if (selectedModelNodes[j1][1]==simData[0][j]){
										//console.log(simData[0][j]);
										if (selectedModelNodes[j1][5]==2 ){
											scene.children[2].geometry.attributes.size.array[(ln1+cnt1)]= size;
											//bgeometryP3.attributes.size.array[(ln1+cnt1)]= size;
											//console.log("resize place"+(cnt1))
											cnt1++;
										}
										if (selectedModelNodes[j1][5]==4 ){
											scene.children[4].geometry.attributes.size.array[(ln2+cnt2)]= size;
											//bgeometryP5.attributes.size.array[(ln2+cnt2)]= size;
											//console.log("resize reaction"+size)
											cnt2++;
										}
									}
								}
							}
							//console.log(simData[0][j])
						}
						scene.children[2].geometry.attributes.size.needsUpdate = true;
						scene.children[4].geometry.attributes.size.needsUpdate = true;
					
					//console.log(simRow);
				}
				if (simModeValue==1){
					//timerElement.innerHTML=""+slideAmount;
					timerElement.innerHTML=""+simData[1][slideAmount][1];
					
					//timerElement.innerHTML=""+simDataTime[Object.keys(simDataTime)[slideAmount]][0][1];
					simTimer=slideAmount;
					//simRow=[simData[1][simTimer]];
					
					//sliderElement.value=simTimer;
						simRow=simDataTime[Object.keys(simDataTime)[simTimer]];
						//console.log(simRow)
						
						//setAttribute("value", simTimer);
						// change property of model nodes to express flux
						
						// change nodes size according to flux values (take into account boundaries as min/max values)
						var ln1 = startModelPlaces;
						var ln2 = startModelReactions;
						var cnt1=0;
						var cnt2 = 0;
						for(var j=3;j<simData[1][simTimer].length-1;j++){
							var min = simDataBounds[j-3][0];
							var max = simDataBounds[j-3][1];
							var size=30;
							if ((max-min)!=0){
								size = 30+(50*(simData[1][simTimer][j]-min)/(max-min));
								
								if (!isFinite(size)){
									size =30;
								}
								for(var j1=0;j1<selectedModelNodes.length;j1++){
									if (selectedModelNodes[j1][1]==simData[0][j]){
										//console.log(simData[0][j]);
										if (selectedModelNodes[j1][5]==2 ){
											scene.children[2].geometry.attributes.size.array[(ln1+cnt1)]= size;
											//bgeometryP3.attributes.size.array[(ln1+cnt1)]= size;
											//console.log("resize place"+(cnt1))
											cnt1++;
										}
										if (selectedModelNodes[j1][5]==4 ){
											scene.children[4].geometry.attributes.size.array[(ln2+cnt2)]= size;
											//bgeometryP5.attributes.size.array[(ln2+cnt2)]= size;
											//console.log("resize reaction"+size)
											cnt2++;
										}
									}
								}
							}
							//console.log(simData[0][j])
						}
						scene.children[2].geometry.attributes.size.needsUpdate = true;
						scene.children[4].geometry.attributes.size.needsUpdate = true;
					
					//console.log(simRow);
				}
			}
		}
		
		function updateSlider2(slideAmount){
			console.log(slideAmount/100);
			for (var i=0;i<segmentPts;i++){
				for (var i=0;i<b2lopacity.length;i++){
					
					b2lopacity[i]=(parseFloat(slideAmount)/100);
				}	
			}
			scene.children[7].geometry.attributes.op.needsUpdate = true;
		}
		
		selectedModel = qm.extra;
		selectedModelNodes=selectedModel[2];
		selectedModelEdges=selectedModel[3];
		//console.log(selectedModelNodes);
		//console.log(selectedModelEdges);
		// in model edges, position index 2: product = 1 , preplace =2, consumed = 0
	
		nbPlacesModel=0;
		nbReactionsModel=0;
		nbEdgesModel=selectedModelEdges.length;
		
		for (var i = 0, ii= selectedModelNodes.length;i<ii;i++){
			if (selectedModelNodes[i][5]==2 ){
				nbPlacesModel++;					
			}
			if (selectedModelNodes[i][5]==4 ){
				nbReactionsModel++;
			}
		}
		var layouts = <%- JSON.stringify(qmls)%>;
		//console.log(layouts)
		for (var i =0; i<layouts.length;i++){
				$('#selectLayout').append("<option value="+layouts[i][0]+">"+layouts[i][1]+"</option>");	
		}
		//console.log(mqml)
		//console.log(mqml.id)
		if (mqml.hasOwnProperty("id")){
			document.getElementById("selectLayout").value=mqml.id;
			//console.log(mtnl.id)
		}
		
		//for (var i=0;i<qmlayouts.length;i++){
		//		$('#selectLayout').append("<option value="+qmlayouts[i][0]+">"+qmlayouts[i][1]+"</option>")
			
		//}
		if (mqml.hasOwnProperty("id")){
			document.getElementById("selectLayout").value=mqml.id;
			//console.log(mtnl.id)
			for (var sublayout in mqml["layout"]){
				if (mqml["layout"].hasOwnProperty(sublayout)) {
					$('#selectsublayout').append("<option value="+sublayout+">"+sublayout+"</option>")
				}
			}
			document.getElementById("defaultSlider4").value=0;
			document.getElementById("defaultSlider5").value=0;
			
		}
		
		
		
		init();
		animate();
		
		
		function init() {
		
		
			//localStorage.selection=[];
			//localStorage.;

			camera = new THREE.PerspectiveCamera( 45, WIDTH / HEIGHT, 1, 30000 );
			//camera.position.z = 800;
			
			camera.position.y = 500+1.0*yStartDisplacement;
			camera.position.x = 3500;
			//camera2 = new THREE.PerspectiveCamera( 45, WIDTH / HEIGHT, 1, 10000 );
			//camera2.position.z = 250;
			
			

			scene = new THREE.Scene();
			scene2 = new THREE.Scene();
			//////////////////////////////////////////////////
			// define shader attributes for group of particles dna
			particleP1Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP1Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/dna8-green.png" ) }
				

			};

			particleP1Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles rna
			particleP2Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP2Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/rna8.png" ) }
				

			};

			particleP2Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles proteins
			particleP3Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP3Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/disc.png" ) }
				

			};

			particleP3Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles degradation product
			particleP4Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP4Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/disc.png" ) }
				

			};

			particleP4Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles standard pn
			particleP5Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP5Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/PN1.png" ) }
				

			};

			particleP5Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles pn logical
			particleP6Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP6Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/PNLogical1.png" ) }
				

			};

			particleP6Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles pn coarse
			particleP7Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP7Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/PNCoarse1.png" ) }
				

			};

			particleP7Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			// define shader material for group of particles dna
			particle1ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP1Uniforms,
				attributes:     particleP1Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP1' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP1' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle2ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP2Uniforms,
				attributes:     particleP2Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP2' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP2' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle3ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP3Uniforms,
				attributes:     particleP3Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP3' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP3' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle4ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP4Uniforms,
				attributes:     particleP4Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP4' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP4' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle5ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP5Uniforms,
				attributes:     particleP5Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP5' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP5' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle6ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP6Uniforms,
				attributes:     particleP6Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP6' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP6' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle7ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP7Uniforms,
				attributes:     particleP7Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP7' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP7' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			//////////////////////////////////////////////
			// define shader attributes for group of lines
			linesAttributes = {

				//displacement: {	type: 'v3', value: [] },
				ca: {	type: 'c', value: [] },
				op:{ type: "f", value: [] }

			};

			linesUniforms = {

				//amplitude: { type: "f", value: 1.0 },
				opacity:   { type: "f", value: 0.7 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) }

			};
			// define shader material for group of lines
			linesShaderMaterial = new THREE.ShaderMaterial( {

				uniforms:       linesUniforms,
				attributes:     linesAttributes,
				vertexShader:   document.getElementById( 'vertexshader2' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshader2' ).textContent,
				blending:       THREE.AdditiveBlending,
				depthTest:      false,
				transparent:    true

			});

			linesShaderMaterial.linewidth = 1;
			//linesShaderMaterial.attributes.op.value=0.7;
			
			
			
			
			
			/////////////////////////////////////////////////////////////////
			// define shader attributes for group of animated token particles
			tokenAttributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] },
				endPosition: { type: "v3", value: [] },
				mixAmount: 	 { type: 'f', value: [] }
			};

			tokenUniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/small-spark.png" ) }//,
				//mixAmount: 	 { type: "f", value: 0.0 }

			};

			//uniforms.texture.value.wrapS = uniforms.texture.value.wrapT = THREE.RepeatWrapping;

			tokenShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		tokenUniforms,
				attributes:     tokenAttributes,
				vertexShader:   document.getElementById( 'vertexshader3' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshader3' ).textContent,
				depthTest: 		false,
				transparent:	true,
				opacity: 0.8,
				blending:	true

			});
			
			
			//particles = nbDNAParticles // nb of DNA elements
			//+ nbRNAParticles // nb of RNA elements
			//+ nbProtParticles // nb of proteins
			//+ nbDegradParticles // nb of degradation products
			//+ nbPNParticles // nb of PN standard places
			//+ nbLogParticles // nb of logical PN places
			//+ nbCoarseParticles; // nb of PN coarse transitions
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for dna particles
			bgeometryP1 = new THREE.BufferGeometry();
			
			bgeometryP1.dynamic = true;
			var positionsP1 = new Float32Array( nbDNAParticles * 3 );
			var values_colorP1 = new Float32Array( nbDNAParticles * 3 );
			var values_sizeP1 = new Float32Array( nbDNAParticles );
			var compartmentP1 = new Float32Array( nbDNAParticles );
			
			
			var color = new THREE.Color( 0xffffff );
			var radius =400;
			for( var bv = 0; bv < nbDNAParticles; bv++ ) {
			

				values_sizeP1[ bv ] = 10;
				compartmentP1[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;

				positionsP1[ (bv * 3) + 0 ] = (Math.random() * 2 - 1) * radius;
				//b1positions[ (bv * 3) + 1 ] = (Math.random() * 2 - 1) * radius;
				positionsP1[ (bv * 3) + 1 ] = yStartDisplacement;
				positionsP1[ (bv * 3) + 2 ] = (Math.random() * 2 - 1) * radius;
				
				
				//if ( positions[ bv * 3 + 0 ] < 0 )
				//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
				//else
				//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
				values_colorP1[ (bv * 3) + 0 ] = color.r;
				values_colorP1[ (bv * 3) + 1 ] = color.g;
				values_colorP1[ (bv * 3) + 2 ] = color.b;

			}
			bgeometryP1.addAttribute( 'position', new THREE.BufferAttribute( positionsP1, 3 ) );
			bgeometryP1.addAttribute( 'ca', new THREE.BufferAttribute( values_colorP1, 3 ) );
			bgeometryP1.addAttribute( 'size', new THREE.BufferAttribute( values_sizeP1, 1 ) );
			bgeometryP1.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentP1, 1 ) );
			
			b1values_size = bgeometryP1.attributes.size.array;
			b1positions = bgeometryP1.attributes.position.array;
			b1values_color = bgeometryP1.attributes.ca.array;
			b1values_compartment = bgeometryP1.attributes.compartment.array;
			
			
			
			// associate first particle system with bufferGeometry
			PointCloud1 = new THREE.PointCloud( bgeometryP1, particle1ShaderMaterial );

			PointCloud1.dynamic = true;
			PointCloud1.sortParticles = true;
			PointCloud1.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud1 );
			
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for rna particles
			bgeometryP2 = new THREE.BufferGeometry();
			
			bgeometryP2.dynamic = true;
			var positionsP2 = new Float32Array( nbRNAParticles * 3 );
			var values_colorP2 = new Float32Array( nbRNAParticles * 3 );
			var values_sizeP2 = new Float32Array( nbRNAParticles );
			var compartmentP2 = new Float32Array( nbRNAParticles );
									
			//bgeometryP2.attributes.size.needsUpdate = true;
			//bgeometryP2.attributes.position.needsUpdate = true;
			//bgeometryP2.attributes.ca.needsUpdate = true;
			//bgeometryP2.attributes.compartment.needsUpdate = true;
			
			var color = new THREE.Color( 0xffffff );
			var radius =400;
			for( var bv = 0; bv < nbRNAParticles; bv++ ) {
			

				values_sizeP2[ bv ] = 10;
				compartmentP2[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
				
				positionsP2[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius;
				//b2positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
				positionsP2[ bv * 3 + 1 ] = yStartDisplacement;
				
				positionsP2[ bv * 3 + 2 ] = (Math.random() * 2 - 1) * radius;
				
				
				//if ( positions[ bv * 3 + 0 ] < 0 )
				//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
				//else
				//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
				values_colorP2[ bv * 3 + 0 ] = color.r;
				values_colorP2[ bv * 3 + 1 ] = color.g;
				values_colorP2[ bv * 3 + 2 ] = color.b;

			}
			
			
			
			
			
			bgeometryP2.addAttribute( 'position', new THREE.BufferAttribute( positionsP2, 3 ) );
			bgeometryP2.addAttribute( 'ca', new THREE.BufferAttribute( values_colorP2, 3 ) );
			bgeometryP2.addAttribute( 'size', new THREE.BufferAttribute( values_sizeP2, 1 ) );
			bgeometryP2.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentP2, 1 ) );
			
			b2values_size = bgeometryP2.attributes.size.array;
			b2positions = bgeometryP2.attributes.position.array;
			b2values_color = bgeometryP2.attributes.ca.array;
			b2values_compartment = bgeometryP2.attributes.compartment.array;
			// associate first particle system with bufferGeometry
			PointCloud2 = new THREE.PointCloud( bgeometryP2, particle2ShaderMaterial );

			PointCloud2.dynamic = true;
			PointCloud2.sortParticles = true;
			PointCloud2.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud2 );
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for protein particles
			bgeometryP3 = new THREE.BufferGeometry();
			
			bgeometryP3.dynamic = true;
			var positionsP3 = new Float32Array( nbProtParticles * 3 );
			var values_colorP3 = new Float32Array( nbProtParticles * 3 );
			var values_sizeP3 = new Float32Array( nbProtParticles );
			var compartmentP3 = new Float32Array( nbProtParticles );
			
			/*bgeometryP3.attributes = {

				position: {
					itemSize: 3,
					array: new Float32Array( nbProtParticles * 3 )
				},
				ca: {
					itemSize: 3,
					array: new Float32Array( nbProtParticles * 3 )
				},
				size: {
					itemSize: 1,
					array: new Float32Array( nbProtParticles ),
					dynamic: true
				},
				compartment: {
					itemSize: 1,
					array: new Float32Array( nbProtParticles ),
					dynamic: true
				}

			}*/
			//bgeometryP3.attributes.size.needsUpdate = true;
			//bgeometryP3.attributes.position.needsUpdate = true;
			//bgeometryP3.attributes.ca.needsUpdate = true;
			//bgeometryP3.attributes.compartment.needsUpdate = true;
			
			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xff9900 );;
			var color2 = new THREE.Color( 0x55ff55 );
			var radius =400;
			var bv=0;
			//for( var bv = 0; bv < nbProtParticles; bv++ ) {
				for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
					if (jsonObj1[bw][6]==2){
						values_sizeP3[ bv ] = nodeSize;
						//b3values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
						compartmentP3[ bv ] = mapComp[jsonObj1[bw][3]];
						idMap[bw]=[2,bv];
						typesMap[2][bv]=bw;
						
						var rm;
						var rr;
						
						if (nameModel=="hepatonet1-msb201062-s5"){
							rm=bv*0.078*2*Math.PI;
							rr = ((bv*0.02)+0.35*radius)
							positionsP3[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							positionsP3[ bv * 3 + 1 ] = yStartDisplacement+0+(bv*0.05);
						}
						else if (nameModel=="Ec_iAF1260_flux2"){
							rm=bv*0.004*2*Math.PI;
							rr = ((radius*1.08)-(bv*0.03)+1)
							positionsP3[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							positionsP3[ bv * 3 + 1 ] = yStartDisplacement+0-(bv*0.03);

						}
						
						else if (nameModel=="iTO977_v1.00_cobra"){
							rm=bv*0.004*2*Math.PI;
							rr = ((radius*1.08)-(bv*0.03)+1)
							positionsP3[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							positionsP3[ bv * 3 + 1 ] = yStartDisplacement+0-(bv*0.03);

						}
						else{
							rm=bv*0.008*2*Math.PI;
							rr = ((bv*0.02)+0.05*radius);
							positionsP3[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							positionsP3[ bv * 3 + 1 ] = yStartDisplacement+0+(bv*0.02);
						}
						
						positionsP3[ bv * 3 + 2 ] = Math.sin(rm) *rr;
						
						values_colorP3[ bv * 3 + 0 ] = color.r;
						values_colorP3[ bv * 3 + 1 ] = color.g;
						values_colorP3[ bv * 3 + 2 ] = color.b;
						bv++;
					}
				}
				startModelPlaces=bv;
				for( var bw = jsonObj1.length , bww= jsonObj1.length+5000; bw < bww; bw++ ) {
						
		
					//if (jsonObj1[bw][6]==2){
						values_sizeP3[ bv ] = 10;
						//b3values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
						compartmentP3[ bv ] = -1;
						//idMap[bw]=[2,bv];
						//typesMap[2][bv]=bw;
						idMap[bw]=[2,bv];
						typesMap[2][bv]=bw;
						//var rm=(bw-jsonObj1.length)*0.078*2*Math.PI;
						//var	rr = (((bw-jsonObj1.length)*0.02)+0.95*radius)
						//radius=900;
						var rm=(bw-jsonObj1.length)*0.008*2*Math.PI;
						var rr = ((radius)-((bw-jsonObj1.length)*0.3)+1)
						positionsP3[ bv * 3 + 0 ] = (Math.cos(rm) *rr)+900;
						//b3positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius+900;
						//b3positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
						positionsP3[ bv * 3 + 1 ] = yStartDisplacement/2;
						positionsP3[ bv * 3 + 2 ] = ((Math.random() * 2 - 1) * radius)+150000;
						//b3positions[ bv * 3 + 2 ] = (Math.sin(rm) *rr)+50000;
						
						//if ( positions[ bv * 3 + 0 ] < 0 )
						//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
						//else
						//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
						values_colorP3[ bv * 3 + 0 ] = color2.r;
						values_colorP3[ bv * 3 + 1 ] = color2.g;
						values_colorP3[ bv * 3 + 2 ] = color2.b;
						bv++;
					//}
				}
				endModelPlaces=bv;
			
			

			
			/*
			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xff9900 );;
			var color2 = new THREE.Color( 0x55ff55 );
			var radius =400;
			var bv=0;
			//for( var bv = 0; bv < nbProtParticles; bv++ ) {
				for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
					if (jsonObj1[bw][6]==2){
						b3values_size[ bv ] = 10;
						//b3values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
						b3values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
						idMap[bw]=[2,bv];
						typesMap[2][bv]=bw;
						
						var rm;
						var rr;
						
						if (nameModel=="hepatonet1-msb201062-s5"){
							rm=bv*0.078*2*Math.PI;
							rr = ((bv*0.02)+0.35*radius)
							b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							b3positions[ bv * 3 + 1 ] = yStartDisplacement+0+(bv*0.05);
						}
						else if (nameModel=="Ec_iAF1260_flux2"){
							rm=bv*0.004*2*Math.PI;
							rr = ((radius*1.08)-(bv*0.03)+1)
							b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							b3positions[ bv * 3 + 1 ] = yStartDisplacement+0-(bv*0.03);

						}
						
						else if (nameModel=="iTO977_v1.00_cobra"){
							rm=bv*0.004*2*Math.PI;
							rr = ((radius*1.08)-(bv*0.03)+1)
							b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							b3positions[ bv * 3 + 1 ] = yStartDisplacement+0-(bv*0.03);

						}
						else{
							rm=bv*0.008*2*Math.PI;
							rr = ((bv*0.02)+0.05*radius);
							b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							b3positions[ bv * 3 + 1 ] = yStartDisplacement+0+(bv*0.02);
						}
						
						b3positions[ bv * 3 + 2 ] = Math.sin(rm) *rr;
						
						b3values_color[ bv * 3 + 0 ] = color.r;
						b3values_color[ bv * 3 + 1 ] = color.g;
						b3values_color[ bv * 3 + 2 ] = color.b;
						bv++;
					}
				}
				startModelPlaces=bv;
				for( var bw = jsonObj1.length , bww= jsonObj1.length+5000; bw < bww; bw++ ) {
						
		
					//if (jsonObj1[bw][6]==2){
						b3values_size[ bv ] = 30;
						//b3values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
						b3values_compartment[ bv ] = -1;
						//idMap[bw]=[2,bv];
						//typesMap[2][bv]=bw;
						idMap[bw]=[2,bv];
						typesMap[2][bv]=bw;
						//var rm=(bw-jsonObj1.length)*0.078*2*Math.PI;
						//var	rr = (((bw-jsonObj1.length)*0.02)+0.95*radius)
						//radius=900;
						var rm=(bw-jsonObj1.length)*0.008*2*Math.PI;
						var rr = ((radius*1.08)-((bw-jsonObj1.length)*0.3)+1)
						b3positions[ bv * 3 + 0 ] = (Math.cos(rm) *rr)+900;
						//b3positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius+900;
						//b3positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
						b3positions[ bv * 3 + 1 ] = yStartDisplacement+80;
						b3positions[ bv * 3 + 2 ] = ((Math.random() * 2 - 1) * radius)+50000;
						//b3positions[ bv * 3 + 2 ] = (Math.sin(rm) *rr)+50000;
						
						//if ( positions[ bv * 3 + 0 ] < 0 )
						//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
						//else
						//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
						b3values_color[ bv * 3 + 0 ] = color2.r;
						b3values_color[ bv * 3 + 1 ] = color2.g;
						b3values_color[ bv * 3 + 2 ] = color2.b;
						bv++;
					//}
				}
				endModelPlaces=bv;
			//}
			*/
			bgeometryP3.addAttribute( 'position', new THREE.BufferAttribute( positionsP3, 3 ) );
			bgeometryP3.addAttribute( 'ca', new THREE.BufferAttribute( values_colorP3, 3 ) );
			bgeometryP3.addAttribute( 'size', new THREE.BufferAttribute( values_sizeP3, 1 ) );
			bgeometryP3.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentP3, 1 ) );
			
			b3values_size = bgeometryP3.attributes.size.array;
			b3positions = bgeometryP3.attributes.position.array;
			b3values_color = bgeometryP3.attributes.ca.array;
			b3values_compartment = bgeometryP3.attributes.compartment.array;
			
			bgeometryP3.computeBoundingSphere();
			// associate first particle system with bufferGeometry
			PointCloud3 = new THREE.PointCloud( bgeometryP3, particle3ShaderMaterial );

			PointCloud3.dynamic = true;
			PointCloud3.sortParticles = true;
			PointCloud3.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud3 );
			
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for degradable product particles
			bgeometryP4 = new THREE.BufferGeometry();
			
			bgeometryP4.dynamic = true;
			var positionsP4 = new Float32Array( nbDegradParticles * 3 );
			var values_colorP4 = new Float32Array( nbDegradParticles * 3 );
			var values_sizeP4 = new Float32Array( nbDegradParticles );
			var compartmentP4 = new Float32Array( nbDegradParticles );
			
			

			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xff66ff );;
			var radius =400;
			for( var bv = 0; bv < nbDegradParticles; bv++ ) {
			

				values_sizeP4[ bv ] = 10;
				compartmentP4[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;

				positionsP4[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius;
				
				//b4positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
				positionsP4[ bv * 3 + 1 ] = yStartDisplacement+0;
				positionsP4[ bv * 3 + 2 ] = (Math.random() * 2 - 1) * radius;
				
				
				//if ( positions[ bv * 3 + 0 ] < 0 )
				//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
				//else
				//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
				values_colorP4[ bv * 3 + 0 ] = color.r;
				values_colorP4[ bv * 3 + 1 ] = color.g;
				values_colorP4[ bv * 3 + 2 ] = color.b;

			}
			bgeometryP4.addAttribute( 'position', new THREE.BufferAttribute( positionsP4, 3 ) );
			bgeometryP4.addAttribute( 'ca', new THREE.BufferAttribute( values_colorP4, 3 ) );
			bgeometryP4.addAttribute( 'size', new THREE.BufferAttribute( values_sizeP4, 1 ) );
			bgeometryP4.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentP4, 1 ) );
			
			b4values_size = bgeometryP4.attributes.size.array;
			b4positions = bgeometryP4.attributes.position.array;
			b4values_color = bgeometryP4.attributes.ca.array;
			b4values_compartment = bgeometryP4.attributes.compartment.array;
			
			
			
			
			// associate first particle system with bufferGeometry
			PointCloud4 = new THREE.PointCloud( bgeometryP4, particle4ShaderMaterial );

			PointCloud4.dynamic = true;
			PointCloud4.sortParticles = true;
			PointCloud4.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud4 );
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for PN particles
			bgeometryP5 = new THREE.BufferGeometry();
			
			var positionsP5 = new Float32Array( nbPNParticles * 3 );
			var values_colorP5 = new Float32Array( nbPNParticles * 3 );
			var values_sizeP5 = new Float32Array( nbPNParticles );
			var compartmentP5 = new Float32Array( nbPNParticles );
			
			bgeometryP5.dynamic = true;
			/*bgeometryP5.attributes = {

				position: {
					itemSize: 3,
					array: new Float32Array( nbPNParticles * 3 )
				},
				ca: {
					itemSize: 3,
					array: new Float32Array( nbPNParticles * 3 )
				},
				size: {
					itemSize: 1,
					array: new Float32Array( nbPNParticles ),
					dynamic: true
				},
				compartment: {
					itemSize: 1,
					array: new Float32Array( nbPNParticles ),
					dynamic: true
				}

			}*/
			
			
			var color = new THREE.Color( 0xffffff );
					
					var color2 = new THREE.Color( 0x55ffff );
					var radius =400;
					var bv=0;
					//for( var bv = 0; bv < nbPNParticles; bv++ ) {
					/*subSystems=[];
					for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
						if (jsonObj1[bw][6]==4){
							if (jsonObj1[bw][4][1] && jsonObj1[bw][4][1][0]){
								if (subSystems.indexOf(jsonObj1[bw][4][1][0])== -1){
									subSystems.push(jsonObj1[bw][4][1][0]);
								}
							}
						}
					}*/
					//console.log(subSystems);
					// now allocate a nb of nodes by sub systems
					subSystems={};
					totalSubSystems=0;
					
					totalNbreactions=0;
					for( var bs = 0 , bww= jsonObj1.length; bs < bww; bs++ ) {
						if (jsonObj1[bs][6]==4){
							if (jsonObj1[bs][4][1] && jsonObj1[bs][4][1][0]){
								if (subSystems[jsonObj1[bs][4][1][0]]=== undefined){
									subSystems[jsonObj1[bs][4][1][0]]=1;
									totalSubSystems++;
								}
								else{
									subSystems[jsonObj1[bs][4][1][0]]++;
									totalSubSystems++;
								}
								
							}
							totalNbreactions++;
						}
					}
					totalOutsideSubSystems=totalNbreactions-totalSubSystems;
					nbSubSystems=Object.keys(subSystems).length
					if (totalOutsideSubSystems>0){
						nbAreas=nbSubSystems+1;
						subSystems["Not present"]=totalOutsideSubSystems;
					}
					else{
						nbAreas=nbSubSystems;
					}
					//console.log(subSystems);
					
					//console.log(totalSubSystems);
					//console.log(totalNbreactions);
					//console.log(totalOutsideSubSystems);
					//console.log(nbSubSystems);
					
					// if there is no subsystem identified just use standard spiral layout
					
					// if there are n subsystems then display circular region of width proportional to the nb of nodes in each subsystem
					// first make a list of widths
					// total nb of reactions will dictate the overall nb of points that must be displayed on the ring.
					// depth of the ring is 30 points. there are for 0.004 *2Pi=1.44 degrees = 250 graduations on a circle 
					var listWidthSubSystems={};
					var nbCircleGraduations=250;
					var minCircleFraction=1/nbCircleGraduations;
					var nbNodesDepth=40;
					var totalWidth=0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							var width= Math.ceil(subSystems[key]/nbNodesDepth);
							listWidthSubSystems[key]=[subSystems[key]/*nb of nodes*/,width,/*counter value*/0];
							totalWidth+=width;
						}
					}
					nbNodesDepth=Math.ceil((40*totalWidth)/244);
					listWidthSubSystems={};
					var totalWidth=0;
					var cumulativeWidth=0;
					var colorswap=1.0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							var width= Math.ceil(subSystems[key]/nbNodesDepth);
							listWidthSubSystems[key]=[subSystems[key]/*nb of nodes*/,width,cumulativeWidth,/*counter value*/0,colorswap];
							totalWidth+=width;
							cumulativeWidth+=width;
							if (colorswap==1.0){
							colorswap=0.7;
							}
							else{colorswap=1.0}
						}
					}
					
					
					var localRSeparator=0;
					for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
						
						if (jsonObj1[bw][6]==4){

							values_sizeP5[ bv ] = nodeSize;
							//b5values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
							
							// try to assign the compartment of the majority of the products the reaction is linked to 
							// if there is no product, assign the compartment of the majority of modifiers
							// if there is no modifier, assign the compartment of the majority of reactants
							var listProducts= jsonObj1[bw][11][0];
							var listModifiers= jsonObj1[bw][11][1];
							var listReactants= jsonObj1[bw][11][2];
							
							if (listProducts.length>0){
								var votes=[];
								for (var ncc=0;ncc<nbCompartments;ncc++){
									votes[ncc]=0;
								}
								for(var lp=0;lp<listProducts.length;lp++){
									if (mapComp[jsonObj1[listProducts[lp]][3]]>=0)
										votes[mapComp[jsonObj1[listProducts[lp]][3]]]++;
								}
								var winner= votes.indexOf(Math.max.apply( Math, votes ));
								compartmentP5[ bv ] = winner;
								if (winner==-1){
									compartmentP5[ bv ] = mapComp[jsonObj1[bw][3]];
								}
							} 
							else if (listModifiers.length>0){
								var votes=[];
								for (var ncc=0;ncc<nbCompartments;ncc++){
									votes[ncc]=0;
								}
								for(var lp=0;lp<listModifiers.length;lp++){
									if (mapComp[jsonObj1[listModifiers[lp]][3]]>=0)
										votes[mapComp[jsonObj1[listModifiers[lp]][3]]]++;
								}
								var winner= votes.indexOf(Math.max.apply( Math, votes ));
								compartmentP5[ bv ] = winner;
								if (winner==-1){
									compartmentP5[ bv ] = mapComp[jsonObj1[bw][3]];
								}
							}
							else if (listReactants.length>0){
								var votes=[];
								for (var ncc=0;ncc<nbCompartments;ncc++){
									votes[ncc]=0;
								}
								for(var lp=0;lp<listReactants.length;lp++){
									if (mapComp[jsonObj1[listReactants[lp]][3]]>=0)
										votes[mapComp[jsonObj1[listReactants[lp]][3]]]++;
								}
								var winner= votes.indexOf(Math.max.apply( Math, votes ));
								compartmentP5[ bv ] = winner;
								if (winner==-1){
									compartmentP5[ bv ] = mapComp[jsonObj1[bw][3]];
								}
							}
							else {
								// if no species linked, put reaction in the center
								compartmentP5[ bv ] = mapComp[jsonObj1[bw][3]];
							}
							
							idMap[bw]=[4,bv];
							typesMap[4][bv]=bw;
							
							var rm;
							var rr; 
							
							
							
							
							if (nameModel=="Ec_iAF1260_flux2" || nameModel=="iTO977_v1.00_cobra"){
								rm=bv*0.078*2*Math.PI;
								rr = ((bv*0.02)+0.35*radius)
								//b5positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
								positionsP5[ bv * 3 + 1 ] = (yStartDisplacement/2)+(bv*0.04);
							}
							else{
								var yModifier=0;
								var mDepth=0;
								//rr= ((radius*1.08)-(0*0.03)+1);
								if (jsonObj1[bw][4][1] && jsonObj1[bw][4][1][0]){
									
									//console.log("increment node")
									//console.log(jsonObj1[bw][4][1][0]);
									if (listWidthSubSystems.hasOwnProperty(jsonObj1[bw][4][1][0])) {
									
										var startingW=listWidthSubSystems[jsonObj1[bw][4][1][0]][2];
										var maxWidth=listWidthSubSystems[jsonObj1[bw][4][1][0]][1];
										var maxDepth=nbNodesDepth;
										var maxNbNodes=listWidthSubSystems[jsonObj1[bw][4][1][0]][0];
										var presentIndex= listWidthSubSystems[jsonObj1[bw][4][1][0]][3];
										if (presentIndex<maxNbNodes){
										//cnt1++;
											var localWPos=0;
											
											var localRR=0;
											localWPos=Math.floor(presentIndex/maxDepth);
											//if (presentIndex>=maxDepth){
											
												localRR=presentIndex%maxDepth;
											yModifier=	localRR;
											mDepth=maxDepth;
											//}
											//else{
											//	localRR=presentIndex;
											//}
											//if(presentIndex==0){
											//	localRSeparator+=(nbCircleGraduations-totalWidth)/(2*nbAreas);//	rm=((startingW+localWPos+localRSeparator)*0.004*(2*Math.PI));
											//console.log(jsonObj1[bw][4][1][0])
											//listWidthSubSystems[jsonObj1[bw][4][1][0]][2]+=((nbCircleGraduations-totalWidth)/(nbAreas));
											//startingW=listWidthSubSystems[jsonObj1[bw][4][1][0]][2];
											//color.r-=0.01
											//}
											rm=((startingW+localRSeparator+localWPos)*0.004*(2*Math.PI));
											
											rr= ((radius-maxDepth*5)+(localRR*5));
											listWidthSubSystems[jsonObj1[bw][4][1][0]][3]++;
											color.r=listWidthSubSystems[jsonObj1[bw][4][1][0]][4];
											if (color.r==1.0){
											color.g=1.0;
											color.b=1.0;
											}
											else{
											color.g=0.4;
											color.b=1.0;
											}
										}
									}
								}
								else{
									
									//subSystems["Not present"]=totalOutsideSubSystems;
									if (listWidthSubSystems.hasOwnProperty("Not present")) {
									
									//console.log("increment not present")
										var startingW=listWidthSubSystems["Not present"][2];
										var maxWidth=listWidthSubSystems["Not present"][1];
										var maxDepth=nbNodesDepth;
										var maxNbNodes=listWidthSubSystems["Not present"][0];
										var presentIndex= listWidthSubSystems["Not present"][3];
										if (presentIndex<maxNbNodes){
										//cnt2++;
											var localWPos=0;
											var localRR=0;
											localWPos=Math.floor(presentIndex/maxDepth);
											//if (presentIndex>=maxDepth){
											
												localRR=presentIndex%maxDepth;
												yModifier=	localRR;	
												mDepth=maxDepth;
											//}
											//else{
											//	localRR=presentIndex;
											//}
											//if(presentIndex==0){
											//console.log(jsonObj1[bw][4][1][0])
											//listWidthSubSystems["Not present"][2]+=((nbCircleGraduations-totalWidth)/(nbAreas));
											//startingW=listWidthSubSystems["Not present"][2];
											//	localRSeparator+=(nbCircleGraduations-totalWidth)/(2*nbAreas);//	rm=((startingW+localWPos+localRSeparator)*0.004*(2*Math.PI));
											//}
											rm=((startingW+localRSeparator+localWPos)*0.004*(2*Math.PI));
											rr= ((radius-maxDepth*5)+(localRR*5));
											listWidthSubSystems["Not present"][3]++;
											color = new THREE.Color( 0xff0000 );
										}
									}
								}
								//console.log(listWidthSubSystems);
							
								//rm=bv*0.004*2*Math.PI;
								//rr= ((radius*1.08)-(bv*0.03)+1);
								
								//b5positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
								//b5positions[ bv * 3 + 1 ] = 0-(bv*0.03);
								positionsP5[ bv * 3 + 1 ] = yStartDisplacement-(mDepth*4)+(yModifier*4);
								//console.log(jsonObj1[bw][4][1][0])
							}
							positionsP5[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							positionsP5[ bv * 3 + 2 ] = Math.sin(rm) *rr;
							
							
							values_colorP5[ bv * 3 + 0 ] = color.r;
							values_colorP5[ bv * 3 + 1 ] = color.g;
							values_colorP5[ bv * 3 + 2 ] = color.b;
							bv++;
						}
					}
					//console.log("increment"+cnt1 + "  " +cnt2)
					startModelReactions=bv;
					for( var bw = jsonObj1.length , bww= jsonObj1.length+5000; bw < bww; bw++ ) {
						
						values_sizeP5[ bv ] = 10;
						
						compartmentP5[ bv ] = -1;
						idMap[bw]=[4,bv];
						typesMap[4][bv]=bw;
						
						
						
						//radius=900;
						var rm=(bw-jsonObj1.length)*0.008*2*Math.PI;
						var rr = ((radius)-((bw-jsonObj1.length)*0.3)+1)
						//b5positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius+900;
						positionsP5[ bv * 3 + 0 ] = (Math.cos(rm) *rr)+1800;
						//b5positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
						positionsP5[ bv * 3 + 1 ] = yStartDisplacement/2-180;
						
						positionsP5[ bv * 3 + 2 ] = ((Math.random() * 2 - 1) * radius)+150000;
						
						
						//if ( positions[ bv * 3 + 0 ] < 0 )
						//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
						//else
						//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
						values_colorP5[ bv * 3 + 0 ] = color2.r;
						values_colorP5[ bv * 3 + 1 ] = color2.g;
						values_colorP5[ bv * 3 + 2 ] = color2.b;
						bv++;
					}
					endModelReactions=bv;
			
			
			
			
			
			bgeometryP5.addAttribute( 'position', new THREE.BufferAttribute( positionsP5, 3 ) );
			bgeometryP5.addAttribute( 'ca', new THREE.BufferAttribute( values_colorP5, 3 ) );
			bgeometryP5.addAttribute( 'size', new THREE.BufferAttribute( values_sizeP5, 1 ) );
			bgeometryP5.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentP5, 1 ) );
			
			//bgeometryP5.attributes.size.needsUpdate = true;
			//bgeometryP5.attributes.position.needsUpdate = true;
			//bgeometryP5.attributes.ca.needsUpdate = true;
			//bgeometryP5.attributes.compartment.needsUpdate = true;

			b5values_size = bgeometryP5.attributes.size.array;
			b5positions = bgeometryP5.attributes.position.array;
			b5values_color = bgeometryP5.attributes.ca.array;
			b5values_compartment = bgeometryP5.attributes.compartment.array;
									
			// associate first particle system with bufferGeometry
			PointCloud5 = new THREE.PointCloud( bgeometryP5, particle5ShaderMaterial );

			PointCloud5.dynamic = true;
			PointCloud5.sortParticles = true;
			PointCloud5.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud5 );
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for PN particles
			bgeometryP6 = new THREE.BufferGeometry();
			
			bgeometryP6.dynamic = true;
			
			var positionsP6 = new Float32Array( nbLogParticles * 3 );
			var values_colorP6 = new Float32Array( nbLogParticles * 3 );
			var values_sizeP6 = new Float32Array( nbLogParticles );
			var compartmentP6 = new Float32Array( nbLogParticles );
			
			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xffffff );;
			var radius =400;
			for( var bv = 0; bv < nbLogParticles; bv++ ) {
			

				values_sizeP6[ bv ] = 10;
				compartmentP6[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;

				positionsP6[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius;
				//b6positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
				positionsP6[ bv * 3 + 1 ] = yStartDisplacement;
				
				positionsP6[ bv * 3 + 2 ] = (Math.random() * 2 - 1) * radius;
				
				
				//if ( positions[ bv * 3 + 0 ] < 0 )
				//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
				//else
				//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
				values_colorP6[ bv * 3 + 0 ] = color.r;
				values_colorP6[ bv * 3 + 1 ] = color.g;
				values_colorP6[ bv * 3 + 2 ] = color.b;

			}

			bgeometryP6.addAttribute( 'position', new THREE.BufferAttribute( positionsP6, 3 ) );
			bgeometryP6.addAttribute( 'ca', new THREE.BufferAttribute( values_colorP6, 3 ) );
			bgeometryP6.addAttribute( 'size', new THREE.BufferAttribute( values_sizeP6, 1 ) );
			bgeometryP6.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentP6, 1 ) );
			
			b6values_size = bgeometryP6.attributes.size.array;
			b6positions = bgeometryP6.attributes.position.array;
			b6values_color = bgeometryP6.attributes.ca.array;
			b6values_compartment = bgeometryP6.attributes.compartment.array;
			
			
			
			
			// associate first particle system with bufferGeometry
			PointCloud6 = new THREE.PointCloud( bgeometryP6, particle6ShaderMaterial );

			PointCloud6.dynamic = true;
			PointCloud6.sortParticles = true;
			PointCloud6.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud6 );
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for PN particles
			bgeometryP7 = new THREE.BufferGeometry();
			
			bgeometryP7.dynamic = true;
			
			var positionsP7 = new Float32Array( nbCoarseParticles * 3 );
			var values_colorP7 = new Float32Array( nbCoarseParticles * 3 );
			var values_sizeP7 = new Float32Array( nbCoarseParticles );
			var compartmentP7 = new Float32Array( nbCoarseParticles );
			
			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xffffff );;
			var radius =400;
			for( var bv = 0; bv < nbCoarseParticles; bv++ ) {
			

				values_sizeP7[ bv ] = 10;
				compartmentP7[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;

				positionsP7[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius;
				//b7positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
				positionsP7[ bv * 3 + 1 ] = yStartDisplacement;
				
				positionsP7[ bv * 3 + 2 ] = (Math.random() * 2 - 1) * radius;
				
				
				//if ( positions[ bv * 3 + 0 ] < 0 )
				//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
				//else
				//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
				values_colorP7[ bv * 3 + 0 ] = color.r;
				values_colorP7[ bv * 3 + 1 ] = color.g;
				values_colorP7[ bv * 3 + 2 ] = color.b;

			}

			bgeometryP7.addAttribute( 'position', new THREE.BufferAttribute( positionsP7, 3 ) );
			bgeometryP7.addAttribute( 'ca', new THREE.BufferAttribute( values_colorP7, 3 ) );
			bgeometryP7.addAttribute( 'size', new THREE.BufferAttribute( values_sizeP7, 1 ) );
			bgeometryP7.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentP7, 1 ) );
			
			b7values_size = bgeometryP7.attributes.size.array;
			b7positions = bgeometryP7.attributes.position.array;
			b7values_color = bgeometryP7.attributes.ca.array;
			b7values_compartment = bgeometryP7.attributes.compartment.array;
			
			
			
			
			// associate first particle system with bufferGeometry
			PointCloud7 = new THREE.PointCloud( bgeometryP7, particle7ShaderMaterial );

			PointCloud7.dynamic = true;
			PointCloud7.sortParticles = true;
			PointCloud7.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud7 );
			
			// populates second buffer geometry for lines  with coordinates, colors, and size
			//segmentPts = 20000;
			bgeometry2 = new THREE.BufferGeometry();
			
			var positionsL1 = new Float32Array( (segmentPts+10000) * 3 );
			var colorsL1 = new Float32Array( (segmentPts+10000) * 3 );
			var opL1 = new Float32Array((segmentPts+10000));
			var compartmentL1 = new Float32Array( (segments+5000)*2 );
			var fluxL1 = new Float32Array( (segments+5000) );
			var boundsL1= new Float32Array( (segments+5000) * 2 );
			
			/*bgeometry2.attributes = {
				position: {
					itemSize: 3,
					array: new Float32Array((segmentPts+5000) * 3)
				},
				ca: {
					itemSize: 3,
					array: new Float32Array((segmentPts+5000) * 3)
				},
				op: {
					itemSize: 1,
					array: new Float32Array( segmentPts+5000  ),
					dynamic: true
				},
				compartment: {
					itemSize: 2,
					array: new Float32Array( (segments+2500) * 2 ),
					dynamic: true
				}
				,flux: {
					itemSize: 1,
					array: new Float32Array( segments+2500 ),
					dynamic: true
				}
				,bounds: {
					itemSize: 2,
					array: new Float32Array( (segments+2500) * 2 ),
					dynamic: true
				}
			};*/
			
			var r = 800;
			var col = new THREE.Color( 0x00ffff );
			var col2 = new THREE.Color( 0x55ff55 );
			
			var iv=0;
			for ( var i = 0; i < segments; i ++ ) {
			
				var t1 = jsonObj1[jsonObj2[i][0]][6]
				var t2 = jsonObj1[jsonObj2[i][1]][6]
				var ivList=[]
				
				if (t1==2){
					positionsL1[ (iv * 3)+0 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
					positionsL1[ (iv * 3) + 1 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
					positionsL1[ (iv * 3) + 2 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
					compartmentL1[ (i*2)+0 ] = b3values_compartment[ (idMap[jsonObj2[i][0]][1]) ];
					opL1[iv]=0.25;
					colorsL1[ iv * 3 ] = 0.0;
					colorsL1[ iv * 3 + 1 ] = 1.0;
					colorsL1[ iv * 3 + 2 ] = 1.0;
					ivList.push(iv)
					//linesMap[i]=iv
					
					iv++;
				}
				else if (t1==4){
					positionsL1[ (iv * 3)+0 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
					positionsL1[ (iv * 3) + 1 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
					positionsL1[ (iv * 3) + 2 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
					compartmentL1[ (i*2)+0 ] = b5values_compartment[ (idMap[jsonObj2[i][0]][1]) ];
					opL1[iv]=0.25;
					colorsL1[ iv * 3 ] = 0.0;
					colorsL1[ iv * 3 + 1 ] = 1.0;
					colorsL1[ iv * 3 + 2 ] = 1.0;
					//linesMap[i]=iv
					ivList.push(iv)
					iv++;
				}
				if (t2 ==2){
					positionsL1[ (iv * 3)+0 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
					positionsL1[ (iv * 3) + 1 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
					positionsL1[ (iv * 3) + 2 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;
					compartmentL1[ (i*2)+1 ] = b3values_compartment[ (idMap[jsonObj2[i][1]][1]) ];
					opL1[iv]=0.25;
					colorsL1[ iv * 3 ] = 0.0;
					colorsL1[ iv * 3 + 1 ] = 1.0;
					colorsL1[ iv * 3 + 2 ] = 1.0;
					//linesMap[i]=iv
					ivList.push(iv)
					iv++;
				}
				else if (t2 ==4){
					positionsL1[ (iv * 3)+0 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
					positionsL1[ (iv * 3) + 1 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
					positionsL1[ (iv * 3) + 2 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;
					compartmentL1[ (i*2)+1 ] = b5values_compartment[ (idMap[jsonObj2[i][1]][1]) ];
					opL1[iv]=0.25;
					colorsL1[ iv * 3 ] = 0.0;
					colorsL1[ iv * 3 + 1 ] = 1.0;
					colorsL1[ iv * 3 + 2 ] = 1.0;
					//linesMap[i]=iv
					ivList.push(iv)
					iv++;
				}
				linesMap[i]=ivList
			}
			var radius=400;
			extraLinesCnt=iv;
			for ( var i = segments; i < segments+maxNbTokenModel; i ++ ) {
				
					positionsL1[ (iv * 3)+0 ] = (Math.random() * 2 - 1) * radius;
					positionsL1[ (iv * 3) + 1 ] = 80;
					positionsL1[ (iv * 3) + 2 ] = ((Math.random() * 2 - 1) * radius)+50000;
					compartmentL1[ (i*2)+0 ] = -1;
					opL1[iv]=0.25;
					colorsL1[ iv * 3 ] = 0.33;
					colorsL1[ iv * 3 + 1 ] = 1.0;
					colorsL1[ iv * 3 + 2 ] = 0.33;
					ivList.push(iv)
					//linesMap[i]=iv
					
					iv++;
				
				
				
			}

			bgeometry2.addAttribute( 'position', new THREE.BufferAttribute( positionsL1, 3 ) );	
			bgeometry2.addAttribute( 'ca', new THREE.BufferAttribute( colorsL1, 3 ) );
			bgeometry2.addAttribute( 'op', new THREE.BufferAttribute( opL1, 1 ) );
			bgeometry2.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentL1, 2 ) );

			/*
				
			//bgeometry2.attributes.position.needsUpdate = true;
			//bgeometry2.attributes.ca.needsUpdate = true;
			//bgeometry2.attributes.compartment.needsUpdate = true;
			//bgeometry2.attributes.op.needsUpdate = true;

			b2lpositions = bgeometry2.attributes.position.array;
				//var colors = bgeometry.attributes.color.array;
			b2lcolors = bgeometry2.attributes.ca.array;
			b2lcompartments=bgeometry2.attributes.compartment.array;
			b2lopacity = bgeometry2.attributes.op.array;
			var r = 800;
			var col = new THREE.Color( 0x00ffff );
			var col2 = new THREE.Color( 0x55ff55 );
			
			var iv=0;
			for ( var i = 0; i < segments; i ++ ) {
			
				var t1 = jsonObj1[jsonObj2[i][0]][6]
				var t2 = jsonObj1[jsonObj2[i][1]][6]
				var ivList=[]
				
				if (t1==2){
					b2lpositions[ (iv * 3)+0 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
					b2lpositions[ (iv * 3) + 1 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
					b2lpositions[ (iv * 3) + 2 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
					b2lcompartments[ (i*2)+0 ] = b3values_compartment[ (idMap[jsonObj2[i][0]][1]) ];
					b2lopacity[iv]=0.25;
					b2lcolors[ iv * 3 ] = col.r;
					b2lcolors[ iv * 3 + 1 ] = col.g;
					b2lcolors[ iv * 3 + 2 ] = col.b;
					ivList.push(iv)
					//linesMap[i]=iv
					
					iv++;
				}
				else if (t1==4){
					b2lpositions[ (iv * 3)+0 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
					b2lpositions[ (iv * 3) + 1 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
					b2lpositions[ (iv * 3) + 2 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
					b2lcompartments[ (i*2)+0 ] = b5values_compartment[ (idMap[jsonObj2[i][0]][1]) ];
					b2lopacity[iv]=0.25;
					b2lcolors[ iv * 3 ] = col.r;
					b2lcolors[ iv * 3 + 1 ] = col.g;
					b2lcolors[ iv * 3 + 2 ] = col.b;
					//linesMap[i]=iv
					ivList.push(iv)
					iv++;
				}
				if (t2 ==2){
					b2lpositions[ (iv * 3)+0 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
					b2lpositions[ (iv * 3) + 1 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
					b2lpositions[ (iv * 3) + 2 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;
					b2lcompartments[ (i*2)+1 ] = b3values_compartment[ (idMap[jsonObj2[i][1]][1]) ];
					b2lopacity[iv]=0.25;
					b2lcolors[ iv * 3 ] = col.r;
					b2lcolors[ iv * 3 + 1 ] = col.g;
					b2lcolors[ iv * 3 + 2 ] = col.b;
					//linesMap[i]=iv
					ivList.push(iv)
					iv++;
				}
				else if (t2 ==4){
					b2lpositions[ (iv * 3)+0 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
					b2lpositions[ (iv * 3) + 1 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
					b2lpositions[ (iv * 3) + 2 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;
					b2lcompartments[ (i*2)+1 ] = b5values_compartment[ (idMap[jsonObj2[i][1]][1]) ];
					b2lopacity[iv]=0.25;
					b2lcolors[ iv * 3 ] = col.r;
					b2lcolors[ iv * 3 + 1 ] = col.g;
					b2lcolors[ iv * 3 + 2 ] = col.b;
					//linesMap[i]=iv
					ivList.push(iv)
					iv++;
				}
				linesMap[i]=ivList
			}
			var radius=400;
			extraLinesCnt=iv;
			for ( var i = segments; i < segments+maxNbTokenModel; i ++ ) {
				
					b2lpositions[ (iv * 3)+0 ] = (Math.random() * 2 - 1) * radius;
					b2lpositions[ (iv * 3) + 1 ] = 80;
					b2lpositions[ (iv * 3) + 2 ] = ((Math.random() * 2 - 1) * radius)+50000;
					b2lcompartments[ (i*2)+0 ] = -1;
					b2lopacity[iv]=0.25;
					b2lcolors[ iv * 3 ] = col2.r;
					b2lcolors[ iv * 3 + 1 ] = col2.g;
					b2lcolors[ iv * 3 + 2 ] = col2.b;
					ivList.push(iv)
					//linesMap[i]=iv
					
					iv++;
				
				
				
			}*/
			//for ( var i = 0; i < segmentPts; i ++ ) {
			//if (i<50)
			//	console.log(i+" -- "+b1values_compartment[i]);
			//}
			
			bgeometry2.computeBoundingSphere();
		//console.log(bgeometry2);
			mesh = new THREE.Line( bgeometry2, linesShaderMaterial,THREE.LinePieces );
			scene.add( mesh );
			b2lpositions = bgeometry2.attributes.position.array;
				//var colors = bgeometry.attributes.color.array;
			b2lcolors = bgeometry2.attributes.ca.array;
			b2lcompartments=bgeometry2.attributes.compartment.array;
			b2lopacity = bgeometry2.attributes.op.array;
			
			// create and populate geometry with token particles coordinates, colors, and size
			var radius = 300;
			//tokenGeometry = new THREE.CubeGeometry( 0.8 * radius, 0.8 * radius, 0.8 * radius, 150, 100, 1 );
			// populate token geometry with "start" extremities of line segmentPts
			tokenGeometry = new THREE.Geometry();
			for ( var i = 0; i < segmentPts; i +=2 ) {
				tokenGeometry.vertices.push(new THREE.Vector3(b2lpositions[ (i * 3) ]+0,b2lpositions[ (i * 3) + 1 ]+0,b2lpositions[ (i * 3) + 2 ]+0));
			}
			// add models tokens
			for ( var i = segmentPts; i < segmentPts+maxNbTokenModel; i +=2 ) {
				tokenGeometry.vertices.push(new THREE.Vector3(b2lpositions[ (i * 3) ]+0,b2lpositions[ (i * 3) + 1 ]+0,b2lpositions[ (i * 3) + 2 ]+0));
				
			}
			//var v1 = new THREE.Vector3(0,0,0);
			//var v2 = new THREE.Vector3(0,500,0);
			//var v3 = new THREE.Vector3(0,500,500);

			
			//tokenShaderMaterial.blending = THREE.AdditiveBlending; // "glowing" particles
			tokenPS = new THREE.PointCloud( tokenGeometry, tokenShaderMaterial );
			//tokenPS = new THREE.PointCloud( tokenGeometry, spriteMaterial );
			tokenPS.dynamic = true;
			//sphere.sortParticles = true;

			tvertices = tokenPS.geometry.vertices;
			tvalues_size = tokenAttributes.size.value;
			tvalues_color = tokenAttributes.ca.value;
			tvalues_p = tokenAttributes.endPosition.value;
			for( var v = 0, vv= tvertices.length; v < vv; v++ ) {

				tvalues_size[ v ] = 5;
				tvalues_color[ v ] = new THREE.Color( 0xff7777 );
				//tvalues_p[v]=new THREE.Vector3( 600+(Math.random() * 2 - 1) * radius, (Math.random() * 2 - 1) * radius , (Math.random() * 2 - 1) * radius );	
				//tvalues_p[v]=new THREE.Vector3(b2positions[ (v+1) * 3 ],b2positions[ (v+1) * 3 + 1 ],b2positions[ (v+1) * 3 + 2 ]);
			}
			//for( var v = tvertices.length-2500, vv= tvertices.length; v < vv; v++ ) {

			//	tvalues_size[ v ] = 15;
			//	tvalues_color[ v ] = new THREE.Color( 0xff00ff );
				//tvalues_p[v]=new THREE.Vector3( 600+(Math.random() * 2 - 1) * radius, (Math.random() * 2 - 1) * radius , (Math.random() * 2 - 1) * radius );	
				//tvalues_p[v]=new THREE.Vector3(b2positions[ (v+1) * 3 ],b2positions[ (v+1) * 3 + 1 ],b2positions[ (v+1) * 3 + 2 ]);
			//}
			
			for ( var i = 1; i < segmentPts; i +=2 ) {
				tvalues_p.push(new THREE.Vector3(b2lpositions[ i * 3 ],b2lpositions[ i * 3 + 1 ],b2lpositions[ i * 3 + 2 ]+0));
			}
			for ( var i = segmentPts+1; i < segmentPts+maxNbTokenModel; i +=2 ) {
				tvalues_p.push(new THREE.Vector3(b2lpositions[ i * 3 ],b2lpositions[ i * 3 + 1 ],b2lpositions[ i * 3 + 2 ]+0));
			}
			
			//sphere.geometry.__dirtyVertices = true;
			scene.add( tokenPS );
			
			
			
			
			
			// outline mesh for lines
			
			lineGeometry = new THREE.Geometry();
			lineGeometry.vertices.push(new THREE.Vector3(-10000, -10000, -50000));
			lineGeometry.vertices.push(new THREE.Vector3(-10000, -10000, -51000));
			lineGeometry.verticesNeedUpdate = true;
			
			outlineMaterial1 = new THREE.MeshBasicMaterial( { color: 0xff0000} );			
			outlineMesh1 = new THREE.Line( lineGeometry, outlineMaterial1 );	
			//outlineMesh1.scale.multiplyScalar(1.002);
			scene.add( outlineMesh1 );
			
			
			
			var spriteMaterial = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/glow.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false, blending: THREE.AdditiveBlending
			});
			sprite = new THREE.Sprite( spriteMaterial );
			sprite.scale.set(8, 8, 8);
			//crateGlow.add(sprite); // this centers the glow at the mesh
			if (marker==0){
			sprite.position.set(-50000,-10000,10000);
			//sprite.transparent=true;
			}		
			scene.add( sprite );
			
			
			var spriteMaterial2 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/tg2.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false//, blending: THREE.AdditiveBlending
			});
			for (var i=0;i<nbSpritesSelected;i++){
				spritesSelected[i] = new THREE.Sprite( spriteMaterial2 );
				spritesSelected[i].scale.set(100, 100, 100);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				spritesSelected[i].position.set(-50000,-10000,10000);
				
					
				scene.add( spritesSelected[i] );
			}
			
			var spriteMaterial22 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/tg2.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false//, blending: THREE.AdditiveBlending
			});
			for (var i=0;i<modelnbSpritesSelected;i++){
				modelspritesSelected[i] = new THREE.Sprite( spriteMaterial22 );
				modelspritesSelected[i].scale.set(100, 100, 100);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				modelspritesSelected[i].position.set(-50000,-10000,10000);
				
					
				scene.add( modelspritesSelected[i] );
			}
			
			
			
			var spriteMaterial3 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/square_canvas.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false
			});
			for (var i=0;i<nbModelReactionLocators;i++){
				modelReactionLocators[i] = new THREE.Sprite( spriteMaterial3 );
				modelReactionLocators[i].scale.set(40, 40, 40);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				modelReactionLocators[i].position.set(-50000,-10000,10000);
				//modelReactionLocators[i].position.set(400,400,200*i);
					
				scene.add( modelReactionLocators[i] );
			}
			
			var spriteMaterial4 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/product.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false
			});
			for (var i=0;i<nbModelReactionLocators;i++){
				modelProductLocators[i] = new THREE.Sprite( spriteMaterial4 );
				modelProductLocators[i].scale.set(40, 40, 40);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				modelProductLocators[i].position.set(-50000,-10000,10000);
				//modelProductLocators[i].position.set(400,400,200*i);
					
				scene.add( modelProductLocators[i] );
			}
			
			var spriteMaterial5 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/reactant2.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false
			});
			for (var i=0;i<nbModelReactionLocators;i++){
				modelReactantLocators[i] = new THREE.Sprite( spriteMaterial5 );
				modelReactantLocators[i].scale.set(40, 40, 40);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				modelReactantLocators[i].position.set(-50000,-10000,10000);
				//modelProductLocators[i].position.set(400,400,200*i);
					
				scene.add( modelReactantLocators[i] );
			}
			
			var spriteMaterial6 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/modifier2.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false
			});
			for (var i=0;i<nbModelReactionLocators;i++){
				modelModifierLocators[i] = new THREE.Sprite( spriteMaterial6 );
				modelModifierLocators[i].scale.set(40, 40, 40);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				modelModifierLocators[i].position.set(-50000,-10000,10000);
				//modelProductLocators[i].position.set(400,400,200*i);
					
				scene.add( modelModifierLocators[i] );
			}
			
			
			// add dynamic texture on plan 
			// MESHES WITH ANIMATED TEXTURES!
	
			/*var runnerTexture = new THREE.ImageUtils.loadTexture( 'mrdoob-three.js-r67/examples/textures/run3.png' );
			animatorT1 = new TextureAnimator( runnerTexture, 9, 1, 9, 30 ); // texture, #horiz, #vert, #total, duration.
			var runnerMaterial = new THREE.MeshBasicMaterial( { map: runnerTexture, side:THREE.DoubleSide } );
			var runnerGeometry = new THREE.PlaneGeometry(400, 10, 1, 1);
			var runner = new THREE.Mesh(runnerGeometry, runnerMaterial);
			runner.position.set(0,800,1500);
			runner.rotation.x -= (90*(Math.PI / 180));
			scene.add(runner);*/
			
			// add an array of planes that will be superimposed on lines to express flows
			var planeTexture = new THREE.ImageUtils.loadTexture( '/images/glow3.png' );
			//var planeTexture = new THREE.ImageUtils.loadTexture( 'mrdoob-three.js-r67/examples/textures/sprites/small-spark.png' );
			var planeMaterial = new THREE.MeshBasicMaterial( { map: planeTexture ,side: THREE.DoubleSide}  );
			planeMaterial.blending=THREE.AdditiveBlending;
			//planeMaterial.transparent = true;
			//planeMaterial.opacity = 0.6;
			for(var i=0;i<nbModelPlanesFlow;i++){
				var planeGeometry = new THREE.PlaneGeometry(400, 5, 1, 1);
				planeMesh[i] = new THREE.Mesh(planeGeometry, planeMaterial);
				planeMesh[i].position.set(0,0,150000);
				planeMesh[i].geometry.dynamic = true;
				planeMesh[i].geometry.verticesNeedUpdate = true;
				planeMesh[i].frustumCulled = false;
				scene.add(planeMesh[i]);	
			}
			
			// add planar stuff for demonstration
			var KeggMapTexture = new THREE.ImageUtils.loadTexture( '/images/keggmap-big.png' );
			var KeggMapMaterial = new THREE.MeshBasicMaterial( { map: KeggMapTexture /*,side: THREE.DoubleSide*/}  );
			var KeggMapGeometry = new THREE.PlaneGeometry( 900, 547, 0, 0 ) // size image 2587 1575
			KeggMapPlan = new THREE.Mesh( KeggMapGeometry, KeggMapMaterial );
			KeggMapPlan.position.set(3000, 200, 0 );
			KeggMapPlan.rotation.x -= (90*(Math.PI / 180));
			KeggMapPlan.rotation.z += (90*(Math.PI / 180));
			KeggMapPlan.name="mapkegg";
			KeggMapPlan.visible=false;
			scene.add( KeggMapPlan );
			
			
			//geometryLineChart= new THREE.BufferGeometry();
			//geometryLineChart.attributes = {
			//	position: {
			//		itemSize: 3,
			//		array: new Float32Array((chartSegmentPts) * 3)
			//	},
			//	ca: {
			//		itemSize: 3,
			//		array: new Float32Array((chartSegmentPts) * 3)
			//	}
			//};
			//var col = new THREE.Color( 0xff0000 );
			//chartPositions = geometryLineChart.attributes.position.array;
			//chartColors = geometryLineChart.attributes.ca.array;
			//var iv=0;
			//for ( var i = 0; i < chartSegment; i ++ ) {
			//	chartPositions[ (iv * 3)+0 ] = 50400;
			//	chartPositions[ (iv * 3) + 1 ] = 0;
			//	chartPositions[ (iv * 3) + 2 ] = -50400;
				//chartColors[ iv * 3 ] = col.r;
				//chartColors[ iv * 3 + 1 ] = col.g;
				//chartColors[ iv * 3 + 2 ] = col.b;
			//	iv++;
			//	chartPositions[ (iv * 3)+0 ] = 50400;
			//	chartPositions[ (iv * 3) + 1 ] = 0;
			//	chartPositions[ (iv * 3) + 2 ] = -50400;
				//chartColors[ iv * 3 ] = col.r;
				//chartColors[ iv * 3 + 1 ] = col.g;
				//chartColors[ iv * 3 + 2 ] = col.b;
			//	iv++
			//}
			//geometryLineChart.computeBoundingSphere();
			//var lineChartMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000} );
			//meshLineChart = new THREE.Line( geometryLineChart, lineChartMaterial,THREE.LinePieces);
			//scene2.add( meshLineChart );
			
			/*
			// create mesh of lines for kegg 3d bar chart 
			geometryKegg = new THREE.BufferGeometry();
			keggSegment = 1000;
			keggSegmentPts = keggSegment*2;
			geometryKegg.attributes = {
				position: {
					itemSize: 3,
					array: new Float32Array((keggSegmentPts) * 3)
				},
				ca: {
					itemSize: 3,
					array: new Float32Array((keggSegmentPts) * 3)
				}
			};
			var col = new THREE.Color( 0xff0000 );
			keggPositions = geometryKegg.attributes.position.array;
			keggColors = geometryKegg.attributes.ca.array;
			var iv=0;
			for ( var i = 0; i < keggSegment; i ++ ) {
				keggPositions[ (iv * 3)+0 ] = 50000;
				keggPositions[ (iv * 3) + 1 ] = 0;
				keggPositions[ (iv * 3) + 2 ] = -50000;
				keggColors[ iv * 3 ] = col.r;
				keggColors[ iv * 3 + 1 ] = col.g;
				keggColors[ iv * 3 + 2 ] = col.b;
				iv++;
				keggPositions[ (iv * 3)+0 ] = 50000;
				keggPositions[ (iv * 3) + 1 ] = 800;
				keggPositions[ (iv * 3) + 2 ] = -50000;
				keggColors[ iv * 3 ] = col.r;
				keggColors[ iv * 3 + 1 ] = col.g;
				keggColors[ iv * 3 + 2 ] = col.b;
				iv++
			}
			geometryKegg.computeBoundingSphere();
			//var meshKegg = new THREE.Line( geometryKegg, keggLinesShaderMaterial,THREE.LinePieces );
			var keggoutlineMaterial1 = new THREE.MeshBasicMaterial( { color: 0xff0000} );
			var meshKegg = new THREE.Line( geometryKegg, keggoutlineMaterial1,THREE.LinePieces );
				
			scene.add( meshKegg );
			*/
			
			// add keegmap cubes instead
			
			var geometry = new THREE.BoxGeometry( 1, 1, 1 );
			
			for ( var i = 0; i < keggSegment; i ++ ) {
				var material = new THREE.MeshBasicMaterial( {color: 0xff0000} );
				cubesGeometry[i] = new THREE.Mesh( geometry, material );
				cubesGeometry[i].position.x=50000;
				cubesGeometry[i].position.y=200;
				cubesGeometry[i].position.z=-50000;
				cubesGeometry[i].name="k"+i;
				scene.add( cubesGeometry[i] );
			}
			
			//nbOrganelles=7;
			var canvasSize=900
			
			/*for (var i=0;i<nbOrganelles;i++){
				arraymaterial[i] = new THREE.MeshBasicMaterial( { color: 0x1111ff, side: THREE.DoubleSide } );
				var o1 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
				o1.applyMatrix( new THREE.Matrix4().makeTranslation(0, canvasSize/2, 0) );
				var o2 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
				o2.applyMatrix( new THREE.Matrix4().makeTranslation(0, -canvasSize/2, 0) );
				var o3 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
				o3.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
				o3.applyMatrix( new THREE.Matrix4().makeTranslation(canvasSize/2, 0, 0) );
				var o4 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
				o4.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
				o4.applyMatrix( new THREE.Matrix4().makeTranslation(-canvasSize/2, 0, 0) );
				o1.merge(o2);
				o1.merge(o3);
				o1.merge(o4);
				organelles[i] = new THREE.Mesh( o1, arraymaterial[i] );
				//organelles[i].position.set( Math.sin((2*Math.PI)/nbOrganelles*i)*scaleExplosion, -10, Math.cos((2*Math.PI)/nbOrganelles*i)*scaleExplosion );
				organelles[i].name="c"+i;
				organelles[i].position.set(0, yStartDisplacement, 0 );
				organelles[i].rotation.x += (90*(Math.PI / 180));
				scene.add( organelles[i] );
			}*/
			
			
			
			// add planar stuff for demonstration
			//var material2 = new THREE.MeshBasicMaterial( { color: 0x1111ff, side: THREE.DoubleSide } );
			// arraymaterial[nbOrganelles] = new THREE.MeshBasicMaterial( { color: 0x1111ff, side: THREE.DoubleSide } );
			// var n1 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			// n1.applyMatrix( new THREE.Matrix4().makeTranslation(0, canvasSize/2, 0) );
			// var n2 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			// n2.applyMatrix( new THREE.Matrix4().makeTranslation(0, -canvasSize/2, 0) );
			// var n3 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			// n3.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
			// n3.applyMatrix( new THREE.Matrix4().makeTranslation(canvasSize/2, 0, 0) );
			// var n4 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			// n4.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
			// n4.applyMatrix( new THREE.Matrix4().makeTranslation(-canvasSize/2, 0, 0) );
			// n1.merge(n2);
				// n1.merge(n3);
				// n1.merge(n4);
			// //var n3 = new THREE.PlaneGeometry( 1000, 10, 1, 1 )
			// //var n4 = new THREE.PlaneGeometry( 1000, 10, 1, 1 )
			// //nucleus = new THREE.Mesh( new THREE.PlaneGeometry( 1000, 1000, 1, 1 ), material1 );
			// nucleus = new THREE.Mesh( n1, arraymaterial[nbOrganelles] );
			// nucleus.name="c"+nbOrganelles;
			// //THREE.GeometryUtils.merge(n2, nucleus);
			// nucleus.position.set( 0, yStartDisplacement, 0 );
			// nucleus.rotation.x += (90*(Math.PI / 180));
			// scene.add( nucleus );
			
			// // add planar stuff for demonstration
			// //var material2 = new THREE.MeshBasicMaterial( { color: 0x1f51ff, side: THREE.DoubleSide } );
			// arraymaterial[nbOrganelles+1] = new THREE.MeshBasicMaterial( { color: 0x1111ff, side: THREE.DoubleSide } );
			// var c1 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			// c1.applyMatrix( new THREE.Matrix4().makeTranslation(0, canvasSize/2, 0) );
			// var c2 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			// c2.applyMatrix( new THREE.Matrix4().makeTranslation(0, -canvasSize/2, 0) );
			// var c3 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			// c3.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
			// c3.applyMatrix( new THREE.Matrix4().makeTranslation(canvasSize/2, 0, 0) );
			// var c4 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			// c4.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
			// c4.applyMatrix( new THREE.Matrix4().makeTranslation(-canvasSize/2, 0, 0) );
			// c1.merge(c2);
			// c1.merge(c3);
			// c1.merge(c4);
			// cytoplasm = new THREE.Mesh( c1, arraymaterial[nbOrganelles+1] );
			// cytoplasm.name="c"+(nbOrganelles+1);
			// cytoplasm.position.set( 0, yStartDisplacement, 0 );
			// cytoplasm.rotation.x += (90*(Math.PI / 180));
			// scene.add( cytoplasm );
			
			// // add planar stuff for demonstration
			// //var material3 = new THREE.MeshBasicMaterial( { color: 0x1f511f, side: THREE.DoubleSide } );
			// arraymaterial[nbOrganelles+2] = new THREE.MeshBasicMaterial( { color: 0x1111ff, side: THREE.DoubleSide } );
			// var e1 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			// e1.applyMatrix( new THREE.Matrix4().makeTranslation(0, canvasSize/2, 0) );
			// var e2 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			// e2.applyMatrix( new THREE.Matrix4().makeTranslation(0, -canvasSize/2, 0) );
			// var e3 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			// e3.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
			// e3.applyMatrix( new THREE.Matrix4().makeTranslation(canvasSize/2, 0, 0) );
			// var e4 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			// e4.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
			// e4.applyMatrix( new THREE.Matrix4().makeTranslation(-canvasSize/2, 0, 0) );
			// e1.merge(e2);
			// e1.merge(e3);
			// e1.merge(e4);
			
			// ECM = new THREE.Mesh( e1, arraymaterial[nbOrganelles+2] );
			// ECM.name="c"+(nbOrganelles+2);
			// ECM.position.set( 0, yStartDisplacement, 0 );
			// ECM.rotation.x += (90*(Math.PI / 180));
			// scene.add( ECM );
			
			
			
			// create skybox
			var mimagePrefix = "/images/";
			var mdirections  = ["p2", "p2", "p2", "p2", "p2", "p2"];
			var mimageSuffix = ".png";
			var mskyGeometry = new THREE.BoxGeometry( 29000, 29000, 29000 );	
			//var cubePath = "/rsi/static/tex/cube/Grid3/";
            //var cubeFormat = ".jpg";
            //var cubeFaces = [cubePath + 'px' + cubeFormat, cubePath + 'nx' + cubeFormat, cubePath + 'py' + cubeFormat, cubePath + 'ny' + cubeFormat, cubePath + 'pz' + cubeFormat, cubePath + 'nz' + cubeFormat];
            //this.gridCubeTex = THREE.ImageUtils.loadTextureCube(cubeFaces);
			var mmaterialArray = [];
			for (var i = 0; i < 6; i++)
				mmaterialArray.push( new THREE.MeshBasicMaterial({
					map: THREE.ImageUtils.loadTexture( mimagePrefix + mdirections[i] + mimageSuffix ),
					side: THREE.BackSide
				}));
			var mskyMaterial = new THREE.MeshFaceMaterial( mmaterialArray );
			var mskyBox = new THREE.Mesh( mskyGeometry, mskyMaterial );
			mskyBox.name="skybox"
			scene.add( mskyBox );
			
			
			
			// add arrows
			//var material3 = new THREE.MeshBasicMaterial( { color: 0x1f511f, side: THREE.DoubleSide } );
			//var arrow1 = cylinderMesh(new THREE.Vector3(0, 30, 0),new THREE.Vector3(200,200, 0),material3);
			//scene.add( arrow1 );
			
			// function to create a 3d arrow
			
			if (nbPlacesModel!=0 && nbReactionsModel!=0){
			
				var cnt1=0;
				var cnt2=0;
				var cnt=0;
				
				//var ln1 = scene.children[2].geometry.attributes.size.array.length-5000; 
				//var ln2 = scene.children[4].geometry.attributes.size.array.length-5000; 
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				//console.log(ln1)
				//console.log(startModelPlaces)
				for (var i= 0; i<selectedModelNodes.length;i++){
					if (selectedModelNodes[i][5]==2 ){
						//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]=((Math.random() * 2 - 1) * 400);
						var rm=cnt1*0.008*2*Math.PI;
						//radius=900;
						var rr = ((radius*1.48)-(cnt1*0.2)+1)
						scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]= (Math.cos(rm) *rr)+900;
						scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (Math.sin(rm) *rr);
						scene.children[2].geometry.attributes.compartment.array[(ln1+cnt1)]= selectedModelNodes[i][2];
						//scene.children[2].geometry.attributes.compartment.array[(ln1+cnt1)]= Math.floor(Math.random()*nbCompartments);
						idMap[jsonObj1.length+cnt]=[2,cnt1+ln1]
						//typesMap[2][cnt1]=i;
						cnt1++;
						cnt++;
					}
					else if (selectedModelNodes[i][5]==4 ){
						//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=((Math.random() * 2 - 1) * 400);
						var rm=cnt2*0.008*2*Math.PI;
						//radius=600;
						var rr = ((radius*1.480)-(cnt2*0.2)+1)
						scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(Math.cos(rm) *rr)+1800;
						scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(Math.sin(rm) *rr);
						scene.children[4].geometry.attributes.compartment.array[(ln2+cnt2)]= selectedModelNodes[i][2];
						//scene.children[4].geometry.attributes.compartment.array[(ln2+cnt2)]= Math.floor(Math.random()*nbCompartments);
						idMap[jsonObj1.length+cnt]=[4,cnt2+ln2]
						//typesMap[4][cnt2]=i;
						cnt2++;
						cnt++;
					}
				}
				//console.log(cnt1)
				//console.log(cnt2)
				scene.children[2].geometry.attributes.compartment.needsUpdate = true;
				scene.children[4].geometry.attributes.compartment.needsUpdate = true;
				scene.children[2].geometry.attributes.position.needsUpdate = true;
				scene.children[4].geometry.attributes.position.needsUpdate = true;
				
				var col2 = new THREE.Color( 0xffa500 );
				
				
				//console.log(selectedModelNodes)
				//for (var s= 0; s<selectedModelEdges.length;s++){
				//	if (selectedModelEdges[s][0]==108){
				//	console.log(s)
				//	}
				//}
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					if (sim2==2){
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
					}
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					if (sim2==2){
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
					}
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				selectedLinesPathsIds=[]
				for (var i=0; i<selectedLinesPaths.length;i++){
					for (var j=0;j<linesMap[selectedLinesPaths[i]].length;j+=1){
						selectedLinesPathsIds.push(linesMap[selectedLinesPaths[i]][j])
					}
				}
				selectedLinesPathsIds = unique(selectedLinesPathsIds)
				for (var i=0;i<selectedLinesPathsIds.length;i+=1){
					scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] +=50000;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
					
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+50000;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+50000;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				//tokenUniforms.mixAmount.value = 0.0;
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.mixAmount.value[ii] = 0.0;
					ii++;
				}
				tokenAttributes.mixAmount.needsUpdate = true;
			}	
			
			
			
			var geometry = new THREE.SphereGeometry( radiusComp, 50, 15 );

			for ( var i = 0; i < maxNbComp; i ++ ) {
				var object = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: 0x9966ff, ambient: 0x9966ff, // should generally match color
				specular: 0x050505,
				shininess: 200,side: THREE.BackSide}));//THREE.BackSide}));//, transparent: true, opacity: 0.5} ) );
				//var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: (1.0-((i/maxNbComp)*0.5)) * 0xffffff, side: THREE.BackSide}));
				object.material.ambient = object.material.color;
				object.position.x = -99999999;
				object.position.y = -99999999;
				object.position.z = -99999999;
				object.scale.y = 0.5;
				
				scene.add( object );
				objects.push( object );
			}
			
			//mtnlLayout["compartments_layout"]["name-position-scale"]=[];
			//for (var i=0; i<listCompartments.length;i++ ){
			//	mtnlLayout["compartments_layout"]["name-position-scale"][i]=[objects[i].name, objects[i].position , objects[i].scale];
			//}
			for ( var i = 0; i < listCompartments.length; i ++ ) {
				objects[i].position.x = 0;
				objects[i].position.y = 0;
				objects[i].position.z = 0;
				objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
				//stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
				//objects[i].castShadow = true;
				//objects[i].receiveShadow = true;	
			}
			if (mtnlLayout["compartments_layout"] && mtnlLayout["compartments_layout"].hasOwnProperty("name-position-scale")){
				if (mtnlLayout["compartments_layout"]["name-position-scale"].length>0){
					for ( var i = 0; i < mtnlLayout["compartments_layout"]["name-position-scale"].length; i ++ ) {
						objects[i].position.x = mtnlLayout["compartments_layout"]["name-position-scale"][i][1].x;
						objects[i].position.y = mtnlLayout["compartments_layout"]["name-position-scale"][i][1].y;
						objects[i].position.z = mtnlLayout["compartments_layout"]["name-position-scale"][i][1].z;
						objects[i].name = mtnlLayout["compartments_layout"]["name-position-scale"][i][0];
						//stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
						objects[i].scale.x = mtnlLayout["compartments_layout"]["name-position-scale"][i][2].x;
						objects[i].scale.y = mtnlLayout["compartments_layout"]["name-position-scale"][i][2].y;
						objects[i].scale.z = mtnlLayout["compartments_layout"]["name-position-scale"][i][2].z;
					}
				}
			}
			
			if (mtnlLayout["compartments_layout"] && mtnlLayout["compartments_layout"].hasOwnProperty("relations")){
				generalLayout=mtnlLayout["compartments_layout"]["relations"];
			}
			
			
			
			
			
			// add subtle blue ambient lighting
			var ambientLight = new THREE.AmbientLight(0x000027);
			  
			scene.add(ambientLight);
			  
			// directional lighting
			directionalLight = new THREE.DirectionalLight(0x55ffff); 
			directionalLight.position.set(13, 1, 1).normalize();
			ambientLight.name="dlight"
			scene.add(directionalLight);
			
			
			projector = new THREE.Projector();
			raycaster = new THREE.Raycaster();
			
			//renderer = new THREE.WebGLRenderer( { alpha: false } );
			//renderer.setSize( WIDTH, HEIGHT );
			
			//ray = new THREE.Ray();
			

			renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
			//renderer.sortObjects = false;
			renderer.setSize( window.innerWidth, window.innerHeight );
			//renderer.setSize( parseInt(window.innerWidth*0.99), window.innerHeight );
			
			pip = document.createElement('div');
			pip.style.width = window.innerWidth*0.6;
			pip.style.height = window.innerHeight*0.15;
			pip.style.position = 'absolute';
			pip.style.backgroundColor = 'black';
			pip.style.borderRadius = "5px";
			pip.style.border = '2px solid white';
			pip.style.padding = "0px 20px";
			pip.style.left = "2000px";
			pip.style.top = "2000px";
			document.body.appendChild(pip);
			
			//renderer2 = new THREE.WebGLRenderer({ antialias: true, alpha: false });
			//renderer.sortObjects = false;
			//renderer2.setSize( window.innerWidth*0.6, window.innerHeight*0.15 );
			//pip.appendChild(renderer2.domElement);
			
			//var container2 = document.createElement( 'div' );
			//document.body.appendChild(container2);
			//container2.appendChild( rendererCSS3.domElement );
			
			var container = document.getElementById( 'container' );
			
			container.appendChild( renderer.domElement );
			positionContainer = $("#container").position();//$("#showresult").position().top + $("#showresult").height()+$("#visualisation").height()
			var menu = document.getElementById( 'menu' )
			menu.style.position="absolute";
			menu.style.right="0px";
			menu.style.bottom=(0-positionContainer.top)+"px";//(positionContainer.top-positionContainer.height-30)+"px";
			contYPos = $("#showresult").position().top + $("#showresult").height()+($("#visualisation").height()/2);
			halfHeight = ($("#showresult").height()+$("#visualisation").height())/2;
			halfvis=($("#visualisation").height()/2);
			//console.log( "left: " + position.left + ", top: " + position.top );
			
			//container.appendChild( rendererCSS2.domElement );
			
			
			controls = new THREE.OrbitControls( camera, container  );
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;
				
			
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			
			container.appendChild( stats.domElement );
			stats.domElement.style.top = ($("#container").height()-60)+'px';
			// add grid for graph...
			/*var gridYZ = new THREE.GridHelper(50, 10);
			gridYZ.position.set( 1000,100,100 );
			gridYZ.rotation.y = Math.PI/2;
			gridYZ.setColors( new THREE.Color(0x660000), new THREE.Color(0x660000) );
			scene.add(gridYZ);*/

			//
			//renderer.domElement.addEventListener( 'mousemove', onMouseMove );
			
			
			
			
			//gui = new dat.GUI();
			
			
			function stopEvents(){
				stopThreeJsMouseEvent=true;
			}
			function resumeEvents(){
				stopThreeJsMouseEvent=false;
			}
			//gui.domElement.onmouseenter = stopEvents;
			//gui.domElement.onmouseleave = resumeEvents;
			
			
			
	
			//parameters = 
			//{
			//	size:8,
			//	x: 0, y: 30, z: 0,
				//x1: 0, y1: 30, z1: 0, 
				//x2: 0, y2: 30, z2: 0,
			//	color: "#ff0000", // color (change "#" to "0x")
				//opacity: 1, 
			//	visible: true,
				//material: "Phong",
				//reset: function() { resetCube() },
			//	name: "something"
				
			//};
			/*
			var FParameters = function() {
				this.size=8;
				this.x=0;
				this.y=0;
				this.z=0;
				this.color= "#ff0000";
				this.visible=true;
				this.name="";
			}
			
			parameters= new FParameters();
			
			var folder1 = gui.addFolder('Position element');
			var guiX = folder1.add( parameters, 'x' ).min(-800).max(800).step(10).listen();
			var guiY = folder1.add( parameters, 'y' ).min(-800).max(800).step(10).listen();
			var guiZ = folder1.add( parameters, 'z' ).min(-800).max(800).step(10).listen();
			guiX.onChange(function(value){   
				if(closestType>=0 && closestType<7){
					scene.children[closestType].geometry.attributes.position.array[closestid*3+0]=value;
					scene.children[closestType].geometry.attributes.position.needsUpdate = true;
				}
			});
			guiY.onChange(function(value){   
				if(closestType>=0 && closestType<7){
					scene.children[closestType].geometry.attributes.position.array[closestid*3+1]=value;
					scene.children[closestType].geometry.attributes.position.needsUpdate = true;
				}
			});
			guiZ.onChange(function(value){ 
				if(closestType>=0 && closestType<7){			
					scene.children[closestType].geometry.attributes.position.array[closestid*3+2]=value;
					scene.children[closestType].geometry.attributes.position.needsUpdate = true;
				}
			});
			
			// add a re-size gui element. When size changed, particle size updated...
			sizeParticleGuiElem = gui.add( parameters, 'size').min(5).max(80).step(1).listen().name("size");
			
			sizeParticleGuiElem.onChange(function(value) {
				if(closestType>=0 && closestType<7){	
					scene.children[closestType].geometry.attributes.size.array[closestid]=value;
					scene.children[closestType].geometry.attributes.size.needsUpdate = true;
				}
			});
			
			
			
			colorParticleGuiElem = gui.addColor( parameters, 'color' ).name('Color').listen();
			colorParticleGuiElem.onChange(function(value){
				if(closestType>=0 && closestType<7){	
				//controls = undefined;
					colorParticleGui.setHex( value.replace("#", "0x") );
					scene.children[closestType].geometry.attributes.ca.array[closestid*3+0]=colorParticleGui.r;	
					scene.children[closestType].geometry.attributes.ca.array[closestid*3+1]=colorParticleGui.g;	
					scene.children[closestType].geometry.attributes.ca.array[closestid*3+2]=colorParticleGui.b;					
					scene.children[closestType].geometry.attributes.ca.needsUpdate = true;	
				}
				if(closestType==7){	
				//controls = undefined;
					colorParticleGui.setHex( value.replace("#", "0x") );
					scene.children[closestType].geometry.attributes.ca.array[closestid*3+0]=colorParticleGui.r;	
					scene.children[closestType].geometry.attributes.ca.array[closestid*3+1]=colorParticleGui.g;	
					scene.children[closestType].geometry.attributes.ca.array[closestid*3+2]=colorParticleGui.b;	
					scene.children[closestType].geometry.attributes.ca.array[(closestid+1)*3+0]=colorParticleGui.r;	
					scene.children[closestType].geometry.attributes.ca.array[(closestid+1)*3+1]=colorParticleGui.g;	
					scene.children[closestType].geometry.attributes.ca.array[(closestid+1)*3+2]=colorParticleGui.b;	
					scene.children[closestType].geometry.attributes.ca.needsUpdate = true;	
				}
			});
			gui.add( parameters, 'name' ).name("type").listen();
			
			gui.open();
			*/
			/*var FParameters = function() {
				this.models="";
			}
			var parameters= new FParameters();
			var chooseModel=gui.add(parameters, 'models', simpleListModels );
			chooseModel.onChange(function(newValue) {
				if (newValue!="none"){
					// ask server to send model file...
					socket.emit('request-model', [ newValue, myusername]);
					//xhttp.open("GET","models/"+newValue+".json",false);
					//xhttp.send();
					//selectedModel=JSON.parse(xhttp.responseText);
					//console.log("getting model data from : "+newValue+"_model.json" );
					
				}
				else{
					selectedModel=[[],[],[],[]];
					updatedModel=true;
					
				}
				
				
			});
			gui.open();
			*/
			//selectedModel=
			
			window.addEventListener( 'resize', onWindowResize, false );
			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			document.addEventListener( 'mousedown', onDocumentMouseDown, false );
			document.addEventListener( 'mouseup', onDocumentMouseUp, false );
			
			
			var button = document.getElementById( 'view4' );
			button.addEventListener( 'click', function ( event ) {
				//console.log("view3");
				
				if (toggledLines==0){
					//console.log(scene.children[7].geometry.attributes.compartment.array.length);
					//for ( var iv = 0; iv < scene.children[7].geometry.attributes.position.array.length; iv +=2) {
					for ( var iv = 0; iv <extraLinesCnt; iv +=2) {
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] -=50000;
						scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] -=50000;
					}
					
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					toggledLines=1
				}
				else{
					//for ( var iv = 0; iv < scene.children[7].geometry.attributes.position.array.length; iv +=2) {
					for ( var iv = 0; iv <extraLinesCnt; iv +=2) {
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] +=50000;
						scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] +=50000;
					}
					
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					
					
					toggledLines=0
				}

			}, false );
			
			var button = document.getElementById( 'view5' );
		button.addEventListener( 'click', function ( event ) {
			//console.log("view3");
			
			if (toggledToken==0){
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					//scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y-=50000;
					//scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					//tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y-=50000;
					//tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				//tokenUniforms.mixAmount.value = 0.0;
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.mixAmount.value[ii] = 0.0;
					ii++;
				}
				tokenAttributes.mixAmount.needsUpdate = true;
				toggledToken=1
			}
			else{
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					//scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y+=50000;
					//scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					//tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y+=50000;
					//tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				//tokenUniforms.mixAmount.value = 0.0;
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.mixAmount.value[ii] = 0.0;
					ii++;
				}
				tokenAttributes.mixAmount.needsUpdate = true;
				toggledToken=0
			}

		}, false );
		
		
			
			
			
			
		}
		
		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		}
		
		function onDocumentMouseMove( event ) {
		
			//event.preventDefault();
			//position = window.pageYOffset+$("#container").position();//+;
			
			mouse.x = ( (event.clientX+window.pageXOffset) / window.innerWidth ) * 2 - 1;
			mouse.y = - ( (event.clientY-$("#container").position().top+window.pageYOffset) / window.innerHeight ) * 2 + 1;

		}
		
		function unique(a){
			var arr = [];
			for (var i=0;i<a.length;i++){
				if ( arr.indexOf(a[i]) == -1){
					arr.push(a[i]);
				}
			}
			return arr
		}
		
		function onDocumentMouseDown( event ) {

				//event.preventDefault();
				
				switch ( event.button ) {
					case 0: // left 
					
						if	((isOnParticle==1) && (hoveredType>=0) && (stopThreeJsMouseEvent==false) ){
							closestid =closest;
							closestType=hoveredType;
							//parameters.size=scene.children[closestType].geometry.attributes.size.array[closestid];
							//colorParticleGui.r=scene.children[closestType].geometry.attributes.ca.array[closestid*3+0];
							//colorParticleGui.g=scene.children[closestType].geometry.attributes.ca.array[closestid*3+1];
							//colorParticleGui.b=scene.children[closestType].geometry.attributes.ca.array[closestid*3+2];
							//parameters.color='#' +('000000'+colorParticleGui.getHex().toString(16)).slice(-6);
							
							//myLinkName=""+jsonObj1[typesMap[closestType][closestid]][2]
							//var mlTile= document.getElementById( 'myLink' )
							//mlTile.innerHTML=myLinkName
							//mlTile.href=null
							//var ml=[]
							//for (var ln =0; ln<10;ln++){
								//ml[ln] = document.getElementById( 'myLink'+ln )
								
							//}
							
							//ml.innerHTML=myLinkName
							
							//for (var ln =0; ln<10;ln++){
							//	myLink[ln]=null
								//myLink[ln]=jsonObj1[typesMap[closestType][closestid]].encodedBy[ln]
								//ml[ln].innerHTML=""
								//ml[ln].href=myLink[ln]
							//}
							//console.log(closestid)
							//console.log(typesMap[closestType][closestid])
							
							
							//var dat =typesMap[listretPointsTypes[myr]][closest];
							//if(jsonObj1[dat]){
							//	stringTxt = jsonObj1[dat][0]+" "+jsonObj1[dat][2];
							//	if (jsonObj1[dat][4][1] && jsonObj1[dat][4][1][0]){
							//		stringTxt = jsonObj1[dat][0]+" "+jsonObj1[dat][2]+" ("+jsonObj1[dat][4][1][0]+")";
							//	}
								
							//}
							//else{
							//	if (listretPointsTypes[myr]==2){																
							//		stringTxt = " "+selectedModelNodes[dat-jsonObj1.length][1];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
							//	}
							//	else if (listretPointsTypes[myr]==4){											
							//			stringTxt = " "+selectedModelNodes[nbPlacesModel+dat-jsonObj1.length][1];
							//	}
								//else{stringTxt = " ";}
							//}
							
							//console.log(jsonObj1[typesMap[closestType][closestid]])
							var nbS2=0
							try{
								text0.innerHTML = ""+jsonObj1[typesMap[closestType][closestid]][2];
								text0.style.top = contYPos-halfHeight +10+ 'px';
								text0.style.left = 20 + 'px';
								
								
								var txtListGenes = '<ul style="margin-left:0em;padding-left:1.3em;height:50px;">';
								for (var ln =0; ln<jsonObj1[typesMap[closestType][closestid]][4][0].length;ln++){
									myLink[ln]=jsonObj1[typesMap[closestType][closestid]][4][0][ln]
									//ml[ln].innerHTML=myLink[ln].substring(myLink[ln].lastIndexOf("/")+1);;
									txtListGenes += '<li ><a href="'+myLink[ln]+'" target="_blank">'+myLink[ln].substring(myLink[ln].lastIndexOf("/")+1);+'</a></li>';
									//ml[ln].href=myLink[ln]
								}
								txtListGenes += '</ul>';
								listGenesContent.innerHTML = txtListGenes;
								if (jsonObj1[typesMap[closestType][closestid]][4][0].length<=0){
									listGenes.style.top = 2000 + 'px';
									listGenes.style.left = 2000 + 'px';
								}else{
									listGenes.style.top = (text0.clientHeight+contYPos-halfHeight) +40+ 'px';
									listGenes.style.left = 20 + 'px';
									//text0.style.top = (listGenes.clientHeight+positionContainer.top) + 'px';
								}
							}
							catch(e){
								var stringTxt;
								var tpId;
								if (closestType==2){	
									tpId=typesMap[closestType][closestid]-jsonObj1.length;					
									stringTxt = " "+selectedModelNodes[tpId][1];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
								}
								else if (closestType==4){	
									tpId=nbPlacesModel+typesMap[closestType][closestid]-jsonObj1.length;
									stringTxt = " "+selectedModelNodes[tpId][1];
								}
								text0.innerHTML = ""+stringTxt;//selectedModelNodes[typesMap[closestType][closestid]-jsonObj1.length];
								text0.style.top = contYPos-halfHeight +10+ 'px';
								text0.style.left = 20 + 'px';
								var identifier=typesMap[closestType][closestid]
								var txtListLinks = '<ul style="margin-left:0em;padding-left:1.3em;height:150px;">';
								if (selectedModelNodesPaths.indexOf(tpId)!=-1){
									selectedModelNodesPaths.splice(selectedModelNodesPaths.indexOf(tpId),1)
								}
								else{
									selectedModelNodesPaths.push(tpId)
									for (var i=0; i<selectedModelEdges.length;i++){
										if (selectedModelEdges[i][0]==tpId){
												
												// if selectedModelEdges[i][2]=0 then reactant , if 2 then modifier, if 1 then product
												if(selectedModelEdges[i][2]==0){
													txtListLinks += '<li >'+"transition with consumed pre-place: "+selectedModelNodes[selectedModelEdges[i][1]][1]+'</li>';
													nbS2+=1;
												}
												else if (selectedModelEdges[i][2]==1){
													txtListLinks += '<li >'+"transition with non-consumed pre-place: "+selectedModelNodes[selectedModelEdges[i][1]][1]+'</li>';
													nbS2+=1;
												}
												else if (selectedModelEdges[i][2]==2){
													txtListLinks += '<li >'+"transition with product post-place: "+selectedModelNodes[selectedModelEdges[i][1]][1]+'</li>';
													nbS2+=1;
												}
												else{
													txtListLinks += '<li >'+"place linked to metabolic network: "+jsonObj1[selectedModelEdges[i][1]][2]+'</li>';
													nbS2+=1;
												}
										}
										if (selectedModelEdges[i][1]==tpId){
												// if selectedModelEdges[i][2]=0 then reactant , if 2 then modifier, if 1 then product
												if(selectedModelEdges[i][2]==0){
													txtListLinks += '<li >'+"as consumed pre-place in transition: "+selectedModelNodes[selectedModelEdges[i][0]][1]+'</li>';
													nbS2+=1;
												}
												else if (selectedModelEdges[i][2]==1){
													txtListLinks += '<li >'+"as non-consumed pre-place in transition: "+selectedModelNodes[selectedModelEdges[i][0]][1]+'</li>';
													nbS2+=1;
												}
												else if (selectedModelEdges[i][2]==2){
													txtListLinks += '<li >'+"as post-place in transition: "+selectedModelNodes[selectedModelEdges[i][0]][1]+'</li>';
													nbS2+=1;
												}
												else{
													txtListLinks += '<li >'+"as anomaly: "+selectedModelEdges[i]+'</li>';
													nbS2+=1;
												}
										}
									}
									txtListLinks += '</ul>';
									//console.log(txtListLinks);
									listLinksContent.innerHTML =txtListLinks;
								}
								
							}
							
							var nbS=0
							var txtListLinks2 = '<ul style="margin-left:0em;padding-left:1.3em;height:150px;">';
							var identifier=typesMap[closestType][closestid]
							
							//console.log(selectedModelEdges[iv-extraLinesCnt][1]);
							
							
							/*if (selectedModelNodesPaths.indexOf(identifier-jsonObj1.length)!=-1){
								selectedModelNodesPaths.splice(selectedModelNodesPaths.indexOf(identifier-jsonObj1.length),1)
								for (var i=0; i<selectedModelEdges.length;i++){
									if (selectedModelEdges[i][0]==identifier-jsonObj1.length){
										selectedModelLinesPaths.splice(selectedModelLinesPaths.indexOf(i),1)
									}
									if (selectedModelEdges[i][1]==identifier-jsonObj1.length){
										selectedModelLinesPaths.splice(selectedModelLinesPaths.indexOf(i),1)
									}
								}
							} else{
								selectedModelNodesPaths.push(identifier-jsonObj1.length)
								for (var i=0; i<selectedModelEdges.length;i++){
									if (selectedModelEdges[i][0]==identifier-jsonObj1.length){
										selectedModelLinesPaths.push(i)
										txtListLinks += '<li >'+selectedModelNodes[selectedModelEdges[i][1]][1]+'</li>';
										nbS+=1;
									}
									if (selectedModelEdges[i][1]==identifier){
										selectedModelLinesPaths.push(i)
										txtListLinks += '<li >'+selectedModelNodes[selectedModelEdges[i][1]][1]+'</li>';
										nbS+=1;
									}
								}
					
							}*/
							
							if (selectedNodesPaths.indexOf(identifier)!=-1){
								selectedNodesPaths.splice(selectedNodesPaths.indexOf(identifier),1)
								for (var i=0; i<jsonObj2.length;i++){
									if (jsonObj2[i][0]==identifier){
										selectedLinesPaths.splice(selectedLinesPaths.indexOf(i),1)
									}
									if (jsonObj2[i][1]==identifier){
										selectedLinesPaths.splice(selectedLinesPaths.indexOf(i),1)
									}
								}
							} else{
								selectedNodesPaths.push(identifier)
								for (var i=0; i<jsonObj2.length;i++){
									if (jsonObj2[i][0]==identifier){
										selectedLinesPaths.push(i)
										txtListLinks2 += '<li >'+jsonObj1[jsonObj2[i][1]][2]+'</li>';
										nbS+=1;
									}
									if (jsonObj2[i][1]==identifier){
										selectedLinesPaths.push(i)
										txtListLinks2 += '<li >'+jsonObj1[jsonObj2[i][0]][2]+'</li>';
										nbS+=1;
									}
								}
					
							}
							for (var i=0; i<selectedLinesPathsIds.length;i++){
								scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] -=50000;
							}
							selectedLinesPathsIds=[]
							for (var i=0; i<selectedLinesPaths.length;i++){
								for (var j=0;j<linesMap[selectedLinesPaths[i]].length;j+=1){
									selectedLinesPathsIds.push(linesMap[selectedLinesPaths[i]][j])
								}
							}
							selectedLinesPathsIds = unique(selectedLinesPathsIds)
							for (var i=0;i<selectedLinesPathsIds.length;i+=1){
								scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] +=50000;
							}
							scene.children[7].geometry.attributes.position.needsUpdate = true;
							txtListLinks2 += '</ul>';
							//
							if (nbS==0 && nbS2==0){
								listLinks.style.top = 2000 + 'px';
								listLinks.style.left = 2000 + 'px';
							}else{
								if (nbS!=0){
									listLinksContent.innerHTML =txtListLinks2;
								}
								
								//listLinksContent.width=$("#container").width;
								//listLinksContent.height=$("#container").height+positionContainer.top;
								//listLinks.width=$("#container").width;
								//listLinks.height=$("#container").height+positionContainer.top;
								//listLinks.style.width=$("#container").width;
								//listLinks.style.height=$("#container").style.height;
								listLinks.style.overflow="auto";
								listLinks.style.top = (listGenes.clientHeight+contYPos-halfHeight)+40 + 'px';
								listLinks.style.left = 20 + 'px';
							}
							//console.log(selectedLinesPathsIds)
						}
						else if (isOnLine==1 && isOnParticle==0 && stopThreeJsMouseEvent==false){
							parameters.name="line";
							closestType=hoveredType;
							closestid =closestLine;
							parameters.size=0;
							
							colorParticleGui.r=scene.children[closestType].geometry.attributes.ca.array[closestid*3+0];
							colorParticleGui.g=scene.children[closestType].geometry.attributes.ca.array[closestid*3+1];
							colorParticleGui.b=scene.children[closestType].geometry.attributes.ca.array[closestid*3+2];
							parameters.color='#' +('000000'+colorParticleGui.getHex().toString(16)).slice(-6);
							
						}
						else{
							
							//if(onDraggableNb>1){
							//	container.style.cursor = 'pointer';
							//}
							//else{
							//	container.style.cursor = 'auto';
							//}
							//if(onDraggableNb>1){
							//			container.style.cursor = 'pointer';
							//		}
							//if(onDraggableNb>0){
							//container.style.cursor = 'pointer';
								//container.style.cursor = 'auto';
							//	controls.noRotate=true;
							//	if(onDraggableNb>1){
							//		container.style.cursor = 'pointer';
							//	}
							//	else{container.style.cursor = 'auto';}
							//}
							//else{
							//container.style.cursor = 'auto';
							//}
						}
							//parameters.name="";
						break;
					case 1: // middle
						break;
					case 2: // right
						break;
				}
				
					
				

				
			}
		function onDocumentMouseUp( event ) {
			switch ( event.button ) {
			
				case 0:
					break;
				case 1: // middle
					break;
				case 2: // right
					break;
			}
		}
		//function onMouseMove( e ) {

		//		mouse.x = e.clientX;
		//		mouse.y = e.clientY;

		//	}
		function animate() {

			requestAnimationFrame( animate );

			render();
			
			
			
			stats.update();

		}
		
		function toXYCoords (pos) {
			//var vector = projector.projectVector(pos.clone(), camera);
			var vector = pos.clone().project(camera);
			vector.x = (vector.x + 1)/2 * window.innerWidth;
			vector.y = -(vector.y - 1)/2 * window.innerHeight;
			return vector;
		}

		function render() {
			//var delta = clock.getDelta(); 
			//animatorT1.update(1500 * delta);
			
			//cssScene2.children[0].direction=camera.direction;
			//element1.position.x = camera.position.x;
			//element1.position.y = camera.position.y;
			//element1.position.z = camera.position.z;
			controls.update();
			keyboard.update();
			
			
			if ( keyboard.pressed("A") ) {
			
				controls.panLeft(5* controls.zoomScale());
			}
			if ( keyboard.pressed("D") ) {
				controls.panLeft(-5* controls.zoomScale());
			}
				
			if ( keyboard.pressed("W") ) {
				controls.panUp(5* controls.zoomScale());
			}
				
			if ( keyboard.pressed("S") ){
				controls.panUp(-5* controls.zoomScale());
			} 
			
			if ( keyboard.pressed("X") ) {
				controls.dollyIn();
			}
				
			if ( keyboard.pressed("Z") ){
				//controls.pan(-5* controls.zoomScale(),0);
				controls.dollyOut();
			} 
			if ( keyboard.down("1") ){
				if (linesShaderMaterial.depthTest){
					linesShaderMaterial.depthTest = false;
				}
				else{
					linesShaderMaterial.depthTest = true;
				}
			} 
			if ( keyboard.down("2") ){
				if (linesShaderMaterial.blending){
					linesShaderMaterial.blending = false;
				}
				else{
					linesShaderMaterial.blending = THREE.AdditiveBlending;
				}
			} 
			if ( keyboard.down("3") ){
				if (linesShaderMaterial.transparent){
					linesShaderMaterial.transparent = false;
				}
				else{
					linesShaderMaterial.transparent = true;
				}
			} 
			if ( keyboard.down("]") ){
				for (var i=0;i<segmentPts;i++){
				//for (var i=0;i<b2lopacity.length;i++){
					if (b2lopacity[i]<1.0){
					b2lopacity[i]+=0.05;
					}
				}
				scene.children[7].geometry.attributes.op.needsUpdate = true;
				//if (linesUniforms.opacity.value<1.0){
				//	linesUniforms.opacity.value+=0.05;
				//}
				//console.log("opacity: "+linesUniforms.opacity.value);
				//consol.log("+")
					//linesShaderMaterial.transparent = false;
					//linesShaderMaterial.linesUniforms.attributes.opacity+=0.1;
				//linesUniforms.opacity.value=1.0;
				//linesUniforms.opacity.value+=0.05;
				//linesUniforms.color.value.offsetHSL( 0.0005, 0, 0 );
				//linesUniforms.amplitude.value+=0.1;
			} 
			if ( keyboard.down("[")){//linesShaderMaterial.opacity-=0.1;
				//if (linesUniforms.opacity.value>0.0){
				//	linesUniforms.opacity.value-=0.05;
				//}
				for (var i=0;i<segmentPts;i++){
				//for (var i=0;i<b2lopacity.length;i++){
					if (b2lopacity[i]>0.0){
					b2lopacity[i]-=0.05;
					}
				}
				scene.children[7].geometry.attributes.op.needsUpdate = true;
				//console.log("opacity: "+linesUniforms.opacity.value);
					//linesUniforms.opacity.value-=0.05;
					//linesUniforms.color.value.offsetHSL( -0.0005, 0, 0 );
					//linesUniforms.amplitude.value-=0.1;
			} 
				
			
				
			if (updatedListModels==true){
				console.log("changing models from updated listmodels");
				// update list of all models
				simpleListModels=["none"];
				for (var i =0;i< listModels.length;i++){
					simpleListModels.push(listModels[i][0]);
				}
				
				var listBoxModels=document.getElementById("listModels");
				var stringlist="";
				for (var i =0;i< simpleListModels.length;i++){
					stringlist+='<option value="'+simpleListModels[i]+'">'+simpleListModels[i]+'</option>';	
				}
				listBoxModels.innerHTML = stringlist;	
				// file list of metabolic files
				listMetabolicFiles = [];
				for (var i =0;i< listModels.length;i++){
					if (listMetabolicFiles.indexOf(listModels[i][4])<0){
						listMetabolicFiles.push(listModels[i][4]);
					}
				}
				
				//var listBoxMetabolic=document.getElementById("listMetabolic");
				//var stringlist="";
				//for (var i =0;i< listMetabolicFiles.length;i++){
				//	stringlist+='<option value="'+listMetabolicFiles[i]+'">'+listMetabolicFiles[i]+'</option>';	
				//}
				//listBoxMetabolic.innerHTML = stringlist;
				
				
				updatedListModels=false;
			}
			//
			if (updatedModel==true){
				resetSpreadsheet=true;
				//for (var i =0;i<spritesSelected.length;i++){		
				//		spritesSelected[i].position.set(-50000,-10000,50000);
				//	}
				//localStorage.selection=="";
				//mselectedList=[];
					//console.log("empty")
					
				
			
				//localStorage.selection=="";
				//mselectedList=[];
				//for (var i =0;i<spritesSelected.length;i++){		
				//	spritesSelected[i].position.set(-50000,-10000,10000);
				//	spritesSelected[i].scale.set(100, 100, 100);
				//}
				var fValue = document.getElementById("listModels").value;
			    var iv=0;
				if (fValue!="none"){
					
					
					// erase stuff first
					var lll=bgeometryP3.attributes.position.array.length;
					for (var ml =0;ml<lll;ml+=3){
						bgeometryP3.attributes.position.array[ml]+=50000;
					}
					var lll=bgeometryP5.attributes.position.array.length;
					for (var ml =0;ml<lll;ml+=3){
						bgeometryP5.attributes.position.array[ml]+=50000;
					}
					// erase lines 
					var iv=0;
					for ( var i = 0; i < segments; i ++ ) {
						var t1 = jsonObj1[jsonObj2[i][0]][6]
						var t2 = jsonObj1[jsonObj2[i][1]][6]
						//console.log(t1)
						//console.log(t2)
						//var ivList=[]
						var doIt=0
						if (t1==2){
							//console.log(idMap[jsonObj2[i][0]][1])
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] +=50000.0;
							
							iv++;
						}
						else if (t1==4){
							//console.log(idMap[jsonObj2[i][0]][1])
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] =50000.0;
							iv++;
						}
						if (t2 ==2){
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ]=50000.0;
							iv++;
						}
						else if (t2 ==4){
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] =50000.0;			
							iv++;
						}
						
					}
					for ( var i = segments; i < segments+5000; i ++ ) {
							//b2lpositions[ (iv * 3)+0 ] = 0;
							//b2lpositions[ (iv * 3) + 1 ] = 80;
							b2lpositions[ (iv * 3) + 2 ] = 50000;
							iv++;
					}
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					bgeometry2.attributes.position.needsUpdate = true;
					
					var ii=0;
					for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					
						//scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
						//scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
						scene.children[8].geometry.vertices[ii].z=50000;
						ii++;
					}
					//console.log(tokenAttributes.endPosition.value[0]);
					var ii=0;
					for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
						//tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
						//tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
						tokenAttributes.endPosition.value[ii].z=50000;
						ii++;
					}
					//console.log(tokenAttributes.endPosition.value[0]);
					scene.children[8].geometry.verticesNeedUpdate = true;
					tokenAttributes.endPosition.needsUpdate = true;
					//tokenUniforms.mixAmount.value = 0.0;
					var ii=0;
					for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
						tokenAttributes.mixAmount.value[ii] = 0.0;
						ii++;
					}
					tokenAttributes.mixAmount.needsUpdate = true;
					// erase tokens
					
					
					//var lll=bgeometry2.attributes.position.array.length;
					//for (var ml =0;ml<lll;ml+=3){
					//	bgeometry2.attributes.position.array[ml]+=50000;
					//}
					
					//var lll=bgeometry2.attributes.position.array.length;
					//for (var ml =0;ml<lll;ml+=3){
					//	bgeometry2.attributes.position.array[ml]+=50000;
					//}
					
					//for ( var iv = extraLinesCnt; iv <extraLinesCnt+2000; iv +=2) {
					//		scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+50000;	
					//		scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+50000;	
					//}
					
				
					
					
					//console.log(selectedMetabolicData);
					//console.log(selectedModel[0]);
					//metabolicCompartments = selectedMetabolicData[0];
					
					//oldNbOrganelles=nbOrganelles;
					//oldNbCompartments=nbCompartments;
					
					//nbCompartments=metabolicCompartments.length
					
					// nbOrganelles=nbCompartments-3;
					// if (selectedModel[0][0]=="Ecoli2.0"){
						// mapComp = {'-1':-1, Extra_organism:0 ,Periplasm:1 ,Cytosol:2}
						// nameComp = ["Extra_organism","Periplasm","Cytosol" ];	
						// element1.src	= "slickgrid132E.html"	
					// }
					
					// else if (selectedModel[0][0]=="HepatocyteQSSPN"){
						// mapComp = {'-1':-1, GolErMi:0 ,bile:1 ,lyso:2 ,mito:3 ,peroxy:4 ,nuc:5 ,cyto:6 ,ext:7 }
						// nameComp = ["GolErMi","bile","lysosome","mytochodria","peroxisome", "nucleus", "cytoplasm" ,"extra-cellular" ];	
						// element1.src	= "slickgrid13HP.html"	
					// }
					// else{
						// mapComp = {'-1':-1, g:0 ,r:1 ,l:2 ,m:3 ,x:4 ,n:5 ,c:6 ,e:7 }
						// nameComp = ["golgi","ER","lysosome","mytochodria","peroxisome", "nucleus", "cytoplasm" ,"extra-cellular" ];		
						// element1.src	= "slickgrid131.html"						
					// }
					clearedTokenIndex=[];
					stackTokenModel=[];
					tokenStackCount=0;
					simTimer=0;
					simulationIsOn=false;
					simulationIsPaused==false;
					sliderElement.value=simTimer;
					timerElement.innerHTML="0";
					
					metabolicNodes = selectedMetabolicData[1];
					metabolicEdges = selectedMetabolicData[2];
					jsonObj1=metabolicNodes
					jsonObj2=metabolicEdges
					mnbDNA=0;
					mnbRNA=0;
					mnbProt=0;
					mnbDegProd=0;
					mnbPN=0;
					mnbLog=0;
					mnbCoarse=0;
					for (var i = 0, ii= jsonObj1.length;i<ii;i++){
						if (jsonObj1[i][6]==0){
							mnbDNA++;
						}
						if (jsonObj1[i][6]==1){
							mnbRNA++;
						}
						if (jsonObj1[i][6]==2){
							mnbProt++;
						}
						if (jsonObj1[i][6]==3){
							mnbDegProd++;
						}
						if (jsonObj1[i][6]==4){
							mnbPN++;
						}
						if (jsonObj1[i][6]==5){
							mnbLog++;
						}
						if (jsonObj1[i][6]==6){
							mnbCoarse++;
						}
					}
					nbDNAParticles=mnbDNA; // nb of DNA elements
					nbRNAParticles=mnbRNA; // nb of RNA elements
					nbProtParticles=mnbProt+10000; // nb of proteins
					nbDegradParticles=mnbDegProd; // nb of degradation products
					nbPNParticles=mnbPN+10000; // nb of PN standard places
					nbLogParticles=mnbLog; // nb of logical PN places
					nbCoarseParticles=mnbCoarse; // nb of PN coarse transitions
			
					idMap=[];
					typesMap=[];
					for (var im=0;im<7;im++){
						typesMap[im]=[];
					};
					reactionMap=[];
			
					segments =jsonObj2.length;
					//var segments =0;
					segmentPts =segments*2;
					
					
					
					/////////////////////////////////////////////
					// defines first buffergeometry for protein particles
					
					
					
					
					
					bgeometryP3.attributes.size.needsUpdate = true;
					bgeometryP3.attributes.position.needsUpdate = true;
					bgeometryP3.attributes.ca.needsUpdate = true;
					bgeometryP3.attributes.compartment.needsUpdate = true;

					//b3values_size = bgeometryP3.attributes.size.array;
					//b3positions = bgeometryP3.attributes.position.array;
					//b3values_color = bgeometryP3.attributes.ca.array;
					//b3values_compartment = bgeometryP3.attributes.compartment.array;
					
					
					
					// populates first buffer geometry for particles with coordinates, colors, and size
					var color = new THREE.Color( 0xff9900 );;
					var color2 = new THREE.Color( 0x55ff55 );
					var radius =400;
					var bv=0;
					//for( var bv = 0; bv < nbProtParticles; bv++ ) {
						for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
							if (jsonObj1[bw][6]==2){
								b3values_size[ bv ] = 10;
								//b3values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
								b3values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
								idMap[bw]=[2,bv];
								typesMap[2][bv]=bw;
								
								var rm;
								var rr;
								
								if (selectedModel[0][0]=="HepatocyteQSSPN"){
									rm=bv*0.078*2*Math.PI;
									rr = ((bv*0.02)+0.35*radius)
									b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
									b3positions[ bv * 3 + 1 ] = 0+(bv*0.05);
								}
								else if (selectedModel[0][0]=="Ecoli2.0"){
									rm=bv*0.004*2*Math.PI;
									rr = ((radius*1.08)-(bv*0.03)+1)
									b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
									b3positions[ bv * 3 + 1 ] = 0-(bv*0.03);

								}
								else{
									rm=bv*0.008*2*Math.PI;
									rr = ((bv*0.02)+0.05*radius);
									b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
									b3positions[ bv * 3 + 1 ] = 0+(bv*0.02);
								}
								
								b3positions[ bv * 3 + 2 ] = Math.sin(rm) *rr;
								
								b3values_color[ bv * 3 + 0 ] = color.r;
								b3values_color[ bv * 3 + 1 ] = color.g;
								b3values_color[ bv * 3 + 2 ] = color.b;
								bv++;
							}
						}
						startModelPlaces=bv;
						for( var bw = jsonObj1.length , bww= jsonObj1.length+10000; bw < bww; bw++ ) {
								
				
							//if (jsonObj1[bw][6]==2){
								b3values_size[ bv ] = 30;
								//b3values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
								b3values_compartment[ bv ] = -1;
								//idMap[bw]=[2,bv];
								//typesMap[2][bv]=bw;
								idMap[bw]=[2,bv];
								typesMap[2][bv]=bw;
								//var rm=(bw-jsonObj1.length)*0.078*2*Math.PI;
								//var	rr = (((bw-jsonObj1.length)*0.02)+0.95*radius)
								//radius=900;
								var rm=(bw-jsonObj1.length)*0.008*2*Math.PI;
								var rr = ((radius*1.08)-((bw-jsonObj1.length)*0.3)+1)
								b3positions[ bv * 3 + 0 ] = (Math.cos(rm) *rr)+900;
								//b3positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius+900;
								//b3positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
								b3positions[ bv * 3 + 1 ] = 80;
								b3positions[ bv * 3 + 2 ] = ((Math.random() * 2 - 1) * radius)+50000;
								//b3positions[ bv * 3 + 2 ] = (Math.sin(rm) *rr)+50000;
								
								//if ( positions[ bv * 3 + 0 ] < 0 )
								//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
								//else
								//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
								b3values_color[ bv * 3 + 0 ] = color2.r;
								b3values_color[ bv * 3 + 1 ] = color2.g;
								b3values_color[ bv * 3 + 2 ] = color2.b;
								bv++;
							//}
						}
						endModelPlaces=bv;
					//}
				
				
					// associate first particle system with bufferGeometry
					//PointCloud3 = new THREE.PointCloud( bgeometryP3, particle3ShaderMaterial );

					PointCloud3.dynamic = true;
					PointCloud3.sortParticles = true;
					PointCloud3.geometry.__dirtyVertices = true;
					
					
					
					
					bgeometryP5.attributes.size.needsUpdate = true;
					bgeometryP5.attributes.position.needsUpdate = true;
					bgeometryP5.attributes.ca.needsUpdate = true;
					bgeometryP5.attributes.compartment.needsUpdate = true;

					//b5values_size = bgeometryP5.attributes.size.array;
					//b5positions = bgeometryP5.attributes.position.array;
					//b5values_color = bgeometryP5.attributes.ca.array;
					//b5values_compartment = bgeometryP5.attributes.compartment.array;
					
					// populates first buffer geometry for particles with coordinates, colors, and size
					var color = new THREE.Color( 0xffffff );
					
					var color2 = new THREE.Color( 0x55ffff );
					var radius =400;
					var bv=0;
					//for( var bv = 0; bv < nbPNParticles; bv++ ) {
					/*subSystems=[];
					for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
						if (jsonObj1[bw][6]==4){
							if (jsonObj1[bw][4][1] && jsonObj1[bw][4][1][0]){
								if (subSystems.indexOf(jsonObj1[bw][4][1][0])== -1){
									subSystems.push(jsonObj1[bw][4][1][0]);
								}
							}
						}
					}*/
					//console.log(subSystems);
					// now allocate a nb of nodes by sub systems
					subSystems={};
					totalSubSystems=0;
					
					totalNbreactions=0;
					for( var bs = 0 , bww= jsonObj1.length; bs < bww; bs++ ) {
						if (jsonObj1[bs][6]==4){
							if (jsonObj1[bs][4][1] && jsonObj1[bs][4][1][0]){
								if (subSystems[jsonObj1[bs][4][1][0]]=== undefined){
									subSystems[jsonObj1[bs][4][1][0]]=1;
									totalSubSystems++;
								}
								else{
									subSystems[jsonObj1[bs][4][1][0]]++;
									totalSubSystems++;
								}
								
							}
							totalNbreactions++;
						}
					}
					totalOutsideSubSystems=totalNbreactions-totalSubSystems;
					nbSubSystems=Object.keys(subSystems).length
					if (totalOutsideSubSystems>0){
						nbAreas=nbSubSystems+1;
						subSystems["Not present"]=totalOutsideSubSystems;
					}
					else{
						nbAreas=nbSubSystems;
					}
					console.log(subSystems);
					
					//console.log(totalSubSystems);
					//console.log(totalNbreactions);
					//console.log(totalOutsideSubSystems);
					//console.log(nbSubSystems);
					
					// if there is no subsystem identified just use standard spiral layout
					
					// if there are n subsystems then display circular region of width proportional to the nb of nodes in each subsystem
					// first make a list of widths
					// total nb of reactions will dictate the overall nb of points that must be displayed on the ring.
					// depth of the ring is 30 points. there are for 0.004 *2Pi=1.44 degrees = 250 graduations on a circle 
					var listWidthSubSystems={};
					var nbCircleGraduations=250;
					var minCircleFraction=1/nbCircleGraduations;
					var nbNodesDepth=40;
					var totalWidth=0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							var width= Math.ceil(subSystems[key]/nbNodesDepth);
							listWidthSubSystems[key]=[subSystems[key]/*nb of nodes*/,width,/*counter value*/0];
							totalWidth+=width;
						}
					}
					nbNodesDepth=Math.ceil((40*totalWidth)/244);
					listWidthSubSystems={};
					var totalWidth=0;
					var cumulativeWidth=0;
					var colorswap=1.0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							var width= Math.ceil(subSystems[key]/nbNodesDepth);
							listWidthSubSystems[key]=[subSystems[key]/*nb of nodes*/,width,cumulativeWidth,/*counter value*/0,colorswap];
							totalWidth+=width;
							cumulativeWidth+=width;
							if (colorswap==1.0){
							colorswap=0.7;
							}
							else{colorswap=1.0}
						}
					}
					
					//console.log(totalWidth);
					//console.log(listWidthSubSystems);
					/*for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							var percentage= subSystems[key]/totalNbreactions;
							if (percentage < minCircleFraction){
								percentage= minCircleFraction;
								
							}
							subSystems[key]=percentage;
							totalPercentage+=percentage;
							
							//console.log(percentage);
						}
					}
					console.log(totalPercentage);
					var toDistribute=0;
					if (totalPercentage>1){
						toDistribute= totalPercentage-1;
					}
					var nbReducable=0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							if((subSystems[key]*(1-toDistribute))>minCircleFraction){
								nbReducable++;
							}
						}
					}
					console.log(nbReducable);
					var sums=0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							if((subSystems[key]*(1-toDistribute))>minCircleFraction){
								var res=subSystems[key]*(1-(toDistribute));
								subSystems[key]=res;
								
							}
							sums+=subSystems[key];
							
							//toDistribute/nbReducable
						}
					}
					console.log(subSystems+" total: "+sums);*/
					//var cnt1=0
					//var cnt2=0;
					var localRSeparator=0;
					for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
						
						if (jsonObj1[bw][6]==4){

							b5values_size[ bv ] = 10;
							//b5values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
							
							// try to assign the compartment of the majority of the products the reaction is linked to 
							// if there is no product, assign the compartment of the majority of modifiers
							// if there is no modifier, assign the compartment of the majority of reactants
							var listProducts= jsonObj1[bw][11][0];
							var listModifiers= jsonObj1[bw][11][1];
							var listReactants= jsonObj1[bw][11][2];
							
							if (listProducts.length>0){
								var votes=[];
								for (var ncc=0;ncc<nbCompartments;ncc++){
									votes[ncc]=0;
								}
								for(var lp=0;lp<listProducts.length;lp++){
									if (mapComp[jsonObj1[listProducts[lp]][3]]>=0)
										votes[mapComp[jsonObj1[listProducts[lp]][3]]]++;
								}
								var winner= votes.indexOf(Math.max.apply( Math, votes ));
								b5values_compartment[ bv ] = winner;
								if (winner==-1){
									b5values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
								}
							} 
							else if (listModifiers.length>0){
								var votes=[];
								for (var ncc=0;ncc<nbCompartments;ncc++){
									votes[ncc]=0;
								}
								for(var lp=0;lp<listModifiers.length;lp++){
									if (mapComp[jsonObj1[listModifiers[lp]][3]]>=0)
										votes[mapComp[jsonObj1[listModifiers[lp]][3]]]++;
								}
								var winner= votes.indexOf(Math.max.apply( Math, votes ));
								b5values_compartment[ bv ] = winner;
								if (winner==-1){
									b5values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
								}
							}
							else if (listReactants.length>0){
								var votes=[];
								for (var ncc=0;ncc<nbCompartments;ncc++){
									votes[ncc]=0;
								}
								for(var lp=0;lp<listReactants.length;lp++){
									if (mapComp[jsonObj1[listReactants[lp]][3]]>=0)
										votes[mapComp[jsonObj1[listReactants[lp]][3]]]++;
								}
								var winner= votes.indexOf(Math.max.apply( Math, votes ));
								b5values_compartment[ bv ] = winner;
								if (winner==-1){
									b5values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
								}
							}
							else {
								// if no species linked, put reaction in the center
								b5values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
							}
							
							idMap[bw]=[4,bv];
							typesMap[4][bv]=bw;
							
							var rm;
							var rr; 
							
							
							
							
							if (selectedModel[0][0]=="Ecoli2.0"){
								rm=bv*0.078*2*Math.PI;
								rr = ((bv*0.02)+0.35*radius)
								//b5positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
								b5positions[ bv * 3 + 1 ] = 0+(bv*0.04);
							}
							else{
								//rr= ((radius*1.08)-(0*0.03)+1);
								if (jsonObj1[bw][4][1] && jsonObj1[bw][4][1][0]){
									
									//console.log("increment node")
									//console.log(jsonObj1[bw][4][1][0]);
									if (listWidthSubSystems.hasOwnProperty(jsonObj1[bw][4][1][0])) {
									
										var startingW=listWidthSubSystems[jsonObj1[bw][4][1][0]][2];
										var maxWidth=listWidthSubSystems[jsonObj1[bw][4][1][0]][1];
										var maxDepth=nbNodesDepth;
										var maxNbNodes=listWidthSubSystems[jsonObj1[bw][4][1][0]][0];
										var presentIndex= listWidthSubSystems[jsonObj1[bw][4][1][0]][3];
										if (presentIndex<maxNbNodes){
										//cnt1++;
											var localWPos=0;
											var localRR=0;
											localWPos=Math.floor(presentIndex/maxDepth);
											//if (presentIndex>=maxDepth){
												
												localRR=presentIndex%maxDepth;
											//}
											//else{
											//	localRR=presentIndex;
											//}
											//if(presentIndex==0){
											//	localRSeparator+=(nbCircleGraduations-totalWidth)/(2*nbAreas);//	rm=((startingW+localWPos+localRSeparator)*0.004*(2*Math.PI));
											//console.log(jsonObj1[bw][4][1][0])
											//listWidthSubSystems[jsonObj1[bw][4][1][0]][2]+=((nbCircleGraduations-totalWidth)/(nbAreas));
											//startingW=listWidthSubSystems[jsonObj1[bw][4][1][0]][2];
											//color.r-=0.01
											//}
											rm=((startingW+localRSeparator+localWPos)*0.004*(2*Math.PI));
											
											rr= ((radius-maxDepth*5)+(localRR*5));
											listWidthSubSystems[jsonObj1[bw][4][1][0]][3]++;
											color.r=listWidthSubSystems[jsonObj1[bw][4][1][0]][4];
											if (color.r==1.0){
											color.g=1.0;
											color.b=1.0;
											}
											else{
											color.g=0.4;
											color.b=1.0;
											}
										}
									}
								}
								else{
									
									//subSystems["Not present"]=totalOutsideSubSystems;
									if (listWidthSubSystems.hasOwnProperty("Not present")) {
									
									//console.log("increment not present")
										var startingW=listWidthSubSystems["Not present"][2];
										var maxWidth=listWidthSubSystems["Not present"][1];
										var maxDepth=nbNodesDepth;
										var maxNbNodes=listWidthSubSystems["Not present"][0];
										var presentIndex= listWidthSubSystems["Not present"][3];
										if (presentIndex<maxNbNodes){
										//cnt2++;
											var localWPos=0;
											var localRR=0;
											localWPos=Math.floor(presentIndex/maxDepth);
											//if (presentIndex>=maxDepth){
												
												localRR=presentIndex%maxDepth;
											//}
											//else{
											//	localRR=presentIndex;
											//}
											//if(presentIndex==0){
											//console.log(jsonObj1[bw][4][1][0])
											//listWidthSubSystems["Not present"][2]+=((nbCircleGraduations-totalWidth)/(nbAreas));
											//startingW=listWidthSubSystems["Not present"][2];
											//	localRSeparator+=(nbCircleGraduations-totalWidth)/(2*nbAreas);//	rm=((startingW+localWPos+localRSeparator)*0.004*(2*Math.PI));
											//}
											rm=((startingW+localRSeparator+localWPos)*0.004*(2*Math.PI));
											rr= ((radius-maxDepth*5)+(localRR*5));
											listWidthSubSystems["Not present"][3]++;
											color = new THREE.Color( 0xff0000 );
										}
									}
								}
								//console.log(listWidthSubSystems);
							
								//rm=bv*0.004*2*Math.PI;
								//rr= ((radius*1.08)-(bv*0.03)+1);
								
								//b5positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
								//b5positions[ bv * 3 + 1 ] = 0-(bv*0.03);
								b5positions[ bv * 3 + 1 ] = 0-(0*0.03);
								//console.log(jsonObj1[bw][4][1][0])
							}
							b5positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							b5positions[ bv * 3 + 2 ] = Math.sin(rm) *rr;
							
							
							b5values_color[ bv * 3 + 0 ] = color.r;
							b5values_color[ bv * 3 + 1 ] = color.g;
							b5values_color[ bv * 3 + 2 ] = color.b;
							bv++;
						}
					}
					//console.log("increment"+cnt1 + "  " +cnt2)
					startModelReactions=bv;
					for( var bw = jsonObj1.length , bww= jsonObj1.length+10000; bw < bww; bw++ ) {
						
						b5values_size[ bv ] = 30;
						
						b5values_compartment[ bv ] = -1;
						idMap[bw]=[4,bv];
						typesMap[4][bv]=bw;
						
						
						
						//radius=900;
						var rm=(bw-jsonObj1.length)*0.008*2*Math.PI;
						var rr = ((radius*0.78)-((bw-jsonObj1.length)*0.3)+1)
						//b5positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius+900;
						b5positions[ bv * 3 + 0 ] = (Math.cos(rm) *rr)+1800;
						//b5positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
						b5positions[ bv * 3 + 1 ] = 180;
						
						b5positions[ bv * 3 + 2 ] = ((Math.random() * 2 - 1) * radius)+50000;
						
						
						//if ( positions[ bv * 3 + 0 ] < 0 )
						//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
						//else
						//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
						b5values_color[ bv * 3 + 0 ] = color2.r;
						b5values_color[ bv * 3 + 1 ] = color2.g;
						b5values_color[ bv * 3 + 2 ] = color2.b;
						bv++;
					}
					endModelReactions=bv;
					
					// associate first particle system with bufferGeometry
					PointCloud5 = new THREE.PointCloud( bgeometryP5, particle5ShaderMaterial );

					PointCloud5.dynamic = true;
					PointCloud5.sortParticles = true;
					PointCloud5.geometry.__dirtyVertices = true;
				
					//console.log("changing model file representation");
					
					
					
					bgeometry2.attributes.position.needsUpdate = true;
					bgeometry2.attributes.ca.needsUpdate = true;
					bgeometry2.attributes.compartment.needsUpdate = true;

					//b2lpositions = bgeometry2.attributes.position.array;
						//var colors = bgeometry.attributes.color.array;
					//b2lcolors = bgeometry2.attributes.ca.array;
					//b2lcompartments=bgeometry2.attributes.compartment.array;
					
					var r = 800;
					var col = new THREE.Color( 0x00ffff );
					var col2 = new THREE.Color( 0x55ff55 );
					
					var iv=0;
					for ( var i = 0; i < segments; i ++ ) {
						
						var t1 = jsonObj1[jsonObj2[i][0]][6]
						var t2 = jsonObj1[jsonObj2[i][1]][6]
						var ivList=[]
						if (t1==2){
							b2lpositions[ (iv * 3)+0 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
							b2lpositions[ (iv * 3) + 1 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
							b2lpositions[ (iv * 3) + 2 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
							b2lcompartments[ (i*2)+0 ] = b3values_compartment[ (idMap[jsonObj2[i][0]][1]) ];
							b2lcolors[ iv * 3 ] = col.r;
							b2lcolors[ iv * 3 + 1 ] = col.g;
							b2lcolors[ iv * 3 + 2 ] = col.b;
							ivList.push(iv)
							//linesMap[i]=iv
							
							iv++;
						}
						else if (t1==4){
							b2lpositions[ (iv * 3)+0 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
							b2lpositions[ (iv * 3) + 1 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
							b2lpositions[ (iv * 3) + 2 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
							b2lcompartments[ (i*2)+0 ] = b5values_compartment[ (idMap[jsonObj2[i][0]][1]) ];
							b2lcolors[ iv * 3 ] = col.r;
							b2lcolors[ iv * 3 + 1 ] = col.g;
							b2lcolors[ iv * 3 + 2 ] = col.b;
							//linesMap[i]=iv
							ivList.push(iv)
							iv++;
						}
						if (t2 ==2){
							b2lpositions[ (iv * 3)+0 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
							b2lpositions[ (iv * 3) + 1 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
							b2lpositions[ (iv * 3) + 2 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;
							b2lcompartments[ (i*2)+1 ] = b3values_compartment[ (idMap[jsonObj2[i][1]][1]) ];
							b2lcolors[ iv * 3 ] = col.r;
							b2lcolors[ iv * 3 + 1 ] = col.g;
							b2lcolors[ iv * 3 + 2 ] = col.b;
							//linesMap[i]=iv
							ivList.push(iv)
							iv++;
						}
						else if (t2 ==4){
							b2lpositions[ (iv * 3)+0 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
							b2lpositions[ (iv * 3) + 1 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
							b2lpositions[ (iv * 3) + 2 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;
							b2lcompartments[ (i*2)+1 ] = b5values_compartment[ (idMap[jsonObj2[i][1]][1]) ];
							b2lcolors[ iv * 3 ] = col.r;
							b2lcolors[ iv * 3 + 1 ] = col.g;
							b2lcolors[ iv * 3 + 2 ] = col.b;
							//linesMap[i]=iv
							ivList.push(iv)
							iv++;
						}
						linesMap[i]=ivList
					}
					
					var radius=400;
					extraLinesCnt=iv;
					for ( var i = segments; i < segments+5000; i ++ ) {
						
							b2lpositions[ (iv * 3)+0 ] = (Math.random() * 2 - 1) * radius;
							b2lpositions[ (iv * 3) + 1 ] = 80;
							b2lpositions[ (iv * 3) + 2 ] = ((Math.random() * 2 - 1) * radius)+50000;
							b2lcompartments[ (i*2)+0 ] = -1;
							b2lcolors[ iv * 3 ] = col2.r;
							b2lcolors[ iv * 3 + 1 ] = col2.g;
							b2lcolors[ iv * 3 + 2 ] = col2.b;
							ivList.push(iv)
							//linesMap[i]=iv
							
							iv++;
						
						
						
					}
					
					
					
					// do the token thing
					/*var ii=0;
					for ( var i = segmentPts; i <segmentPts+5000 ; i +=2 ) {
					
						scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
						scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
						scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
						ii++;
					}
					//console.log(tokenAttributes.endPosition.value[0]);
					var ii=0;
					for ( var i = segmentPts+1; i <segmentPts+5000 ; i +=2 ) {
						tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
						tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
						tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
						ii++;
					}
					//console.log(tokenAttributes.endPosition.value[0]);
					scene.children[8].geometry.verticesNeedUpdate = true;
					tokenAttributes.endPosition.needsUpdate = true;
					//tokenUniforms.mixAmount.value = 0.0;
					var ii=0;
					for ( var i = 1; i <segmentPts+5000 ; i +=2 ) {
						tokenAttributes.mixAmount.value[ii] = 0.0;
						ii++;
					}
					tokenAttributes.mixAmount.needsUpdate = true;
					*/
					
					//for ( var i = 0; i < segmentPts; i ++ ) {
					//if (i<50)
					//	console.log(i+" -- "+b1values_compartment[i]);
					//}
					
					//bgeometry2.computeBoundingSphere();
				//console.log(bgeometry2);
					//mesh = new THREE.Line( bgeometry2, linesShaderMaterial,THREE.LinePieces );
					
					//var radius = 300;
					//tokenGeometry = new THREE.CubeGeometry( 0.8 * radius, 0.8 * radius, 0.8 * radius, 150, 100, 1 );
					// populate token geometry with "start" extremities of line segmentPts
					//tokenGeometry = new THREE.Geometry();
					
					//for ( var i = 0; i < segmentPts; i +=2 ) {
					//	tokenGeometry.vertices.push(new THREE.Vector3(b2lpositions[ (i * 3) ]+0,b2lpositions[ (i * 3) + 1 ]+0,b2lpositions[ (i * 3) + 2 ]+0));
					//}
					//var v1 = new THREE.Vector3(0,0,0);
					//var v2 = new THREE.Vector3(0,500,0);
					//var v3 = new THREE.Vector3(0,500,500);

					//geom.vertices.push(v1);
					//geom.vertices.push(v2);
					//geom.vertices.push(v3);
					
					//tokenPS = new THREE.PointCloud( tokenGeometry, tokenShaderMaterial );
					//tokenPS.dynamic = true;
					//sphere.sortParticles = true;

					//var tvertices = tokenPS.geometry.vertices;
					//var tvalues_size = tokenAttributes.size.value;
					//var tvalues_color = tokenAttributes.ca.value;
					//var tvalues_p = tokenAttributes.endPosition.value;
					//for( var v = 0, vv= tvertices.length; v < vv; v++ ) {

					//	tvalues_size[ v ] = 5;
					//	tvalues_color[ v ] = new THREE.Color( 0xff0000 );
						//tvalues_p[v]=new THREE.Vector3( 600+(Math.random() * 2 - 1) * radius, (Math.random() * 2 - 1) * radius , (Math.random() * 2 - 1) * radius );	
						//tvalues_p[v]=new THREE.Vector3(b2positions[ (v+1) * 3 ],b2positions[ (v+1) * 3 + 1 ],b2positions[ (v+1) * 3 + 2 ]);
					//}
					//for ( var i = 1; i < segmentPts; i +=2 ) {
					//	tvalues_p.push(new THREE.Vector3(b2lpositions[ i * 3 ],b2lpositions[ i * 3 + 1 ],b2lpositions[ i * 3 + 2 ]));
					//}
					
					
					
					
					// remake organelles containers
					//oldNbOrganelles=nbOrganelles;
					//var	oldNbCompartments=nbCompartments;
					//for (var i=0;i<oldNbOrganelles;i++){
					//organelles[i].position.set(-50000, 50000, 0 );
					//if (selectedModel[0][0]=="Ecoli2.0"){
					//				organelles[i].position.set(-50000, 50000, 50000 );
					//}
					
					//	scene.remove( organelles[i] );
					//}
					
					//organelles[nbOrganelles].position.set(-50000, 50000, 50000 );
					//organelles[nbOrganelles+1].position.set(-50000, 50000, 50000 );
					//organelles[nbOrganelles+2].position.set(-50000, 50000, 50000 );
					
					
					
					var canvasSize=900
					
					//organelles=[];
					
									
					
					// for (var i=0;i<nbOrganelles;i++){
						// arraymaterial[i] = new THREE.MeshBasicMaterial( { color: 0x1111ff, side: THREE.DoubleSide } );
						// var o1 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
						// o1.applyMatrix( new THREE.Matrix4().makeTranslation(0, canvasSize/2, 0) );
						// var o2 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
						// o2.applyMatrix( new THREE.Matrix4().makeTranslation(0, -canvasSize/2, 0) );
						// var o3 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
						// o3.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
						// o3.applyMatrix( new THREE.Matrix4().makeTranslation(canvasSize/2, 0, 0) );
						// var o4 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
						// o4.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
						// o4.applyMatrix( new THREE.Matrix4().makeTranslation(-canvasSize/2, 0, 0) );
						// o1.merge(o2);
						// o1.merge(o3);
						// o1.merge(o4);
						// organelles[i] = new THREE.Mesh( o1, arraymaterial[i] );
						// //organelles[i].position.set( Math.sin((2*Math.PI)/nbOrganelles*i)*scaleExplosion, -10, Math.cos((2*Math.PI)/nbOrganelles*i)*scaleExplosion );
						
						// organelles[i].name="c"+i;
						// organelles[i].position.set(0, 0, 0 );
						
						// organelles[i].rotation.x += (90*(Math.PI / 180));
						// scene.add( organelles[i] );
						
					// }
					
					
					
					
					// erase stuff
					var c = 2;
						for (var h=scene.children[c].geometry.attributes.size.array.length-10000, hh=scene.children[c].geometry.attributes.size.array.length+10000;h<hh;h++){
								scene.children[c].geometry.attributes.position.array[h*3+2]=((Math.random() * 2 - 1) * 400)+50000;
								scene.children[c].geometry.attributes.compartment.array[h]= -1;
						}
						scene.children[c].geometry.attributes.position.needsUpdate = true;
						modelVisible=false;
						var c = 4;
						for (var h=scene.children[c].geometry.attributes.size.array.length-10000, hh=scene.children[c].geometry.attributes.size.array.length+10000;h<hh;h++){
								scene.children[c].geometry.attributes.position.array[h*3+2]=((Math.random() * 2 - 1) * 400)+50000;	
								scene.children[c].geometry.attributes.compartment.array[h]= -1;
						}
						scene.children[c].geometry.attributes.position.needsUpdate = true;
						//console.log(extraLinesCnt)
						//console.log(extraLinesCnt+nbReactionsModel)
						for ( var iv = extraLinesCnt; iv <extraLinesCnt+5000; iv +=2) {
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+50000;	
							scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+50000;	
						}
					
					
					
					//console.log(modelData);
					//selectedModel=modelData;
					// update model visualisation 
					// add data 
					//console.log("selectedModel "+selectedModel[4]);
					selectedModelNodes=selectedModel[2];
					selectedModelEdges=selectedModel[3];
					//console.log(selectedModelNodes);
					//console.log(selectedModelEdges);
					// in model edges, position index 2: product = 1 , preplace =2, consumed = 0
				
					nbPlacesModel=0;
					nbReactionsModel=0;
					nbEdgesModel=selectedModelEdges.length;
					
					for (var i = 0, ii= selectedModelNodes.length;i<ii;i++){
						if (selectedModelNodes[i][5]==2 ){
							nbPlacesModel++;					
						}
						if (selectedModelNodes[i][5]==4 ){
							nbReactionsModel++;
						}
					}
					//console.log("nbPlacesModel "+nbPlacesModel);
					//console.log("nbReactionsModel "+nbReactionsModel); startModelReactions startModelPlaces
					if (modelVisible==false && nbPlacesModel!=0 && nbReactionsModel!=0){
					
						var cnt1=0;
						var cnt2=0;
						var cnt=0;
						
						//var ln1 = scene.children[2].geometry.attributes.size.array.length-5000; 
						//var ln2 = scene.children[4].geometry.attributes.size.array.length-5000; 
						var ln1 = startModelPlaces;
						var ln2 = startModelReactions;
						//console.log(ln1)
						//console.log(startModelPlaces)
						for (var i= 0; i<selectedModelNodes.length;i++){
							if (selectedModelNodes[i][5]==2 ){
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]=((Math.random() * 2 - 1) * 400);
								var rm=cnt1*0.008*2*Math.PI;
								//radius=900;
								var rr = ((radius*1.08)-(cnt1*0.2)+1)
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]= (Math.cos(rm) *rr)+900;
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (Math.sin(rm) *rr);
								scene.children[2].geometry.attributes.compartment.array[(ln1+cnt1)]= selectedModelNodes[i][2];
								//scene.children[2].geometry.attributes.compartment.array[(ln1+cnt1)]= Math.floor(Math.random()*nbCompartments);
								idMap[jsonObj1.length+cnt]=[2,cnt1+ln1]
								//typesMap[2][cnt1]=i;
								cnt1++;
								cnt++;
							}
							else if (selectedModelNodes[i][5]==4 ){
								//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=((Math.random() * 2 - 1) * 400);
								var rm=cnt2*0.008*2*Math.PI;
								//radius=600;
								var rr = ((radius*0.78)-(cnt2*0.2)+1)
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(Math.cos(rm) *rr)+1800;
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(Math.sin(rm) *rr);
								scene.children[4].geometry.attributes.compartment.array[(ln2+cnt2)]= selectedModelNodes[i][2];
								//scene.children[4].geometry.attributes.compartment.array[(ln2+cnt2)]= Math.floor(Math.random()*nbCompartments);
								idMap[jsonObj1.length+cnt]=[4,cnt2+ln2]
								//typesMap[4][cnt2]=i;
								cnt2++;
								cnt++;
							}
						}
						//console.log(cnt1)
						//console.log(cnt2)
						scene.children[2].geometry.attributes.compartment.needsUpdate = true;
						scene.children[4].geometry.attributes.compartment.needsUpdate = true;
						scene.children[2].geometry.attributes.position.needsUpdate = true;
						scene.children[4].geometry.attributes.position.needsUpdate = true;
						
						var col2 = new THREE.Color( 0xffa500 );
						
						
						//console.log(selectedModelNodes)
						//for (var s= 0; s<selectedModelEdges.length;s++){
						//	if (selectedModelEdges[s][0]==108){
						//	console.log(s)
						//	}
						//}
						
						var count=0;
						for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
							var t1;
							var t2;
							var pt1;
							var pt2;
							var sim1=1;
							var sim2=1;
							pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
							sim1 = idMap[pt1][0]
							t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
							if (selectedModelEdges[iv-extraLinesCnt][3]==2){
								//console.log("link between model and metabolic nodes")
								
								if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
									pt2=selectedModelEdges[iv-extraLinesCnt][1];
								}
								else{
									pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
								}
								t2 = jsonObj1[pt2][6]
								sim2=2;
							}
							else{
								//console.log("link between model nodes")
								if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
									pt2=selectedModelEdges[iv-extraLinesCnt][1];
								}
								else{
									pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
								}
								t2 = selectedModelNodes[pt2][5];
							}
							if (sim2!=2){
								pt2+=jsonObj1.length;
								//console.log(idMap[pt2]);
							}
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
							startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
							if (sim2==2){
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
							}
							count+=1;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
							endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
							if (sim2==2){
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
							}
							count+=1;
						}
						scene.children[7].geometry.attributes.position.needsUpdate = true;
						scene.children[7].geometry.attributes.ca.needsUpdate = true;
						
						// do the token thing
						// also create a map that connect indexes
						
						/*var ii=0;
						for ( var i = segmentPts; i <segmentPts+5000 ; i +=2 ) {
							startPositionTokenMap[ii]=i;
							scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+50000;
							scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
							scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ];
							ii++;
						}
						//console.log(tokenAttributes.endPosition.value[0]);
						
						var ii=0;
						for ( var i = segmentPts+1; i <segmentPts+5000 ; i +=2 ) {
							endPositionTokenMap[ii]=i;
							tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+50000;
							tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
							tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ];
							
							ii++;
						}
						*/
						//var ii=0;
						//for ( var i = segmentPts; i <segmentPts+(nbEdgesModel) ; i ++ ) {
							//startPositionTokenMap[ii]=i;
							//scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+50000;
							//scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
							//scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ];
							
							//tokenAttributes.mixAmount.value[ii] = 0.0;
							//tokenAttributes.size.value[ii] = 30.0;
							//tokenAttributes.ca.value[ ii ] = new THREE.Color( 0xffffaa );
							
							//endPositionTokenMap[ii]=i+1;
							//tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ ((i+1) * 3) ]+50000;
							//tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ ((i+1) * 3) + 1 ]+0;
							//tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ ((i+1) * 3) + 2 ];
							
						//	ii++;
						//}
						//console.log("nb of start/end pts for tokens"+ii + "  "+(nbEdgesModel*2));
						
						//console.log(tokenAttributes.endPosition.value[0]);
						//scene.children[8].geometry.verticesNeedUpdate = true;
						//tokenAttributes.endPosition.needsUpdate = true;
						//tokenUniforms.mixAmount.value = 0.0;
						/*var ii=0;
						for ( var i = 1; i <segmentPts+5000 ; i +=2 ) {
							tokenAttributes.mixAmount.value[ii] = 0.0;
							tokenAttributes.size.value[ii] = 30.0;
							tokenAttributes.ca.value[ ii ] = new THREE.Color( 0xffaaaa );
							ii++;
						}*/
						
						//tokenAttributes.mixAmount.needsUpdate = true;
						//tokenAttributes.size.needsUpdate = true;
						//tokenAttributes.ca.needsUpdate = true;
						
						modelVisible=true;
					}
					else if ( nbPlacesModel==0 && nbReactionsModel==0){
						
						var c = 2;
						for (var h=scene.children[c].geometry.attributes.size.array.length-10000, hh=scene.children[c].geometry.attributes.size.array.length+10000;h<hh;h++){
								scene.children[c].geometry.attributes.position.array[h*3+2]=((Math.random() * 2 - 1) * 400)+50000;
								scene.children[c].geometry.attributes.compartment.array[h]= -1;
						}
						scene.children[c].geometry.attributes.position.needsUpdate = true;
						modelVisible=false;
						var c = 4;
						for (var h=scene.children[c].geometry.attributes.size.array.length-10000, hh=scene.children[c].geometry.attributes.size.array.length+10000;h<hh;h++){
								scene.children[c].geometry.attributes.position.array[h*3+2]=((Math.random() * 2 - 1) * 400)+50000;	
								scene.children[c].geometry.attributes.compartment.array[h]= -1;
						}
						scene.children[c].geometry.attributes.position.needsUpdate = true;
						//console.log(extraLinesCnt)
						//console.log(extraLinesCnt+nbReactionsModel)
						for ( var iv = extraLinesCnt; iv <extraLinesCnt+2000; iv +=2) {
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+50000;	
							scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+50000;	
						}
						
						scene.children[7].geometry.attributes.position.needsUpdate = true;
						modelVisible=false;
					}
					else{
						
						var cnt1=0;
						var cnt2=0;
						var cnt=0;
						//var ln1 = scene.children[2].geometry.attributes.size.array.length-5000;
						//var ln2 = scene.children[4].geometry.attributes.size.array.length-5000;
						var ln1 = startModelPlaces;
						var ln2 = startModelReactions;
						for (var i= 0; i<selectedModelNodes.length;i++){
							if (selectedModelNodes[i][5]==2 ){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]=((Math.random() * 2 - 1) * 400);
								scene.children[2].geometry.attributes.compartment.array[(ln1+cnt1)]= selectedModelNodes[i][2];
								//scene.children[2].geometry.attributes.compartment.array[(ln1+cnt1)]= Math.floor(Math.random()*nbCompartments);
								idMap[jsonObj1.length+cnt]=[2,cnt1+ln1]
								cnt1++;
								cnt++;
							}
							else if (selectedModelNodes[i][5]==4 ){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=((Math.random() * 2 - 1) * 400);
								scene.children[4].geometry.attributes.compartment.array[(ln2+cnt2)]= selectedModelNodes[i][2];
								//scene.children[4].geometry.attributes.compartment.array[(ln2+cnt2)]= Math.floor(Math.random()*nbCompartments);
								idMap[jsonObj1.length+cnt]=[4,cnt2+ln2]
								cnt2++;
								cnt++;
							}
						}
						scene.children[2].geometry.attributes.compartment.needsUpdate = true;
						scene.children[4].geometry.attributes.compartment.needsUpdate = true;
						scene.children[2].geometry.attributes.position.needsUpdate = true;
						scene.children[4].geometry.attributes.position.needsUpdate = true;
						
						var col2 = new THREE.Color( 0xffa500 );
						
						//var lModelNodes=[];
						
						//console.log(nbEdgesModel)
						var count=0;
						for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
							var t1;
							var t2;
							var pt1;
							var pt2;
							var sim1=1;
							var sim2=1;
							pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
							sim1 = idMap[pt1][0]
							t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
							if (selectedModelEdges[iv-extraLinesCnt][3]==2){
								//console.log("link between model and metabolic nodes")
								
								if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
									pt2=selectedModelEdges[iv-extraLinesCnt][1];
								}
								else{
									pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
								}
								t2 = jsonObj1[pt2][6]
								sim2=2;
							}
							else{
								//console.log("link between model nodes")
								if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
									pt2=selectedModelEdges[iv-extraLinesCnt][1];
								}
								else{
									pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
								}
								t2 = selectedModelNodes[pt2][5];
							}
							if (sim2!=2){
								pt2+=jsonObj1.length;
								//console.log(idMap[pt2]);
							}
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
							
							if (sim2==2){
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
							}
							count+=1;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
							
							if (sim2==2){
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
							}
							count+=1;
						}
						
						
						scene.children[7].geometry.attributes.position.needsUpdate = true;
						scene.children[7].geometry.attributes.ca.needsUpdate = true;
						
						
						//var ii=0;
						//for ( var i = segmentPts; i <segmentPts+(nbEdgesModel) ; i ++ ) {
							//startPositionTokenMap[ii]=i;
							//scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+50000;
							//scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
							//scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ];
							
							//tokenAttributes.mixAmount.value[ii] = 0.0;
							//tokenAttributes.size.value[ii] = 30.0;
							//tokenAttributes.ca.value[ ii ] = new THREE.Color( 0xffaaaa );
							
							//endPositionTokenMap[ii]=i+1;
							//tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ ((i+1) * 3) ]+50000;
							//tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ ((i+1) * 3) + 1 ]+0;
							//tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ ((i+1) * 3) + 2 ];
							
							//ii++;
						//}
					
						
						
						
						
						modelVisible=true;
					}
					
					
				}
				else{
				// erase stuff first
					var lll=bgeometryP3.attributes.position.array.length;
					for (var ml =0;ml<lll;ml+=3){
						bgeometryP3.attributes.position.array[ml]+=50000;
					}
					var lll=bgeometryP5.attributes.position.array.length;
					for (var ml =0;ml<lll;ml+=3){
						bgeometryP5.attributes.position.array[ml]+=50000;
					}
					var c = 2;
					//for (var h=scene.children[c].geometry.attributes.size.array.length-5000, hh=scene.children[c].geometry.attributes.size.array.length+5000;h<hh;h++){
					//		scene.children[c].geometry.attributes.position.array[h*3+2]=((Math.random() * 2 - 1) * 400)+50000;
					//		scene.children[c].geometry.attributes.compartment.array[h]= -1;
					//}
					scene.children[c].geometry.attributes.position.needsUpdate = true;
					//modelVisible=false;
					var c = 4;
					//for (var h=scene.children[c].geometry.attributes.size.array.length-5000, hh=scene.children[c].geometry.attributes.size.array.length+5000;h<hh;h++){
					//		scene.children[c].geometry.attributes.position.array[h*3+2]=((Math.random() * 2 - 1) * 400)+50000;	
					//		scene.children[c].geometry.attributes.compartment.array[h]= -1;
					//}
					scene.children[c].geometry.attributes.position.needsUpdate = true;
					//console.log(extraLinesCnt)
					//console.log(extraLinesCnt+nbReactionsModel)
					for ( var iv = extraLinesCnt; iv <extraLinesCnt+5000; iv +=2) {
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+50000;	
						scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+50000;	
					}
				
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					modelVisible=false;
				}
				updatedModel=false;
			}
			
			
			//if (mtween)
				//camTween.update();
			TWEEN.update();
			//var time = Date.now() * 0.005;

			//PointCloud1.rotation.z = 0.01 * time;
			if (stopThreeJsMouseEvent==false){
			if (flagPick==1){
				var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
				//projector.unprojectVector( vector, camera );
				vector.unproject( camera );
				raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
				var distance=99999999;
				var listretPointsIndexes=[];
				var listretPointsDistances=[];	
				var listretPointsTypes=[];	
				var listretPointsIndexesL=[];
				var listretPointsDistancesL=[];	
				var listretPointsTypesL=[];	
				var point = new THREE.Vector3(0,0,0);		
				var myray=raycaster.ray;
				var point1 = new THREE.Vector3(0,0,0);	
				var point2 = new THREE.Vector3(0,0,0);
				
				
				for(var i=0, ii=scene.children.length;i<ii;i++){
					
					for (var partT=0;partT<7;partT++){
					// mouse hover detect particle
					if (scene.children[i] instanceof THREE.PointCloud && (i==partT)){
						var a1 = scene.children[i].geometry.attributes.position.array;
						var a2 = scene.children[i].geometry.attributes.size.array;
						particles = a2.length;
						var a3 = scene.children[i].geometry.attributes.ca.array;
						
						for(var j=0;j<particles;j++){
							point.x = (a1[j*3]);
							point.y = (a1[j*3+1]);
							point.z = (a1[j*3+2]);
							distance = myray.distanceToPoint(point);
							if ( distance <=2 ) {
								listretPointsIndexes.push(j);
								listretPointsDistances.push(distance);	
								listretPointsTypes.push(i);	
							}
						}
						
					}
					/*if (scene.children[i] instanceof THREE.Mesh ){
						for (var nc=0;nc<nbCompartments;nc++){
							if (scene.children[i] instanceof THREE.Mesh && scene.children[i].name=="c"+nc){
								//console.log(scene.children[i])
								var ptMesh = scene.children[i].position;
								var meshdistance = myray.distanceToPoint(point);
								if (meshdistance)<=2
								console.log(ptMesh)
							}
						}
					}*/
					
					
					}
					var h1 = listretPointsDistances.length;
					var myr;
					var mymin = Math.min.apply(Math, listretPointsDistances);
					var v1=0;
					while(h1--){
						if (listretPointsDistances[h1]==mymin){
							myr=h1;
								}
								if (myr==h1)
									break;
								
					}						
					closest = listretPointsIndexes[myr];
					if (closest>=0){
						//console.log(listretPointsTypes[myr]);
						if (listretPointsTypes[myr]>=0)
							sprite.position.set(scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3],scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3+1],scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3+2]);	
						//console.log(closest);
						//console.log(i);
						isOnParticle=1;
							//cssObject.element.children[1].textContent=""+closest;//.element.symbol.textContent=closest;
							
							if (listretPointsTypes[myr]>=0){
								
								var pp = toXYCoords(sprite.position);
								
								if ((text1PreviousPos.x != pp.x) && (text1PreviousPos.y != pp.y)){
									//console.log(text1PreviousPos)
									//console.log(listretPointsTypes[myr])
									// display 2d text in html in screen 2s coordinate corresponding to near the 3d position... 
									//camera.updateMatrixWorld() ;
									//text1.firstChild.value=""+jsonObj1[typesMap[listretPointsTypes[myr]][closest]][2];
									text1.style.top = (pp.y+contYPos +halfvis)+ 'px';								
									text1.style.left = (pp.x -(text1.firstChild.length*8))-18+ 'px';
									text1PreviousPos = pp;
									var stringTxt="";
									var dat =typesMap[listretPointsTypes[myr]][closest];
									if(jsonObj1[dat]){
										stringTxt = jsonObj1[dat][0]+" "+jsonObj1[dat][2];
										if (jsonObj1[dat][4][1] && jsonObj1[dat][4][1][0]){
											stringTxt = jsonObj1[dat][0]+" "+jsonObj1[dat][2]+" ("+jsonObj1[dat][4][1][0]+")";
										}
										
									}
									else{
										if (listretPointsTypes[myr]==2){
											if (selectedModelNodes[dat-jsonObj1.length])
											stringTxt = " "+selectedModelNodes[dat-jsonObj1.length][1];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
										}
										else if (listretPointsTypes[myr]==4){
												if (selectedModelNodes[nbPlacesModel+dat-jsonObj1.length])
												stringTxt = " "+selectedModelNodes[nbPlacesModel+dat-jsonObj1.length][1];
										}
										//else{stringTxt = " ";}
									}
									if (text1PreviousString!=stringTxt){
										text1.innerHTML=stringTxt;
										text1PreviousString=stringTxt;
									}
									//text1.innerHTML=stringTxt;
									/*else{
										//text1.innerHTML = " ";
										if (listretPointsTypes[myr]==2){												
											text1.innerHTML = " "+selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
										}
										if (listretPointsTypes[myr]==4){
											text1.innerHTML = " "+selectedModelNodes[nbPlacesModel+typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length];
										}
									}*/
									/*try{
										
									text1.innerHTML = ""+jsonObj1[typesMap[listretPointsTypes[myr]][closest]][2];		
																		
									
									}
									catch(e){
										text1.innerHTML = " ";
										try{
											//var ln1 = startModelPlaces;
											//var ln2 = startModelReactions;
											//selectedModelNodes[i][5]==2
											//var Ptype= idMap[closest][0];
											//var Pindex= idMap[closest][1];
											//text1.innerHTML = " "+idMap[closest];
											if (listretPointsTypes[myr]==2){
												
												text1.innerHTML = " "+selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
												//console.log(selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length]);
												//console.log(selectedModelNodes);
											}
											if (listretPointsTypes[myr]==4){
												text1.innerHTML = " "+selectedModelNodes[nbPlacesModel+typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length];
											//	text1.innerHTML = " "+selectedModelNodes[nbPlacesModel+typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
											}
											
											//typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length;
											//+selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
										}
										catch(e1){
											
										}
									
									}*/
								}
								else{
									text1.style.top =  (text1PreviousPos.y+contYPos +halfvis)+ 'px';								
									text1.style.left = text1PreviousPos.x -(text1.firstChild.length*8)-18+ 'px';
								}
							}
							
							//try{
							//cssObject.element.children[1].textContent=""+jsonObj1[typesMap[listretPointsTypes[myr]][closest]][2];
							//	cssObject.element.children[2].textContent=particleClass[listretPointsTypes[myr]];
								hoveredType=listretPointsTypes[myr];
								//}
							//catch(err){
							//}
					}
					else{
						sprite.position.set(-10000,-10000,-50000);
						//if (text1.style.top == (2000 + 'px')){
						//else{
						//	text1.style.top = 2000 + 'px';
						//	text1.style.left = 2000 + 'px';
						//}
						//text1.style.top = 2000 + 'px';
						//text1.style.left = 2000 + 'px';
						
						isOnParticle=0;		
						if (isOnLine==0 && noKeggCube){
						
						textk.style.top = 2000 + 'px';
						textk.style.left = 2000 + 'px';
						//cssObject.element.children[1].textContent="";
						//cssObject.element.children[2].textContent="";
						hoveredType=-1
						}
					}
					
					
					// mouse hover detect line
					//if (scene.children[i] instanceof THREE.Line && i==7){
					//		var a1 = scene.children[i].geometry.attributes.position.array;
					//		var a2 = scene.children[i].geometry.attributes.ca.array;
					//		var interSegment = new THREE.Vector3();
					//		var interRay = new THREE.Vector3();
							
					//		for(var j=0, jj= segmentPts;j<jj;j+=2){
					//			point1.x = (a1[j*3]); point1.y = (a1[(j*3)+1]); point1.z = (a1[(j*3)+2]);
					//			point2.x = (a1[(j+1)*3]); point2.y = (a1[((j+1)*3)+1]); point2.z = (a1[((j+1)*3)+2]);
					//			distance = myray.distanceSqToSegment( point1, point2, interRay, interSegment );
					//			if ( distance <=4 ) {
					//				listretPointsIndexesL.push(j);
					//				listretPointsDistancesL.push(distance);	
					//			}
					//		}
					//		var h1 = listretPointsDistancesL.length;
					//		var myr;
					//		var mymin = Math.min.apply(Math, listretPointsDistancesL);
					//		var v1=0;
					//		while(h1--){
					//			if (listretPointsDistancesL[h1]==mymin){
					//				myr=h1;
					//			}
					//			if (myr==h1)
					//				break;
									
					//			}						
					//		closestLine = listretPointsIndexesL[myr];
					//		if (closestLine>=0){
					//			isOnLine=1;
					//			if (isOnParticle==0){
					//				cssObject.element.children[1].textContent=""+closestLine;//.element.symbol.textContent=closest;
					//				cssObject.element.children[2].textContent="Line";
									
								// set position of outline mesh
					//			outlineMesh1.geometry.vertices[0].x=a1[closestLine*3]; outlineMesh1.geometry.vertices[0].y=a1[closestLine*3+1]; outlineMesh1.geometry.vertices[0].z=a1[closestLine*3+2];
					//			outlineMesh1.geometry.vertices[1].x=a1[(closestLine+1)*3]; outlineMesh1.geometry.vertices[1].y=a1[(closestLine+1)*3+1]; outlineMesh1.geometry.vertices[1].z=a1[(closestLine+1)*3+2];
					//			lineGeometry.verticesNeedUpdate = true;
					//			hoveredType=7;
					//			}
								//
					//		}
					//		else{//sprite.position.set(-10000,-10000,10000);	
					//			//cssObject.element.children[1].textContent="e";
					//			outlineMesh1.geometry.vertices[0].x=-10000; outlineMesh1.geometry.vertices[0].y=-10000; outlineMesh1.geometry.vertices[0].z=-50000;
					//			outlineMesh1.geometry.vertices[1].x=-10000; outlineMesh1.geometry.vertices[1].y=-10000; outlineMesh1.geometry.vertices[1].z=-51000;
					//			lineGeometry.verticesNeedUpdate = true;isOnLine=0;
					//		}
							
							
					//}
				}
				if (isOnParticle==0 ){
					text1.style.top = 2000 + 'px';
					text1.style.left = 2000 + 'px';
					//pip.style.top = 2000 + 'px';
					//pip.style.left = 2000 + 'px';
				}
				//else{
				//pip.style.top = 50 + 'px';
				//	pip.style.left = 25 + 'px';
				//}
				var intersects = raycaster.intersectObjects( scene.children );
				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].object ) {

						//if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
						if (INTERSECTED instanceof THREE.Mesh ){
							
							//
							if (INTERSECTED.name.charAt(0)=="k"){
								noKeggCube=false;
								INTERSECTED.material.color.setHex( 0xffdd33 );
								var pp = toXYCoords(INTERSECTED.position);
								if (textkPreviousPos != pp){
									//console.log(closest)
									//console.log(listretPointsTypes[myr])
									// display 2d text in html in screen 2s coordinate corresponding to near the 3d position... 
									//camera.updateMatrixWorld() ;
									//text1.firstChild.value=""+jsonObj1[typesMap[listretPointsTypes[myr]][closest]][2];
									textk.innerHTML = ""+keggCubesProperties[INTERSECTED.name][0]+"  - value:" + keggCubesProperties[INTERSECTED.name][1];		
									textk.style.top = pp.y +contYPos+ 'px';								
									textk.style.left = (pp.x -(text1.firstChild.length*8))+20+ 'px';
									textkPreviousPos = pp;
									
									
								}
								//console.log(keggCubesProperties[INTERSECTED.name])
							}
							else if(INTERSECTED.name=="skybox"){
								noKeggCube=true;
								INTERSECTED = null;
								container.style.cursor = 'auto';
								
								
								
								for ( var k = 0; k < previousKeggLength; k ++ ) {
									cubesGeometry[k].material.color.setHex( 0xff0000 );
								}
								
							}
							else{container.style.cursor = 'auto';
							noKeggCube=true;
							for ( var k = 0; k < previousKeggLength; k ++ ) {
								cubesGeometry[k].material.color.setHex( 0xff0000 );
							}
							}
						
						}
						//INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						//

					}

				} else {

					//if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
					noKeggCube=true;
					INTERSECTED = null;
					container.style.cursor = 'auto';
					
					

				}
				
				flagPick=0;
				
				
			}
			else
				flagPick++;
			}	
			
			
			var t = clock.getElapsedTime();
			
			if( simulationIsOn==true && simulationIsPaused==false){
				
				//console.log(simData[1][simTimer])
				
				
				// refactor simTimer to Object.keys(simDataTime)
				//var limTimer=0;
				//if (simModeValue==0){
				//	limTimer=simData[1].length
				//}
				//if (simModeValue==1){
				var	limTimer=Object.keys(simDataTime).length
				//}
				
				if (simData && simTimer<limTimer){
					//console.log(simTimer)
					//console.log(simTimer);
					
					scene.children[7].geometry.attributes.op.needsUpdate = true;
				
					//if (simTimerPrevious!=simTimer){
					//	console.log("new timer:"+simTimerPrevious +" becomes "+simTimer)
						//for(var v=0;v<nbModelReactionLocators;v++){
						//	modelProductLocators[v].position.set(50000,50000,-50000);
						//	modelReactantLocators[v].position.set(50000,50000,-50000);
						//	modelModifierLocators[v].position.set(50000,50000,-50000);
						//}
					//	simTimerPrevious=simTimer;
					//}
					// change display of timer property
					//console.log(simDataTime[Object.keys(simDataTime)[simTimer]][0]);
					if (simModeValue==0){
						for (var i=segmentPts;i<b2lopacity.length;i++){
							if (b2lopacity[i]>0.0){
							b2lopacity[i]=0.2;
							}
						}
						for (var i=0;i<10;i++){
							planeMesh[i].material.blending=THREE.AdditiveBlending;
						}
						for (var i=0;i<tokenAttributes.size.value.length;i++){
							tokenAttributes.size.value[i]=30;
						}
						timerElement.innerHTML=""+simDataTime[Object.keys(simDataTime)[simTimer]][0][1];
						sliderElement.value=simTimer;
						simRow=[simData[1][simTimer]];
						var ln1 = startModelPlaces;
						var ln2 = startModelReactions;
						var cnt1=0;
						var cnt2 = 0;
						var min;
						var max; 
						for(var j=3;j<simData[1][simTimer].length-1;j++){
							min = simDataBounds[j-3][0];
							max = simDataBounds[j-3][1];
							var size=30;
							if ((max-min)!=0){
								size = 30+(50*(simData[1][simTimer][j]-min)/(max-min))
								if (size>80){
									size = 80;
									//console.log("biiig "+ simData[1][simTimer][j])
									}
								if (isNaN(size)){
									size=30;
									//console.log("NaN "+simData[1][simTimer][j] + " "+min+" "+max );
								}
								//console.log(size);
								for(var j1=0;j1<selectedModelNodes.length;j1++){
									if (selectedModelNodes[j1][1]==simData[0][j]){
									
										
										
										//console.log(simData[0][j]);
										if (selectedModelNodes[j1][5]==2 ){
											scene.children[2].geometry.attributes.size.array[(ln1+cnt1)]= size;
											//console.log("node place index"+(ln1+cnt1))
											//bgeometryP3.attributes.size.array[(ln1+cnt1)]= size;
											//console.log("resize place"+(cnt1))
											cnt1++;
										}
										if (selectedModelNodes[j1][5]==4 ){
											scene.children[4].geometry.attributes.size.array[(ln2+cnt2)]= size;
											//console.log("node reaction index"+(ln2+cnt2))
											//bgeometryP5.attributes.size.array[(ln2+cnt2)]= size;
											//console.log("resize reaction"+size)
											cnt2++;
										}
										
									}
								}
							}
							//console.log(window.innerWidth*0.6)
							//console.log(simFlowChart)
							var indexChart=simFlowChart-1+3;
							//console.log(simData[0][indexChart+3]);
							if (j==indexChart){
								if (simTimer==0){
									var iv=0;
									for ( var i = 0; i < chartSegment; i ++ ) {
										chartPositions[ (iv * 3)+0 ] = 50400;
										chartPositions[ (iv * 3) + 1 ] = 0;
										chartPositions[ (iv * 3) + 2 ] = -50400;
										//chartColors[ iv * 3 ] = col.r;
										//chartColors[ iv * 3 + 1 ] = col.g;
										//chartColors[ iv * 3 + 2 ] = col.b;
										iv++;
										chartPositions[ (iv * 3)+0 ] = 50400;
										chartPositions[ (iv * 3) + 1 ] = 0;
										chartPositions[ (iv * 3) + 2 ] = -50400;
										//chartColors[ iv * 3 ] = col.r;
										//chartColors[ iv * 3 + 1 ] = col.g;
										//chartColors[ iv * 3 + 2 ] = col.b;
										iv++
									}
									if (max==min){
										chartPositions[ ((simTimer*2) * 3)+0 ] = -(window.innerWidth*0.11)+((simTimer)*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(0);
										chartPositions[ ((simTimer*2+1) * 3)+0 ] = -(window.innerWidth*0.11)+(simTimer*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2+1) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2+1) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(0);
									}
									else{
										chartPositions[ ((simTimer*2) * 3)+0 ] = -(window.innerWidth*0.11)+((simTimer)*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(((simData[1][simTimer][indexChart]-min)/(max-min))*(-(window.innerHeight*0.15*0.9)));
										chartPositions[ ((simTimer*2+1) * 3)+0 ] = -(window.innerWidth*0.11)+(simTimer*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2+1) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2+1) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(((simData[1][simTimer][indexChart]-min)/(max-min))*(-(window.innerHeight*0.15*0.9)));
									}
									//console.log("value:" +simData[1][simTimer][j] + " min: " + min + " max: " + max)
									}
								else {
								//if ((((simData[1][simTimer-1][5]-min)/(max-min))*-30) != (((simData[1][simTimer][5]-min)/(max-min))*-30) && (simTimer%2==0)){
									if (max==min){
										chartPositions[ ((simTimer*2) * 3)+0 ] = -(window.innerWidth*0.11)+((simTimer-1)*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(0);
										chartPositions[ ((simTimer*2+1) * 3)+0 ] = -(window.innerWidth*0.11)+(simTimer*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2+1) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2+1) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(0);
									}
									else{
										chartPositions[ ((simTimer*2) * 3)+0 ] = -(window.innerWidth*0.11)+((simTimer-1)*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(((simData[1][simTimer-1][indexChart]-min)/(max-min))*(-(window.innerHeight*0.15*0.9)));
										chartPositions[ ((simTimer*2+1) * 3)+0 ] = -(window.innerWidth*0.11)+(simTimer*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2+1) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2+1) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(((simData[1][simTimer][indexChart]-min)/(max-min))*(-(window.innerHeight*0.15*0.9)));
									}
									//console.log("value:" +simData[1][simTimer][j] + " min: " + min + " max: " + max + " coord2:"+ simData[1][simTimer][indexChart])
									//console.log("value:"+simData[1][simTimer][indexChart]+ " normalised value: "+((simData[1][simTimer][indexChart]-min)/(max-min))+ " scale modifier"+(-(window.innerHeight*0.075)));
								//	}
								}
								geometryLineChart.attributes.position.needsUpdate = true;
							}
							
							
							// display linechart in function of timer
							
							//for ( var i = 0; i < chartSegment; i ++ ) {
							
							
							//chartPositions[ ((simTimer*2+1) * 3)+0 ] = 50000;
							//chartPositions[ ((simTimer*2+1) * 3) + 1 ] = 180;
							//chartPositions[ ((simTimer*2+1) * 3) + 2 ] = -500+(((simData[1][simTimer][5]-min)/(max-min))*-30);
							
							//chartPositions[ ((simTimer+1) * 3)+0 ] = 400+simTimer;
							//chartPositions[ ((simTimer+1) * 3) + 1 ] = 180;
							//chartPositions[ ((simTimer+1) * 3) + 2 ] = -500+(((simData[1][simTimer][5]-min)/(max-min))*-30);
							
							//for ( var i = simTimer+1; i < chartSegment*2; i ++ ) {
							//	chartPositions[ (i * 3)+0 ] = 400+simTimer;
							//	chartPositions[ (i * 3) + 1 ] = 180;
							//	chartPositions[ (i * 3) + 2 ] = -500+(((simData[1][simTimer][5]-min)/(max-min))*-30);
							//}//
								//iv++;
								//chartPositions[ (iv * 3)+0 ] = 400+simTimer+1;
								//chartPositions[ (iv * 3) + 1 ] = 0;
								//chartPositions[ (iv * 3) + 2 ] = (simData[1][simTimer+1][j]-min)/(max-min)*-400;
								
								//iv++
							//}
							//chartPositions.needsUpdate = true;
							
							//buffer_geometry.attributes.position.array;
						}
						scene.children[2].geometry.attributes.size.needsUpdate = true;
						scene.children[4].geometry.attributes.size.needsUpdate = true;
						
						//console.log();
						//var nbTokens=Object.keys(startPositionTokenMap).length;
						var triggerOnceReaction=true;
						for (var tk= 0; tk<selectedModelEdges.length;tk++){
							//console.log("aaa");
							
							// if link between model reaction and model place, create token
							if (selectedModelEdges[tk][3]==1){
								// add different possiblities from the simDataTime[Object.keys(simDataTime)[simTimer]][0][1];
								//if (selectedModelNodes[selectedModelEdges[tk][0]][1]==simData[1][simTimer][2]){
								for (var rw=0;rw<simRow.length;rw++){
									if (selectedModelNodes[selectedModelEdges[tk][0]][1]==simRow[rw][2]){
										
										//if (simRow.length>1){console.log(simRow[rw][2])}
										//if (allFalse){
										var nb;
										if (clearedTokenIndex.length>0){
											nb=clearedTokenIndex.pop();	
											stackTokenModel[nb]=[0,nb,selectedModelEdges[tk][0],selectedModelEdges[tk][1],1,true,selectedModelEdges[tk][2]];	
											//tokenAttributes.size.value[nb]=30;
											
										}
										else{
											nb=stackTokenModel.length;		
											stackTokenModel.push([0,nb,selectedModelEdges[tk][0],selectedModelEdges[tk][1],1,true,selectedModelEdges[tk][2]]);	
											//tokenAttributes.size.value[nb]=30;
										}
										// stackTokenModel element: mixamount value, id of token, pt1 model node id, pt2 model node id, type of link (1= model/model or 2 =model/sim) 
										//console.log(stackTokenModel.length)
										tokenStackCount+=1;
										tokenAttributes.mixAmount.value[nb]=0;
										//planeMesh[nb].position.set(0,0,0);
										//if(selectedModelEdges[tk][2]==0 || selectedModelEdges[tk][2]==2){
										if(selectedModelEdges[tk][2]==1 ){
											//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])]=1.0;
											//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])+1]=1.0;
											
											scene.children[8].geometry.vertices[nb].x=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) ]+0;
											scene.children[8].geometry.vertices[nb].y=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 1 ]+0;
											scene.children[8].geometry.vertices[nb].z=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 2 ]+0;
											tokenAttributes.endPosition.value[nb].x=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) ]+0;
											tokenAttributes.endPosition.value[nb].y=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 1 ]+0;
											tokenAttributes.endPosition.value[nb].z=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 2 ]+0;
											// change color
											tokenAttributes.ca.value[nb]= new THREE.Color( 0xff0000 );
											
											/*var x1= (scene.children[8].geometry.vertices[nb].x+tokenAttributes.endPosition.value[nb].x)/2;											
											var y1 = (scene.children[8].geometry.vertices[nb].y+tokenAttributes.endPosition.value[nb].y)/2;
											var z1 = (scene.children[8].geometry.vertices[nb].z+tokenAttributes.endPosition.value[nb].z)/2;
											
											var isInFlowsStack =false;
											for (var fs=0;fs<flowsStack.length;fs++){
												if (flowsStack[fs]){
													if ((flowsStack[fs][0]==x1) && (flowsStack[fs][1]==y1) && (flowsStack[fs][2]==z1) ){
														isInFlowsStack=true;
													}
												}
											}
											//console.log(isInFlowsStack)
											if (!isInFlowsStack){
												flowsStack.push([x1,y1,z1]);
												planeMesh[flowsStack.length-1].position.set(0,0,0);
												planeMesh[flowsStack.length-1].geometry.vertices[0].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[0].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[0].z=scene.children[8].geometry.vertices[nb].z-1;
												planeMesh[flowsStack.length-1].geometry.vertices[2].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[2].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[2].z=scene.children[8].geometry.vertices[nb].z+1;
												planeMesh[flowsStack.length-1].geometry.vertices[1].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[1].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[1].z=tokenAttributes.endPosition.value[nb].z-1;
												planeMesh[flowsStack.length-1].geometry.vertices[3].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[3].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[3].z=tokenAttributes.endPosition.value[nb].z+1;
												
												//planeMesh[flowsStack.length-1].scale.z=size/30;
												planeMesh[flowsStack.length-1].geometry.verticesNeedUpdate=true;
											}
											*/
											
											
											//console.log(planeMesh[0].geometry);
											
											//planeMesh[0].position.x=scene.children[8].geometry.vertices[nb].x;
											//planeMesh[0].position.y=scene.children[8].geometry.vertices[nb].y;
											//planeMesh[0].position.z=scene.children[8].geometry.vertices[nb].z;
											//planeMesh[0].geometry.__dirtyVertices = true; 
											//planeMesh[0].geometry.computeCentroids();
											//planeMesh[nb].geometry.verticesNeedUpdate=true;
										}
										// if preplace to reaction
										if(selectedModelEdges[tk][2]!=1 ){
											//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-2]=1.0;
											//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-1]=1.0;
											//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-4]=1.0;
											//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-3]=1.0;
											scene.children[8].geometry.vertices[nb].x=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) ]+0;
											scene.children[8].geometry.vertices[nb].y=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 1 ]+0;
											scene.children[8].geometry.vertices[nb].z=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 2 ]+0;
											tokenAttributes.endPosition.value[nb].x=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) ]+0;
											tokenAttributes.endPosition.value[nb].y=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 1 ]+0;
											tokenAttributes.endPosition.value[nb].z=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 2 ]+0;
											// change color
											tokenAttributes.ca.value[nb]= new THREE.Color( 0x0000ff );
											/*
											var x1= (scene.children[8].geometry.vertices[nb].x+tokenAttributes.endPosition.value[nb].x)/2;											
											var y1 = (scene.children[8].geometry.vertices[nb].y+tokenAttributes.endPosition.value[nb].y)/2;
											var z1 = (scene.children[8].geometry.vertices[nb].z+tokenAttributes.endPosition.value[nb].z)/2;
											
											var isInFlowsStack =false;
											for (var fs=0;fs<flowsStack.length;fs++){
												if (flowsStack[fs]){
													if ((flowsStack[fs][0]==x1) && (flowsStack[fs][1]==y1) && (flowsStack[fs][2]==z1) ){
														isInFlowsStack=true;
													}
												}
											}
											if (!isInFlowsStack){
												flowsStack.push([x1,y1,z1]);
												planeMesh[flowsStack.length-1].position.set(0,0,0);
												planeMesh[flowsStack.length-1].geometry.vertices[0].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[0].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[0].z=scene.children[8].geometry.vertices[nb].z-1;
												planeMesh[flowsStack.length-1].geometry.vertices[2].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[2].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[2].z=scene.children[8].geometry.vertices[nb].z+1;
												planeMesh[flowsStack.length-1].geometry.vertices[1].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[1].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[1].z=tokenAttributes.endPosition.value[nb].z-1;
												planeMesh[flowsStack.length-1].geometry.vertices[3].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[3].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[3].z=tokenAttributes.endPosition.value[nb].z+1;
												
												//planeMesh[flowsStack.length-1].scale.z=size/30;
												planeMesh[flowsStack.length-1].geometry.verticesNeedUpdate=true;
											}*/
											
											
											
										}
										
										var x1= (scene.children[8].geometry.vertices[nb].x+tokenAttributes.endPosition.value[nb].x)/2;											
										var y1 = (scene.children[8].geometry.vertices[nb].y+tokenAttributes.endPosition.value[nb].y)/2;
										var z1 = (scene.children[8].geometry.vertices[nb].z+tokenAttributes.endPosition.value[nb].z)/2;
										
										var isInFlowsStack =false;
										var indexCnt=-1;
										for (var fs=0;fs<flowsStack.length;fs++){
											if (flowsStack[fs]){
												if ((flowsStack[fs][0]==x1) && (flowsStack[fs][1]==y1) && (flowsStack[fs][2]==z1) ){
													isInFlowsStack=true;
													indexCnt=fs;
												}
											}
										}
										if (!isInFlowsStack){
											flowsStack.push([x1,y1,z1]);
											planeMesh[flowsStack.length-1].position.set(0,0,0);
											planeMesh[flowsStack.length-1].geometry.vertices[0].x=scene.children[8].geometry.vertices[nb].x;
											planeMesh[flowsStack.length-1].geometry.vertices[0].y=scene.children[8].geometry.vertices[nb].y;
											planeMesh[flowsStack.length-1].geometry.vertices[0].z=scene.children[8].geometry.vertices[nb].z-1;
											planeMesh[flowsStack.length-1].geometry.vertices[2].x=scene.children[8].geometry.vertices[nb].x;
											planeMesh[flowsStack.length-1].geometry.vertices[2].y=scene.children[8].geometry.vertices[nb].y;
											planeMesh[flowsStack.length-1].geometry.vertices[2].z=scene.children[8].geometry.vertices[nb].z+1;
											planeMesh[flowsStack.length-1].geometry.vertices[1].x=tokenAttributes.endPosition.value[nb].x;
											planeMesh[flowsStack.length-1].geometry.vertices[1].y=tokenAttributes.endPosition.value[nb].y;
											planeMesh[flowsStack.length-1].geometry.vertices[1].z=tokenAttributes.endPosition.value[nb].z-1;
											planeMesh[flowsStack.length-1].geometry.vertices[3].x=tokenAttributes.endPosition.value[nb].x;
											planeMesh[flowsStack.length-1].geometry.vertices[3].y=tokenAttributes.endPosition.value[nb].y;
											planeMesh[flowsStack.length-1].geometry.vertices[3].z=tokenAttributes.endPosition.value[nb].z+1;
											stackModel2PlaneMesh[nb]=flowsStack.length-1;
											//planeMesh[flowsStack.length-1].scale.z=size/30;
											planeMesh[flowsStack.length-1].geometry.verticesNeedUpdate=true;
										}
										else{
										if (simData[1][simTimer][j]<0){
											if(Math.abs(planeMesh[indexCnt].geometry.vertices[0].z-planeMesh[indexCnt].geometry.vertices[2].z)<20){
												planeMesh[indexCnt].geometry.vertices[0].z+=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
												planeMesh[indexCnt].geometry.vertices[2].z-=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
												planeMesh[indexCnt].geometry.vertices[1].z+=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
												planeMesh[indexCnt].geometry.vertices[3].z-=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
											}
										}
										else{
											if(Math.abs(planeMesh[indexCnt].geometry.vertices[0].z-planeMesh[indexCnt].geometry.vertices[2].z)<20){
												planeMesh[indexCnt].geometry.vertices[0].z-=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
												planeMesh[indexCnt].geometry.vertices[2].z+=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
												planeMesh[indexCnt].geometry.vertices[1].z-=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
												planeMesh[indexCnt].geometry.vertices[3].z+=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
												//console.log(Math.abs(planeMesh[indexCnt].geometry.vertices[0].z-planeMesh[indexCnt].geometry.vertices[2].z))
											}
										}
											planeMesh[indexCnt].geometry.verticesNeedUpdate=true;
										}
										// if preplace to reaction
										//if(selectedModelEdges[tk][2]==1){
										//	scene.children[8].geometry.vertices[nb].x=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) ]+0;
										//	scene.children[8].geometry.vertices[nb].y=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 1 ]+0;
										//	scene.children[8].geometry.vertices[nb].z=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 2 ]+0;
										//	tokenAttributes.endPosition.value[nb].x=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) ]+0;
										//	tokenAttributes.endPosition.value[nb].y=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 1 ]+0;
										//	tokenAttributes.endPosition.value[nb].z=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 2 ]+0;
										//}
										tokenAttributes.size.value[nb] = 30.0;
										//}
										if (tokenIDStackCount.hasOwnProperty(simRow[rw][2]) && triggerOnceReaction==true) {
												tokenIDStackCount[simRow[rw][2]][0]+=1;
												//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
												//modelReactionLocators[rw].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
												triggerOnceReaction=false;
												//console.log(tokenIDStackCount);
										}
										else{
											if( triggerOnceReaction==true){
												if(selectedModelEdges[tk][2]!=1){
													tokenIDStackCount[simRow[rw][2]]=[1,tokenAttributes.endPosition.value[nb].x,tokenAttributes.endPosition.value[nb].y,tokenAttributes.endPosition.value[nb].z];
													
												}
												if(selectedModelEdges[tk][2]==1){
													tokenIDStackCount[simRow[rw][2]]=[1,scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z];
													
												}
											//tokenIDStackCount[simRow[rw][2]]=[1,scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z];
											//modelReactionLocators[rw].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
											triggerOnceReaction=false;
											//console.log(tokenIDStackCount);
											//var vectorp = new THREE.Vector3( scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
											//vectorp.x +=10;
											//var ppv = toXYCoords(vectorp	);
											//txtReactionActivation[cntLabels].style.top = ppv.y + 'px';
											//txtReactionActivation[cntLabels].style.left = ppv.x + 'px';
											//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
											}
											
										}
										//cntLabels++;
									}
									
								}
							}
							
						}
						//console.log(flowsStack.length);
						//for (var f = 0;f<planeMesh.length;f++){
						//planeMesh[f].geometry.verticesNeedUpdate= true;
						//}
						scene.children[7].geometry.attributes.op.needsUpdate = true;
						tokenAttributes.mixAmount.needsUpdate = true;
						tokenAttributes.ca.needsUpdate = true;
						scene.children[8].geometry.verticesNeedUpdate = true;
						tokenAttributes.endPosition.needsUpdate = true;
						tokenAttributes.size.needsUpdate = true;
						simTimer++;
						//reactionIsDone=false;
					}
					if (simModeValue==1){
						//console.log(simTimer);
						//console.log(tokenAttributes.size.value.length)
						timerElement.innerHTML=""+simDataTime[Object.keys(simDataTime)[simTimer]][0][1];
						
						sliderElement.value=simTimer;
						simRow=simDataTime[Object.keys(simDataTime)[simTimer]];
						
						for (var i=segmentPts;i<b2lopacity.length;i++){
							if (b2lopacity[i]>0.0){
							b2lopacity[i]=0.2;
							}
						}
						
						for (var i=0, j=tokenAttributes.size.value.length ;i<j;i++){
							tokenAttributes.size.value[i]=80;
						}
						tokenAttributes.size.needsUpdate = true;
						
						var ln1 = startModelPlaces;
						var ln2 = startModelReactions;
						var cnt1=0;
						var cnt2 = 0;
						/*for(var j=3;j<simData[1][simTimer].length-1;j++){
							var min = simDataBounds[j-3][0];
							var max = simDataBounds[j-3][1];
							var size=30;
							if ((max-min)!=0){
								size = 30+(50*(simData[1][simTimer][j]-min)/(max-min))
								if (size>80){
									size = 80;
									//console.log("biiig "+ simData[1][simTimer][j])
									}
								if (isNaN(size)){
									size=30;
									//console.log("NaN "+simData[1][simTimer][j] + " "+min+" "+max );
								}
								//console.log(size);
								for(var j1=0;j1<selectedModelNodes.length;j1++){
									if (selectedModelNodes[j1][1]==simData[0][j]){
										//console.log(simData[0][j]);
										if (selectedModelNodes[j1][5]==2 ){
											scene.children[2].geometry.attributes.size.array[(ln1+cnt1)]= size;
											//bgeometryP3.attributes.size.array[(ln1+cnt1)]= size;
											//console.log("resize place"+(cnt1))
											cnt1++;
										}
										if (selectedModelNodes[j1][5]==4 ){
											scene.children[4].geometry.attributes.size.array[(ln2+cnt2)]= size;
											//bgeometryP5.attributes.size.array[(ln2+cnt2)]= size;
											//console.log("resize reaction"+size)
											cnt2++;
										}
									}
								}
							}
							//console.log(simData[0][j])
						}
						scene.children[2].geometry.attributes.size.needsUpdate = true;
						scene.children[4].geometry.attributes.size.needsUpdate = true;
						*/
						//console.log();
						//var nbTokens=Object.keys(startPositionTokenMap).length;
						var triggerOnceReaction=true;
						var namePresentReaction="";
						var counterReactionLinks=0;
						
							//modelProductLocators[v].position.set(50000,50000,-50000);
							//console.log(modelProductLocators[v])
						//}
						for (var tk= 0; tk<selectedModelEdges.length;tk++){
							//console.log("aaa");
							
							// if link between model reaction and model place, create token
							if (selectedModelEdges[tk][3]==1){
								// add different possiblities from the simDataTime[Object.keys(simDataTime)[simTimer]][0][1];
								//if (selectedModelNodes[selectedModelEdges[tk][0]][1]==simData[1][simTimer][2]){
								for (var rw=0;rw<simRow.length;rw++){
									if (selectedModelNodes[selectedModelEdges[tk][0]][1]==simRow[rw][2]){
										
										//if (simRow.length>1){console.log(simRow[rw-1][2]+"  "+simRow[rw][2])}
										if (allFalse){
											//console.log("allFalse is true")
											if (namePresentReaction!=simRow[rw][2]){
												namePresentReaction=simRow[rw][2];
												counterReactionLinks=1;
											}
											else{
												counterReactionLinks++;
											}
											
											var nb;
											if (clearedTokenIndex.length>0){
												nb=clearedTokenIndex.pop();	
												stackTokenModel[nb]=[0,nb,selectedModelEdges[tk][0],selectedModelEdges[tk][1],1,true,selectedModelEdges[tk][2],counterReactionLinks-1];		
												//tokenAttributes.size.value[nb]=0;
						
												//tokenStackCount-=1;								
											}
											else{
												nb=stackTokenModel.length;		
												stackTokenModel.push([0,nb,selectedModelEdges[tk][0],selectedModelEdges[tk][1],1,true,selectedModelEdges[tk][2],counterReactionLinks-1]);	
												//tokenAttributes.size.value[nb]=0;
											}
											// stackTokenModel element: mixamount value, id of token, pt1 model node id, pt2 model node id, type of link (1= model/model or 2 =model/sim) 
											//console.log(stackTokenModel.length)
											tokenStackCount+=1;
											tokenAttributes.mixAmount.value[nb]=0;
											// if reaction to post-place orient token
											if(counterReactionLinks-1==0){
												for (var ct=0;ct<10;ct++){
													planeMesh[ct].position.set(0,0,-150000);
												}
												for(var v=0;v<nbModelReactionLocators;v++){
													modelReactantLocators[v].position.set(50000,50000,-150000);
													modelModifierLocators[v].position.set(50000,50000,-150000);
												}
											}
											
											if(selectedModelEdges[tk][2]==1){
											
												//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])]=1.0;
												//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])+1]=1.0;
												
												
												
						
												scene.children[8].geometry.vertices[nb].x=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) ]+0;
												scene.children[8].geometry.vertices[nb].y=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 1 ]+0;
												scene.children[8].geometry.vertices[nb].z=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 2 ]+0;
												tokenAttributes.endPosition.value[nb].x=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) ]+0;
												tokenAttributes.endPosition.value[nb].y=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 1 ]+0;
												tokenAttributes.endPosition.value[nb].z=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 2 ]+0;
												modelProductLocators[counterReactionLinks-1].position.set(tokenAttributes.endPosition.value[nb].x,tokenAttributes.endPosition.value[nb].y,tokenAttributes.endPosition.value[nb].z);
												// change color
												tokenAttributes.ca.value[nb]= new THREE.Color( 0xff0000 );
												
					
												planeMesh[counterReactionLinks-1].position.set(0,0,0);
												planeMesh[counterReactionLinks-1].geometry.vertices[0].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[0].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[0].z=scene.children[8].geometry.vertices[nb].z-5;
												planeMesh[counterReactionLinks-1].geometry.vertices[2].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[2].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[2].z=scene.children[8].geometry.vertices[nb].z+5;
												planeMesh[counterReactionLinks-1].geometry.vertices[1].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[1].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[1].z=tokenAttributes.endPosition.value[nb].z-5;
												planeMesh[counterReactionLinks-1].geometry.vertices[3].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[3].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[3].z=tokenAttributes.endPosition.value[nb].z+5;
												planeMesh[counterReactionLinks-1].geometry.verticesNeedUpdate=true;
												//planeMesh[counterReactionLinks-1].material.transparent = true;
												//planeMesh[counterReactionLinks-1].material.opacity = 0.6;
												planeMesh[counterReactionLinks-1].material.blending=false;
											
												//console.log(tokenAttributes.ca.value[nb])
												//modelReactantLocators[counterReactionLinks-1].position.set(50000,50000,-50000);
												//modelModifierLocators[counterReactionLinks-1].position.set(50000,50000,-50000);
											}
											// if preplace to reaction
											if(selectedModelEdges[tk][2]!=1){
												//console.log(selectedModelEdges[tk][0]);
												//console.log(selectedModelEdges[tk][1]);
												//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-1]=1.0;
												//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-2]=1.0;
												//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-3]=1.0;
												//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-4]=1.0;
												scene.children[8].geometry.vertices[nb].x=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) ]+0;
												scene.children[8].geometry.vertices[nb].y=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 1 ]+0;
												scene.children[8].geometry.vertices[nb].z=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 2 ]+0;
												tokenAttributes.endPosition.value[nb].x=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) ]+0;
												tokenAttributes.endPosition.value[nb].y=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 1 ]+0;
												tokenAttributes.endPosition.value[nb].z=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 2 ]+0;
												// change color
												tokenAttributes.ca.value[nb]= new THREE.Color( 0x0000ff );
												
												planeMesh[counterReactionLinks-1].position.set(0,0,0);
												planeMesh[counterReactionLinks-1].geometry.vertices[0].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[0].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[0].z=scene.children[8].geometry.vertices[nb].z-5;
												planeMesh[counterReactionLinks-1].geometry.vertices[2].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[2].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[2].z=scene.children[8].geometry.vertices[nb].z+5;
												planeMesh[counterReactionLinks-1].geometry.vertices[1].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[1].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[1].z=tokenAttributes.endPosition.value[nb].z-5;
												planeMesh[counterReactionLinks-1].geometry.vertices[3].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[3].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[3].z=tokenAttributes.endPosition.value[nb].z+5;
												planeMesh[counterReactionLinks-1].geometry.verticesNeedUpdate=true;
												//planeMesh[counterReactionLinks-1].material.transparent = true;
												//planeMesh[counterReactionLinks-1].material.opacity = 0.6;
												planeMesh[counterReactionLinks-1].material.blending=false;
												
												if (selectedModelEdges[tk][2]==0){
													modelReactantLocators[counterReactionLinks-1].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z+10);
													//modelModifierLocators[counterReactionLinks-1].position.set(50000,50000,-50000);
													//modelProductLocators[counterReactionLinks-1].position.set(50000,50000,-50000);
												}
												if (selectedModelEdges[tk][2]==2){
													modelModifierLocators[counterReactionLinks-1].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
													//modelReactantLocators[counterReactionLinks-1].position.set(50000,50000,-50000);
													//modelProductLocators[counterReactionLinks-1].position.set(50000,50000,-50000);
												}
												
												
												
											}
											
											
											tokenAttributes.size.value[nb] = 30.0;
											// if consumed pre-place
											//if (selectedModelEdges[tk][2]==0){
														
											//	}
											// if non-consumed pre-place
											//if (selectedModelEdges[tk][2]==2){
														
											//	}
											// if postplace
											//if (selectedModelEdges[tk][2]==1){
														
											//	}
											//console.log(selectedModelEdges[tk]);
											//console.log(counterReactionLinks)
											//modelProductLocators[rw].position.set(tokenAttributes.endPosition.value[nb].x,tokenAttributes.endPosition.value[nb].y,tokenAttributes.endPosition.value[nb].z);
											
											if (tokenIDStackCount.hasOwnProperty(simRow[rw][2]) && triggerOnceReaction==true ) {
													
													tokenIDStackCount[simRow[rw][2]][0]+=1;
													if(selectedModelEdges[tk][2]!=1){
														modelReactionLocators[rw].position.set(tokenAttributes.endPosition.value[nb].x,tokenAttributes.endPosition.value[nb].y,tokenAttributes.endPosition.value[nb].z);
														//modelProductLocators[rw].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
													}
													if(selectedModelEdges[tk][2]==1){
														modelReactionLocators[rw].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
														//modelProductLocators[counterReactionLinks-1].position.set(tokenAttributes.endPosition.value[nb].x,tokenAttributes.endPosition.value[nb].y,tokenAttributes.endPosition.value[nb].z);
														
													}
													
													
													
													
													//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
													triggerOnceReaction=false;
													
											}
											else{
												
												if( triggerOnceReaction==true){
												
												//modelReactionLocators[rw].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
												if(selectedModelEdges[tk][2]!=1){
														tokenIDStackCount[simRow[rw][2]]=[1,tokenAttributes.endPosition.value[nb].x,tokenAttributes.endPosition.value[nb].y,tokenAttributes.endPosition.value[nb].z];
														modelReactionLocators[rw].position.set(tokenAttributes.endPosition.value[nb].x,tokenAttributes.endPosition.value[nb].y,tokenAttributes.endPosition.value[nb].z);
														//console.log(tokenIDStackCount[simRow[rw][2]])
													}
												if(selectedModelEdges[tk][2]==1){
														tokenIDStackCount[simRow[rw][2]]=[1,scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z];
														modelReactionLocators[rw].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
														//console.log(tokenIDStackCount[simRow[rw][2]])
													}
												triggerOnceReaction=false;
												//console.log(selectedModelEdges[tk]);
												//console.log(selectedModelEdges[tk]);
												//console.log(tokenIDStackCount);
												//var vectorp = new THREE.Vector3( scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
												//vectorp.x +=10;
												//var ppv = toXYCoords(vectorp	);
												//txtReactionActivation[cntLabels].style.top = ppv.y + 'px';
												//txtReactionActivation[cntLabels].style.left = ppv.x + 'px';
												//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
												}
												
												//var vectorp = new THREE.Vector3( scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
												//vectorp.x +=10;
												//var ppv = toXYCoords(vectorp	);
												//txtReactionActivation[cntLabels].style.top = ppv.y + 'px';
												//txtReactionActivation[cntLabels].style.left = ppv.x + 'px';
												//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
											}
											
											//cntLabels++;
										}
									}
									
								}
							}
							
						}
						//scene.children[7].geometry.attributes.op.needsUpdate = true;
						tokenAttributes.mixAmount.needsUpdate = true;
						tokenAttributes.ca.needsUpdate = true;
						scene.children[8].geometry.verticesNeedUpdate = true;
						tokenAttributes.endPosition.needsUpdate = true;
						tokenAttributes.size.needsUpdate = true;
						if (allFalse){
							
							simTimer++;
							reactionIsDone=false;
							//console.log("allfalse true and reactiondone false")
						}
						
						
						
						
					}
					if (simModeValue==2 ){
						//console.log(selectedModelNodes)
						//timerElement.innerHTML=""+simData[1][simTimer][1];
						timerElement.innerHTML=""+simDataTime[Object.keys(simDataTime)[simTimer]][0][1];
						sliderElement.value=simTimer;
						simRow=[simData[1][simTimer]];
						var ln1 = startModelPlaces;
						var ln2 = startModelReactions;
						var cnt1=0;
						var cnt2 = 0;
						for(var j=3;j<simData[1][simTimer].length-1;j++){
							var min = simDataBounds[j-3][0];
							var max = simDataBounds[j-3][1];
							var val =simData[1][simTimer][j];
							var size=30;
							if ((max-min)!=0){
								size = 30+(50*(simData[1][simTimer][j]-min)/(max-min))
								if (size>80){
									size = 80;
									//console.log("biiig "+ simData[1][simTimer][j])
									}
								if (isNaN(size)){
									size=30;
									//console.log("NaN "+simData[1][simTimer][j] + " "+min+" "+max );
								}
								
								listChangingKeggCoordinates=[];
								//console.log(size);
								for(var j1=0;j1<selectedModelNodes.length;j1++){
									if (selectedModelNodes[j1][1]==simData[0][j]){
										//console.log(simData[0][j]);
										if (selectedModelNodes[j1][5]==2 ){
											scene.children[2].geometry.attributes.size.array[(ln1+cnt1)]= size;
											//console.log(idMap[ln1+cnt1]);
											if (selectedModelNodes[j1][7]==3){
												for (var ed= 0; ed<selectedModelEdges.length;ed++){
													if ((selectedModelEdges[ed][0]==selectedModelNodes[j1][0]) && selectedModelEdges[ed][3]==2){
														//console.log(selectedModelEdges[ed][0]+"to metabolic :"+jsonObj1[selectedModelEdges[ed][1]][1])
														if (jsonObj1[selectedModelEdges[ed][1]][4][1][2] && jsonObj1[selectedModelEdges[ed][1]][4][1][2].length>0){
															//console.log(jsonObj1[selectedModelEdges[ed][1]][4][1][2])
															//listChangingKeggCoordinates.push([jsonObj1[selectedModelEdges[ed][1]][4][1][2][0],size])
															for (var kk = 0; kk<jsonObj1[selectedModelEdges[ed][1]][4][1][2].length;kk++){
																listChangingKeggCoordinates.push([jsonObj1[selectedModelEdges[ed][1]][4][1][2][kk],size-30,jsonObj1[selectedModelEdges[ed][1]][4][1][1],val])
															}
															
														}
													}
												}
												
											}
											//bgeometryP3.attributes.size.array[(ln1+cnt1)]= size;
											//console.log("resize place"+(cnt1))
											cnt1++;
										}
										if (selectedModelNodes[j1][5]==4 ){
											scene.children[4].geometry.attributes.size.array[(ln2+cnt2)]= size;
											//console.log("node reaction index"+(ln2+cnt2))
											//bgeometryP5.attributes.size.array[(ln2+cnt2)]= size;
											//console.log("resize reaction"+size)
											cnt2++;
										}
									}
								}
								if (previousKeggLength<listChangingKeggCoordinates.length){
								previousKeggLength=listChangingKeggCoordinates.length;
								}
								//console.log(listChangingKeggCoordinates)
								//console.log(listChangingKeggCoordinates.length)
								/*
								var iv =0;
								for ( var i = 0; i < keggSegment.length; i ++ ) {
									keggPositions[ (iv * 3)+0 ] = 50000;
									keggPositions[ (iv * 3) + 1 ] = 0;
									keggPositions[ (iv * 3) + 2 ] = -50000;
									//keggColors[ iv * 3 ] = col.r;
									//keggColors[ iv * 3 + 1 ] = col.g;
									//keggColors[ iv * 3 + 2 ] = col.b;
									iv++;
									keggPositions[ (iv * 3)+0 ] = 50000;
									keggPositions[ (iv * 3) + 1 ] = 0;
									keggPositions[ (iv * 3) + 2 ] = -50000;
									//keggColors[ iv * 3 ] = col.r;
									//keggColors[ iv * 3 + 1 ] = col.g;
									//keggColors[ iv * 3 + 2 ] = col.b;
									iv++
								}
								var iv =0;
								for ( var i = 0; i < listChangingKeggCoordinates.length; i ++ ) {
									keggPositions[ (iv * 3)+0 ] = (listChangingKeggCoordinates[i][0][0]*0.69605)+3000-450;
									keggPositions[ (iv * 3) + 1 ] = 200;
									keggPositions[ (iv * 3) + 2 ] = (listChangingKeggCoordinates[i][0][1]*0.69605)-273;
									//keggColors[ iv * 3 ] = col.r;
									//keggColors[ iv * 3 + 1 ] = col.g;
									//keggColors[ iv * 3 + 2 ] = col.b;
									iv++;
									keggPositions[ (iv * 3)+0 ] = (listChangingKeggCoordinates[i][0][0]*0.69605)+3000-450;
									keggPositions[ (iv * 3) + 1 ] = 200+(listChangingKeggCoordinates[i][1]*3);
									keggPositions[ (iv * 3) + 2 ] = (listChangingKeggCoordinates[i][0][1]*0.69605)-273;
									//keggColors[ iv * 3 ] = col.r;
									//keggColors[ iv * 3 + 1 ] = col.g;
									//keggColors[ iv * 3 + 2 ] = col.b;
									iv++
								}
								
								
								keggPositions.needsUpdate = true;
								geometryKegg.attributes.position.needsUpdate = true;
								*/
								//for ( var i = listChangingKeggCoordinates.length; i < 1000; i ++ ) {
								//	cubesGeometry[i].position.x=50000;
								//	cubesGeometry[i].position.y=200;
								//	cubesGeometry[i].position.z=-50000;
								//}
								//console.log(listChangingKeggCoordinates.length)
								for ( var i = 0; i < listChangingKeggCoordinates.length; i ++ ) {
			
									//console.log(cubesGeometry[i])
									//cubesGeometry[i].position.x=(listChangingKeggCoordinates[i][0][0]*0.69605)+3000-450;
									//cubesGeometry[i].position.y=200+(listChangingKeggCoordinates[i][1]*1.5);
									//cubesGeometry[i].position.z=(listChangingKeggCoordinates[i][0][1]*0.69605)-273;
									cubesGeometry[i].position.x=3000+(listChangingKeggCoordinates[i][0][1]*0.69605)-273;
									cubesGeometry[i].position.y=200+(listChangingKeggCoordinates[i][1]*1.5);
									cubesGeometry[i].position.z=-(listChangingKeggCoordinates[i][0][0]*0.69605)+450;
									
									if (listChangingKeggCoordinates[i][1]!=0){
									cubesGeometry[i].scale.y =(listChangingKeggCoordinates[i][1]*3);
									}
									else{
									cubesGeometry[i].scale.y =1;
									}
									keggCubesProperties["k"+i]=[listChangingKeggCoordinates[i][2],listChangingKeggCoordinates[i][3]]
									
								}
								//bgeometry2.attributes.ca.needsUpdate = true;
								/*var iv=0;
								for ( var i = 0; i < keggSegment; i ++ ) {
									keggPositions[ (iv * 3)+0 ] = iv*100;
									keggPositions[ (iv * 3) + 1 ] = 0;
									keggPositions[ (iv * 3) + 2 ] = iv*100;
									//keggColors[ iv * 3 ] = col.r;
									//keggColors[ iv * 3 + 1 ] = col.g;
									//keggColors[ iv * 3 + 2 ] = col.b;
									iv++;
									keggPositions[ (iv * 3)+0 ] = (iv-1)*100;
									keggPositions[ (iv * 3) + 1 ] = size;
									keggPositions[ (iv * 3) + 2 ] = (iv-1)*100;
									//keggColors[ iv * 3 ] = col.r;
									//keggColors[ iv * 3 + 1 ] = col.g;
									//keggColors[ iv * 3 + 2 ] = col.b;
									iv++
								}*/
								
							}
							//console.log(simData[0][j])
						}
						scene.children[2].geometry.attributes.size.needsUpdate = true;
						scene.children[4].geometry.attributes.size.needsUpdate = true;
						simTimer++;
					}
					//console.log(simRow)
					
					//setAttribute("value", simTimer);
					// change property of model nodes to express flux
					
					// change nodes size according to flux values (take into account boundaries as min/max values)
					
					
					
						
					
					
						
					
					
					//simTimer++;
					
				}
				else{
				
					if (tokenStackCount<=0){
						simTimer=0;
						simulationIsOn=false;
						for (var ii=0;ii<stackTokenModel.length;ii++) {
							stackTokenModel[ii][5]==false
						}
						
						
						for (var tkNb=0; tkNb< txtReactionActivation.length;tkNb++){	
							txtReactionActivation[tkNb].innerHTML = '';
						}
						for (var i=segmentPts;i<b2lopacity.length;i++){	
							b2lopacity[i]=0.7;	
						}
						scene.children[7].geometry.attributes.op.needsUpdate = true;
						allfalse=true;
						//stackTokenModel=[];
						reactionIsDone=false;
						flowsStack=[];
						for(var i=0;i<nbModelPlanesFlow;i++){
							planeMesh[i].position.set(0,0,50000);
						}
						tokenIDStackCount={};
						
						
		
					}
				}
				
				//if (simData && simTimer<simData.length){
				//	console.log(simData[simTimer])
				//}
				
			

				//tokenIDStackCount;
				//for (var reac in tokenIDStackCount) {
				//	if (tokenIDStackCount.hasOwnProperty(reac)) {
						
				//	}	
				//}
			}
			
			if (simulationIsPaused==false && tokenStackCount>0 && simulationIsOn==true){
				//console.log(tokenStackCount)
				
				for (var ii=0;ii<stackTokenModel.length;ii++) {
						
						//if (stackTokenModel[ii] && stackTokenModel[ii][0]){
							//console.log(stackTokenModel[ii][5])
							//for (var j =0;j<stackTokenModel[ii].length;j++){
							
								if (stackTokenModel[ii][0]<1 && stackTokenModel[ii][5]==true){
									//console.log(stackTokenModel[ii][0])
									//console.log(stackTokenModel[ii][6])
									if (stackTokenModel[ii][6]!=1){
										//console.log("animate ")
										if (simModeValue==0){
										stackTokenModel[ii][0]+=0.001;					
										}
										if (simModeValue==1){
										
										stackTokenModel[ii][0]+=0.025;
										}
										tokenAttributes.mixAmount.value[stackTokenModel[ii][1]]=stackTokenModel[ii][0];
									}
									if (stackTokenModel[ii][6]==1 ){
									//console.log("animate 2")
										if (simModeValue==0){
										stackTokenModel[ii][0]+=0.001;
										}
										if (simModeValue==1 && reactionIsDone){
										stackTokenModel[ii][0]+=0.025;
										}
										if (simModeValue==1 && reactionIsDone==false && stackTokenModel.length==1){
											
											stackTokenModel[ii][0]+=0.025;
											if (stackTokenModel[ii][0]>=1.0){
												modelProductLocators[stackTokenModel[ii][7]].position.set(50000,50000,-50000);
											}
										}
										tokenAttributes.mixAmount.value[stackTokenModel[ii][1]]=stackTokenModel[ii][0];
										
									}
									//console.log(stackTokenModel[ii][0]);
									
									//tokenAttributes.mixAmount.value[stackTokenModel[ii][1]]=stackTokenModel[ii][0];
								}
								//else if (stackTokenModel[ii][0]<1 && stackTokenModel[ii][5]==false){
								else if (stackTokenModel[ii][0]<1 && stackTokenModel[ii][5]==false){
								//console.log("animate 3")
									scene.children[8].geometry.vertices[stackTokenModel[ii][1]].z-=50000;
									// erase product/modifier/reactant signs if necessary
									if (stackTokenModel[ii][7]){
										if (stackTokenModel[ii][6]==0){ // reactant
											//modelReactantLocators[stackTokenModel[ii][7]].position.set(50000,50000,-50000);
										}
										else if (stackTokenModel[ii][6]==1){ // product
											modelProductLocators[stackTokenModel[ii][7]].position.set(50000,50000,-50000);
										}	
										else if (stackTokenModel[ii][6]==2){// modifier
											//modelModifierLocators[stackTokenModel[ii][7]].position.set(50000,50000,-50000);
										}
										else{}
									}
									
									//console.log(stackTokenModel[ii][0]);
									
									//tokenAttributes.mixAmount.value[stackTokenModel[ii][1]]=stackTokenModel[ii][0];
								}
								else {
									//console.log("animate 4")
									/*if (simModeValue==0 ){
										planeMesh[stackModel2PlaneMesh[ii]].geometry.vertices[0].z-=(0.03);
										planeMesh[stackModel2PlaneMesh[ii]].geometry.vertices[2].z+=(0.03);
										planeMesh[stackModel2PlaneMesh[ii]].geometry.vertices[1].z-=(0.03);
										planeMesh[stackModel2PlaneMesh[ii]].geometry.vertices[3].z+=(0.03);
										planeMesh[stackModel2PlaneMesh[ii]].geometry.verticesNeedUpdate=true;
									}*/
									
									if (stackTokenModel[ii][6]!=1 ){
										
										reactionIsDone=true;
									}
									tokenAttributes.mixAmount.value[ii]=0;
									//tokenAttributes.mixAmount.value[stackTokenModel[ii][1]]=0;
									clearedTokenIndex.push(stackTokenModel[ii][1]);
									stackTokenModel[ii][0]=0;
									
									if(tokenStackCount>0){
										tokenStackCount-=1;
									}
									stackTokenModel[ii][5]=false;
									if (stackTokenModel[ii][7] ){
										if (stackTokenModel[ii][6]==0){ // reactant
											//modelReactantLocators[stackTokenModel[ii][7]].position.set(50000,50000,-50000);
										}
										else if (stackTokenModel[ii][6]==1){ // product
											modelProductLocators[stackTokenModel[ii][7]].position.set(50000,50000,-50000);
										}	
										else if (stackTokenModel[ii][6]==2){// modifier
											//modelModifierLocators[stackTokenModel[ii][7]].position.set(50000,50000,-50000);
										}
										else{}										
									}
									//erasingArray.push(ii);
									//stackTokenModel.splice(ii,1);
									
									
									//console.log(tokenStackCount)
									//console.log(clearedTokenIndex.length);
								}
								
							
							//}

						
						//}
					
				}
				allFalse=true;
				for (var ii=0;ii<stackTokenModel.length;ii++) {
					if (stackTokenModel[ii][5]==true){
						allFalse=false;
					}
				}
				//if (stackTokenModel.length==1){
				//	reactionIsDone=true;
				//}
				
				
				//console.log(stackTokenModel.length)	
				
				
			}
			
			//for (var ii=0;ii<erasingArray.length;ii++){
			//tokenAttributes.mixAmount.value[stackTokenModel[ii][1]]=0;
			//stackTokenModel.splice(erasingArray[ii],1);
			//}
			//var t = clock.getElapsedTime();
			//tokenUniforms.mixAmount.value = 0.5 * (1.0 + Math.sin(t));
			//console.log(stackTokenModel.length)
			//tokenUniforms.mixAmount.value = 0.5 * (1.0 + Math.sin(t));
			//var ii=0;
			//for ( var i = 0; i <segmentPts ; i +=2 ) {
			//	tokenAttributes.mixAmount.value[i] = 0.5 * (1.0 + Math.sin(t));
			//}
			/*for (var ii=0;ii<stackTokenModel.length;ii++) {
				
					if (stackTokenModel[ii]){
						//for (var j =0;j<stackTokenModel[ii].length;j++){
						if (stackTokenModel[ii][0]){
							if (stackTokenModel[ii][0]<1){
								stackTokenModel[ii][0]+=0.005;
								tokenAttributes.mixAmount.value[stackTokenModel[ii][2]]=stackTokenModel[ii][j][0];
							}
							if (stackTokenModel[ii][0]>=1){
								
								//tokenAttributes.mixAmount.value[ii]=0;
								tokenAttributes.mixAmount.value[stackTokenModel[ii][2]]=0;
								stackTokenModel.splice(ii,1);
								tokenStackCount-=1;
								//console.log(tokenStackCount);
							}
						}
						//}

					
					}
				
			}*/
			
				//ii++;
			//}
			// trigger start of token from/to reactions
			//if (simData && simTimer<simData.length){
			//console.log("trigger: "+simData[1][simTimer][2])
			//}
			
			tokenAttributes.mixAmount.needsUpdate = true;
			//var tokenPoses =tokenAttributes.mixAmount.value;
			//for ( var i = 1; i <segmentPts ; i +=2 ) {
			//	
			//}
			//rendererCSS.render( cssScene, camera2 );
			//rendererCSS3.render( cssScene3, camera2 );
			//rendererCSS2.render( cssScene2, camera2 );
			renderer.render( scene, camera );
			//renderer2.render( scene2, camera2 );
			
			if (idsOfSelectedRows.length>0){
				for (var i =0;i<spritesSelected.length;i++){		
					spritesSelected[i].position.set(-50000,-10000,10000);
					spritesSelected[i].scale.set(100, 100, 100);
				}
				
				for (var i =0;i<idsOfSelectedRows.length;i++){
					if (i<spritesSelected.length){
						var a1 = scene.children[idMap[idsOfSelectedRows[i]][0]].geometry.attributes.position.array;
						//console.log(idMap[idsOfSelectedRows[i]])
						spritesSelected[i].position.set(a1[idMap[idsOfSelectedRows[i]][1]*3],a1[idMap[idsOfSelectedRows[i]][1]*3+1],a1[idMap[idsOfSelectedRows[i]][1]*3+2]);			
					}
				}
				for (var i =0;i<idsOfSelectedRows.length;i++){
					//for (var j =0;j<spritesSelected.length;j++){
					if (i<spritesSelected.length){
						var dx= camera.position.x-spritesSelected[i].position.x
						var dy= camera.position.y-spritesSelected[i].position.y
						var dz= camera.position.z-spritesSelected[i].position.z
						var dc = Math.sqrt(((dx*dx) + (dy*dy)))
						var ds = Math.sqrt((dc*dc) + (dz*dz))
						var mult = ((ds/100)*5)+20
						spritesSelected[i].scale.set(mult, mult, mult);
					}
				}
			}
			else{
				for (var i =0;i<spritesSelected.length;i++){		
					spritesSelected[i].position.set(-50000,-10000,10000);
					spritesSelected[i].scale.set(100, 100, 100);
				}
			}
			
			if (idsOfModelSelectedRows.length>0){
				for (var i =0;i<modelspritesSelected.length;i++){		
					modelspritesSelected[i].position.set(-50000,-10000,10000);
					modelspritesSelected[i].scale.set(100, 100, 100);
				}
				var anb=jsonObj1.length;
				for (var i =0;i<idsOfModelSelectedRows.length;i++){
					if (i<modelspritesSelected.length){
						var a1 = scene.children[idMap[parseInt(idsOfModelSelectedRows[i])+anb][0]].geometry.attributes.position.array;
						//console.log(idMap[(jsonObj1.length+1)])
						//console.log(jsonObj1.length)
						//console.log(parseInt(idsOfModelSelectedRows[i]))
						//console.log(idMap[parseInt(idsOfModelSelectedRows[i])+anb]);
						modelspritesSelected[i].position.set(a1[idMap[parseInt(idsOfModelSelectedRows[i])+anb][1]*3],a1[idMap[parseInt(idsOfModelSelectedRows[i])+anb][1]*3+1],a1[idMap[parseInt(idsOfModelSelectedRows[i])+anb][1]*3+2]);			
					}
				}
				for (var i =0;i<idsOfModelSelectedRows.length;i++){
					//for (var j =0;j<spritesSelected.length;j++){
					if (i<modelspritesSelected.length){
						var dx= camera.position.x-modelspritesSelected[i].position.x
						var dy= camera.position.y-modelspritesSelected[i].position.y
						var dz= camera.position.z-modelspritesSelected[i].position.z
						var dc = Math.sqrt(((dx*dx) + (dy*dy)))
						var ds = Math.sqrt((dc*dc) + (dz*dz))
						var mult = ((ds/100)*5)+20
						modelspritesSelected[i].scale.set(mult, mult, mult);
					}
				}
			}
			else{
				for (var i =0;i<modelspritesSelected.length;i++){		
					modelspritesSelected[i].position.set(-50000,-10000,10000);
					modelspritesSelected[i].scale.set(100, 100, 100);
				}
			}
		/*if(typeof(Storage)!=="undefined") {
			
				if(resetSpreadsheet==true){localStorage.selection=[];}
				if (localStorage.selection==""){
					mselectedList=[]
					//console.log("empty")
					for (var i =0;i<spritesSelected.length;i++){		
						spritesSelected[i].position.set(-50000,-10000,10000);
					}
				
				}
				else if (localStorage.selection.length>0 ){
					//console.log(mselectedList); 
					//console.log(localStorage.selection.split(",").map(function(x){return parseInt(x)})); 
					
					var tmpS= localStorage.selection.split(",").map(function(x){return parseInt(x)});
					
					if(!($(tmpS).not(mselectedList).length == 0 && $(mselectedList).not(tmpS).length == 0)) {
					//	console.log(localStorage.selection); 
						mselectedList=[];
						for (var i =0;i<tmpS.length;i++){
						mselectedList[i] =tmpS[i];
						}
						//console.log(mselectedList); 
						//console.log(camera.position)
						// highlight selection
						for (var i =0;i<spritesSelected.length;i++){		
							spritesSelected[i].position.set(-50000,-10000,10000);
							spritesSelected[i].scale.set(100, 100, 100);
						}
						//if(resetSpreadsheet==true){
						//resetSpreadsheet=false;
						//}
						//else{
						for (var i =0;i<mselectedList.length;i++){
							//for (var j =0;j<spritesSelected.length;j++){
							if (i<spritesSelected.length){
								//spritesSelected
								//console.log(idMap[mselectedList[i]])
								var a1 = scene.children[idMap[mselectedList[i]][0]].geometry.attributes.position.array;
								spritesSelected[i].position.set(a1[idMap[mselectedList[i]][1]*3],a1[idMap[mselectedList[i]][1]*3+1],a1[idMap[mselectedList[i]][1]*3+2]);	
								//var dx= camera.position.x-spritesSelected[i].position.x
								//var dy= camera.position.y-spritesSelected[i].position.y
								//var dz= camera.position.z-spritesSelected[i].position.z
								//var dc = Math.sqrt(((dx*dx) + (dy*dy)))
								//var ds = Math.sqrt((dc*dc) + (dz*dz))
								//var mult = ((ds/100)*5)+50
								//spritesSelected[i].scale.set(mult, mult, mult);
								//console.log(ds)
								
							}
							
						}
						
						//}
						
					}
				
					for (var i =0;i<mselectedList.length;i++){
							//for (var j =0;j<spritesSelected.length;j++){
							if (i<spritesSelected.length){
								var dx= camera.position.x-spritesSelected[i].position.x
								var dy= camera.position.y-spritesSelected[i].position.y
								var dz= camera.position.z-spritesSelected[i].position.z
								var dc = Math.sqrt(((dx*dx) + (dy*dy)))
								var ds = Math.sqrt((dc*dc) + (dz*dz))
								var mult = ((ds/100)*5)+20
								spritesSelected[i].scale.set(mult, mult, mult);
							}
					}
					   
				}
			//else if 	(resetSpreadsheet==true){
			//	for (var i =0;i<spritesSelected.length;i++){		
			//				spritesSelected[i].position.set(-50000,-10000,10000);
			//				spritesSelected[i].scale.set(100, 100, 100);
			//			}
			//	resetSpreadsheet=false;
			//}		
        }*/
		
		
		
		if 	(resetSpreadsheet==true){
		resetSpreadsheet=false;
		}
		
		var tokenIDStackCountSize=Object.keys(tokenIDStackCount).length
		if( reactionIsDone && (simModeValue==1)){
			for (var tkNb=0; tkNb< tokenIDStackCountSize;tkNb++){
				
				var tmp=tokenIDStackCount[Object.keys(tokenIDStackCount)[tkNb]];
				
				//console.log(tokenIDStackCount[tkNb])
				txtReactionActivation[tkNb].innerHTML = ''+tmp[0];
				var vectorp = new THREE.Vector3( tmp[1],tmp[2],tmp[3]);
				vectorp.x +=10;
				var ppv = toXYCoords(vectorp	);
				txtReactionActivation[tkNb].style.top = (ppv.y+$("#showresult").position().top + $("#showresult").height()+$("#visualisation").height()) + 'px';
				txtReactionActivation[tkNb].style.left = ppv.x + 'px';
									//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
				
				
				
			}
		}
		else if( simModeValue==0){
			for (var tkNb=0; tkNb< tokenIDStackCountSize;tkNb++){
				
				var tmp=tokenIDStackCount[Object.keys(tokenIDStackCount)[tkNb]];
				
				//console.log(tokenIDStackCount[tkNb])
				txtReactionActivation[tkNb].innerHTML = ''+tmp[0];
				var vectorp = new THREE.Vector3( tmp[1],tmp[2],tmp[3]);
				vectorp.x +=10;
				var ppv = toXYCoords(vectorp	);
				txtReactionActivation[tkNb].style.top = (ppv.y+$("#showresult").position().top + $("#showresult").height()+$("#visualisation").height()) + 'px';
				txtReactionActivation[tkNb].style.left = ppv.x + 'px';
									//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
				//planeMesh[tkNb].position.set(0,0,50000);
				
				
			}
		}
		else{
			for (var tkNb=0; tkNb< tokenIDStackCountSize;tkNb++){
				
				
				txtReactionActivation[tkNb].innerHTML = '';
				//var vectorp = new THREE.Vector3( tmp[1],tmp[2],tmp[3]);
				//vectorp.x +=10;
				//var ppv = toXYCoords(vectorp	);
				//txtReactionActivation[tkNb].style.top = ppv.y + 'px';
				//txtReactionActivation[tkNb].style.left = ppv.x + 'px';
									//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
				
				
				
			}
		}
		
		//meshLineChart.direction=controls.direction;
		//meshLineChart.position.x=controls.target.x;
		//meshLineChart.position.y=controls.target.y;
		//meshLineChart.position.z=controls.target.z;
		//console.log(controls.target);
		//meshLineChart.lookAt(camera.position);
			//meshLineChart.position.set(camera.position);
			//meshLineChart.position.z+=400;
			//meshLineChart.direction=camera.direction;
		//mselectedList=[]
					//console.log("empty")
		//			for (var i =0;i<spritesSelected.length;i++){		
		//				spritesSelected[i].position.set(-50000,-10000,10000);
		//			}
		//}	
		

		}
	
		
		
		
		
		
		







//console.log(results.length);
//console.log(headTitles.length);

//for (var j=0;j<results.length;j++){
//	if (results[j][1]=="Time"){
//		console.log(j);
//	}
//}


// choose a headTitles index value between 3 and headTitles.length-1 to display graph corresponding to place/transition
var indChartsNames=[];
var indCharts =[]
var plotchartdata0=[];
for (var i=0;i<indCharts.length;i++){
	plotchartdata0[headTitles[indCharts[i]]]= [];
	
	for (var j=0;j<results.length;j++){
		if (isNaN(results[j][1])){
			console.log("problem at time not numbered"+ results[j][1])
			}
		plotchartdata0[headTitles[indCharts[i]]].push([results[j][1],results[j][i]]);
	}
	
}

var plotchartdata=[];
for (var i=0;i<indCharts.length;i++){
	
	for (var j=0;j<results.length;j++){
		plotchartdata.push({ symbol: headTitles[indCharts[i]], date: results[j][1] , price: results[j][indCharts[i]], event: results[j][2] });
	}
	
}
var hslider= document.getElementById("slider2");
if ((results.length-1)>=0){
	hslider.max= results.length-1;
}
//console.log(plotchartdata)

var params =<%-JSON.stringify( exp.parameters) %>
//console.log(params)

//var format = d3.time.format("%L");
var jsondata =[[2, 64.64], [3, 64.66], [4, 64.52], [5, 64.39], [6, 64.23], [7, 64.2], [8, 64.28], [9, 64.27], [10, 64.3], [11, 64.235], [12, 64.34], [13, 64.5], [14, 64.5499], [15, 64.67], [16, 64.7], [17, 64.78], [18, 64.81], [19, 64.68], [21, 64.72], [22, 64.8], [23, 64.87], [24, 64.77], [25, 64.715], [26, 64.57], [27, 64.77], [28, 64.65], [29, 64.78], [30, 64.81], [31, 64.76], [32, 64.78], [33, 64.77], [34, 64.69], [35, 64.69], [36, 64.62], [37, 64.57], [38, 64.57], [39, 64.59], [40, 64.56], [41, 64.62], [42, 64.67], [43, 64.62], [44, 64.67], [45, 64.54], [46, 64.52], [47, 64.5], [49, 64.5], [50, 64.52], [51, 64.52], [52, 64.52], [53, 64.41], [54, 64.36], [55, 64.305], [57, 64.34], [58, 64.34], [59, 64.38], [61, 64.35], [62, 64.35], [64, 64.35], [65, 64.35], [66, 64.32], [69, 64.3196], [70, 64.38], [71, 64.38], [72, 64.26], [73, 64.21], [74, 64.15], [75, 64.15], [76, 64.04], [77, 63.96], [78, 63.97], [79, 63.89], [80, 63.934], [81, 63.99], [82, 64.0], [83, 63.91], [84, 64.01], [86, 64.0], [87, 64.03], [88, 64.03], [89, 64.01], [91, 64.03], [92, 64.03], [93, 64.1], [94, 64.11], [95, 64.13], [96, 64.1], [97, 64.075], [98, 64.09], [99, 64.07], [100, 64.03], [101, 64.03], [102, 64.025], [104, 64.03], [105, 64.01], [106, 64.08], [108, 64.085], [109, 64.08], [110, 64.065], [111, 64.07], [112, 64.03], [113, 64.03], [114, 64.06], [115, 64.1], [116, 64.085], [117, 64.09], [118, 64.14], [120, 64.1], [121, 64.055], [122, 64.085], [123, 64.08], [124, 64.05], [125, 64.07], [126, 64.09], [127, 64.06], [128, 64.08], [129, 64.09], [130, 64.12], [131, 64.12], [132, 64.1], [133, 64.12], [134, 64.13], [135, 64.19], [136, 64.2], [137, 64.21], [138, 64.19], [139, 64.205], [140, 64.2], [141, 64.24], [142, 64.22], [143, 64.2], [144, 64.2], [145, 64.2], [146, 64.185], [147, 64.18], [148, 64.2], [149, 64.2], [150, 64.205], [151, 64.24], [152, 64.225], [153, 64.19], [154, 64.255], [155, 64.29], [156, 64.26], [157, 64.245], [158, 64.25], [159, 64.27], [160, 64.29], [161, 64.3], [162, 64.31], [164, 64.248], [165, 64.23], [166, 64.21], [167, 64.2], [168, 64.23], [169, 64.23], [170, 64.24], [173, 64.22], [174, 64.23], [176, 64.249], [177, 64.27], [178, 64.28], [180, 64.28], [181, 64.26], [182, 64.27], [185, 64.31], [186, 64.3], [187, 64.3], [188, 64.28], [191, 64.295], [192, 64.295], [194, 64.32], [195, 64.34], [196, 64.36], [197, 64.37], [198, 64.41], [199, 64.43], [200, 64.44], [201, 64.46], [202, 64.45], [203, 64.4], [204, 64.43], [205, 64.44], [206, 64.43], [207, 64.43], [208, 64.435], [209, 64.47], [212, 64.46], [213, 64.46], [214, 64.45], [215, 64.45], [216, 64.46], [217, 64.5], [218, 64.5], [219, 64.52], [220, 64.52], [221, 64.5011], [222, 64.52], [224, 64.52], [225, 64.4925], [226, 64.5], [227, 64.54], [228, 64.61], [229, 64.63], [230, 64.63], [231, 64.63], [232, 64.73], [235, 64.71], [236, 64.76], [237, 64.79], [238, 64.8], [239, 64.7675], [240, 64.71], [241, 64.67], [242, 64.69], [243, 64.66], [244, 64.66], [245, 64.62], [246, 64.645], [247, 64.62], [248, 64.61], [249, 64.59], [250, 64.59], [251, 64.59], [252, 64.59], [253, 64.59], [254, 64.59], [255, 64.58], [256, 64.62], [261, 64.655], [262, 64.65], [264, 64.64], [265, 64.65], [266, 64.59], [267, 64.56], [268, 64.57], [269, 64.59], [270, 64.585], [271, 64.56], [272, 64.54], [273, 64.56], [274, 64.57], [275, 64.59], [277, 64.59], [278, 64.61], [279, 64.64], [280, 64.65], [282, 64.69], [283, 64.67], [284, 64.68], [285, 64.66], [286, 64.64], [287, 64.58], [288, 64.55], [289, 64.55], [290, 64.55], [292, 64.5525], [293, 64.57], [294, 64.58], [295, 64.58], [296, 64.5905], [297, 64.57], [298, 64.55], [300, 64.56], [301, 64.59], [302, 64.61], [304, 64.62], [305, 64.62], [306, 64.635], [307, 64.64], [308, 64.639], [309, 64.639], [310, 64.65], [311, 64.67], [312, 64.7], [313, 64.69], [314, 64.71], [315, 64.7], [316, 64.72], [317, 64.73], [318, 64.69], [320, 64.72], [321, 64.74], [322, 64.81], [323, 64.78], [324, 64.78], [325, 64.77], [326, 64.77], [327, 64.8], [328, 64.8], [329, 64.775], [330, 64.73], [331, 64.75], [333, 64.72], [334, 64.71], [335, 64.7175], [336, 64.73], [337, 64.74], [338, 64.8], [339, 64.84], [340, 64.8], [341, 64.78], [342, 64.8], [344, 64.81], [345, 64.83], [346, 64.83], [347, 64.87], [349, 64.87], [351, 64.92], [352, 64.88], [353, 64.88], [354, 64.88], [355, 64.86], [356, 64.8699], [357, 64.805], [358, 64.81], [359, 64.8], [360, 64.74], [361, 64.75], [364, 64.8], [365, 64.78], [366, 64.79], [368, 64.805], [369, 64.78], [371, 64.795], [372, 64.78], [373, 64.76], [374, 64.77], [376, 64.78], [377, 64.78], [378, 64.7798], [379, 64.77], [380, 64.74], [381, 64.75], [382, 64.75], [383, 64.75], [384, 64.73], [385, 64.75], [386, 64.78], [387, 64.755], [388, 64.76], [393, 64.77]];
var context = cubism.context().serverDelay(Date.now())
                                .step((params['simulations_p'][nbRes][0][3]/(results.length*1.0))) // Distance between data points in milliseconds
                                .size(results.length) // Number of data points
                                .stop();   // Fetching from a static data source; don't update values
			
           d3.select("#democ").append("div") // Add a vertical rule
              .attr("class", "rule")      // to the graph
              .call(context.rule());
			//document.getElementById("democ").style.width=results.length+"px";
			//document.getElementById("democ").style.width=($("#container").width()*0.8)+"px"
			//document.getElementById("democ").style.overflow="auto";
			//console.log(results.length)
            function stock(name) { 
                return context.metric(function(start, stop, step, callback) {
				
                    //d3.json(jsondata, function(rows) {
					rows = plotchartdata0[name];
					
					var allval=[]
					for (var i =0;i<rows.length;i++){
						allval.push(rows[i][1]);
					}
					var maxval=Math.max.apply( Math, allval );
					var minval=Math.min.apply( Math, allval );
					//console.log(rows)
                        var compare = rows[0][1], value = rows[0][1], values = [value];
                        
                        // Creates an array of the price differences throughout the day
                        rows.forEach(function(d) {
						if (maxval-minval!=0){
                            values.push(value = ((d[1]-minval)/(maxval-minval)) );
							}
						else
							values.push(value = ((d[1])) );
                        }); 
                    callback(null, values); //}); 
                }, name); 
            }


            function draw_graph(stocks_list) {
                d3.select("#demo")                 // Select the div on which we want to act           
                  .selectAll(".axis")              // This is a standard D3 mechanism to
                  .data(["top"])                   // bind data to a graph. In this case
                  .enter()                         // we're binding the axes "top" and "bottom".
                  .append("div")                   // Create two divs and 
                  .attr("class", function(d) {     // give them the classes
                    return d + " axis";            // top axis and bottom axis
                  })                               // respectively 
                  .each(function(d) {              // For each of these axes,
					d3.select(this)                // draw the axes with 4 intervals
                      .call(context.axis()         // and place them in their proper places
					  .ticks(20).tickFormat(d3.time.format("%L"))
                      .orient(d));  
                  });

				
                d3.select("#demo")                 
                  .selectAll(".horizon")           
                  .data(stocks_list.map(stock))    
                  .enter()                         
                  .insert("div", ".bottom")        // Insert the graph in a div  
                  .attr("class", "horizon")        // Turn the div into
                  .call(context.horizon()          // a horizon graph
                  .format(d3.format(".1p%")));    // Format the values to 1 floating-point decimals


                context.on("focus", function(i) {
					//format = d3.format(".1f");
                    d3.selectAll(".value").style("right",                  // Make the rule coincide 
                        i == null ? null : (context.size() - i-30) + "px");//.text(format(primary.valueAt(Math.floor(i))) + "\u00B0C"); // with the mouse
						//console.log(results.length)
						if (window.event && i != null){
							$("#mytooltip")
							.html(""+i+"/"+results.length)
							.css('left', window.event.clientX+40)
							.css('top', $('#democ').position().top+($( '.axis' ).height()/2))
							//.css('top', window.event.clientY)
							.css('height', 25)
							.css('width', 80)
							.show();
						}
						else{
							$("#mytooltip").html('').hide();
						}
                });
				
				
				
				//context.on('mouseover', function(d) {
				//	$("#mytooltip")
                //      .html("<b>okok</b><br>")
				//	  .css('left', window.event.clientX+40)
                //      .css('top', window.event.clientY)
                //      .show();
				//});
				//context.on("mouseout", function(d) {
				//	$("#mytooltip").html('').hide();
			   
				//});
            } 
			var listCharts=[];
            for (var i=0;i<indCharts.length;i++){
				listCharts.push(headTitles[indCharts[i]]);
			}
			//draw_graph(headTitles.slice(3));
			draw_graph(listCharts);

document.getElementById("demo").style.width=results.length+"px";

document.getElementById("democ").style.width=($("#container").width()*0.98)+"px"
document.getElementById("democ").style.left=($("#container").width()*0.01)+"px"

//document.getElementById("demo").style.overflow="scroll";

var data = plotchartdata








var margin = {top: 8, right: window.innerWidth*0.1, bottom: 2, left: window.innerWidth*0.1},
    width = window.innerWidth - margin.left - margin.right,
    height = 69 - margin.top - margin.bottom;

//var parseDate = d3.time.format("%b %Y").parse;

var x = d3.time.scale()
    .range([0, width]);

var y = d3.scale.linear()
    .range([height, 0]);

var area = d3.svg.area()
    .x(function(d) { return x(d.date); })
    .y0(height)
    .y1(function(d) { return y(d.price); });

var line = d3.svg.line()
    .x(function(d) { return x(d.date); })
    .y(function(d) { return y(d.price); });

//d3.csv("stocks.csv", type, function(error, data) {

  // Nest data by symbol.
  var symbols = d3.nest()
      .key(function(d) { return d.symbol; })
      .entries(data);

  // Compute the maximum price per symbol, needed for the y-domain.
  symbols.forEach(function(s) {
    s.maxPrice = d3.max(s.values, function(d) { return d.price; });
  });

  // Compute the minimum and maximum date across symbols.
  // We assume values are sorted by date.
  x.domain([
    d3.min(symbols, function(s) { return s.values[0].date; }),
    d3.max(symbols, function(s) { return s.values[s.values.length - 1].date; })
  ]);

  // Add an SVG element for each symbol, with the desired dimensions and margin.
  var svg = d3.select("#mygraph").selectAll("svg")
      .data(symbols)
    .enter().append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  // Add the area path elements. Note: the y-domain is set per element.
  svg.append("path")
      .attr("class", "marea")
      .attr("d", function(d) { y.domain([0, d.maxPrice]); return area(d.values); });

  // Add the line path elements. Note: the y-domain is set per element.
  svg.append("path")
      .attr("class", "mline")
      .attr("d", function(d) { y.domain([0, d.maxPrice]); return line(d.values); });

  // Add a small label for the symbol name.
  svg.append("text")
      .attr("x", width - 6)
      .attr("y", height - 6)
      .style("text-anchor", "end")
      .text(function(d) { return d.key; });
//});

function type(d) {
  d.price = +d.price;
  d.date = d.date;
  return d;
}

//console.log($("#container").height())
//console.log($("#democ").height())
//console.log($("#visualisation").height())
//console.log($("#mygraph").height())

$("#container").css({top:  $("#showresult").position().top + $("#showresult").height()+$("#visualisation").height()});

//$("#selectChannels1").css({top:  $("#container").position().top + $("#container").height()});
//document.getElementById('selectChannels1').style.top = $("#container").position().top + $("#container").height()+'px';
//$("#selectChannels1").val(  [headTitles[3]]); // pre-select elements
$("#select1text").css({top:  $("#democ2").position().top + $("#democ2").height()+20});


$("#democ2").css({top:  $("#container").position().top + $("#container").height()});
$("#select1text").css({top:  $("#democ2").position().top + $("#democ2").height()+20});
$("#mygraph").css({top:  $("#select1text").position().top + $("#select1text").height()});
$("#democ").css({top:  $("#mygraph").position().top + $("#mygraph").height()});

//$("#democ3").css({top:  $("#mygraph").position().top + $("#mygraph").height()});

$("#reactionCategoryTable").css({top:  $("#democ").position().top + $("#democ").height()+50});
$("#democ4").css({top:  $("#reactionCategoryTable").position().top + $("#reactionCategoryTable").height()+20});
$("#sliderdiv").css({top:  $("#democ4").position().top + $("#democ4").height()+20});
$("#sliderdiv").width($("#hiveplot").width());
$("#hiveplot").css({top:  $("#sliderdiv").position().top + $("#sliderdiv").height()+20});	
//$("#hiveplot").css({top:  $("#democ4").position().top + $("#democ4").height()});	


//$("#democ").css({top:  $("#mygraph").position().top + $("#mygraph").height()});
//$("#democ3").css({top:  $("#democ").position().top + $("#democ").height()});

//$("#democ2").css({top:  $("#democ3").position().top + $("#democ3").height()});
//$("#democ4").css({top:  $("#democ2").position().top + $("#democ2").height()});



/*
var width = $("#container").width(),
    height = screen.height*0.9,
    innerRadius = 40,
    outerRadius = (screen.height*0.7)/2;
var nbAxis = 4;
var angle = d3.scale.ordinal().domain(d3.range(nbAxis+1)).rangePoints([0, 2 * Math.PI]),
    radius = d3.scale.linear().range([innerRadius, outerRadius]),
    color = d3.scale.category10().domain(d3.range(20));

var nodes = [
  {x: 0, y: .1},
  {x: 0, y: .9},
  {x: 1, y: .2},
  {x: 1, y: .3},
  {x: 2, y: .1},
  {x: 2, y: .8},
  {x: 3, y: .5},
  {x: 3, y: .6}
];

for(var j=0;j<5000;j++){
		nodes.push({x:Math.floor((Math.random() * 4) ),y:Math.random()})
}


var links = [
  {source: nodes[0], target: nodes[2]},
  {source: nodes[1], target: nodes[3]},
  {source: nodes[2], target: nodes[4]},
  {source: nodes[2], target: nodes[5]},
  {source: nodes[3], target: nodes[5]},
  {source: nodes[4], target: nodes[0]},
  {source: nodes[5], target: nodes[1]},
  {source: nodes[6], target: nodes[1]}
];

for(var j=0;j<2000;j++){
		links.push({source: nodes[Math.floor((Math.random() * nodes.length) )], target: nodes[Math.floor((Math.random() * nodes.length) )]})
}

var svg2 = d3.select("#democ2").append("svg")
    .attr("width", width)
    .attr("height", height)
  .append("g")
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
//console.log(d3.range(nbAxis))
svg2.selectAll(".hvaxis")
    .data(d3.range(nbAxis))
  .enter().append("line")
    .attr("class", "hvaxis")
    .attr("transform", function(d) { return "rotate(" + degrees(angle(d)) + ")"})
    .attr("x1", radius.range()[0])
    .attr("x2", radius.range()[1]);

svg2.selectAll(".hvlink")
    .data(links)
  .enter().append("path")
    .attr("class", "hvlink")
    .attr("d", d3.hive.link(nbAxis)
		.angle(function(d) { return angle(d.x); })
		.radius(function(d) { return radius(d.y); }))
	.on("mouseover", linkMouseover)
    .on("mouseout", mouseout)
    .style("stroke", function(d) { return color(d.source.x); });
	

	

svg2.selectAll(".hvnode")
    .data(nodes)
  .enter().append("circle")
    .attr("class", "hvnode")
    .attr("transform", function(d) { return "rotate(" + degrees(angle(d.x)) + ")"; })
    .attr("cx", function(d) { return radius(d.y); })
    .attr("r", 2.0)
    .style("fill", function(d) { return color(d.x); })
	.on("mouseover", nodeMouseover)
    .on("mouseout", mouseout);

	
function nodeMouseover(d) {
	
	var neiNodeList = [];
	svg2.selectAll(".hvlink").classed("active", function (p) {
		
		if (p.source.x == d.x && p.source.y == d.y) {
			neiNodeList.push(p.target);
		}
		if (p.target.x == d.x && p.target.y == d.y ) {
			neiNodeList.push(p.source);
		}
		return p.source === d || p.target === d;
	});
	
	d3.select(this).classed("active", true);
	//nodename.text(d.name);
	//nodehiv.text(d.type);
	//nodegender.text(capitalizeFirstLetter(d.gender));
	//nodefriends.text(d.degree + " friends");

	//var percentfemale = d3.sum(neiNodeList.map(
	//	function (d) {
	//		return d.gender == 'female';
	//	})) / neiNodeList.length;
	//var percenthiv = d3.sum(neiNodeList.map(
	//	function (d) {
	//		return d.binaryAttribute;
	//	})) / neiNodeList.length;
	//var pfemale = d3.round(100 * percentfemale, 2) + "%";
	//var phiv = d3.round(100 * percenthiv, 2) + "%";

	//nodephiv.text(phiv + " of friends are HIV-Positive");
	//nodepfemale.text(pfemale + " of friends are female");
}	
function linkMouseover(d) {
			svg2.selectAll(".hvlink").classed("active", function (p) {
                return p === d;
            });
			//d3.select(this).classed("active", true);
            svg2.selectAll(".hvnode").classed("active", function (p) {
				
                return p === d.source || p === d.target;
            });
            //name1.text(d.source.node.name).style("fill", linkColor(d.typeByGender)).style("opacity", "0.75");
            //name2.text(d.target.node.name).style("fill", linkColor(d.typeByGender)).style("opacity", "0.75");
            //gender1.text(capitalizeFirstLetter(d.source.node.gender)).style("fill", linkColor(d.typeByGender)).style("opacity", "0.75");
            //gender2.text(capitalizeFirstLetter(d.target.node.gender)).style("fill", linkColor(d.typeByGender)).style("opacity", "0.75");
            //hiv1.text(d.source.node.type).style("fill", linkColor(d.typeByGender)).style("opacity", "0.75");
            //hiv2.text(d.target.node.type).style("fill", linkColor(d.typeByGender)).style("opacity", "0.75");
            //nodehiv.text("↔").style("fill", linkColor(d.typeByGender)).style("opacity", "0.75").style("font-size", "34");
}
// Clear any highlighted nodes or links.
function mouseout() {
	svg2.selectAll(".active").classed("active", false);
	
	//name1.text(defaultText);
	//name2.text(defaultText);
	//gender1.text(defaultText);
	//gender2.text(defaultText);
	//hiv1.text(defaultText);
	//hiv2.text(defaultText);
	//nodename.text(defaultText);
	//nodehiv.text(defaultText).style("font-size", "16").style("fill", "white").style("opacity", "1");
	//nodegender.text(defaultText);
	//nodefriends.text(defaultText);
	//nodephiv.text(defaultText);
	//nodepfemale.text(defaultText);
}	
	
function degrees(radians) {
  return radians / Math.PI * 180 - 90;
}

*/

function selectLinePlotsChannels(){
	//console.log("tick")
	var maxSelected=200;
	var countSelected=0;
	indCharts =[];
	indChartsNames=[];
	$( "#shuttle-dst option" ).each(function() {
		
		if (countSelected<maxSelected){
			indChartsNames.push($( this ).text());
			indCharts.push(headTitles.indexOf($( this ).text()));
		}
		countSelected++;
    });
	
	

	plotchartdata=[];
	for (var i=0;i<indCharts.length;i++){
		
		for (var j=0;j<results.length;j++){
			plotchartdata.push({ symbol: headTitles[indCharts[i]], date: results[j][1] , price: results[j][indCharts[i]], event: results[j][2] });
		}
		
	}
	$("#mygraph").html("");
	var data = plotchartdata
	var margin = {top: 8, right: window.innerWidth*0.1, bottom: 2, left: window.innerWidth*0.1},
    width = window.innerWidth - margin.left - margin.right,
    height = 69 - margin.top - margin.bottom;

//var parseDate = d3.time.format("%b %Y").parse;

var x = d3.time.scale()
    .range([0, width]);

var y = d3.scale.linear()
    .range([height, 0]);

var area = d3.svg.area()
    .x(function(d) { return x(d.date); })
    .y0(height)
    .y1(function(d) { return y(d.price); });

var line = d3.svg.line()
    .x(function(d) { return x(d.date); })
    .y(function(d) { return y(d.price); });

//d3.csv("stocks.csv", type, function(error, data) {

  // Nest data by symbol.
  var symbols = d3.nest()
      .key(function(d) { return d.symbol; })
      .entries(data);

  // Compute the maximum price per symbol, needed for the y-domain.
  symbols.forEach(function(s) {
    s.maxPrice = d3.max(s.values, function(d) { return d.price; });
	s.minPrice = d3.min(s.values, function(d) { return d.price; });
  });

  // Compute the minimum and maximum date across symbols.
  // We assume values are sorted by date.
  x.domain([
    d3.min(symbols, function(s) { return s.values[0].date; }),
    d3.max(symbols, function(s) { return s.values[s.values.length - 1].date; })
  ]);

  // Add an SVG element for each symbol, with the desired dimensions and margin.
  var svg = d3.select("#mygraph").selectAll("svg")
      .data(symbols)
    .enter().append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  // Add the area path elements. Note: the y-domain is set per element.
  svg.append("path")
      .attr("class", "marea")
      .attr("d", function(d) { y.domain([d.minPrice, d.maxPrice]); return area(d.values); });

  // Add the line path elements. Note: the y-domain is set per element.
  svg.append("path")
      .attr("class", "mline")
      .attr("d", function(d) { y.domain([d.minPrice, d.maxPrice]); return line(d.values); });

  // Add a small label for the symbol name.
  svg.append("text")
      .attr("x", width - 6)
      .attr("y", height - 6)
      .style("text-anchor", "end")
      .text(function(d) { return d.key; });
//});

function type(d) {
  d.price = +d.price;
  d.date = d.date;
  return d;
}

plotchartdata0=[];
for (var i=0;i<indCharts.length;i++){
	plotchartdata0[headTitles[indCharts[i]]]= [];
	
	for (var j=0;j<results.length;j++){
		if (isNaN(results[j][1])){
			console.log("problem at time not numbered"+ results[j][1])
			}
		plotchartdata0[headTitles[indCharts[i]]].push([results[j][1],results[j][indCharts[i]]]);
	}
	
}

$("#demo").html("");

jsondata =[[2, 64.64], [3, 64.66], [4, 64.52], [5, 64.39], [6, 64.23], [7, 64.2], [8, 64.28], [9, 64.27], [10, 64.3], [11, 64.235], [12, 64.34], [13, 64.5], [14, 64.5499], [15, 64.67], [16, 64.7], [17, 64.78], [18, 64.81], [19, 64.68], [21, 64.72], [22, 64.8], [23, 64.87], [24, 64.77], [25, 64.715], [26, 64.57], [27, 64.77], [28, 64.65], [29, 64.78], [30, 64.81], [31, 64.76], [32, 64.78], [33, 64.77], [34, 64.69], [35, 64.69], [36, 64.62], [37, 64.57], [38, 64.57], [39, 64.59], [40, 64.56], [41, 64.62], [42, 64.67], [43, 64.62], [44, 64.67], [45, 64.54], [46, 64.52], [47, 64.5], [49, 64.5], [50, 64.52], [51, 64.52], [52, 64.52], [53, 64.41], [54, 64.36], [55, 64.305], [57, 64.34], [58, 64.34], [59, 64.38], [61, 64.35], [62, 64.35], [64, 64.35], [65, 64.35], [66, 64.32], [69, 64.3196], [70, 64.38], [71, 64.38], [72, 64.26], [73, 64.21], [74, 64.15], [75, 64.15], [76, 64.04], [77, 63.96], [78, 63.97], [79, 63.89], [80, 63.934], [81, 63.99], [82, 64.0], [83, 63.91], [84, 64.01], [86, 64.0], [87, 64.03], [88, 64.03], [89, 64.01], [91, 64.03], [92, 64.03], [93, 64.1], [94, 64.11], [95, 64.13], [96, 64.1], [97, 64.075], [98, 64.09], [99, 64.07], [100, 64.03], [101, 64.03], [102, 64.025], [104, 64.03], [105, 64.01], [106, 64.08], [108, 64.085], [109, 64.08], [110, 64.065], [111, 64.07], [112, 64.03], [113, 64.03], [114, 64.06], [115, 64.1], [116, 64.085], [117, 64.09], [118, 64.14], [120, 64.1], [121, 64.055], [122, 64.085], [123, 64.08], [124, 64.05], [125, 64.07], [126, 64.09], [127, 64.06], [128, 64.08], [129, 64.09], [130, 64.12], [131, 64.12], [132, 64.1], [133, 64.12], [134, 64.13], [135, 64.19], [136, 64.2], [137, 64.21], [138, 64.19], [139, 64.205], [140, 64.2], [141, 64.24], [142, 64.22], [143, 64.2], [144, 64.2], [145, 64.2], [146, 64.185], [147, 64.18], [148, 64.2], [149, 64.2], [150, 64.205], [151, 64.24], [152, 64.225], [153, 64.19], [154, 64.255], [155, 64.29], [156, 64.26], [157, 64.245], [158, 64.25], [159, 64.27], [160, 64.29], [161, 64.3], [162, 64.31], [164, 64.248], [165, 64.23], [166, 64.21], [167, 64.2], [168, 64.23], [169, 64.23], [170, 64.24], [173, 64.22], [174, 64.23], [176, 64.249], [177, 64.27], [178, 64.28], [180, 64.28], [181, 64.26], [182, 64.27], [185, 64.31], [186, 64.3], [187, 64.3], [188, 64.28], [191, 64.295], [192, 64.295], [194, 64.32], [195, 64.34], [196, 64.36], [197, 64.37], [198, 64.41], [199, 64.43], [200, 64.44], [201, 64.46], [202, 64.45], [203, 64.4], [204, 64.43], [205, 64.44], [206, 64.43], [207, 64.43], [208, 64.435], [209, 64.47], [212, 64.46], [213, 64.46], [214, 64.45], [215, 64.45], [216, 64.46], [217, 64.5], [218, 64.5], [219, 64.52], [220, 64.52], [221, 64.5011], [222, 64.52], [224, 64.52], [225, 64.4925], [226, 64.5], [227, 64.54], [228, 64.61], [229, 64.63], [230, 64.63], [231, 64.63], [232, 64.73], [235, 64.71], [236, 64.76], [237, 64.79], [238, 64.8], [239, 64.7675], [240, 64.71], [241, 64.67], [242, 64.69], [243, 64.66], [244, 64.66], [245, 64.62], [246, 64.645], [247, 64.62], [248, 64.61], [249, 64.59], [250, 64.59], [251, 64.59], [252, 64.59], [253, 64.59], [254, 64.59], [255, 64.58], [256, 64.62], [261, 64.655], [262, 64.65], [264, 64.64], [265, 64.65], [266, 64.59], [267, 64.56], [268, 64.57], [269, 64.59], [270, 64.585], [271, 64.56], [272, 64.54], [273, 64.56], [274, 64.57], [275, 64.59], [277, 64.59], [278, 64.61], [279, 64.64], [280, 64.65], [282, 64.69], [283, 64.67], [284, 64.68], [285, 64.66], [286, 64.64], [287, 64.58], [288, 64.55], [289, 64.55], [290, 64.55], [292, 64.5525], [293, 64.57], [294, 64.58], [295, 64.58], [296, 64.5905], [297, 64.57], [298, 64.55], [300, 64.56], [301, 64.59], [302, 64.61], [304, 64.62], [305, 64.62], [306, 64.635], [307, 64.64], [308, 64.639], [309, 64.639], [310, 64.65], [311, 64.67], [312, 64.7], [313, 64.69], [314, 64.71], [315, 64.7], [316, 64.72], [317, 64.73], [318, 64.69], [320, 64.72], [321, 64.74], [322, 64.81], [323, 64.78], [324, 64.78], [325, 64.77], [326, 64.77], [327, 64.8], [328, 64.8], [329, 64.775], [330, 64.73], [331, 64.75], [333, 64.72], [334, 64.71], [335, 64.7175], [336, 64.73], [337, 64.74], [338, 64.8], [339, 64.84], [340, 64.8], [341, 64.78], [342, 64.8], [344, 64.81], [345, 64.83], [346, 64.83], [347, 64.87], [349, 64.87], [351, 64.92], [352, 64.88], [353, 64.88], [354, 64.88], [355, 64.86], [356, 64.8699], [357, 64.805], [358, 64.81], [359, 64.8], [360, 64.74], [361, 64.75], [364, 64.8], [365, 64.78], [366, 64.79], [368, 64.805], [369, 64.78], [371, 64.795], [372, 64.78], [373, 64.76], [374, 64.77], [376, 64.78], [377, 64.78], [378, 64.7798], [379, 64.77], [380, 64.74], [381, 64.75], [382, 64.75], [383, 64.75], [384, 64.73], [385, 64.75], [386, 64.78], [387, 64.755], [388, 64.76], [393, 64.77]];
context = cubism.context().serverDelay(Date.now())
                                .step((params['simulations_p'][nbRes][0][3]/(results.length*1.0))) // Distance between data points in milliseconds
                                .size(results.length) // Number of data points
                                .stop();   // Fetching from a static data source; don't update values
			
           
            function stock(name) { 
                return context.metric(function(start, stop, step, callback) {
				
                    //d3.json(jsondata, function(rows) {
					rows = plotchartdata0[name];
					
					var allval=[]
					for (var i =0;i<rows.length;i++){
						allval.push(rows[i][1]);
					}
					var maxval=Math.max.apply( Math, allval );
					var minval=Math.min.apply( Math, allval );
					//console.log(rows)
                        var compare = rows[0][1], value = rows[0][1], values = [value];
                        
                        // Creates an array of the price differences throughout the day
                        rows.forEach(function(d) {
						//if (maxval-minval!=0){
                        //    values.push(value = ((d[1]-minval)/(maxval-minval)) );
						//	}
						//else
						//	values.push(value = ((d[1])) );
						values.push(value = ((d[1])) );
                        }); 
                    callback(null, values); //}); 
                }, name); 
            }


            function draw_graph(stocks_list) {
                d3.select("#demo")                 // Select the div on which we want to act           
                  .selectAll(".axis")              // This is a standard D3 mechanism to
                  .data(["top"])                   // bind data to a graph. In this case
                  .enter()                         // we're binding the axes "top" and "bottom".
                  .append("div")                   // Create two divs and 
                  .attr("class", function(d) {     // give them the classes
                    return d + " axis";            // top axis and bottom axis
                  })                               // respectively 
                  .each(function(d) {              // For each of these axes,
					d3.select(this)                // draw the axes with 4 intervals
                      .call(context.axis()         // and place them in their proper places
					  .ticks(20).tickFormat(d3.time.format("%L"))
                      .orient(d));  
                  });

				
                d3.select("#demo")                 
                  .selectAll(".horizon")           
                  .data(stocks_list.map(stock))    
                  .enter()                         
                  .insert("div", ".bottom")        // Insert the graph in a div  
                  .attr("class", "horizon")        // Turn the div into
                  .call(context.horizon()          // a horizon graph
                  .format(d3.format(".1g"))//.format(d3.format(".1p%"))
				  .mode("mirror")
				  );    // Format the values to 1 floating-point decimals


                context.on("focus", function(i) {
					//format = d3.format(".1f");
                    d3.selectAll(".value").style("right",                  // Make the rule coincide 
                        i == null ? null : (context.size() - i-30) + "px");//.text(format(primary.valueAt(Math.floor(i))) + "\u00B0C"); // with the mouse
						//console.log(results.length)
						if (window.event && i != null){
							$("#mytooltip")
							.html(""+i+"/"+results.length)
							.css('left', window.event.clientX+40)
							.css('top', $('#democ').position().top+($( '.axis' ).height()/2))
							//.css('top', window.event.clientY)
							.css('height', 25)
							.css('width', 80)
							.show();
						}
						else{
							$("#mytooltip").html('').hide();
						}
                });
            } 



var listCharts=[];

for (var i=0;i<indCharts.length;i++){

	listCharts.push(headTitles[indCharts[i]]);
}
//console.log(indCharts);
//console.log(plotchartdata0);
//draw_graph(headTitles.slice(3));
draw_graph(listCharts);

$("#democ2").css({top:  $("#container").position().top + $("#container").height()});
$("#select1text").css({top:  $("#democ2").position().top + $("#democ2").height()+20});
$("#mygraph").css({top:  $("#select1text").position().top + $("#select1text").height()});
$("#democ").css({top:  $("#mygraph").position().top + $("#mygraph").height()});

$("#reactionCategoryTable").css({top:  $("#democ").position().top + $("#democ").height()+50});
$("#democ4").css({top:  $("#reactionCategoryTable").position().top + $("#reactionCategoryTable").height()+20});
$("#sliderdiv").css({top:  $("#democ4").position().top + $("#democ4").height()+20});
$("#sliderdiv").width($("#hiveplot").width());
$("#hiveplot").css({top:  $("#sliderdiv").position().top + $("#sliderdiv").height()+20});	

		
	//console.log(plotchartdata)
}


function selectValue(){
		var val =document.getElementById("selectLayout").value;
		//console.log(val)
		if (parseInt(val)!=0){
			document.getElementById("qml-id").value=val;
		}
		document.getElementById("mtnl-id").value=document.getElementById("layout-selector").value;
		
	}



	
	function updateSlider2(slideAmount){
			var el = document.getElementById("selectLayout")
			var amountScale = 0.1+(0.9*(parseFloat(slideAmount)/100));
			if (parseInt(el.value)==0){
				console.log("default layout");
			}
			else {
				console.log("other layout");
				//console.log(layouts[el.value])
				var layout_nodes_coordinates={};
				for (var i=0, j=layouts[el.value].length;i<j;i++){
					if (layouts[el.value][i]['group']=='nodes'){
						layout_nodes_coordinates[layouts[el.value][i]['data']['id']]=[layouts[el.value][i]['position']['x'],layouts[el.value][i]['position']['y'] ]
					}
				}
				//console.log(selectedModelNodes);
				var cnt1=0;
				var cnt2=0;
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				for (var i=0, j=selectedModelNodes.length;i<j;i++){
					if (selectedModelNodes[i][5]==2 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
							}
							cnt1++;
					}
					if (selectedModelNodes[i][5]==4 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
							}
							cnt2++;
					}
					
				}
				scene.children[2].geometry.attributes.position.needsUpdate = true;
				scene.children[4].geometry.attributes.position.needsUpdate = true;
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				/*
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;*/
				//tokenUniforms.mixAmount.value = 0.0;
				
				
				//for (elem in layout_nodes_coordinates){
				//	if (layout_nodes_coordinates.hasOwnProperty(elem)){
						//layout_nodes_coordinates[elem]
				//	}
				//}
				
				//console.log(layout_nodes_coordinates);
				
			}	
		}
		
		function updateSlider3(slideAmount){
			var el = document.getElementById("selectLayout");
			var el2= document.getElementById("defaultSlider2");
			var amountScale = 0.1+(0.9*(parseFloat(el2.value)/100));
			var distance = (parseFloat(slideAmount)/100)*200
			
			if (parseInt(el.value)==0){
				console.log("default layout");
			}
			else {
				console.log("other layout");
				//console.log(layouts[el.value])
				var layout_nodes_coordinates={};
				for (var i=0, j=layouts[el.value].length;i<j;i++){
					if (layouts[el.value][i]['group']=='nodes'){
						layout_nodes_coordinates[layouts[el.value][i]['data']['id']]=[layouts[el.value][i]['position']['x'],layouts[el.value][i]['position']['y'] ]
					}
				}
				//console.log(selectedModelNodes);
				var cnt1=0;
				var cnt2=0;
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				for (var i=0, j=selectedModelNodes.length;i<j;i++){
					if (selectedModelNodes[i][5]==2 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
								//console.log(scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1])//=50;
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=200;
							}
							cnt1++;
					}
					if (selectedModelNodes[i][5]==4 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=50;
								//console.log(scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1])//=50;
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1]=200-distance;
							}
							cnt2++;
					}
					
				}
				scene.children[2].geometry.attributes.position.needsUpdate = true;
				scene.children[4].geometry.attributes.position.needsUpdate = true;
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				
				/*var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				//tokenUniforms.mixAmount.value = 0.0;*/
				
				
				//for (elem in layout_nodes_coordinates){
				//	if (layout_nodes_coordinates.hasOwnProperty(elem)){
						//layout_nodes_coordinates[elem]
				//	}
				//}
				
				//console.log(layout_nodes_coordinates);
				
			}	
		}
		
		

///////////////////////////////////////////////////		
if (stats2.length>0){
var margins = {
    top: 12,
    left: 450,
    right: 24,
    bottom: 24
},
legendPanel = {
    width: 180
},
width = 900- margins.left - margins.right - legendPanel.width,
    height = (names.length*20) - margins.top - margins.bottom,
    dataset = stats2,
    mseries = dataset.map(function (d) {
        return d.name;
    }),
    dataset = dataset.map(function (d) {
        return d.data.map(function (o, i) {
            // Structure it so that your numeric
            // axis (the stacked amount) is y
            return {
                y: o.nb_token,
                x: o.transition
            };
        });
    }),
    stack = d3.layout.stack();

stack(dataset);

var dataset = dataset.map(function (group) {
    return group.map(function (d) {
        // Invert the x and y values, and y0 becomes x0
        return {
            x: d.y,
            y: d.x,
            x0: d.y0
        };
    });
}),
	svg3 = d3.select("#democ2")//.append("svg")//svg = d3.select('body')
        .append('svg')
        .attr('width', width + margins.left + margins.right + legendPanel.width)
        .attr('height', height + margins.top + margins.bottom)
        .append('g')
        .attr('transform', 'translate(' + margins.left + ',' + margins.top + ')'),
    xMax = d3.max(dataset, function (group) {
        return d3.max(group, function (d) {
            return d.x + d.x0;
        });
    }),
	
    xScale = d3.scale.linear()
        .domain([0, xMax])
        .range([0, width]),
    months = dataset[0].map(function (d) {
		//if (d.y==""){console.log("empty name")}
        //return d.y.substring(0, 20);//
		return d.y ;
    }),
    //_ = console.log(months),
    yScale = d3.scale.ordinal()
        .domain(months)
        //.rangeRoundBands([0, height]),
		.rangeRoundBands([0, height*0.953], .1),
	//_ = console.log(height),
    xAxis = d3.svg.axis()
        .scale(xScale)
        .orient('bottom'),
    yAxis = d3.svg.axis()
        .scale(yScale)
        .orient('left'),
	
    colours = d3.scale.category10(),
    groups = svg3.selectAll('g')
        .data(dataset)
        .enter()
        .append('g')
        .style('fill', function (d, i) {
        return colours(i);
    }),
    rects = groups.selectAll('rect')
        .data(function (d) {
        return d;
    })
        .enter()
        .append('rect')
        .attr('x', function (d) {
        return xScale(d.x0);
    })
        .attr('y', function (d, i) {
			//console.log(yScale(d.y))
        return yScale(d.y);
    })
        .attr('height', function (d) {
        return yScale.rangeBand();
    })
        .attr('width', function (d) {
        return xScale(d.x);
    })
        .on('mouseover', function (d,i) {
        //var xPos = parseFloat(d3.select(this).attr('x')) / 2 + width / 2;
        //var yPos = parseFloat(d3.select(this).attr('y')) + yScale.rangeBand() / 2;
		//console.log(i)
		
		var tot =0;
		for (var ind=0;  ind<lengthStats; ind++){
			tot+=stats2[ind]['data'][i]['nb_token'];
		}
		var st = "name: <i>"+d.y+"</i> - nb of token: "+d.x+"/"+tot+" <br>"
		for (var ind=0;  ind<lengthStats; ind++){
			
			st +=" sample "+ind+": <b>"+stats2[ind]['data'][i]['nb_token']+"</b>";
			if (ind!=0 && (ind%9==0)){
				st +="<br> ";
			}
		}
		st +=" total: <b>"+tot+"</b>";
		$("#mtooltip")
                      .html(st)//.html("name: <i>"+d.y+"</i> - nb of token: <b>"+d.x+"</b>") // stats2[0]['data'][i]['nb_token'])
					  .css('left', window.event.clientX+40)
                      .css('top', $("#democ2").position().top +parseFloat(d3.select(this).attr('y')) + yScale.rangeBand() / 2)
					  //.css('top', $("#democ2").position().top + $("#democ2").height()+window.event.clientY)
                      .show();
        //d3.select('#mtooltip')
        //    .style('left', xPos + 'px')
        //    .style('top', yPos + 'px')
        //    .select('#value')
        //    .text(d.x);

        //d3.select('#mtooltip').classed('hidden', false);
    })
        .on('mouseout', function () {
		$("#mtooltip").html('');
		$("#mtooltip").hide();
		//document.getElementById("mytooltip").setAttribute("type", "hidden");
		//x.setAttribute("type", "hidden");
        //d3.select('#mtooltip').classed('hidden', true);
    })

    svg3.append('g')
        .attr('class', 'maxis2')
        .attr('transform', 'translate(0,' + height + ')')
        .call(xAxis);

svg3.append('g')
    .attr('class', 'maxis2')
    .call(yAxis);

svg3.append('rect')
    .attr('fill', 'yellow')
    .attr('width', 160)
    .attr('height', 30 * dataset.length)
    .attr('x', width + margins.left-450)
    .attr('y', 0);

mseries.forEach(function (s, i) {
	
    svg3.append('text')
        .attr('fill', 'black')
        .attr('x', width + margins.left + 8-450)
        .attr('y', i * 24 + 24)
        .text(s);
    svg3.append('rect')
        .attr('fill', colours(i))
        .attr('width', 60)
        .attr('height', 20)
        .attr('x', width + margins.left + 90-450)
        .attr('y', i * 24 + 6);
});		
}

//////////////////////////////////////////////
// adjacency matrix

var constraints = <%-JSON.stringify( exp.qsspn_model_instance.qssf.constraints) %>;
var indexcol=-1;
var indexrow=-1;
var constraints2Fluxes={};
var fluxes=[];
for (var i=0; i<constraints.length;i++ ){
	constraints2Fluxes[constraints[i]["constraint"]["name"]]=constraints[i]["constraint"]["flux_list"];
	fluxes=$.unique(fluxes.concat(constraints[i]["constraint"]["flux_list"]));
}
var constraints = Object.keys(constraints2Fluxes);
//console.log(constraints)
//console.log(constraints2Fluxes)
//console.log(fluxes)


/*
	var detailMTN={};
	var listMTN={};
	var tmpListModelNodes={};
	var mtns={};
	var aresults ={};
	
	mtns[mtb['name']]=mtb['file'][1];
	
	for (var i=0, j= qm.extra[3].length; i<j; i++){
		if (qm.extra[3][i][3]==2){
			//var name_model_node= 
			if (tmpListModelNodes.hasOwnProperty(qm.extra[2][qm.extra[3][i][0]][1])){
				tmpListModelNodes[qm.extra[2][qm.extra[3][i][0]][1]].push(mtns[mtb.name][qm.extra[3][i][1]][1]);
				if (detailMTN.hasOwnProperty(mtb.name)){
					if (detailMTN[mtb.name].indexOf(mtns[mtb.name][qm.extra[3][i][1]][1])==-1){
						
						detailMTN[mtb.name].push(mtns[mtb.name][qm.extra[3][i][1]][1]);
					}
				}
				else{
					detailMTN[mtb.name]=[];
					detailMTN[mtb.name].push(mtns[mtb.name][qm.extra[3][i][1]][1]);
					
				}
			}
			else{
				tmpListModelNodes[qm.extra[2][qm.extra[3][i][0]][1]]=[];
				tmpListModelNodes[qm.extra[2][qm.extra[3][i][0]][1]].push(mtns[mtb.name][qm.extra[3][i][1]][1]);
				if (detailMTN.hasOwnProperty(mtb.name)){
					if (detailMTN[mtb.name].indexOf(mtns[mtb.name][qm.extra[3][i][1]][1])==-1){
						
						detailMTN[mtb.name].push(mtns[mtb.name][qm.extra[3][i][1]][1]);
					}
				}
				else{
					detailMTN[mtb.name]=[];
					detailMTN[mtb.name].push(mtns[mtb.name][qm.extra[3][i][1]][1]);
					
				}
			}
		
		}
	}
	listMTN[qm.name]=[mtb.name,tmpListModelNodes];
	
	
	var myListModels=Object.keys(listMTN);
	var mylistMTN=Object.keys(detailMTN);
	//console.log(listMTN)
	//console.log(detailMTN)
	var adata;
	for (el0 in listMTN ){
		if (listMTN.hasOwnProperty(el0)) {
			adata = [];
			for (var j = 0, jl =detailMTN[listMTN[el0][0]].length; j < jl; j += 1) {
				var tmpdata = [];
				for (var k = 0, kl = Object.keys(listMTN[el0][1]).length; k < kl; k += 1) {
					if (listMTN[el0][1][Object.keys(listMTN[el0][1])[k]].indexOf(detailMTN[listMTN[el0][0]][j])>-1){
					tmpdata.push(1);
					}
					else{
					tmpdata.push(0);
					}
				}
				adata.push(tmpdata);
			}
			aresults[el0]=adata;
		}
	}
	
	var nbModel=0;
	var adata = [];
	for (var j = 0, jl =detailMTN[listMTN[myListModels[nbModel]][0]].length; j < jl; j += 1) {
		var tmpdata = [];
		for (var k = 0, kl = Object.keys(listMTN[myListModels[nbModel]][1]).length; k < kl; k += 1) {
			if (listMTN[myListModels[nbModel]][1][Object.keys(listMTN[myListModels[nbModel]][1])[k]].indexOf(detailMTN[listMTN[myListModels[nbModel]][0]][j])>-1){
			tmpdata.push([0, detailMTN[listMTN[myListModels[nbModel]][0]][j]]);
			}
			else{
			tmpdata.push([0,""]);
			}
		}
		adata.push(tmpdata);
	}
	*/
	var nbModel=0;
	var adata = [];
	for (var j = 0, jl =fluxes.length; j < jl; j += 1) {
		var tmpdata = [];
		for (var k = 0, kl = constraints.length; k < kl; k += 1) {
			if (constraints2Fluxes[constraints[k]].indexOf(fluxes[j])>-1){
			tmpdata.push([-1, fluxes[j]]);
			}
			else{
			tmpdata.push([-1,""]);
			}
		}
		adata.push(tmpdata);
	}
	
	//console.log(listMTN);
	//console.log(detailMTN);
    // Make the changes
	//$("#democ0").html("");
	var width = window.innerWidth / 5,
    height = window.innerHeight *0.6,
    mdiv = d3.select('#democ4'),
    msvg = mdiv.append('svg')
        .attr('width', width)
        .attr('height', height),
	rw = width/constraints.length,
    rh = height/fluxes.length;
	
	var line1 = msvg.append("line")
        .attr("x1", 5)
        .attr("y1", 5)
        .attr("x2", 50)
        .attr("y2", 50)
        .attr("stroke-width", 0)                         
		.attr("stroke", "black")
		.attr('class', function(d,i){ return "ln1"; });
	var line2 = msvg.append("line")
        .attr("x1", 5)
        .attr("y1", 5)
        .attr("x2", 50)
        .attr("y2", 50)
        .attr("stroke-width", 0)                         
		.attr("stroke", "black")
		.attr('class', function(d,i){ return "ln2"; });
	var line3 = msvg.append("line")
        .attr("x1", 5)
        .attr("y1", 5)
        .attr("x2", 50)
        .attr("y2", 50)
        .attr("stroke-width", 0)                         
		.attr("stroke", "black")
		.attr('class', function(d,i){ return "ln3"; });
	var line4 = msvg.append("line")
        .attr("x1", 5)
        .attr("y1", 5)
        .attr("x2", 50)
        .attr("y2", 50)
        .attr("stroke-width", 0)                         
		.attr("stroke", "black")
		.attr('class', function(d,i){ return "ln4"; });	
		
	//var msvg = d3.select("#democ0").transition();
	var grp = msvg.selectAll('g')
		.data(adata)
		.enter()
		.append('g')
		.attr('class', function(d,i){ return "row" + i; })
		.attr('transform', function(d, i) {
			return 'translate(0, ' + (rh*1.0) * i + ')';
		})
		.on('mouseover', function(d,i,j) {
			d3.select(".ln3")
				.attr("x1", 0)
				.attr("y1", (rh*1.0) * i)
				.attr("x2", width)
				.attr("y2", ((rh*1.0) * i))
				.attr("stroke-width", 0.3) ;
			d3.select(".ln4")
				.attr("x1", 0)
				.attr("y1", ((rh*1.0) * i)+rh)
				.attr("x2", width)
				.attr("y2", ((rh*1.0) * i)+rh)
				.attr("stroke-width", 0.3) ;
					//console.log(i)
					//indexrow=i;
					
					//d3.selectAll(".col" + indexcol)
					//.style({'stroke-opacity':0.3,'stroke':'#0000aa', 'stroke-width':0.3});
					//.style('background-color', 'yellow');
					//d3.select(".row" + i)
					//.style({'stroke-opacity':0.3,'stroke':'#000', 'stroke-width':1});
					//.style("fill", "gray")
					//.style('background-color', 'green');
					//d3.select(this).transition().duration(10)
					//.style({'stroke-opacity':0.3,'stroke':'#000', 'stroke-width':1});
		})
		.on("mouseout", function(d,i) {
			d3.select(".ln3")
				.attr("stroke-width", 0.0) ;
			d3.select(".ln4")
				.attr("stroke-width", 0.0) ;
					//d3.selectAll(".row" + i)
					//.style({'stroke-opacity':0.0,'stroke':'#000000', 'stroke-width':0.0});
					//indexrow=i;
					//d3.selectAll(".row" + i)
					//.style({'stroke-opacity':0.0, 'stroke-width':0});
					//d3.selectAll(".col" + indexcol)
					//.style({'stroke-opacity':0.0, 'stroke-width':0});
					//indexcol=-1;
					//.style('background-color', 'transparent');
					//d3.select(".row" + i)
					//.style({'stroke-opacity':0.0,'stroke':'#000', 'stroke-width':0});
					//.style('background-color', 'transparent');
				   //d3.select(this).transition().duration(100)
					//.style({'stroke-opacity':0.0,'stroke':'transparent','stroke-width':0});
		});
		
	

	// For each group, create a set of rectangles and bind 
	// them to the inner array (the inner array is already
	// binded to the group)
	grp.selectAll('rect')
		.data(function(d) { return d; })
		.enter()
		.append('rect')
        .attr('x', function(d, i) { return (rw*1.0 )* i; })
        .attr('width', rw)
        .attr('height', rh)
		.attr('class', function(d,i){ return "col" + i; })
		.style("fill", function(d, i) { if (d[1]!="") {return "gray"} else return "transparent"})
		.on('mouseover', function(d,i,j) {
				//console.log(i)
				//indexcol=i;
				//
				d3.select(".ln1")
				.attr("x1", (rw*1.0 )* i)
				.attr("y1", 0)
				.attr("x2", (rw*1.0 )* i)
				.attr("y2", height)
				.attr("stroke-width", 0.3) ;
				d3.select(".ln2")
				.attr("x1", ((rw*1.0 )* i)+rw)
				.attr("y1", 0)
				.attr("x2", ((rw*1.0 )* i)+rw)
				.attr("y2", height)
				.attr("stroke-width", 0.3) ;
				//d3.selectAll(".col" + i)
				//.style({'stroke-opacity':0.3,'stroke':'#0000aa', 'stroke-width':0.3});
				//d3.selectAll(".row" + indexrow)
				//.style({'stroke-opacity':0.3,'stroke':'#0000aa', 'stroke-width':0.3});	
					disableSelection=true;
					if (d[1]!=""){
					//d3.select(this).transition().duration(10)
					//.style({'stroke-opacity':1,'stroke':'#000', 'stroke-width':0});
					$("#mytooltip3")
                      .html("Link between: <br>Model constraint: <b>"+constraints[i]+"</b><br>and reaction: <b>"+fluxes[j]) //listMTN[myListModels[nbModel]][1]
					  .css('left', window.event.clientX+40)
                      .css('top', window.event.clientY)
                      .show();
					}
					
                    
		})
		.on("mouseout", function(d,i) {
			d3.select(".ln1")
				.attr("stroke-width", 0.0) ;
			d3.select(".ln2")
				.attr("stroke-width", 0.0) ;
					//d3.selectAll(".col" + i)
					//.style({'stroke-opacity':0.0,'stroke':'#0000aa', 'stroke-width':0.0});
					//d3.selectAll(".row" + indexrow)
					//.style({'stroke-opacity':0.0,'stroke':'#0000aa', 'stroke-width':0.0});
					disableSelection=false;
				   $("#mytooltip3").html('').hide();
				   //d3.select(this).transition().duration(100)
					//.style({'stroke-opacity':0.0,'stroke':'transparent','stroke-width':0});
		});
	
		
		
//$("#democ4").css({top:  $("#democ3").position().top + $("#democ3").height()});
var sfbaReacM={};
var dataJsonSfba=<%-JSON.stringify(exp.sfba_model_instance)%>;
var tmpN="";
var tmpS="";
for (var i=0,j=dataJsonSfba.length;i<j;i++){
	if(dataJsonSfba[i]){
		tmpN=dataJsonSfba[i][0];
		tmpS=dataJsonSfba[i][1];
		var aString=tmpS.replace(/(\d+\.\d+)|(\+)|(\=)/g, "").split(/\s+/);
		sfbaReacM[tmpN]=aString;
		//console.log(rString)
	}
}

var sfbaGeneralReactionMap={}
var k_sfbaReacM=Object.keys(sfbaReacM);
for (var i=0, j=k_sfbaReacM.length;i<j;i++){
	var components = sfbaReacM[k_sfbaReacM[i]];
	var cl =components.length;
	for (var i1=0, j1=k_sfbaReacM.length;i1<j1;i1++){
		if (i1!=i){
			var components2 = sfbaReacM[k_sfbaReacM[i1]];
			for (var c=0;c<cl;c++){
				var ind = components2.indexOf(components[c]);
				if (ind!=-1){
					if (sfbaGeneralReactionMap.hasOwnProperty(k_sfbaReacM[i])){
						if (sfbaGeneralReactionMap[k_sfbaReacM[i]].indexOf(k_sfbaReacM[i1])==-1){
							sfbaGeneralReactionMap[k_sfbaReacM[i]].push(k_sfbaReacM[i1]);
						}
						
					}
					else{
						sfbaGeneralReactionMap[k_sfbaReacM[i]]=[];
						
						sfbaGeneralReactionMap[k_sfbaReacM[i]].push(k_sfbaReacM[i1]);
						
					}
				}
			}
		}	
	}
	
}


var nbCloneAxis=0;
var nbAxis=0;

var $container14 = $("#reactionCategoryTable");
$container14.handsontable({
	data: [],
	width: 400,
	height:300,
	dataSchema: {reaction: null, category: null},
	startRows: 5,
	startCols: 4,
	colHeaders: ['reaction', 'category', ],
	columns: [
	{data: "reaction"},
	{data: "category"},
	],
	afterChange: function(changes, source) {
		var dt = this.getData();	
		categoriesReactions={};
		reactionsCategories={};
		var countPerCategory={};
		for (var i=0, j= dt.length;i<j-1;i++){
			var tmpReaction = dt[i].reaction;
			var tmpCategory = dt[i].category;
			//if (tmpCategory!="null"){
				if (categoriesReactions.hasOwnProperty(tmpCategory)){
					if (categoriesReactions[tmpCategory].indexOf(tmpReaction)==-1){
						categoriesReactions[tmpCategory].push(tmpReaction);
					}
				}
				else {
					categoriesReactions[tmpCategory]=[];
					categoriesReactions[tmpCategory].push(tmpReaction);
				}
			//}
		}
		//console.log(categoriesReactions)
		for (var i=0, j= dt.length;i<j-1;i++){
			var tmpReaction = dt[i].reaction;
			var tmpCategory = dt[i].category;
			//if (tmpCategory!="null"){
				if (reactionsCategories.hasOwnProperty(tmpReaction)){
					if (reactionsCategories[tmpReaction].indexOf(tmpCategory)==-1){
						reactionsCategories[tmpReaction].push(tmpCategory);
					}
				}
				else {
					reactionsCategories[tmpReaction]=[];
					reactionsCategories[tmpReaction].push(tmpCategory);
				}
			//}
		}
		
		var listCategory = Object.keys(categoriesReactions);
		for (var i=0, j=listCategory.length;i<j;i++){
			countPerCategory[listCategory[i]]=0;
		}
		
		
		var listCloneCategory = [];
		nbCloneAxis=0;
		var listReactions = Object.keys(reactionsCategories);
		//console.log(listCategory)
		var hwidth = (screen.width*0.5),
		hheight = screen.height*0.9,
		innerRadius = 40,
		outerRadius = (screen.height*0.7)/2;
		nbAxis = listCategory.length;
		
		var angle = d3.scale.ordinal().domain(d3.range(nbAxis+1)).rangePoints([0, 2 * Math.PI]),
		radius = d3.scale.linear().range([innerRadius, outerRadius]),
		color = d3.scale.category10().domain(d3.range(20));
		//console.log(angle)
		//console.log(reactionsCategories)
		nodes =[];
		var listDisplayedNodes=[];
		links = [];
		for (var i=0,j=listReactions.length;i<j;i++){
			if (sfbaGeneralReactionMap.hasOwnProperty(listReactions[i])) {
				//var laxis=categoriesReactions[reactionsCategories[listReactions[i]][0]].length;
				var indexSource;
				var indexTarget;
				if(listDisplayedNodes.indexOf(listReactions[i])==-1){
					listDisplayedNodes.push(listReactions[i]);
					indexSource=listDisplayedNodes.length-1;
					//nodes.push({x: listCategory.indexOf(reactionsCategories[listReactions[i]][0]), y: (countPerCategory[reactionsCategories[listReactions[i]][0]]/(categoriesReactions[reactionsCategories[listReactions[i]][0]].length))*(categoriesReactions[reactionsCategories[listReactions[i]][0]].length/100)});
					nodes.push({x: listCategory.indexOf(reactionsCategories[listReactions[i]][0]), y: (countPerCategory[reactionsCategories[listReactions[i]][0]]/(categoriesReactions[reactionsCategories[listReactions[i]][0]].length))*(categoriesReactions[reactionsCategories[listReactions[i]][0]].length/100), nname:listReactions[i]});
					
					countPerCategory[reactionsCategories[listReactions[i]][0]]+=1;
				}
				else{
					indexSource=listDisplayedNodes.indexOf(listReactions[i]);
				}
				for(var i1=0,j1=sfbaGeneralReactionMap[listReactions[i]].length;i1<j1;i1++){
					var nextNode= sfbaGeneralReactionMap[listReactions[i]][i1];
					if(listDisplayedNodes.indexOf(nextNode)==-1){
						if (reactionsCategories[nextNode]){
							if (listCategory.indexOf(reactionsCategories[nextNode][0])!=-1){
								if (listCategory.indexOf(reactionsCategories[nextNode][0])!=listCategory.indexOf(reactionsCategories[listReactions[i]][0])){
									listDisplayedNodes.push(nextNode);
									indexTarget=listDisplayedNodes.length-1;
									//nodes.push({x: listCategory.indexOf(reactionsCategories[nextNode][0]), y: (countPerCategory[reactionsCategories[nextNode][0]]/(categoriesReactions[reactionsCategories[nextNode][0]].length))*(categoriesReactions[reactionsCategories[nextNode][0]].length/100)});
									nodes.push({x: listCategory.indexOf(reactionsCategories[nextNode][0]), y: (countPerCategory[reactionsCategories[nextNode][0]]/(categoriesReactions[reactionsCategories[nextNode][0]].length))*(categoriesReactions[reactionsCategories[nextNode][0]].length/100), nname:nextNode});
									
									countPerCategory[reactionsCategories[nextNode][0]]+=1;
									links.push({source: nodes[indexSource], target: nodes[indexTarget]})
								}
								else{
									/*if (listCloneCategory.indexOf(reactionsCategories[nextNode][0])==-1){
										listCloneCategory.push(reactionsCategories[nextNode][0]);
										nbCloneAxis++;
									}*/
									//console.log(nbAxis+listCloneCategory.indexOf(reactionsCategories[nextNode][0]))
									listDisplayedNodes.push(nextNode);
									indexTarget=listDisplayedNodes.length-1;
									//nodes.push({x: listCategory.indexOf(reactionsCategories[nextNode][0]), y: 1.0+(countPerCategory[reactionsCategories[nextNode][0]]/(categoriesReactions[reactionsCategories[nextNode][0]].length))*(categoriesReactions[reactionsCategories[nextNode][0]].length/100)});
									nodes.push({x: listCategory.indexOf(reactionsCategories[nextNode][0]), y: (countPerCategory[reactionsCategories[nextNode][0]]/(categoriesReactions[reactionsCategories[nextNode][0]].length))*(categoriesReactions[reactionsCategories[nextNode][0]].length/100), nname:nextNode});
									countPerCategory[reactionsCategories[nextNode][0]]+=1;
									//nodes.push({x: (nbAxis+listCloneCategory.indexOf(reactionsCategories[nextNode][0])), y: Math.random()});
									//nodes.push({x: nbAxis+listCloneCategory.indexOf(reactionsCategories[nextNode][0]), y: Math.random()});
									
									links.push({source: nodes[indexSource], target: nodes[indexTarget]})
								}
							}
						}
					}
				}
				//nodes.push({x: listCategory.indexOf(reactionsCategories[listReactions[i]]) Math.floor((Math.random() * nbAxis)), y: Math.random() });
				//nodes.push({x: Math.floor((Math.random() * nbAxis)), y: Math.random() });
				//links.push({source: nodes[nodes.length-2], target: nodes[nodes.length-1]})
			}
		}
		//console.log(listCloneCategory)
		//console.log(nbCloneAxis)
		//for (var i=0,j=listReactions.length;i<j;i++){
		//	if (sfbaGeneralReactionMap.hasOwnProperty(listReactions[i])) {
		//		for(){
				
		//		}
		//	}
		//}
		//console.log(nodes)
		//console.log(links)
		//for (elem in sfbaGeneralReactionMap){
		//	if (sfbaGeneralReactionMap.hasOwnProperty(elem)) {
				//sfbaGeneralReactionMap[elem]
				//nodes.push({x: (Math.random() * nbAxis), y: Math.random() });
				//nodes.push({x: (Math.random() * nbAxis), y: Math.random() });
				//links.push({source: nodes[nodes.length-2], target: nodes[nodes.length-1]})
		//	}
		//}
		
		//var nbReactionsPerSub={};
		// create nodes and links data
		
		/*for (elem in chartData){
			//if (chartData.hasOwnProperty(elem)) {
				//console.log(chartData[elem]/tnbReactions);
				//for (var i=0, j=chartData[elem]; i<j;i++){
					
					nodes.push({x: (Math.random() * nbAxis), y: Math.random() });
					nodes.push({x: (Math.random() * nbAxis), y: Math.random() });
					links.push({source: nodes[nodes.length-2], target: nodes[nodes.length-1]})
				//}
			//}
			nbElem++;
		}*/
		
		
		
		
		
		//document.getElementById("hivePlot").style.top =$("#democ0").position().top+(window.innerHeight *0.6)+150 + 'px';
		//$("#hiveplot").css({top:  $("#democ4").position().top + $("#democ4").height()});
		$("#hiveplot").html("");
		
		
		var svg2 = d3.select("#hiveplot").append("svg")
			.attr("width", hwidth)
			.attr("height", hheight)	
			
			.append("g")
			.call(d3.behavior.zoom().scaleExtent([0.01, 12]).on("zoom", zoom))
			
			.append("g")
			.attr("transform", "translate(" + hwidth / 2 + "," + hheight / 2 + ")");
		
		svg2.append('rect')
       .classed('background', true)
       .attr('y',-100000)
       .attr('x', -100000)
       .attr('height', 200000)
       .attr('width', 200000)
       .attr('fill', 'white')
		//console.log(d3.range(nbAxis))
		svg2.selectAll(".hvaxis")
			.data(d3.range(nbAxis+nbCloneAxis))
		  .enter().append("line")
			.attr("class", "hvaxis")
			.attr("transform", function(d) {if (d<nbAxis) {return "rotate(" + degrees(angle(d)) + ")"} else{return "rotate(" + (degrees(angle(listCategory.indexOf(listCloneCategory[d-nbAxis])))+((360/nbAxis)/4)) + ")"  }})
			.attr("x1", radius.range()[0])
			.attr("x2", radius.range()[1]);
		svg2.append("text")
					.attr("id", "axislabel0")
					.attr("x", 0)
					.attr("y", 0)
					.text("Reactions by category")
					.attr("text-anchor", "middle")
					.attr("style", "fill: black")
					.attr("dy", -(hheight / 2)*0.90)
					.attr("dx", 0);
		
		var mnbElem=0;
		for (var i=0;i< listCategory.length;i++){		
				svg2.append("text")
					.attr("id", "axislabel"+(mnbElem))
					.attr("x", Math.sin(((mnbElem)*(2.0*Math.PI/(nbAxis))))*(width / 1.0)*1.1)
					.attr("y", -Math.cos(((mnbElem)*(2.0*Math.PI/(nbAxis))))*(width / 1.0)*1.1)
					.text(""+listCategory[i].substring(0, 4))
					.attr("text-anchor", "middle")
					.attr("style", "fill: black;fontSize:5px");
					//.attr("dy", )
					//.attr("dx", );
				//console.log(mnbElem+1)
				//console.log(nbAxis)
				mnbElem++;
		}

		
		svg2.selectAll(".hvnode")
			.data(nodes)
		  .enter().append("circle")
			.attr("class", "hvnode")
			.attr("transform", function(d) { if (d.x<nbAxis) {return "rotate(" + degrees(angle(d.x)) + ")"; } else{return "rotate(" + (degrees(angle(listCategory.indexOf(listCloneCategory[d.x-nbAxis])))+((360/nbAxis)/4)) + ")";} })
			.attr("cx", function(d) { return radius(d.y); })
			.attr("r", 0.5)
			//.style("fill", function(d) { return color(d.x); })
			.style("fill", function(d) { return "gray"; })
			.on("mouseover", nodeMouseover)
			.on("mouseout", mouseout);
			
		svg2.selectAll(".hvlink")
			.data(links)
		  .enter().append("path")
			.attr("class", "hvlink")
			.attr("d", d3.hive.link(nbAxis+nbCloneAxis)
				.angle(function(d) { return angle(d.x); })//return angle((angle(listCategory.indexOf(listCloneCategory[d.x-nbAxis])))+((2*Math.PI/nbAxis)/4));} })
				.radius(function(d) { return radius(d.y); }))
			//.attr("stroke", function(d) { return color(d.source.x); })
			.attr("stroke", function(d) { return "gray"; })
			.on("mouseover", linkMouseover)
			.on("mouseout", mouseout);
			//
		
		
		function nodeMouseover(d) {
			
			var neiNodeList = [];
			svg2.selectAll(".hvlink").classed("active", function (p) {
				
				if (p.source.x == d.x && p.source.y == d.y) {
					neiNodeList.push(p.target);
				}
				if (p.target.x == d.x && p.target.y == d.y ) {
					neiNodeList.push(p.source);
				}
				return p.source === d || p.target === d;
			});
			//nodename.text(""+d.nname);
			//console.log(d.nname)
			d3.select(this).classed("active", true);
			$("#mytooltip4")
                      .html("Reaction: <b>"+d.nname+"</b>")
					  .css('left', window.event.clientX+40)
                      .css('top', window.event.clientY)
                      .show();
			//if (Object.keys( nbReactionsPerSub )[d.x-1]){
			//	nodename.text("Nodes from "+Object.keys( nbReactionsPerSub )[d.x-1] + ": "+ (d.y*tnbReactions));
			//}
			//else{
			//	nodename.text("Metabolite nodes: "+ Math.floor(d.y*maxNBMetabolitesPerReaction));
			//}
			
		}	
		function linkMouseover(d) {
					svg2.selectAll(".hvlink").classed("active", function (p) {
						
						return p === d;
					});
					$("#mytooltip4")
                      .html("link between reaction: <b>"+d.source.nname+"</b> and: <b>"+d.target.nname+"</b>")
					  .css('left', window.event.clientX+40)
                      .css('top', window.event.clientY)
                      .show();
					//d3.select(this).classed("active", true);
					svg2.selectAll(".hvnode").classed("active", function (p) {
						
						return p === d.source || p === d.target;
					});
					
					
		}
		
		// Clear any highlighted nodes or links.
		function mouseout() {
			svg2.selectAll(".active").classed("active", false);
			$("#mytooltip4").html('').hide();
		}
		function zoom() {
		  svg2.attr("transform", "translate(" + (d3.event.translate[0] + (hwidth / 2)*d3.event.scale )+","+ (d3.event.translate[1]+ (hheight / 2)*d3.event.scale) +")scale(" + d3.event.scale + ")");
		}
		

		function degrees(radians) {
		  return radians / Math.PI * 180 - 90;
		}
		
		
	},
	minSpareRows: 1
});


function updateSliderh(slideAmount){
	//console.log(slideAmount);
	var slide= parseInt(slideAmount);
	document.getElementById("textslider2").value=slideAmount;
	var totalSlide= results.length;
	
	
		
	
	
	adata = [];
	for (var j = 0, jl =fluxes.length; j < jl; j += 1) {
		var tmpdata = [];
		for (var k = 0, kl = constraints.length; k < kl; k += 1) {
			if (constraints2Fluxes[constraints[k]].indexOf(fluxes[j])>-1){
				var nodeIndex=headTitles.indexOf(constraints[k]);
				
				if (nodeIndex>2){
				
					
					if (parseInt(results[slide][nodeIndex])!= 0 && parseInt(results[slide][nodeIndex])!= 1 && parseInt(results[slide][nodeIndex])!= 2)
						tmpdata.push([-1, fluxes[j]]);
					else{
						tmpdata.push([results[slide][nodeIndex], fluxes[j]]);
						//console.log(tmpdata[tmpdata.length-1])
						}
				}
				else{
					tmpdata.push([-1, fluxes[j]]);
				}
			
			}
			else{
			tmpdata.push([-1,""]);
			}
		}
		adata.push(tmpdata);
	}
	//console.log(adata)
	var svgd4= d3.select("#democ4").select("svg");
	svgd4.selectAll('g').data(adata).selectAll('rect').data(function(d) { return d; })
		.style("fill", function(d, i) { if (d[1]!="") { if (d[0]==0) {return "yellowgreen"} else if (d[0]==1) {return "orange"} else if (d[0]==2) {return "red"} else return "gray"} else return "transparent" });
	
	
	
	// $("#democ4").html("");
	// var width = window.innerWidth / 5,
    // height = window.innerHeight *0.6,
    // mdiv = d3.select('#democ4'),
    // msvg = mdiv.append('svg')
        // .attr('width', width)
        // .attr('height', height),
	// rw = width/constraints.length,
    // rh = height/fluxes.length;
	// //var msvg = d3.select("#democ0").transition();
	// var grp = msvg.selectAll('g')
		// .data(adata)
		// .enter()
		// .append('g')
		// .attr('transform', function(d, i) {
			// return 'translate(0, ' + (rh*1.0) * i + ')';
		// });

	// // For each group, create a set of rectangles and bind 
	// // them to the inner array (the inner array is already
	// // binded to the group)
	// grp.selectAll('rect')
		// .data(function(d) { return d; })
		// .enter()
		// .append('rect')
        // .attr('x', function(d, i) { return (rw*1.0 )* i; })
        // .attr('width', rw)
        // .attr('height', rh)
		// .style("fill", function(d, i) { if (d[1]!="") {if (d[0]==0) {return "cyan"} else if (d[0]==1) {return "orange"} else if (d[0]==2) {return "red"} else return "gray"} else return "transparent"})
		// .on('mouseover', function(d,i,j) {
					// disableSelection=true;
					// if (d[1]!=""){
					// d3.select(this).transition().duration(10)
					// .style({'stroke-opacity':1,'stroke':'#000', 'stroke-width':1});
					// $("#mytooltip3")
                      // .html("Link between: <br>Model node: <b>"+constraints[i]+"</b><br>and Metabolic node: <b>"+fluxes[j]) //listMTN[myListModels[nbModel]][1]
					  // .css('left', window.event.clientX+40)
                      // .css('top', window.event.clientY)
                      // .show();
					// }
                    
		// })
		// .on("mouseout", function(d,i) {
					// disableSelection=false;
				   // $("#mytooltip3").html('').hide();
				   // d3.select(this).transition().duration(100)
					// .style({'stroke-opacity':0.0,'stroke':'transparent','stroke-width':0});
		// });
	
	
	
	var innerRadius = 40;
	var outerRadius = (screen.height*0.7)/2;
		
	var radius = d3.scale.linear().range([innerRadius, outerRadius]);
	
	if (document.getElementById("checkslider2").checked){
		for (var i=0, j=nodes.length;i<j;i++){
				var nodeIndex=headTitles.indexOf(nodes[i]['nname']);
				if (nodeIndex>2){
					nodes[i]['y']=results[slide][nodeIndex]+1.0;
				}
				
		}
	}
	
	var colorLow = 'blue', colorMed = 'gray', colorHigh = 'red';
	var colorScale = d3.scale.linear()
	.domain([-1, 0, 1])
	.range([colorLow, colorMed, colorHigh]);
	var angle = d3.scale.ordinal().domain(d3.range(nbAxis+1)).rangePoints([0, 2 * Math.PI]),
		radius = d3.scale.linear().range([innerRadius, outerRadius]);
	var svgh= d3.select("#hiveplot").select("svg");
	//console.log(results[slide])
	//console.log(headTitles[3])
	//console.log(results[slide][3])
	
	//svgh.select("rect").attr('fill', 'black');
	//svgh.selectAll("text").attr("style", "fill: white");
	//svgh.selectAll("line").attr("style", "stroke: white");
	//svgh.selectAll("circle").attr("style", "stroke: white");
	
	
	svgh.selectAll(".hvnode")
	.data(nodes)
	////.attr("r", function(d) { return(Math.abs(d.y-1.0 ))});
	////.attr("stroke", function(d) { return colorScale(d.y-1.0)});
	.attr("cx", function(d) { return radius(d.y) });
	
	svgh.selectAll(".hvlink")
	.data(links)
	.attr("stroke", function(d) { 
		var nodeIndex=headTitles.indexOf(d.source['nname']);
		if (nodeIndex>2){
			return colorScale(results[slide][nodeIndex]);
		}
	})
	.attr("d", d3.hive.link(nbAxis+nbCloneAxis)
				.angle(function(d) { return angle(d.x); })//return angle((angle(listCategory.indexOf(listCloneCategory[d.x-nbAxis])))+((2*Math.PI/nbAxis)/4));} })
				.radius(function(d) { return radius(d.y); }));
	
	
	/*.attr("stroke-width", function(d) { 
		var nodeIndex=headTitles.indexOf(d.source['nname']);
		if (nodeIndex>2){
			if (slide>0){
				if (results[slide][nodeIndex]!=results[slide-1][nodeIndex]){
					return 2;
				}
				else {
					return 0.5;
				}
			}
			else {
				return 0.5;
			}
			
		}
		else {
			return 0.5;
		}
	});*/
	//console.log(listMTN)
	//console.log(detailMTN)
	//console.log(adata)
	/*for(var i=0; i<adata.length;i++){
		for(var i1=0; i1<adata[i].length;i1++){
			if (adata[i][j][1]!=""){
				adata[i][j][0]=0;
				for (var r=0; r<slideAmount;r++){
					if (results[r][2]!="none"){//adata[i][j][1]){
						adata[i][j][0]=results[r][2];
					}
				}
				
			}
		}
	}*/
	
	//console.log(headTitles)
	// grp.selectAll('rect')
	// .data(function(d) { return d; })
	// .enter()
	// .append('rect')
	// .attr('x', function(d, i) { return (rw*1.0 )* i; })
	// .attr('width', rw)
	// .attr('height', rh)
	// .style("fill", function(d, i) { if (d[0]==1) {return "rgb(0,0,"+(parseInt(255*d[0]))+")"} else return "transparent"})
	// .on('mouseover', function(d,i,j) {
				// disableSelection=true;
				// if (d[0]==1){
				// d3.select(this).transition().duration(10)
				// .style({'stroke-opacity':1,'stroke':'#F00', 'stroke-width':2});
				// $("#mytooltip3")
				  // .html("Link between: <br>Model node: <b>"+Object.keys(listMTN[myListModels[nbModel]][1])[i]+"</b><br>and Metabolic node: <b>"+detailMTN[listMTN[myListModels[nbModel]][0]][j]) //listMTN[myListModels[nbModel]][1]
				  // .css('left', window.event.clientX+40)
				  // .css('top', window.event.clientY)
				  // .show();
				// }
				
	// })
}

function updateSlidert (slideAmount){
	try{
		var slide= parseInt(slideAmount);
		if ((slideAmount>=0) && (slideAmount <results.length)){
			updateSliderh(slideAmount)
		}
		document.getElementById("slider2").value=slideAmount;
	}
	catch(e){}
}
function forward (){
	var slideAmount = parseInt(document.getElementById("slider2").value)
	
	if ((slideAmount>=0) && (slideAmount <results.length-1)){
		document.getElementById("slider2").value=(slideAmount+1)
		updateSliderh((slideAmount+1))
	}
	console.log((slideAmount+1))
	//document.getElementById("textslider2").value=(slideAmount+1);
}
function backward (){
	var slideAmount = parseInt(document.getElementById("slider2").value)
	if ((slideAmount>0) && (slideAmount <results.length)){
		document.getElementById("slider2").value=(slideAmount-1)
		updateSliderh((slideAmount-1))
	}
	console.log((slideAmount-1))
	//document.getElementById("textslider2").value=(slideAmount-1);
}

function updateSliderc (checked){
	var slide= parseInt(document.getElementById("slider2").value);
	if (checked==true){
		
		for (var i=0, j=nodes.length;i<j;i++){
				var nodeIndex=headTitles.indexOf(nodes[i]['nname']);
				if (nodeIndex>2){
					nodes[i]['y']=results[slide][nodeIndex]+1.0;
				}
				
		}
	}
	else{
			var countPerCategory={};
			var listCategory = Object.keys(categoriesReactions);
			for (var i=0, j=listCategory.length;i<j;i++){
				countPerCategory[listCategory[i]]=0;
			}
			
			
			var listCloneCategory = [];
			nbCloneAxis=0;
			var listReactions = Object.keys(reactionsCategories);
			//console.log(listCategory)
			var hwidth = (screen.width*0.5),
			hheight = screen.height*0.9,
			innerRadius = 40,
			outerRadius = (screen.height*0.7)/2;
			nbAxis = listCategory.length;
			
			var angle = d3.scale.ordinal().domain(d3.range(nbAxis+1)).rangePoints([0, 2 * Math.PI]),
			radius = d3.scale.linear().range([innerRadius, outerRadius]),
			color = d3.scale.category10().domain(d3.range(20));
			//console.log(angle)
			//console.log(reactionsCategories)
			nodes =[];
			links =[];
			var listDisplayedNodes=[];
			
			
			for (var i=0,j=listReactions.length;i<j;i++){
				if (sfbaGeneralReactionMap.hasOwnProperty(listReactions[i])) {
					//var laxis=categoriesReactions[reactionsCategories[listReactions[i]][0]].length;
					var indexSource;
					var indexTarget;
					if(listDisplayedNodes.indexOf(listReactions[i])==-1){
						listDisplayedNodes.push(listReactions[i]);
						indexSource=listDisplayedNodes.length-1;
						//nodes.push({x: listCategory.indexOf(reactionsCategories[listReactions[i]][0]), y: (countPerCategory[reactionsCategories[listReactions[i]][0]]/(categoriesReactions[reactionsCategories[listReactions[i]][0]].length))*(categoriesReactions[reactionsCategories[listReactions[i]][0]].length/100)});
						nodes.push({x: listCategory.indexOf(reactionsCategories[listReactions[i]][0]), y: (countPerCategory[reactionsCategories[listReactions[i]][0]]/(categoriesReactions[reactionsCategories[listReactions[i]][0]].length))*(categoriesReactions[reactionsCategories[listReactions[i]][0]].length/100), nname:listReactions[i]});
						
						countPerCategory[reactionsCategories[listReactions[i]][0]]+=1;
					}
					else{
						indexSource=listDisplayedNodes.indexOf(listReactions[i]);
					}
					for(var i1=0,j1=sfbaGeneralReactionMap[listReactions[i]].length;i1<j1;i1++){
						var nextNode= sfbaGeneralReactionMap[listReactions[i]][i1];
						if(listDisplayedNodes.indexOf(nextNode)==-1){
							if (reactionsCategories[nextNode]){
								if (listCategory.indexOf(reactionsCategories[nextNode][0])!=-1){
									if (listCategory.indexOf(reactionsCategories[nextNode][0])!=listCategory.indexOf(reactionsCategories[listReactions[i]][0])){
										listDisplayedNodes.push(nextNode);
										indexTarget=listDisplayedNodes.length-1;
										//nodes.push({x: listCategory.indexOf(reactionsCategories[nextNode][0]), y: (countPerCategory[reactionsCategories[nextNode][0]]/(categoriesReactions[reactionsCategories[nextNode][0]].length))*(categoriesReactions[reactionsCategories[nextNode][0]].length/100)});
										nodes.push({x: listCategory.indexOf(reactionsCategories[nextNode][0]), y: (countPerCategory[reactionsCategories[nextNode][0]]/(categoriesReactions[reactionsCategories[nextNode][0]].length))*(categoriesReactions[reactionsCategories[nextNode][0]].length/100), nname:nextNode});
										
										countPerCategory[reactionsCategories[nextNode][0]]+=1;
										links.push({source: nodes[indexSource], target: nodes[indexTarget]})
									}
									else{
										/*if (listCloneCategory.indexOf(reactionsCategories[nextNode][0])==-1){
											listCloneCategory.push(reactionsCategories[nextNode][0]);
											nbCloneAxis++;
										}*/
										//console.log(nbAxis+listCloneCategory.indexOf(reactionsCategories[nextNode][0]))
										listDisplayedNodes.push(nextNode);
										indexTarget=listDisplayedNodes.length-1;
										//nodes.push({x: listCategory.indexOf(reactionsCategories[nextNode][0]), y: 1.0+(countPerCategory[reactionsCategories[nextNode][0]]/(categoriesReactions[reactionsCategories[nextNode][0]].length))*(categoriesReactions[reactionsCategories[nextNode][0]].length/100)});
										nodes.push({x: listCategory.indexOf(reactionsCategories[nextNode][0]), y: (countPerCategory[reactionsCategories[nextNode][0]]/(categoriesReactions[reactionsCategories[nextNode][0]].length))*(categoriesReactions[reactionsCategories[nextNode][0]].length/100), nname:nextNode});
										countPerCategory[reactionsCategories[nextNode][0]]+=1;
										//nodes.push({x: (nbAxis+listCloneCategory.indexOf(reactionsCategories[nextNode][0])), y: Math.random()});
										//nodes.push({x: nbAxis+listCloneCategory.indexOf(reactionsCategories[nextNode][0]), y: Math.random()});
										
										links.push({source: nodes[indexSource], target: nodes[indexTarget]})
									}
								}
							}
						}
					}
					//nodes.push({x: listCategory.indexOf(reactionsCategories[listReactions[i]]) Math.floor((Math.random() * nbAxis)), y: Math.random() });
					//nodes.push({x: Math.floor((Math.random() * nbAxis)), y: Math.random() });
					//links.push({source: nodes[nodes.length-2], target: nodes[nodes.length-1]})
				}
			}
	}
	updateSliderh(slide)
	//console.log(checked)
}


$("#democ2").css({top:  $("#container").position().top + $("#container").height()});
$("#select1text").css({top:  $("#democ2").position().top + $("#democ2").height()+20});
$("#mygraph").css({top:  $("#select1text").position().top + $("#select1text").height()});
$("#democ").css({top:  $("#mygraph").position().top + $("#mygraph").height()});

//$("#democ3").css({top:  $("#mygraph").position().top + $("#mygraph").height()});

$("#reactionCategoryTable").css({top:  $("#democ").position().top + $("#democ").height()+50});

$("#democ4").css({top:  $("#reactionCategoryTable").position().top + $("#reactionCategoryTable").height()+20});
$("#sliderdiv").css({top:  $("#democ4").position().top + $("#democ4").height()+20});
$("#sliderdiv").width($("#hiveplot").width());
$("#hiveplot").css({top:  $("#sliderdiv").position().top + $("#sliderdiv").height()+20});	

function selectMTNLayout(el){
	//console.log(el.value)
	document.getElementById("mtnl-id").value=el.value;
	document.getElementById("qml-id").value=document.getElementById("selectLayout").value;
	//console.log("mtnl id: "+document.getElementById("mtnl-id").value)
	//console.log("qml id: "+document.getElementById("qml-id").value)
}







// refresh qsspn model graphics from layout
	var el = document.getElementById("mtnl-id").value;
	var sl = document.getElementById("defaultSlider2")
	var amountScale = 0.1+(0.9*(parseFloat(sl.value)/100));
	if (parseInt(el.value)==0){
		//console.log("default layout");
		
		var cnt1=0;
		var cnt2=0;
		var cnt=0;
		var radius=400;
		//var ln1 = scene.children[2].geometry.attributes.size.array.length-5000; 
		//var ln2 = scene.children[4].geometry.attributes.size.array.length-5000; 
		var ln1 = startModelPlaces;
		var ln2 = startModelReactions;
		//console.log(ln1)
		//console.log(startModelPlaces)
		for (var i= 0; i<selectedModelNodes.length;i++){
			if (selectedModelNodes[i][5]==2 ){
				//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]=((Math.random() * 2 - 1) * 400);
				var rm=cnt1*0.008*2*Math.PI;
				//radius=900;
				var rr = ((radius*1.08)-(cnt1*0.2)+1)
				scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (Math.sin(rm) *rr);
				//scene.children[2].geometry.attributes.position.array[(ln2+cnt2)*3+0]= (Math.cos(rm) *rr)+1800;
				scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(Math.cos(rm) *rr)+900;
				cnt1++;
				cnt++;
			}
			else if (selectedModelNodes[i][5]==4 ){
				//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=((Math.random() * 2 - 1) * 400);
				var rm=cnt2*0.008*2*Math.PI;
				//radius=600;
				var rr = ((radius*1.08)-(cnt2*0.2)+1)
				scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(Math.sin(rm) *rr);
				scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]= (Math.cos(rm) *rr)+1800;
				
				cnt2++;
				cnt++;
			}
		}
		//console.log(cnt1)
		//console.log(cnt2)
		
		scene.children[2].geometry.attributes.position.needsUpdate = true;
		scene.children[4].geometry.attributes.position.needsUpdate = true;
		
		var count=0;
		for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
			var t1;
			var t2;
			var pt1;
			var pt2;
			var sim1=1;
			var sim2=1;
			pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
			sim1 = idMap[pt1][0]
			t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
			if (selectedModelEdges[iv-extraLinesCnt][3]==2){
				//console.log("link between model and metabolic nodes")
				
				if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
					pt2=selectedModelEdges[iv-extraLinesCnt][1];
				}
				else{
					pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
				}
				t2 = jsonObj1[pt2][6]
				sim2=2;
			}
			else{
				//console.log("link between model nodes")
				if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
					pt2=selectedModelEdges[iv-extraLinesCnt][1];
				}
				else{
					pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
				}
				t2 = selectedModelNodes[pt2][5];
			}
			if (sim2!=2){
				pt2+=jsonObj1.length;
				//console.log(idMap[pt2]);
			}
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
			startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
			
			count+=1;
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
			endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
			
			count+=1;
		}
		scene.children[7].geometry.attributes.position.needsUpdate = true;
		scene.children[7].geometry.attributes.ca.needsUpdate = true;
		
		
		// var ii=0;
		// for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
		
			// scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
			// scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
			// scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
			// ii++;
		// }
		// //console.log(tokenAttributes.endPosition.value[0]);
		// var ii=0;
		// for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
			// tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
			// tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
			// tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
			// ii++;
		// }
		// //console.log(tokenAttributes.endPosition.value[0]);
		// scene.children[8].geometry.verticesNeedUpdate = true;
		// tokenAttributes.endPosition.needsUpdate = true;
		// tokenUniforms.mixAmount.value = 0.0;
		
		
	}
	else {
		//console.log("other layout");
		//console.log($("#selectLayout").find('option:selected').text())
		//console.log(layouts[el.value])
		var layout_nodes_coordinates={};
		var sublayout=document.getElementById("selectsublayout").value;
		//console.log(sublayout)
		if (mqml["layout"] && mqml["layout"].hasOwnProperty(sublayout)) {
			//console.log(sublayout)
			for (var i=0, j=mqml["layout"][sublayout].length;i<j;i++){
				layout_nodes_coordinates[mqml["layout"][sublayout][i]['data']['id']]=[mqml["layout"][sublayout][i]['position']['x'],mqml["layout"][sublayout][i]['position']['y'] ]
			}
		}
		
		//console.log(layout_nodes_coordinates)
		// //console.log(selectedModelNodes);
		var cnt1=0;
		var cnt2=0;
		var ln1 = startModelPlaces;
		var ln2 = startModelReactions;
		for (var i=0, j=selectedModelNodes.length;i<j;i++){
			if (selectedModelNodes[i][5]==2 ){
					
					if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
						scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
						scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
						//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=50;
						//console.log(scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1])
					}
					cnt1++;
			}
			if (selectedModelNodes[i][5]==4 ){
					
					if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
						scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
						scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
						//console.log(scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1])
					}
					cnt2++;
			}
			
		}
		scene.children[2].geometry.attributes.position.needsUpdate = true;
		scene.children[4].geometry.attributes.position.needsUpdate = true;
		
		var count=0;
		for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
			var t1;
			var t2;
			var pt1;
			var pt2;
			var sim1=1;
			var sim2=1;
			pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
			sim1 = idMap[pt1][0]
			t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
			if (selectedModelEdges[iv-extraLinesCnt][3]==2){
				//console.log("link between model and metabolic nodes")
				
				if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
					pt2=selectedModelEdges[iv-extraLinesCnt][1];
				}
				else{
					pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
				}
				t2 = jsonObj1[pt2][6]
				sim2=2;
			}
			else{
				//console.log("link between model nodes")
				if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
					pt2=selectedModelEdges[iv-extraLinesCnt][1];
				}
				else{
					pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
				}
				t2 = selectedModelNodes[pt2][5];
			}
			if (sim2!=2){
				pt2+=jsonObj1.length;
				//console.log(idMap[pt2]);
			}
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
			startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
			
			count+=1;
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
			endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
			
			count+=1;
		}
		scene.children[7].geometry.attributes.position.needsUpdate = true;
		scene.children[7].geometry.attributes.ca.needsUpdate = true;
		
		
		// var ii=0;
		// for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
		
			// scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
			// scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
			// scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
			// ii++;
		// }
		// //console.log(tokenAttributes.endPosition.value[0]);
		// var ii=0;
		// for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
			// tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
			// tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
			// tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
			// ii++;
		// }
		// //console.log(tokenAttributes.endPosition.value[0]);
		// scene.children[8].geometry.verticesNeedUpdate = true;
		// tokenAttributes.endPosition.needsUpdate = true;
		// tokenUniforms.mixAmount.value = 0.0;
		
	}
	
	
	
	
	var listChildrenPoints=[2,4];
	
	for (var i =0;i< listChildrenPoints.length;i++){
			var c = listChildrenPoints[i];
			for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
				for (var g=0;g<nbCompartments;g++){
					//if (objects[g].scale<1.0){
					//	scene.children[c].geometry
					//}
					if (scene.children[c].geometry.attributes.compartment.array[h]==g){
						//console.log(scene.children[c].geometry)
						
							scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x;//-stackCompInitialPos[cRef].x-stackCompInitialPos[cRef].x;
							scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y;//-stackCompInitialPos[cRef].y-stackCompInitialPos[cRef].y;
							scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z;//-stackCompInitialPos[cRef].z-stackCompInitialPos[cRef].z;
							
							var displacement = new THREE.Vector3(scene.children[c].geometry.attributes.position.array[h*3+0]- objects[g].position.x,
																 scene.children[c].geometry.attributes.position.array[h*3+1]- objects[g].position.y,
																 scene.children[c].geometry.attributes.position.array[h*3+2]- objects[g].position.z)
							if (objects[g].scale.x<1.0){
								scene.children[c].geometry.attributes.position.array[h*3+0]-=(displacement.x*(1-objects[g].scale.x));
								scene.children[c].geometry.attributes.position.array[h*3+1]-=(displacement.y*(1-objects[g].scale.y));
								scene.children[c].geometry.attributes.position.array[h*3+2]-=(displacement.z*(1-objects[g].scale.z));
								scene.children[c].geometry.attributes.size.array[h]*=0.417777;
							}
							if (objects[g].scale.x>1.0){
								var indLayer=-1;
								for (var ref in generalLayout["outer"]){
									if (generalLayout["outer"].hasOwnProperty(ref)){
										indLayer =generalLayout["outer"][ref].indexOf(objects[g].name);
										//if (indLayer!=-1){}
									}
								}
								if (indLayer>-1){
									var lengthV = displacement.length();
									displacement.setLength(lengthV+((indLayer+0.5)*radiusComp));
									scene.children[c].geometry.attributes.position.array[h*3+0]+=(displacement.x);
									scene.children[c].geometry.attributes.position.array[h*3+1]+=(displacement.y+radiusComp/2);
									scene.children[c].geometry.attributes.position.array[h*3+2]+=(displacement.z);
									scene.children[c].geometry.attributes.size.array[h]/=0.417777;
								}
								
								
							}
						
						
					}
				}
			}
			scene.children[c].geometry.attributes.position.needsUpdate = true;
			scene.children[c].geometry.attributes.size.needsUpdate = true;
		}
		
		if (mtnlLayout["nodes_layout"]){
			var listDisplacedNodes = Object.keys(mtnlLayout["nodes_layout"]);
			if (listDisplacedNodes.length>0){
				//console.log(mtnlLayout["nodes_layout"])
				for(var i=0, ii= listDisplacedNodes.length;i<ii;i++){
					var typeNode=idMap[listDisplacedNodes[i]][0];
					var indexNode=idMap[listDisplacedNodes[i]][1];
					if (typeNode==2){
						scene.children[listChildrenPoints[0]].geometry.attributes.position.array[indexNode*3+0]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].x;
						scene.children[listChildrenPoints[0]].geometry.attributes.position.array[indexNode*3+1]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].y;
						scene.children[listChildrenPoints[0]].geometry.attributes.position.array[indexNode*3+2]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].z;
						
					}
					if (typeNode==4){
						scene.children[listChildrenPoints[1]].geometry.attributes.position.array[indexNode*3+0]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].x;
						scene.children[listChildrenPoints[1]].geometry.attributes.position.array[indexNode*3+1]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].y;
						scene.children[listChildrenPoints[1]].geometry.attributes.position.array[indexNode*3+2]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].z;
					}
				}
				scene.children[listChildrenPoints[0]].geometry.attributes.position.needsUpdate = true;
				scene.children[listChildrenPoints[1]].geometry.attributes.position.needsUpdate = true;
				//
				//
				//if (typeNode==2){console.log(""+2)}
				//if (typeNode==4){console.log(""+4)}
				//
				
			}
			//console.log("nodes layout")
			//
		}
		
		//console.log(metabolicNodes[9802])
		
		var indexChildrenLines=7;
		var iv=0;
		for ( var i = 0; i < segments; i ++ ) {
			var t1 = metabolicNodes[metabolicEdges[i][0]][6]
			var t2 = metabolicNodes[metabolicEdges[i][1]][6]
			//console.log(t1)
			//console.log(t2)
			//var ivList=[]
			var doIt=0
			if (t1==2){
				//console.log(idMap[jsonObj2[i][0]][1])
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[listChildrenPoints[0]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[listChildrenPoints[0]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[listChildrenPoints[0]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
				
				iv++;
			}
			else if (t1==4){
				//console.log(idMap[jsonObj2[i][0]][1])
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[listChildrenPoints[1]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[listChildrenPoints[1]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[listChildrenPoints[1]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
				iv++;
			}
			if (t2 ==2){
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[listChildrenPoints[0]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[listChildrenPoints[0]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[listChildrenPoints[0]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
				iv++;
			}
			else if (t2 ==4){
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[listChildrenPoints[1]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[listChildrenPoints[1]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[listChildrenPoints[1]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
				iv++;
			}
			
		}
		scene.children[indexChildrenLines].geometry.attributes.position.needsUpdate = true;
	
		// var ii=0;
		// for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
		
			// scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
			// scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
			// scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
			// ii++;
		// }
		// //console.log(tokenAttributes.endPosition.value[0]);
		// var ii=0;
		// for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
			// tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
			// tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
			// tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
			
			// ii++;
		// }
		// tokenUniforms.mixAmount.value = 0.0;
		// //var ii=0;
		// //for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
		// //	tokenAttributes.mixAmount.value[ii] = 0.0;
		// //	ii++;
		// //}
		// //tokenAttributes.mixAmount.needsUpdate = true;
		// //console.log(tokenAttributes.endPosition.value[0]);
		// scene.children[8].geometry.verticesNeedUpdate = true;
		// tokenAttributes.endPosition.needsUpdate = true;
	
	
	
	
		if (nbPlacesModel!=0 && nbReactionsModel!=0){
				console.log(nbPlacesModel)
				console.log(nbReactionsModel)
				var cnt1=0;
				var cnt2=0;
				var cnt=0;
				
				//var ln1 = scene.children[2].geometry.attributes.size.array.length-5000; 
				//var ln2 = scene.children[4].geometry.attributes.size.array.length-5000; 
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				//console.log(ln1)
				//console.log(startModelPlaces)
				
				
				var col2 = new THREE.Color( 0xffa500 );
				
				
				//console.log(selectedModelNodes)
				//for (var s= 0; s<selectedModelEdges.length;s++){
				//	if (selectedModelEdges[s][0]==108){
				//	console.log(s)
				//	}
				//}
				//console.log(nbEdgesModel)
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					if (sim2==2){
					//console.log("link between model nodes")
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
					}
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					if (sim2==2){
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
					}
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				// selectedLinesPathsIds=[]
				// for (var i=0; i<selectedLinesPaths.length;i++){
					// for (var j=0;j<linesMap[selectedLinesPaths[i]].length;j+=1){
						// selectedLinesPathsIds.push(linesMap[selectedLinesPaths[i]][j])
					// }
				// }
				// selectedLinesPathsIds = unique(selectedLinesPathsIds)
				// for (var i=0;i<selectedLinesPathsIds.length;i+=1){
					// scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] +=150000;
				// }
				// scene.children[7].geometry.attributes.position.needsUpdate = true;
					
				// var ii=0;
				// for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					// scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					// scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					
					// scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					// if (i>=segmentPts){
					// scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ];
					// }
					// ii++;
				// }
				// //console.log(tokenAttributes.endPosition.value[0]);
				// var ii=0;
				// for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					// tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					// tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					// tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					// if (i>=segmentPts){
					// tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ];
					// }
					// ii++;
				// }
				// //console.log(tokenAttributes.endPosition.value[0]);
				// scene.children[8].geometry.verticesNeedUpdate = true;
				// tokenAttributes.endPosition.needsUpdate = true;
				// tokenUniforms.mixAmount.value = 0.0;
			}

			
			
	function selectsublayout(el){
		
		
		
		var sl = document.getElementById("defaultSlider2")
		var amountScale = 0.1+(0.9*(parseFloat(sl.value)/100));
		if (el.value==""){
			console.log("default layout");
			
			var cnt1=0;
			var cnt2=0;
			var cnt=0;
			var radius=400;
			//var ln1 = scene.children[2].geometry.attributes.size.array.length-5000; 
			//var ln2 = scene.children[4].geometry.attributes.size.array.length-5000; 
			var ln1 = startModelPlaces;
			var ln2 = startModelReactions;
			//console.log(ln1)
			//console.log(startModelPlaces)
			for (var i= 0; i<selectedModelNodes.length;i++){
				if (selectedModelNodes[i][5]==2 ){
					//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]=((Math.random() * 2 - 1) * 400);
					var rm=cnt1*0.008*2*Math.PI;
					//radius=900;
					var rr = ((radius*1.08)-(cnt1*0.2)+1)
					scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (Math.sin(rm) *rr);
					//scene.children[2].geometry.attributes.position.array[(ln2+cnt2)*3+0]= (Math.cos(rm) *rr)+1800;
					scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(Math.cos(rm) *rr)+900;
					scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=yStartDisplacement/2;
					cnt1++;
					cnt++;
				}
				else if (selectedModelNodes[i][5]==4 ){
					//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=((Math.random() * 2 - 1) * 400);
					var rm=cnt2*0.008*2*Math.PI;
					//radius=600;
					var rr = ((radius*1.08)-(cnt2*0.2)+1)
					scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(Math.sin(rm) *rr);
					scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]= (Math.cos(rm) *rr)+1800;
					scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1]=yStartDisplacement/2-180;
					cnt2++;
					cnt++;
				}
			}
			//console.log(cnt1)
			//console.log(cnt2)
			
			scene.children[2].geometry.attributes.position.needsUpdate = true;
			scene.children[4].geometry.attributes.position.needsUpdate = true;
			
			var count=0;
			for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
				var t1;
				var t2;
				var pt1;
				var pt2;
				var sim1=1;
				var sim2=1;
				pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
				sim1 = idMap[pt1][0]
				t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
				if (selectedModelEdges[iv-extraLinesCnt][3]==2){
					//console.log("link between model and metabolic nodes")
					
					if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
						pt2=selectedModelEdges[iv-extraLinesCnt][1];
					}
					else{
						pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
					}
					t2 = jsonObj1[pt2][6]
					sim2=2;
				}
				else{
					//console.log("link between model nodes")
					if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
						pt2=selectedModelEdges[iv-extraLinesCnt][1];
					}
					else{
						pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
					}
					t2 = selectedModelNodes[pt2][5];
				}
				if (sim2!=2){
					pt2+=jsonObj1.length;
					//console.log(idMap[pt2]);
				}
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
				startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
				
				count+=1;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
				endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
				
				count+=1;
			}
			scene.children[7].geometry.attributes.position.needsUpdate = true;
			scene.children[7].geometry.attributes.ca.needsUpdate = true;
			
			
			// var ii=0;
			// for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
			
				// scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
				// scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
				// scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
				// ii++;
			// }
			// //console.log(tokenAttributes.endPosition.value[0]);
			// var ii=0;
			// for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				// tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
				// tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
				// tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
				// ii++;
			// }
			// //console.log(tokenAttributes.endPosition.value[0]);
			// scene.children[8].geometry.verticesNeedUpdate = true;
			// tokenAttributes.endPosition.needsUpdate = true;
			// tokenUniforms.mixAmount.value = 0.0;
			
			
		}
		else {
			//console.log("other layout");
			//console.log($("#selectLayout").find('option:selected').text())
			//console.log(layouts[el.value])
			var layout_nodes_coordinates={};
			var sublayout=el.value;
			//console.log(sublayout)
			if (mqml["layout"].hasOwnProperty(sublayout)) {
				console.log(sublayout)
				for (var i=0, j=mqml["layout"][sublayout].length;i<j;i++){
					layout_nodes_coordinates[mqml["layout"][sublayout][i]['data']['id']]=[mqml["layout"][sublayout][i]['position']['x'],mqml["layout"][sublayout][i]['position']['y'] ]
				}
			}
			
			//console.log(layout_nodes_coordinates)
			// //console.log(selectedModelNodes);
			var cnt1=0;
			var cnt2=0;
			var ln1 = startModelPlaces;
			var ln2 = startModelReactions;
			for (var i=0, j=selectedModelNodes.length;i<j;i++){
				if (selectedModelNodes[i][5]==2 ){
						
						if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
							scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
							scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
							
							//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=50;
							//console.log(scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1])
						}
						cnt1++;
				}
				if (selectedModelNodes[i][5]==4 ){
						
						if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
							scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
							scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
							
							//console.log(scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1])
						}
						cnt2++;
				}
				
			}
			scene.children[2].geometry.attributes.position.needsUpdate = true;
			scene.children[4].geometry.attributes.position.needsUpdate = true;
			
			var count=0;
			for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
				var t1;
				var t2;
				var pt1;
				var pt2;
				var sim1=1;
				var sim2=1;
				pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
				sim1 = idMap[pt1][0]
				t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
				if (selectedModelEdges[iv-extraLinesCnt][3]==2){
					//console.log("link between model and metabolic nodes")
					
					if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
						pt2=selectedModelEdges[iv-extraLinesCnt][1];
					}
					else{
						pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
					}
					t2 = jsonObj1[pt2][6]
					sim2=2;
				}
				else{
					//console.log("link between model nodes")
					if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
						pt2=selectedModelEdges[iv-extraLinesCnt][1];
					}
					else{
						pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
					}
					t2 = selectedModelNodes[pt2][5];
				}
				if (sim2!=2){
					pt2+=jsonObj1.length;
					//console.log(idMap[pt2]);
				}
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
				startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
				
				count+=1;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
				endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
				
				count+=1;
			}
			scene.children[7].geometry.attributes.position.needsUpdate = true;
			scene.children[7].geometry.attributes.ca.needsUpdate = true;
			
			
			// var ii=0;
			// for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
			
				// scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
				// scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
				// scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
				// ii++;
			// }
			// //console.log(tokenAttributes.endPosition.value[0]);
			// var ii=0;
			// for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				// tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
				// tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
				// tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
				// ii++;
			// }
			// //console.log(tokenAttributes.endPosition.value[0]);
			// scene.children[8].geometry.verticesNeedUpdate = true;
			// tokenAttributes.endPosition.needsUpdate = true;
			// tokenUniforms.mixAmount.value = 0.0;
			
		}
		
		document.getElementById("defaultSlider4").value=0;
		document.getElementById("defaultSlider5").value=0;
		document.getElementById("defaultSlider6").value=0;
	}
	
	function updateSlider2(slideAmount){
			var el = document.getElementById("selectsublayout").value;
			var amountScale = 0.1+(0.9*(parseFloat(slideAmount)/100));
			if (el==""){
				//console.log("default layout");
			}
			else {
				//console.log("other layout");
				var layout_nodes_coordinates={};
				var sublayout=document.getElementById("selectsublayout").value;
				//console.log(sublayout)
				if (mqml["layout"].hasOwnProperty(sublayout)) {
					//console.log(sublayout)
					for (var i=0, j=mqml["layout"][sublayout].length;i<j;i++){
						layout_nodes_coordinates[mqml["layout"][sublayout][i]['data']['id']]=[mqml["layout"][sublayout][i]['position']['x'],mqml["layout"][sublayout][i]['position']['y'] ]
					}
				}
				//console.log(selectedModelNodes);
				var cnt1=0;
				var cnt2=0;
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				for (var i=0, j=selectedModelNodes.length;i<j;i++){
					if (selectedModelNodes[i][5]==2 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
							}
							cnt1++;
					}
					if (selectedModelNodes[i][5]==4 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
							}
							cnt2++;
					}
					
				}
				scene.children[2].geometry.attributes.position.needsUpdate = true;
				scene.children[4].geometry.attributes.position.needsUpdate = true;
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				
				// var ii=0;
				// for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					// scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					// scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					// scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					// ii++;
				// }
				// //console.log(tokenAttributes.endPosition.value[0]);
				// var ii=0;
				// for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					// tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					// tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					// tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					// ii++;
				// }
				// //console.log(tokenAttributes.endPosition.value[0]);
				// scene.children[8].geometry.verticesNeedUpdate = true;
				// tokenAttributes.endPosition.needsUpdate = true;
				// tokenUniforms.mixAmount.value = 0.0;
				
				
				//for (elem in layout_nodes_coordinates){
				//	if (layout_nodes_coordinates.hasOwnProperty(elem)){
						//layout_nodes_coordinates[elem]
				//	}
				//}
				
				//console.log(layout_nodes_coordinates);
				
			}	
		}
		
		function updateSlider3(slideAmount){
			var el = document.getElementById("selectsublayout").value;
			var el2= document.getElementById("defaultSlider2");
			var amountScale = 0.1+(0.9*(parseFloat(el2.value)/100));
			var distance = (parseFloat(slideAmount)/100)*200
			
			if (el==""){
				//console.log("default layout");
			}
			else {
				//console.log("other layout");
				//console.log(layouts[el.value])
				var layout_nodes_coordinates={};
				var sublayout=document.getElementById("selectsublayout").value;
				//console.log(sublayout)
				if (mqml["layout"].hasOwnProperty(sublayout)) {
					//console.log(sublayout)
					for (var i=0, j=mqml["layout"][sublayout].length;i<j;i++){
						layout_nodes_coordinates[mqml["layout"][sublayout][i]['data']['id']]=[mqml["layout"][sublayout][i]['position']['x'],mqml["layout"][sublayout][i]['position']['y'] ]
					}
				}
				//console.log(selectedModelNodes);
				var cnt1=0;
				var cnt2=0;
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				for (var i=0, j=selectedModelNodes.length;i<j;i++){
					if (selectedModelNodes[i][5]==2 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
								//console.log(scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1])//=50;
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=200;
							}
							cnt1++;
					}
					if (selectedModelNodes[i][5]==4 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=50;
								//console.log(scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1])//=50;
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1]=200-distance;
							}
							cnt2++;
					}
					
				}
				scene.children[2].geometry.attributes.position.needsUpdate = true;
				scene.children[4].geometry.attributes.position.needsUpdate = true;
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				
				// var ii=0;
				// for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					// scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					// scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					// scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					// ii++;
				// }
				// //console.log(tokenAttributes.endPosition.value[0]);
				// var ii=0;
				// for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					// tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					// tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					// tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					// ii++;
				// }
				// //console.log(tokenAttributes.endPosition.value[0]);
				// scene.children[8].geometry.verticesNeedUpdate = true;
				// tokenAttributes.endPosition.needsUpdate = true;
				// tokenUniforms.mixAmount.value = 0.0;
				
				
				//for (elem in layout_nodes_coordinates){
				//	if (layout_nodes_coordinates.hasOwnProperty(elem)){
						//layout_nodes_coordinates[elem]
				//	}
				//}
				
				//console.log(layout_nodes_coordinates);
				
			}	
		}
		var updownPlaneVal=0;
		function updateSlider4(slideAmount){
			var el = document.getElementById("selectsublayout").value;
			var el2= document.getElementById("defaultSlider2");
			var amountScale = 0.1+(0.9*(parseFloat(el2.value)/100));
			var distance = (parseFloat(document.getElementById("defaultSlider3").value)/100)*200
			
			if (el==""){
				//console.log("default layout");
				var slideValue = parseFloat(slideAmount)-updownPlaneVal;
				
				var listChildrenPoints=[2,4];
				for (var i =0;i< listChildrenPoints.length;i++){
					var c = listChildrenPoints[i];
					var start=0;
					var end=0;
					if (c==2){
						start =startModelPlaces ;
						end = endModelPlaces ;
					}
					if (c==4){
						start =startModelReactions ;
						end =endModelReactions ;
					}
					for (var h=start;h<end;h++){					
						scene.children[c].geometry.attributes.position.array[h*3+0]-=slideValue;//-stackCompInitialPos[cRef].x-stackCompInitialPos[cRef].x;
						//scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y;//-stackCompInitialPos[cRef].y-stackCompInitialPos[cRef].y;
						//scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z;//-stackCompInitialPos[cRef].z-stackCompInitialPos[cRef].z;	
					}
					scene.children[c].geometry.attributes.position.needsUpdate = true;
				}
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				
				// var ii=0;
				// for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					// scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					// scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					// scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					// ii++;
				// }
				// //console.log(tokenAttributes.endPosition.value[0]);
				// var ii=0;
				// for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					// tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					// tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					// tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					// ii++;
				// }
				// //console.log(tokenAttributes.endPosition.value[0]);
				// scene.children[8].geometry.verticesNeedUpdate = true;
				// tokenAttributes.endPosition.needsUpdate = true;
				// tokenUniforms.mixAmount.value = 0.0;
				
				updownPlaneVal+=slideValue;
			}
			else {
				//console.log("other layout");
				//console.log(layouts[el.value])
				var layout_nodes_coordinates={};
				var sublayout=document.getElementById("selectsublayout").value;
				//console.log(sublayout)
				if (mqml["layout"].hasOwnProperty(sublayout)) {
					//console.log(sublayout)
					for (var i=0, j=mqml["layout"][sublayout].length;i<j;i++){
						layout_nodes_coordinates[mqml["layout"][sublayout][i]['data']['id']]=[mqml["layout"][sublayout][i]['position']['x'],mqml["layout"][sublayout][i]['position']['y'] ]
					}
				}
				//console.log(selectedModelNodes);
				var cnt1=0;
				var cnt2=0;
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				for (var i=0, j=selectedModelNodes.length;i<j;i++){
					if (selectedModelNodes[i][5]==2 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale)+parseFloat(slideAmount);
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200+parseFloat(slideAmount);
								//console.log(scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1])//=50;
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=200;
							}
							cnt1++;
					}
					if (selectedModelNodes[i][5]==4 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale)+parseFloat(slideAmount);
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200+parseFloat(slideAmount);
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=50;
								//console.log(scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1])//=50;
								//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1]=200-distance+parseFloat(slideAmount);
							}
							cnt2++;
					}
					
				}
				scene.children[2].geometry.attributes.position.needsUpdate = true;
				scene.children[4].geometry.attributes.position.needsUpdate = true;
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				
				// var ii=0;
				// for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					// scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					// scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					// scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					// ii++;
				// }
				// //console.log(tokenAttributes.endPosition.value[0]);
				// var ii=0;
				// for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					// tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					// tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					// tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					// ii++;
				// }
				// //console.log(tokenAttributes.endPosition.value[0]);
				// scene.children[8].geometry.verticesNeedUpdate = true;
				// tokenAttributes.endPosition.needsUpdate = true;
				// tokenUniforms.mixAmount.value = 0.0;
				
				
				//for (elem in layout_nodes_coordinates){
				//	if (layout_nodes_coordinates.hasOwnProperty(elem)){
						//layout_nodes_coordinates[elem]
				//	}
				//}
				
				//console.log(layout_nodes_coordinates);
				
			}	
		}
		var leftRightVal=0;
		function updateSlider5(slideAmount){
			
			var el = document.getElementById("selectsublayout").value;
			var el2= document.getElementById("defaultSlider2");
			var amountScale = 0.1+(0.9*(parseFloat(el2.value)/100));
			var distance = (parseFloat(document.getElementById("defaultSlider3").value)/100)*200
			
			if (el==""){
				//console.log("default layout");
				var slideValue = parseFloat(slideAmount)-leftRightVal;
				
				var listChildrenPoints=[2,4];
				for (var i =0;i< listChildrenPoints.length;i++){
					var c = listChildrenPoints[i];
					var start=0;
					var end=0;
					if (c==2){
						start =startModelPlaces ;
						end = endModelPlaces ;
					}
					if (c==4){
						start =startModelReactions ;
						end =endModelReactions ;
					}
					for (var h=start;h<end;h++){					
						scene.children[c].geometry.attributes.position.array[h*3+2]-=slideValue;//-stackCompInitialPos[cRef].x-stackCompInitialPos[cRef].x;
						//scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y;//-stackCompInitialPos[cRef].y-stackCompInitialPos[cRef].y;
						//scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z;//-stackCompInitialPos[cRef].z-stackCompInitialPos[cRef].z;	
					}
					scene.children[c].geometry.attributes.position.needsUpdate = true;
				}
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				
				// var ii=0;
				// for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					// scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					// scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					// scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					// ii++;
				// }
				// //console.log(tokenAttributes.endPosition.value[0]);
				// var ii=0;
				// for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					// tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					// tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					// tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					// ii++;
				// }
				// //console.log(tokenAttributes.endPosition.value[0]);
				// scene.children[8].geometry.verticesNeedUpdate = true;
				// tokenAttributes.endPosition.needsUpdate = true;
				// tokenUniforms.mixAmount.value = 0.0;
				
				leftRightVal+=slideValue;
			}
			else {
				//console.log("other layout");
				//console.log(layouts[el.value])
				var layout_nodes_coordinates={};
				var sublayout=document.getElementById("selectsublayout").value;
				//console.log(sublayout)
				if (mqml["layout"].hasOwnProperty(sublayout)) {
					//console.log(sublayout)
					for (var i=0, j=mqml["layout"][sublayout].length;i<j;i++){
						layout_nodes_coordinates[mqml["layout"][sublayout][i]['data']['id']]=[mqml["layout"][sublayout][i]['position']['x'],mqml["layout"][sublayout][i]['position']['y'] ]
					}
				}
				//console.log(selectedModelNodes);
				var cnt1=0;
				var cnt2=0;
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				for (var i=0, j=selectedModelNodes.length;i<j;i++){
					if (selectedModelNodes[i][5]==2 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale)-parseFloat(slideAmount);
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
								//console.log(scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1])//=50;
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=200;
							}
							cnt1++;
					}
					if (selectedModelNodes[i][5]==4 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale)-parseFloat(slideAmount);
								//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=50;
								//console.log(scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1])//=50;
								//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1]=200-distance+parseFloat(slideAmount);
							}
							cnt2++;
					}
					
				}
				scene.children[2].geometry.attributes.position.needsUpdate = true;
				scene.children[4].geometry.attributes.position.needsUpdate = true;
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				
				// var ii=0;
				// for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					// scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					// scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					// scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					// ii++;
				// }
				// //console.log(tokenAttributes.endPosition.value[0]);
				// var ii=0;
				// for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					// tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					// tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					// tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					// ii++;
				// }
				// //console.log(tokenAttributes.endPosition.value[0]);
				// scene.children[8].geometry.verticesNeedUpdate = true;
				// tokenAttributes.endPosition.needsUpdate = true;
				// tokenUniforms.mixAmount.value = 0.0;
				
				
				//for (elem in layout_nodes_coordinates){
				//	if (layout_nodes_coordinates.hasOwnProperty(elem)){
						//layout_nodes_coordinates[elem]
				//	}
				//}
				
				//console.log(layout_nodes_coordinates);
				
			}	
		}
		var updownVal=0;
		function updateSlider6(slideAmount){
			var el = document.getElementById("selectsublayout").value;
			var el2= document.getElementById("defaultSlider2");
			var amountScale = 0.1+(0.9*(parseFloat(el2.value)/100));
			var distance = (parseFloat(document.getElementById("defaultSlider3").value)/100)*200
			
			if (el==""){
				//console.log("default layout");
				var slideValue = parseFloat(slideAmount)-updownVal;
				
				var listChildrenPoints=[2,4];
				for (var i =0;i< listChildrenPoints.length;i++){
					var c = listChildrenPoints[i];
					var start=0;
					var end=0;
					if (c==2){
						start =startModelPlaces ;
						end = endModelPlaces ;
					}
					if (c==4){
						start =startModelReactions ;
						end =endModelReactions ;
					}
					for (var h=start;h<end;h++){					
						scene.children[c].geometry.attributes.position.array[h*3+1]-=slideValue;//-stackCompInitialPos[cRef].x-stackCompInitialPos[cRef].x;
						//scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y;//-stackCompInitialPos[cRef].y-stackCompInitialPos[cRef].y;
						//scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z;//-stackCompInitialPos[cRef].z-stackCompInitialPos[cRef].z;	
					}
					scene.children[c].geometry.attributes.position.needsUpdate = true;
				}
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				
				// var ii=0;
				// for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					// scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					// scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					// scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					// ii++;
				// }
				// //console.log(tokenAttributes.endPosition.value[0]);
				// var ii=0;
				// for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					// tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					// tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					// tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					// ii++;
				// }
				// //console.log(tokenAttributes.endPosition.value[0]);
				// scene.children[8].geometry.verticesNeedUpdate = true;
				// tokenAttributes.endPosition.needsUpdate = true;
				// tokenUniforms.mixAmount.value = 0.0;
				
				updownVal+=slideValue;
			}
			else {
				//console.log("other layout");
				//console.log(layouts[el.value])
				var layout_nodes_coordinates={};
				var sublayout=document.getElementById("selectsublayout").value;
				//console.log(sublayout)
				if (mqml["layout"].hasOwnProperty(sublayout)) {
					//console.log(sublayout)
					for (var i=0, j=mqml["layout"][sublayout].length;i<j;i++){
						layout_nodes_coordinates[mqml["layout"][sublayout][i]['data']['id']]=[mqml["layout"][sublayout][i]['position']['x'],mqml["layout"][sublayout][i]['position']['y'] ]
					}
				}
				//console.log(selectedModelNodes);
				var cnt1=0;
				var cnt2=0;
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				for (var i=0, j=selectedModelNodes.length;i<j;i++){
					if (selectedModelNodes[i][5]==2 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
								//console.log(scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1])//=50;
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=200+parseFloat(slideAmount);
							}
							cnt1++;
					}
					if (selectedModelNodes[i][5]==4 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=50;
								//console.log(scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1])//=50;
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1]=200-distance+parseFloat(slideAmount);
							}
							cnt2++;
					}
					
				}
				scene.children[2].geometry.attributes.position.needsUpdate = true;
				scene.children[4].geometry.attributes.position.needsUpdate = true;
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				
				// var ii=0;
				// for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					// scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					// scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					// scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					// ii++;
				// }
				// //console.log(tokenAttributes.endPosition.value[0]);
				// var ii=0;
				// for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					// tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					// tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					// tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					// ii++;
				// }
				// //console.log(tokenAttributes.endPosition.value[0]);
				// scene.children[8].geometry.verticesNeedUpdate = true;
				// tokenAttributes.endPosition.needsUpdate = true;
				// tokenUniforms.mixAmount.value = 0.0;
				
				
				//for (elem in layout_nodes_coordinates){
				//	if (layout_nodes_coordinates.hasOwnProperty(elem)){
						//layout_nodes_coordinates[elem]
				//	}
				//}
				
				//console.log(layout_nodes_coordinates);
				
			}	
		}		


</script>

