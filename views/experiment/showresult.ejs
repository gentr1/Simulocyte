
<br><br>

    
</div>
<div class='container' id="showresult" style="width:80%">
	<h1>Results of simulation : <%= nbRes %> from experiment : <%= exp.name %></h1>
	
	<div id="container"  style="position: absolute;left: 0px; overflow: inherit">  </div>	
	<div id="mygraph"  style="position: absolute;left: 0px; overflow: inherit">  </div>	
<div id="advert" ></div>

<svg id="visualisation" width="1000" height="500" style="position: absolute;overflow: inherit"></svg>
<div class="mag"></div>

<div id="democ" style="position: absolute;left: 10px;overflow: auto">
	
		<div id="demo"></div>	
		
	</div>
</div>
<div id="mytooltip" style="position: absolute;left: 10px"></div>
<div id="democ2" style="position: absolute;left: 10px; overflow: inherit"></div>

<div id="democ3" style="position: absolute;left: 10px; overflow: inherit"> </div>
<div id="mtooltip" style="position: absolute;left: 10px"> </div>
<nav>
		<a href="" id="menuToggle" title="show menu">
		<span class="navClosed"><i>show menu</i></span>
		</a>
		<a href="#" title="Item 1">Hide/Show</a>
		<button class="btn btn-default btn-xs" title="Make metabolic network lines invisible/visible" id="view4" style="position: relative;left: 20px;">Lines</button>
		<button class="btn btn-default btn-xs" title="Hide/show tokens (if problem, just refresh the page)" id="view5" style="position: relative;left: 20px;">Token</button>
		<br><p style="position: relative;left: 20px;color:white">Line Opacity: <input id="defaultSlider" type="range" min="0" max="100" value="25" onchange="updateSlider1(this.value)" style="position: relative;left: 20px"/></p>
		
		
		<a href="#" title="Item 2">Metabolic Layout</a>
		<button class="btn btn-default btn-xs" title="Explode metabolic network by compartment (if problem, just refresh the page)" id="view2" style="position: relative;left: 20px;">explode</button>
		<button class="btn btn-default btn-xs" title="Put back initial view (if problem, just refresh the page)" id="view1" style="position: relative;left: 20px;">flatten</button>
		
		<a href="#" title="Item 3">Model Layout</a>
		<p style="position: relative;left: 20px;color:white">Choose Layout: <select name="select" id="selectLayout" onchange="selectValue(this)">
		  <option value="0" selected>Default</option> 
		</select><br> Scale: <input id="defaultSlider2" type="range" min="0" max="100" value="25" onchange="updateSlider2(this.value)" style="position: relative;left: 20px"/>
		<br> Separation between transition/places: <input id="defaultSlider3" type="range" min="0" max="100" value="25" onchange="updateSlider3(this.value)" style="position: relative;left: 20px"/>
		</p>
		
		<a href="#" title="Item 4">Simulation</a>
		
		<button class="btn btn-default btn-xs" title="Play a simulation trajectory" id="pauseSimulation" style="position: relative;left: 20px;" onclick="Pause();">Play/Pause</button><br><br>
		<input id="slider" type="range" min="0" max="500" step="1" value="0" onchange="updateSlider(this.value)" style="position: relative;left: 20px"/>
		<div id="timer" style="color:white;position: relative;left: 20px" >0.00</div><br>
		<select id="listSimModes" class="form-control-sm" title="Select a visualisation mode for the simulation." STYLE="font-size : 10pt; height: 25px;width: 140px; position: relative;left: 20px" onChange="change_simulationMode()" onkeydown="event.preventDefault();">
			<option value="0">Flux overview</option>
			<option value="1">Token game</option>
			<option value="2">Kegg activity</option>
			
		</select>
	</nav>

<div id="menu" >


			
<%	var data=[];
	_.each(mtb.file, function(compartment) {
		data.push(compartment);
	});
%>	
	

<script type="x-shader/x-vertex" id="vertexshaderP1">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP1">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP2">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP2">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP3">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP3">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP4">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP4">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		
		<script type="x-shader/x-vertex" id="vertexshaderP5">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP5">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP6">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP6">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP7">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP7">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshader2">

			uniform float amplitude;
			attribute vec3 displacement;
			attribute vec3 ca;
			varying vec3 vColor;
			varying float opacity;
			attribute float op;
			void main() {
				vec3 newPosition = position + amplitude * displacement;
				vColor = ca;
				opacity =op;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
			}
			//uniform float amplitude;
			//attribute vec3 displacement;
			//attribute vec3 ca;
			//varying vec3 vColor;
			//void main() {
			//	vec3 newPosition = position + amplitude * displacement;
			//	vColor = ca;
			//	gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
			//}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader2">
			uniform vec3 color;
			varying float opacity;
			varying vec3 vColor;
			void main() {

				gl_FragColor = vec4( vColor * color, opacity );

			}
			//uniform vec3 color;
			//uniform float opacity;
			//varying vec3 vColor;
			//void main() {

			//	gl_FragColor = vec4( vColor * color, opacity );

			//}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshader3">

			attribute float size;
			attribute vec3 ca;
			//uniform float mixAmount;
			attribute float mixAmount;
			attribute vec3 endPosition;
			varying vec3 vColor;

			void main() {

				vColor = ca;
				vec3 newPosition = mix( position, endPosition, mixAmount );
				vec4 mvPosition = modelViewMatrix * vec4( newPosition, 1.0 );

				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader3">

			uniform vec3 color;
			uniform sampler2D texture;

			varying vec3 vColor;

			void main() {

				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );

			}

		</script>	
	
<script>
(function($){
			$(document).ready(function(){
			$('#menuToggle').click(function(e){
			var $parent = $(this).parent('nav');
			$parent.toggleClass("open");
			var navState = $parent.hasClass('open') ? "hide" : "show";
			$(this).attr("title", navState + " navigation");
			// Set the timeout to the animation length in the CSS.
			setTimeout(function(){
			console.log("timeout set");
			$('#menuToggle > span').toggleClass("navClosed").toggleClass("navOpen");
			}, 200);
			e.preventDefault();
			});
			});
			})(jQuery);


var headTitles = <%-JSON.stringify( headtitles) %>
var results= <%-JSON.stringify( dataR) %>
var mtb= <%-JSON.stringify( mtb) %>
//console.log(results);
var qm= <%-JSON.stringify(exp.qsspn_model_instance) %>;

var stats = <%-JSON.stringify(stats)%>;
var nbRes=<%- nbRes %>;
//console.log(stats);

var names = Object.keys(stats);
var stats2 = [];
var lengthStats = 0;
if (stats.hasOwnProperty(names[0])){
	lengthStats =stats[names[0]].length;
}

for (var i=0; i< lengthStats; i++){
	stats2.push({data:[], name: "sample"+i});
}
for (var i=0; i< lengthStats; i++){
	for (var j=0, jj= names.length;j<jj; j++){
		stats2[i]['data'].push({'transition': names[j], 'nb_token':stats[names[j]][i]})
	}
}
//console.log(stats2);

var cbColModel, idsOfSelectedRows = [];
		var idsOfModelSelectedRows=[];





if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
		
		var renderer, renderer2, scene,scene2,  camera, stats, controls, camera2,pip;
		var element1;
		var PointCloud1, uniforms, attributes;
		var mouse = new THREE.Vector2(), INTERSECTED;
		var projector;
		//var vc1;
		var camTween;
		var mtween=false;
		var animatorT1;
		var halfvis;
		var allFalse= true;
		var simModeValue=0;
		var simFlowChart=0;
		var cntLabels=0;
		
		var WIDTH = window.innerWidth;
		var HEIGHT = window.innerHeight;
		var geometry;
		var bgeometryP1;
		var bgeometryP2;
		var bgeometryP3;
		var bgeometryP4;
		var bgeometryP5;
		var bgeometryP6;
		var bgeometryP7;
		
		var bgeometry2;
		var tokenGeometry;
		var tvertices ;
		var tvalues_size ;
		var tvalues_color ;
		var tvalues_p ;
		
		var geometryKegg;
		var keggSegment = 1000;
		var keggSegmentPts = keggSegment*2;
		var keggPositions;
		var keggColors;
		var listChangingKeggCoordinates=[];
		var previousKeggLength=0;
		var cubesGeometry=[];
		var keggCubesProperties={};
		var noKeggCube=true;
		
		var simTimer=0;
		var reactionIsDone=false;
		var listReactionsDone=[]
		//var simTimerPrevious=0;
		var simEnd=0;
		var simulationIsOn=false;
		var simulationIsPaused=false;
		var simRow=[];
		var simDataTime={};
		
		var scaleExplosion=3000;
		var nbCompartments=8;
		var nbOrganelles=nbCompartments-3;
		var organelles=[];
		var oldNbOrganelles=nbOrganelles;
		var	oldNbCompartments=nbCompartments;
		var nucleus;
		var cytoplasm;
		var ECM ;
		var arraymaterial=[];
		var onCompartments=[];
		for (var i=0;i<nbCompartments;i++){
			onCompartments[i]=false;
		}
		var draggingCompartments=[];
		for (var i=0;i<nbCompartments;i++){
			draggingCompartments[i]=false;
		}
		
		var particleClass = {
					0: "DNA",
					1: "RNA",
					2: "Protein",
					3: "Degradation Product",
					4: "Standard Petri Net",
					5: "Logical Transition",
					6: "Coarse Transition"
					};
		
		var particles;
		
		
		var arrows =[];
		
		
		var b1values_size;
		var b1positions;
		var b1values_color;
		var b1values_compartment;
		var particle1ShaderMaterial ;
		
		var b2values_size;
		var b2positions;
		var b2values_color;
		var b2values_compartment;
		var particle2ShaderMaterial ;
		
		var b3values_size;
		var b3positions;
		var b3values_color;
		var b3values_compartment;
		var particle3ShaderMaterial ;
		
		var b4values_size;
		var b4positions;
		var b4values_color;
		var b4values_compartment;
		var particle4ShaderMaterial ;
		
		var b5values_size;
		var b5positions;
		var b5values_color;
		var b5values_compartment;
		var particle5ShaderMaterial ;
		
		var b6values_size;
		var b6positions;
		var b6values_color;
		var b6values_compartment;
		var particle6ShaderMaterial ;
		
		var b7values_size;
		var b7positions;
		var b7values_color;
		var b7values_compartment;
		var particle7ShaderMaterial ;
		var linesShaderMaterial;
		var tokenShaderMaterial;
		var marker=0;
		var sprite;
		
		var b2lpositions;
		var b2lcolors ;
		var b2lcompartments;
		var b2lopacity;
		// 
		var cssScene;
		var rendererCSS;
		var cssObjects=[];
		
		var cssScene2;
		var rendererCSS2;
		var cssObjects2=[];
		
		var cssScene3;
		var rendererCSS3;
		var cssObjects3=[];
		// 
		var flagPick=0;
		
			
		var outlineMaterial1;
		var outlineMesh1;
		var lineGeometry;
		var mesh;
		var tokenPS;
		// clock to animate particles
		var clock = new THREE.Clock();
		
		var parameters;
		var gui;
		
		var isOnParticle=0;
		var isOnLine=0;
		var keyboard = new KeyboardState();
		var goUp=false;
		var goDown=false;
		var goLeft=false;
		var goRight=false;
		var zoomIn=false;
		var zoomOut=false;
		var closest;
		var closestLine;
		var closestid;
		var closestType=-1;
		var hoveredType=-1;
		var sizeParticleGuiElem;
		var colorParticleGuiElem;
		var colorParticleGui = new THREE.Color( 0xffffff );
		
		var stopThreeJsMouseEvent=false;
		var spreadsheet1Visible=false
		
		var updatedListModels=false;
		var updatedModel=false;
		var resetSpreadsheet=false;
		var modelData;
		var simData;
		var simDataBounds=[];
		
		var stackTokenModel=[];
		startPositionTokenMap={};
		endPositionTokenMap={};
		
		function cameraGoTo(position, target) {
						TWEEN.removeAll();
						new TWEEN.Tween( camera.position ).delay(300)
						.to( { x: position.x, y: position.y, z: position.z }, 300 )
						.start();
						new TWEEN.Tween( controls.target )
						.to( { x: target.x, y: target.y, z: target.z }, 300 )
						.start();
						
					}
		var timerElement=document.getElementById("timer");
		var sliderElement=document.getElementById("slider");
		var listModels;
		
		
		var modelVisible=false;
		var selectedModel;
		var selectedMetabolicData;
		//var 
		//default metabolic network file is: recon2.v02.xml_metabolic_net
		//xhttp.open("GET","recon2.v02.xml_metabolic_net2.json",false);
		//xhttp.send();
		selectedMetabolicData = <%-JSON.stringify(data)%>
		console.log("getting metabolic data from default file recon2");
		// set list of edges and nodes from default metabolic data
		var metabolicEdges;
		var metabolicNodes;
		var metabolicCompartments;
		
		metabolicCompartments = selectedMetabolicData[0];
		nbCompartments=metabolicCompartments.length
					
		nbOrganelles=nbCompartments-3;
		var nameModel=mtb.name;
		var mapComp = {'-1':-1, g:0 ,r:1 ,l:2 ,m:3 ,x:4 ,n:5 ,c:6 ,e:7 }
		var nameComp = ["golgi","ER","lysosome","mytochodria","peroxisome", "nucleus", "cytoplasm" ,"extra-cellular" ];
		if (nameModel=="Ec_iAF1260_flux2"){
			mapComp = {'-1':-1, Extra_organism:0 ,Periplasm:1 ,Cytosol:2}
			nameComp = ["Extra_organism","Periplasm","Cytosol" ];	
			//element1.src	= "slickgrid132E.html"	
		}
		
		else if (nameModel=="hepatonet1-msb201062-s5"){
			mapComp = {'-1':-1, GolErMi:0 ,bile:1 ,lyso:2 ,mito:3 ,peroxy:4 ,nuc:5 ,cyto:6 ,ext:7 }
			nameComp = ["GolErMi","bile","lysosome","mytochodria","peroxisome", "nucleus", "cytoplasm" ,"extra-cellular" ];	
			//element1.src	= "slickgrid13HP.html"	
		}
		else{
			mapComp = {'-1':-1, g:0 ,r:1 ,l:2 ,m:3 ,x:4 ,n:5 ,c:6 ,e:7 }
			nameComp = ["golgi","ER","lysosome","mytochodria","peroxisome", "nucleus", "cytoplasm" ,"extra-cellular" ];		
			//element1.src	= "slickgrid131.html"						
		}
		
		
		
		
		//for (var i=0;i<nbCompartments;i++){
		//	mapComp[metabolicCompartments[i][0]]=i;
		//}
		metabolicNodes = selectedMetabolicData[1];
		metabolicEdges = selectedMetabolicData[2];
		
		//console.log(listModels);
		//console.log(simpleListModels);
		//console.log(listMetabolicFiles);
		//console.log(metabolicCompartments);
		//console.log(metabolicNodes);
		//console.log(metabolicEdges);
		
		// open json files with lists of nodes and edges
		//var xhttp=new XMLHttpRequest();
		//xhttp.open("GET","listNodes12.json",false);
		//xhttp.send();
		//var jsonObj4=JSON.parse(xhttp.responseText);
		//console.log(jsonObj4);
		
		//xhttp.open("GET","listEdges.json",false);
		//xhttp.send();
		//var jsonObj3=JSON.parse(xhttp.responseText);
		//console.log(jsonObj3);
		
		var jsonObj1=metabolicNodes
		var jsonObj2=metabolicEdges
		//console.log(jsonObj1);
		//console.log(jsonObj2);
		
		// extract number of qsspn typed icons from lists of nodes...
		var mnbDNA=0;
		var mnbRNA=0;
		var mnbProt=0;
		var mnbDegProd=0;
		var mnbPN=0;
		var mnbLog=0;
		var mnbCoarse=0;
		
		var nbPlacesModel=0;
		var nbReactionsModel=0;
		var nbEdgesModel=0;
		/*for (var i = 0, ii= jsonObj1.length;i<ii;i++){
			if (jsonObj1[i]['typeQSSPN']==0){
				mnbDNA++;
			}
			if (jsonObj1[i]['typeQSSPN']==1){
				mnbRNA++;
			}
			if (jsonObj1[i]['typeQSSPN']==2){
				mnbProt++;
			}
			if (jsonObj1[i]['typeQSSPN']==3){
				mnbDegProd++;
			}
			if (jsonObj1[i]['typeQSSPN']==4){
				mnbPN++;
			}
			if (jsonObj1[i]['typeQSSPN']==5){
				mnbLog++;
			}
			if (jsonObj1[i]['typeQSSPN']==6){
				mnbCoarse++;
			}
			
			
		}*/
		
		for (var i = 0, ii= jsonObj1.length;i<ii;i++){
			if (jsonObj1[i][6]==0){
				mnbDNA++;
			}
			if (jsonObj1[i][6]==1){
				mnbRNA++;
			}
			if (jsonObj1[i][6]==2){
				mnbProt++;
			}
			if (jsonObj1[i][6]==3){
				mnbDegProd++;
			}
			if (jsonObj1[i][6]==4){
				mnbPN++;
			}
			if (jsonObj1[i][6]==5){
				mnbLog++;
			}
			if (jsonObj1[i][6]==6){
				mnbCoarse++;
			}
		}
		var selectedModelEdges;
		var selectedModelNodes;
		
		
		//console.log(mnbDNA);
		//console.log(mnbRNA);
		//console.log(mnbProt);
		//console.log(mnbDegProd);
		//console.log(mnbPN);
		//console.log(mnbLog);
		//console.log(mnbCoarse);
		var nbDNAParticles=mnbDNA; // nb of DNA elements
		var nbRNAParticles=mnbRNA; // nb of RNA elements
		var nbProtParticles=mnbProt+10000; // nb of proteins
		var nbDegradParticles=mnbDegProd; // nb of degradation products
		var nbPNParticles=mnbPN+10000; // nb of PN standard places
		var nbLogParticles=mnbLog; // nb of logical PN places
		var nbCoarseParticles=mnbCoarse; // nb of PN coarse transitions
		var maxNbTokenModel=20000;
		var idMap=[];
		var typesMap=[];
		for (var i=0;i<7;i++){
			typesMap[i]=[];
		};
		var reactionMap=[];
		
		var segments =jsonObj2.length;
		//var segments =0;
		var segmentPts =segments*2;
		
		
		var geometryLineChart;
		var chartSegment = 6000;
		var chartSegmentPts = chartSegment*2;
		var chartPositions ;
		var chartColors ;
		var meshLineChart ;
		
		
		//$.get( "slickgrid7.html", function( data ) {
  //alert( "Data Loaded: " + data );
//});
		
		var mselectedList=[];
		// element for spreadsheet selection
		spritesSelected=[];
		nbSpritesSelected=50;
		var modelspritesSelected=[];
		var modelnbSpritesSelected=50;
		
		var modelReactionLocators=[];
		var modelProductLocators=[];
		var modelReactantLocators=[];
		var modelModifierLocators=[];
		
		var nbModelReactionLocators=50;
		var nbModelPlanesFlow=500;
		var planeMesh=[];
		var stackModel2PlaneMesh=[];
		var flowsStack=[];
		var selectedNodesPaths=[];
		var selectedModelNodesPaths=[];
		var selectedLinesPaths=[];
		var selectedModelLinesPaths=[];
		var toggledLines=0
		var toggledToken=0
		var linesMap=[]
		var selectedLinesPathsIds=[];
		var extraLinesCnt=0;
		var startModelPlaces=0;
		var startModelReactions=0;
		var endModelPlaces=0;
		var endModelReactions=0;
		var myLink =[]
		var myLinkName=[]
		for (var ln =0;ln<10;ln++){
			myLink[ln]=""
			myLinkName[ln]=""
		}
		
		var tokenFlux=[];
		var tokenBounds=[];
		var indexDisabledToken=[];
		
		var tokenStackCount=0;
		var clearedTokenIndex=[]
		
		//var anim = document.getElementById("animload");
		//anim.style.visibility="hidden";
		
		
		
		//var announcementText= document.createElement('div');
		var announcementText= document.getElementById("advert");
		announcementText.style.position = 'absolute';
		
		announcementText.style.width = 100;
		announcementText.style.height = 100;
		//announcementText.setAttribute('animation', 'fadeOut');
		
		announcementText.style.color = "white";
		announcementText.style.textAlign="left";
		announcementText.style.border="3px solid";
		announcementText.style.font="italic bold 20px arial";
		announcementText.style.padding="5px";
		announcementText.style.background="#33AA33";
		//announcementText.style.cssText = 'border: 3px solid #FFF;border-radius: 5px;color: #FFF;font-family: arial;';
		//text0.style.backgroundColor = "#FFFFCC";
		//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
		announcementText.innerHTML = '<p>hello </p>';
		
		announcementText.style.top = 2000 + 'px';
		announcementText.style.left = 2000 + 'px';
		document.body.appendChild(announcementText);
		
		
		var text0 = document.createElement('div');
		text0.style.position = 'absolute';
		text0.style.width = 100;
		text0.style.height = 100;
		text0.style.color = "white";
		text0.style.textAlign="left";
		//text0.style.backgroundColor = "#FFFFCC";
		//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
		text0.innerHTML = 'hello ';
		text0.style.top = 2000 + 'px';
		text0.style.left = 2000 + 'px';
		//document.body.appendChild(text0);
		document.getElementById("container").appendChild(text0);
		var text1 = document.createElement('div');
		text1.style.position = 'absolute';
		text1.style.width = 100;
		text1.style.height = 100;
		text1.style.color = "black";
		text1.style.backgroundColor = "#FFFFCC";
		//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
		text1.innerHTML = 'hello ';
		text1.style.top = 2000 + 'px';
		text1.style.left = 2000 + 'px';
		//text1.style.zIndex = -1;
		document.body.appendChild(text1);
		
		var textk = document.createElement('div');
		textk.style.position = 'absolute';
		textk.style.width = 100;
		textk.style.height = 100;
		textk.style.color = "black";
		textk.style.backgroundColor = "#FFFFCC";
		//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
		textk.innerHTML = 'hello ';
		textk.style.top = 2000 + 'px';
		textk.style.left = 2000 + 'px';
		document.body.appendChild(textk);
		var textkPreviousPos= new THREE.Vector3( 2000, 2000, 1 );
		
		var text1PreviousPos= new THREE.Vector3( 2000, 2000, 1 );
		var text1PreviousString="";
		
		
		var listGenes = document.createElement('div');
		listGenes.id="listGenes";
		var listGenesTitle = document.createElement('div');
		listGenesTitle.innerHTML="Expressed by gene(s):";
		listGenesTitle.style.textAlign="left";
		var listGenesContent = document.createElement('div');
		listGenesContent.className="scroll-box";
		listGenes.style.color = "white";
		listGenesContent.style.color = "white";
		listGenesContent.innerHTML = '<ul style="margin-left:0em;padding-left:1.3em;height:50px;"><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li></ul>';
		listGenes.style.position = 'absolute';
		listGenes.style.top = 2000 + 'px';
		listGenes.style.left = 2000 + 'px';
		listGenes.appendChild(listGenesTitle);
		listGenes.appendChild(listGenesContent);
		//document.body.appendChild(listGenes);
		document.getElementById("container").appendChild(listGenes);
		
		var listLinks = document.createElement('div');
		listLinks.id="listLinks";
		var listLinksTitle = document.createElement('div');
		listLinksTitle.innerHTML="Connectivity:";
		listLinksTitle.style.color = "white";
		listLinksTitle.style.textAlign="left";
		var listLinksContent = document.createElement('div');
		listLinksContent.className="scroll-box";
		
		listLinksContent.style.color = "white";
		listLinksContent.innerHTML = '<ul style="margin-left:0em;padding-left:1.3em;height:150px;"><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li></ul>';
		listLinks.style.position = 'absolute';
		listLinks.style.top = 2000 + 'px';
		listLinks.style.left = 2000 + 'px';
		listLinks.appendChild(listLinksTitle);
		listLinks.appendChild(listLinksContent);
		//document.body.appendChild(listLinks);
		document.getElementById("container").appendChild(listLinks);
		
		var txtComp=[]
		for (var i=0;i<10;i++){
			txtComp[i] = document.createElement('div');
			txtComp[i].style.position = 'absolute';
			txtComp[i].style.width = 100;
			txtComp[i].style.height = 100;
			txtComp[i].style.color = "black";
			//txtComp[i].style.fontWeight="1900";
			txtComp[i].style.backgroundColor = "#99FFCC";
			//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
			txtComp[i].innerHTML = 'hello ';
			txtComp[i].style.top = 2000 + 'px';
			txtComp[i].style.left = 2000 + 'px';
			//text1.style.zIndex = -1;
			document.body.appendChild(txtComp[i]);
			
		}
		var exploded=false;
		var focus_label=-1;
		var allDragged=[];
		for (var i=0;i<nbCompartments;i++){
			allDragged[i]=[]
		}
		
		
		var txtReactionActivation=[]
		var nbActivation=3000;
		var tokenIDStackCount={};
		for (var i=0;i<nbActivation;i++){
			txtReactionActivation[i] = document.createElement('div');
			txtReactionActivation[i].style.position = 'absolute';
			txtReactionActivation[i].style.width = 100;
			txtReactionActivation[i].style.height = 100;
			txtReactionActivation[i].style.color = "white";
			//txtComp[i].style.fontWeight="1900";
			//txtReactionActivation[i].style.backgroundColor = "#99FFCC";
			//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
			txtReactionActivation[i].innerHTML = 'hello ';
			txtReactionActivation[i].style.top = 2000 + 'px';
			txtReactionActivation[i].style.left = 2000 + 'px';
			//text1.style.zIndex = -1;
			document.body.appendChild(txtReactionActivation[i]);
			
		}
		var positionContainer;
		var yStartDisplacement=400;
		
		var contYPos;
		var halfHeight;
		
			simData=[headTitles, results,1];
			// get last simulation version of simdata
			var allEventNone=true;
			//console.log(simData)
			for ( var i=0;i<simData[1].length;i++){
				if(simData[1][i] && simData[1][i][2]!="none"){
					//console.log(simData[1][i][2]+ "  :"+i + " length"+simData[1][i].length);
					
					allEventNone=false;
				}
				for (var j=0;j<simData[1][i].length;j++){
					if(j!=0 && j!= 2){
					var trans = parseFloat(simData[1][i][j]);
						
						if (!isFinite(trans)){
							console.log("Cant't extract float number from "+simData[1][i][j]+ "  row "+i);
							simData[1][i][j]=0;
						}
						else{
							simData[1][i][j]=parseFloat(simData[1][i][j]);
						}
					}
				}
				simTimer=0;
				simEnd=simData[1][simData[1].length-1][1];
				sliderElement.setAttribute("min", simTimer);
				sliderElement.setAttribute("max", simData[1].length-1);
			}
			var tempDataBounds={};
			for(var i=3;i<simData[0].length-1;i++){
				tempDataBounds[simData[0][i]]=[];
			}
			//console.log(simDataBounds);
			for ( var i=0;i<simData[1].length;i++){
				for(var j=3;j<simData[0].length-1;j++){
					
					tempDataBounds[simData[0][j]].push(simData[1][i][j]);
				}
			}
			//console.log(tempDataBounds);
			simDataBounds=[];
			
			for(var j=3;j<simData[0].length-1;j++){
			var min = Math.min.apply(null, tempDataBounds[simData[0][j]]);
			var max = Math.max.apply(null, tempDataBounds[simData[0][j]]);
			//if (!isFinite(min) || !isFinite(max)){
			//	console.log("min max pb"+ min + " " + max + " " +j)
			//}
				simDataBounds.push( [ Math.min.apply(null, tempDataBounds[simData[0][j]]) , Math.max.apply(null, tempDataBounds[simData[0][j]]) ]);
			}
			//console.log (simDataBounds);
			
			if (allEventNone==true){
				console.log("start simulation without triggered events cascades")
			}
			else{
				console.log("start simulation with triggered events cascades")
			}
			//updatedListModels=true;

			// create an object data structure with unique time ids with a corresponding list of rows
			simDataTime={};
			var tmpQueue=[];
			for ( var i=0;i<simData[1].length;i++){
				if (tmpQueue.indexOf(simData[1][i][1])==-1){
					simDataTime[simData[1][i][1]]=[simData[1][i]];
					tmpQueue=[];
					tmpQueue.push(simData[1][i][1]);
				}
				else{
				//console.log("similar index "+simData[1][i][1])
					simDataTime[simData[1][i][1]].push(simData[1][i]);
				}
			}
		
		
		function change_simulationMode(){
			simModeValue = document.getElementById("listSimModes").value;
			tokenIDStackCount={};
			for (var i=0;i<nbActivation;i++){	
				txtReactionActivation[i].innerHTML = '';
				txtReactionActivation[i].style.top = 2000 + 'px';
				txtReactionActivation[i].style.left = 2000 + 'px';
			}
			for(var v=0;v<nbModelReactionLocators;v++){
				modelProductLocators[v].position.set(50000,50000,-50000);
				modelReactantLocators[v].position.set(50000,50000,-50000);
				modelModifierLocators[v].position.set(50000,50000,-50000);
			}
			simTimer=0;
			simulationIsPaused=false;
			simulationIsOn=false;
			//stackTokenModel=[];
			allFalse=true;
			
			//for(var i=0;i<nbModelPlanesFlow;i++){
			//	planeMesh[i].position.set(0,0,50000);
			//}
			//for ( var i = 0; i < 1000; i ++ ) {
			//	cubesGeometry[i].position.x=50000;
			//	cubesGeometry[i].position.y=200;
			//	cubesGeometry[i].position.z=-50000;
			//}
			//var iv=0;
			//for ( var i = 0; i < chartSegment; i ++ ) {
			//	chartPositions[ (iv * 3)+0 ] = 50400;
			//	chartPositions[ (iv * 3) + 1 ] = 0;
			//	chartPositions[ (iv * 3) + 2 ] = -50400;
				//chartColors[ iv * 3 ] = col.r;
				//chartColors[ iv * 3 + 1 ] = col.g;
				//chartColors[ iv * 3 + 2 ] = col.b;
			//	iv++;
			//	chartPositions[ (iv * 3)+0 ] = 50400;
			//	chartPositions[ (iv * 3) + 1 ] = 0;
			//	chartPositions[ (iv * 3) + 2 ] = -50400;
				//chartColors[ iv * 3 ] = col.r;
				//chartColors[ iv * 3 + 1 ] = col.g;
				//chartColors[ iv * 3 + 2 ] = col.b;
			//	iv++
			//}			
			//geometryLineChart.attributes.position.needsUpdate = true;
			//for (var i=segmentPts;i<b2lopacity.length;i++){	
			//	b2lopacity[i]=0.7;	
			//}
			//scene.children[7].geometry.attributes.op.needsUpdate = true;
			
			//stackTokenModel=[];
			//startPositionTokenMap={};
			//endPositionTokenMap={};
			//console.log(simModeValue);
		}
		
		function startTimer(){
			simTimer=0;
			simulationIsOn=true;
			for (var tkNb=0; tkNb< txtReactionActivation.length;tkNb++){
							
							txtReactionActivation[tkNb].innerHTML = '';
						}
		}
		function Pause(){
			//console.log(simData)
			if (simulationIsPaused){
				
				simulationIsPaused=false;
				if (simTimer==0){
					for (var tkNb=0; tkNb< txtReactionActivation.length;tkNb++){	
						txtReactionActivation[tkNb].innerHTML = '';
					}
				}
				
			}
			else if ( simulationIsOn==false && simulationIsPaused==false && simData){
				if (simTimer==0){
					for (var tkNb=0; tkNb< txtReactionActivation.length;tkNb++){	
						txtReactionActivation[tkNb].innerHTML = '';
					}
				}
				simulationIsPaused=false;
				simulationIsOn=true;
			}
			else{
				
				simulationIsPaused=true;
				for (var tkNb=0; tkNb< txtReactionActivation.length;tkNb++){
							
							txtReactionActivation[tkNb].innerHTML = '';
						}
			}
		}
		function change_simulationFlow(){
			simFlowChart = document.getElementById("listFlows").value;
			if (simFlowChart==0){
				pip.style.top = 2000 + 'px';
				pip.style.left = 2000 + 'px';
			}
			else{
				pip.style.top = 25 + 'px';
				pip.style.left = 25 + 'px';
			}
		}
		
		function updateSlider1(slideAmount){
			console.log(slideAmount/100);
			for (var i=0;i<segmentPts;i++){
				for (var i=0;i<b2lopacity.length;i++){
					
					b2lopacity[i]=(parseFloat(slideAmount)/100);
				}	
			}
			scene.children[7].geometry.attributes.op.needsUpdate = true;
		}
		
		
		function updateSlider(slideAmount){
			if (simData){
				if (simModeValue==0){
					//timerElement.innerHTML=""+slideAmount;
					timerElement.innerHTML=""+simData[1][slideAmount][1];
					//timerElement.innerHTML=""+simDataTime[Object.keys(simDataTime)[simTimer]][0][1];
					simTimer=slideAmount;
					simRow=simData[1][simTimer];
					
					//sliderElement.value=simTimer;
						simRow=simDataTime[Object.keys(simDataTime)[simTimer]];
						//console.log(simRow)
						
						//setAttribute("value", simTimer);
						// change property of model nodes to express flux
						
						// change nodes size according to flux values (take into account boundaries as min/max values)
						var ln1 = startModelPlaces;
						var ln2 = startModelReactions;
						var cnt1=0;
						var cnt2 = 0;
						for(var j=3;j<simData[1][simTimer].length-1;j++){
							var min = simDataBounds[j-3][0];
							var max = simDataBounds[j-3][1];
							var size=30;
							if ((max-min)!=0){
								size = 30+(50*(simData[1][simTimer][j]-min)/(max-min));
								if (!isFinite(size)){
									size =30;
								}
								for(var j1=0;j1<selectedModelNodes.length;j1++){
									if (selectedModelNodes[j1][1]==simData[0][j]){
										//console.log(simData[0][j]);
										if (selectedModelNodes[j1][5]==2 ){
											scene.children[2].geometry.attributes.size.array[(ln1+cnt1)]= size;
											//bgeometryP3.attributes.size.array[(ln1+cnt1)]= size;
											//console.log("resize place"+(cnt1))
											cnt1++;
										}
										if (selectedModelNodes[j1][5]==4 ){
											scene.children[4].geometry.attributes.size.array[(ln2+cnt2)]= size;
											//bgeometryP5.attributes.size.array[(ln2+cnt2)]= size;
											//console.log("resize reaction"+size)
											cnt2++;
										}
									}
								}
							}
							//console.log(simData[0][j])
						}
						scene.children[2].geometry.attributes.size.needsUpdate = true;
						scene.children[4].geometry.attributes.size.needsUpdate = true;
					
					//console.log(simRow);
				}
				if (simModeValue==1){
					//timerElement.innerHTML=""+slideAmount;
					timerElement.innerHTML=""+simData[1][slideAmount][1];
					
					//timerElement.innerHTML=""+simDataTime[Object.keys(simDataTime)[slideAmount]][0][1];
					simTimer=slideAmount;
					//simRow=[simData[1][simTimer]];
					
					//sliderElement.value=simTimer;
						simRow=simDataTime[Object.keys(simDataTime)[simTimer]];
						//console.log(simRow)
						
						//setAttribute("value", simTimer);
						// change property of model nodes to express flux
						
						// change nodes size according to flux values (take into account boundaries as min/max values)
						var ln1 = startModelPlaces;
						var ln2 = startModelReactions;
						var cnt1=0;
						var cnt2 = 0;
						for(var j=3;j<simData[1][simTimer].length-1;j++){
							var min = simDataBounds[j-3][0];
							var max = simDataBounds[j-3][1];
							var size=30;
							if ((max-min)!=0){
								size = 30+(50*(simData[1][simTimer][j]-min)/(max-min));
								
								if (!isFinite(size)){
									size =30;
								}
								for(var j1=0;j1<selectedModelNodes.length;j1++){
									if (selectedModelNodes[j1][1]==simData[0][j]){
										//console.log(simData[0][j]);
										if (selectedModelNodes[j1][5]==2 ){
											scene.children[2].geometry.attributes.size.array[(ln1+cnt1)]= size;
											//bgeometryP3.attributes.size.array[(ln1+cnt1)]= size;
											//console.log("resize place"+(cnt1))
											cnt1++;
										}
										if (selectedModelNodes[j1][5]==4 ){
											scene.children[4].geometry.attributes.size.array[(ln2+cnt2)]= size;
											//bgeometryP5.attributes.size.array[(ln2+cnt2)]= size;
											//console.log("resize reaction"+size)
											cnt2++;
										}
									}
								}
							}
							//console.log(simData[0][j])
						}
						scene.children[2].geometry.attributes.size.needsUpdate = true;
						scene.children[4].geometry.attributes.size.needsUpdate = true;
					
					//console.log(simRow);
				}
			}
		}
		
		function updateSlider2(slideAmount){
			console.log(slideAmount/100);
			for (var i=0;i<segmentPts;i++){
				for (var i=0;i<b2lopacity.length;i++){
					
					b2lopacity[i]=(parseFloat(slideAmount)/100);
				}	
			}
			scene.children[7].geometry.attributes.op.needsUpdate = true;
		}
		
		selectedModel = qm.extra;
		selectedModelNodes=selectedModel[2];
		selectedModelEdges=selectedModel[3];
		//console.log(selectedModelNodes);
		//console.log(selectedModelEdges);
		// in model edges, position index 2: product = 1 , preplace =2, consumed = 0
	
		nbPlacesModel=0;
		nbReactionsModel=0;
		nbEdgesModel=selectedModelEdges.length;
		
		for (var i = 0, ii= selectedModelNodes.length;i<ii;i++){
			if (selectedModelNodes[i][5]==2 ){
				nbPlacesModel++;					
			}
			if (selectedModelNodes[i][5]==4 ){
				nbReactionsModel++;
			}
		}
		var layouts = <%- JSON.stringify(ly)%>;
		for (elem in layouts){
			if (layouts.hasOwnProperty(elem)){
				$('#selectLayout').append("<option>"+elem+"</option>")
			}
		}
		init();
		animate();
		
		
		function init() {
		
		
			//localStorage.selection=[];
			//localStorage.;

			camera = new THREE.PerspectiveCamera( 45, WIDTH / HEIGHT, 1, 30000 );
			//camera.position.z = 800;
			
			camera.position.y = 500+1.0*yStartDisplacement;
			camera.position.x = 3500;
			//camera2 = new THREE.PerspectiveCamera( 45, WIDTH / HEIGHT, 1, 10000 );
			//camera2.position.z = 250;
			
			

			scene = new THREE.Scene();
			scene2 = new THREE.Scene();
			//////////////////////////////////////////////////
			// define shader attributes for group of particles dna
			particleP1Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP1Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/dna8-green.png" ) }
				

			};

			particleP1Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles rna
			particleP2Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP2Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/rna8.png" ) }
				

			};

			particleP2Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles proteins
			particleP3Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP3Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/disc.png" ) }
				

			};

			particleP3Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles degradation product
			particleP4Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP4Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/disc.png" ) }
				

			};

			particleP4Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles standard pn
			particleP5Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP5Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/PN1.png" ) }
				

			};

			particleP5Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles pn logical
			particleP6Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP6Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/PNLogical1.png" ) }
				

			};

			particleP6Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles pn coarse
			particleP7Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP7Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/PNCoarse1.png" ) }
				

			};

			particleP7Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			// define shader material for group of particles dna
			particle1ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP1Uniforms,
				attributes:     particleP1Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP1' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP1' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle2ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP2Uniforms,
				attributes:     particleP2Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP2' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP2' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle3ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP3Uniforms,
				attributes:     particleP3Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP3' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP3' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle4ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP4Uniforms,
				attributes:     particleP4Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP4' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP4' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle5ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP5Uniforms,
				attributes:     particleP5Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP5' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP5' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle6ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP6Uniforms,
				attributes:     particleP6Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP6' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP6' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle7ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP7Uniforms,
				attributes:     particleP7Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP7' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP7' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			//////////////////////////////////////////////
			// define shader attributes for group of lines
			linesAttributes = {

				displacement: {	type: 'v3', value: [] },
				ca: {	type: 'c', value: [] },
				op:{ type: "f", value: [] }

			};

			linesUniforms = {

				amplitude: { type: "f", value: 1.0 },
				opacity:   { type: "f", value: 0.7 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) }

			};
			// define shader material for group of lines
			linesShaderMaterial = new THREE.ShaderMaterial( {

				uniforms:       linesUniforms,
				attributes:     linesAttributes,
				vertexShader:   document.getElementById( 'vertexshader2' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshader2' ).textContent,
				blending:       THREE.AdditiveBlending,
				depthTest:      false,
				transparent:    true

			});

			linesShaderMaterial.linewidth = 1;
			//linesShaderMaterial.attributes.op.value=0.7;
			
			
			
			
			
			/////////////////////////////////////////////////////////////////
			// define shader attributes for group of animated token particles
			tokenAttributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] },
				endPosition: { type: "v3", value: [] },
				mixAmount: 	 { type: 'f', value: [] }
			};

			tokenUniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/small-spark.png" ) }//,
				//mixAmount: 	 { type: "f", value: 0.0 }

			};

			//uniforms.texture.value.wrapS = uniforms.texture.value.wrapT = THREE.RepeatWrapping;

			tokenShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		tokenUniforms,
				attributes:     tokenAttributes,
				vertexShader:   document.getElementById( 'vertexshader3' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshader3' ).textContent,
				depthTest: 		false,
				transparent:	true,
				opacity: 0.8,
				blending:	true

			});
			
			
			//particles = nbDNAParticles // nb of DNA elements
			//+ nbRNAParticles // nb of RNA elements
			//+ nbProtParticles // nb of proteins
			//+ nbDegradParticles // nb of degradation products
			//+ nbPNParticles // nb of PN standard places
			//+ nbLogParticles // nb of logical PN places
			//+ nbCoarseParticles; // nb of PN coarse transitions
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for dna particles
			bgeometryP1 = new THREE.BufferGeometry();
			
			bgeometryP1.dynamic = true;
			bgeometryP1.attributes = {

				position: {
					itemSize: 3,
					array: new Float32Array( nbDNAParticles * 3 )
				},
				ca: {
					itemSize: 3,
					array: new Float32Array( nbDNAParticles * 3 )
				},
				size: {
					itemSize: 1,
					array: new Float32Array( nbDNAParticles ),
					dynamic: true
				},
				compartment: {
					itemSize: 1,
					array: new Float32Array( nbDNAParticles ),
					dynamic: true
				}

			}
			bgeometryP1.attributes.size.needsUpdate = true;
			bgeometryP1.attributes.position.needsUpdate = true;
			bgeometryP1.attributes.ca.needsUpdate = true;
			bgeometryP1.attributes.compartment.needsUpdate = true;

			b1values_size = bgeometryP1.attributes.size.array;
			b1positions = bgeometryP1.attributes.position.array;
			b1values_color = bgeometryP1.attributes.ca.array;
			b1values_compartment = bgeometryP1.attributes.compartment.array;
			
			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xffffff );
			var radius =400;
			for( var bv = 0; bv < nbDNAParticles; bv++ ) {
			

				b1values_size[ bv ] = 10;
				b1values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;

				b1positions[ (bv * 3) + 0 ] = (Math.random() * 2 - 1) * radius;
				//b1positions[ (bv * 3) + 1 ] = (Math.random() * 2 - 1) * radius;
				b1positions[ (bv * 3) + 1 ] = yStartDisplacement;
				b1positions[ (bv * 3) + 2 ] = (Math.random() * 2 - 1) * radius;
				
				
				//if ( positions[ bv * 3 + 0 ] < 0 )
				//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
				//else
				//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
				b1values_color[ (bv * 3) + 0 ] = color.r;
				b1values_color[ (bv * 3) + 1 ] = color.g;
				b1values_color[ (bv * 3) + 2 ] = color.b;

			}
			//console.log(bgeometryP1);
			
			// associate first particle system with bufferGeometry
			PointCloud1 = new THREE.PointCloud( bgeometryP1, particle1ShaderMaterial );

			PointCloud1.dynamic = true;
			PointCloud1.sortParticles = true;
			PointCloud1.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud1 );
			
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for rna particles
			bgeometryP2 = new THREE.BufferGeometry();
			
			bgeometryP2.dynamic = true;
			bgeometryP2.attributes = {

				position: {
					itemSize: 3,
					array: new Float32Array( nbRNAParticles * 3 )
				},
				ca: {
					itemSize: 3,
					array: new Float32Array( nbRNAParticles * 3 )
				},
				size: {
					itemSize: 1,
					array: new Float32Array( nbRNAParticles ),
					dynamic: true
				},
				compartment: {
					itemSize: 1,
					array: new Float32Array( nbRNAParticles ),
					dynamic: true
				}
				

			}
			bgeometryP2.attributes.size.needsUpdate = true;
			bgeometryP2.attributes.position.needsUpdate = true;
			bgeometryP2.attributes.ca.needsUpdate = true;
			bgeometryP2.attributes.compartment.needsUpdate = true;

			b2values_size = bgeometryP2.attributes.size.array;
			b2positions = bgeometryP2.attributes.position.array;
			b2values_color = bgeometryP2.attributes.ca.array;
			b2values_compartment = bgeometryP2.attributes.compartment.array;
			
			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xffffff );;
			var radius =400;
			for( var bv = 0; bv < nbRNAParticles; bv++ ) {
			

				b2values_size[ bv ] = 10;
				b2values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
				
				b2positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius;
				//b2positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
				b2positions[ bv * 3 + 1 ] = yStartDisplacement;
				
				b2positions[ bv * 3 + 2 ] = (Math.random() * 2 - 1) * radius;
				
				
				//if ( positions[ bv * 3 + 0 ] < 0 )
				//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
				//else
				//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
				b2values_color[ bv * 3 + 0 ] = color.r;
				b2values_color[ bv * 3 + 1 ] = color.g;
				b2values_color[ bv * 3 + 2 ] = color.b;

			}
			
			
			// associate first particle system with bufferGeometry
			PointCloud2 = new THREE.PointCloud( bgeometryP2, particle2ShaderMaterial );

			PointCloud2.dynamic = true;
			PointCloud2.sortParticles = true;
			PointCloud2.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud2 );
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for protein particles
			bgeometryP3 = new THREE.BufferGeometry();
			
			bgeometryP3.dynamic = true;
			bgeometryP3.attributes = {

				position: {
					itemSize: 3,
					array: new Float32Array( nbProtParticles * 3 )
				},
				ca: {
					itemSize: 3,
					array: new Float32Array( nbProtParticles * 3 )
				},
				size: {
					itemSize: 1,
					array: new Float32Array( nbProtParticles ),
					dynamic: true
				},
				compartment: {
					itemSize: 1,
					array: new Float32Array( nbProtParticles ),
					dynamic: true
				}

			}
			bgeometryP3.attributes.size.needsUpdate = true;
			bgeometryP3.attributes.position.needsUpdate = true;
			bgeometryP3.attributes.ca.needsUpdate = true;
			bgeometryP3.attributes.compartment.needsUpdate = true;

			b3values_size = bgeometryP3.attributes.size.array;
			b3positions = bgeometryP3.attributes.position.array;
			b3values_color = bgeometryP3.attributes.ca.array;
			b3values_compartment = bgeometryP3.attributes.compartment.array;
			
			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xff9900 );;
			var color2 = new THREE.Color( 0x55ff55 );
			var radius =400;
			var bv=0;
			//for( var bv = 0; bv < nbProtParticles; bv++ ) {
				for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
					if (jsonObj1[bw][6]==2){
						b3values_size[ bv ] = 10;
						//b3values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
						b3values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
						idMap[bw]=[2,bv];
						typesMap[2][bv]=bw;
						
						var rm;
						var rr;
						
						if (nameModel=="hepatonet1-msb201062-s5"){
							rm=bv*0.078*2*Math.PI;
							rr = ((bv*0.02)+0.35*radius)
							b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							b3positions[ bv * 3 + 1 ] = yStartDisplacement+0+(bv*0.05);
						}
						else if (nameModel=="Ec_iAF1260_flux2"){
							rm=bv*0.004*2*Math.PI;
							rr = ((radius*1.08)-(bv*0.03)+1)
							b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							b3positions[ bv * 3 + 1 ] = yStartDisplacement+0-(bv*0.03);

						}
						else{
							rm=bv*0.008*2*Math.PI;
							rr = ((bv*0.02)+0.05*radius);
							b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							b3positions[ bv * 3 + 1 ] = yStartDisplacement+0+(bv*0.02);
						}
						
						b3positions[ bv * 3 + 2 ] = Math.sin(rm) *rr;
						
						b3values_color[ bv * 3 + 0 ] = color.r;
						b3values_color[ bv * 3 + 1 ] = color.g;
						b3values_color[ bv * 3 + 2 ] = color.b;
						bv++;
					}
				}
				startModelPlaces=bv;
				for( var bw = jsonObj1.length , bww= jsonObj1.length+10000; bw < bww; bw++ ) {
						
		
					//if (jsonObj1[bw][6]==2){
						b3values_size[ bv ] = 30;
						//b3values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
						b3values_compartment[ bv ] = -1;
						//idMap[bw]=[2,bv];
						//typesMap[2][bv]=bw;
						idMap[bw]=[2,bv];
						typesMap[2][bv]=bw;
						//var rm=(bw-jsonObj1.length)*0.078*2*Math.PI;
						//var	rr = (((bw-jsonObj1.length)*0.02)+0.95*radius)
						//radius=900;
						var rm=(bw-jsonObj1.length)*0.008*2*Math.PI;
						var rr = ((radius)-((bw-jsonObj1.length)*0.3)+1)
						b3positions[ bv * 3 + 0 ] = (Math.cos(rm) *rr)+900;
						//b3positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius+900;
						//b3positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
						b3positions[ bv * 3 + 1 ] = yStartDisplacement/2;
						b3positions[ bv * 3 + 2 ] = ((Math.random() * 2 - 1) * radius)+50000;
						//b3positions[ bv * 3 + 2 ] = (Math.sin(rm) *rr)+50000;
						
						//if ( positions[ bv * 3 + 0 ] < 0 )
						//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
						//else
						//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
						b3values_color[ bv * 3 + 0 ] = color2.r;
						b3values_color[ bv * 3 + 1 ] = color2.g;
						b3values_color[ bv * 3 + 2 ] = color2.b;
						bv++;
					//}
				}
				endModelPlaces=bv;
			//}
			
			
			// associate first particle system with bufferGeometry
			PointCloud3 = new THREE.PointCloud( bgeometryP3, particle3ShaderMaterial );

			PointCloud3.dynamic = true;
			PointCloud3.sortParticles = true;
			PointCloud3.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud3 );
			
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for degradable product particles
			bgeometryP4 = new THREE.BufferGeometry();
			
			bgeometryP4.dynamic = true;
			bgeometryP4.attributes = {

				position: {
					itemSize: 3,
					array: new Float32Array( nbDegradParticles * 3 )
				},
				ca: {
					itemSize: 3,
					array: new Float32Array( nbDegradParticles * 3 )
				},
				size: {
					itemSize: 1,
					array: new Float32Array( nbDegradParticles ),
					dynamic: true
				},
				compartment: {
					itemSize: 1,
					array: new Float32Array( nbDegradParticles ),
					dynamic: true
				}

			}
			bgeometryP4.attributes.size.needsUpdate = true;
			bgeometryP4.attributes.position.needsUpdate = true;
			bgeometryP4.attributes.ca.needsUpdate = true;
			bgeometryP4.attributes.compartment.needsUpdate = true;

			b4values_size = bgeometryP4.attributes.size.array;
			b4positions = bgeometryP4.attributes.position.array;
			b4values_color = bgeometryP4.attributes.ca.array;
			b4values_compartment = bgeometryP4.attributes.compartment.array;
			
			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xff66ff );;
			var radius =400;
			for( var bv = 0; bv < nbDegradParticles; bv++ ) {
			

				b4values_size[ bv ] = 10;
				b4values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;

				b4positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius;
				
				//b4positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
				b4positions[ bv * 3 + 1 ] = yStartDisplacement+0;
				b4positions[ bv * 3 + 2 ] = (Math.random() * 2 - 1) * radius;
				
				
				//if ( positions[ bv * 3 + 0 ] < 0 )
				//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
				//else
				//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
				b4values_color[ bv * 3 + 0 ] = color.r;
				b4values_color[ bv * 3 + 1 ] = color.g;
				b4values_color[ bv * 3 + 2 ] = color.b;

			}
			
			
			// associate first particle system with bufferGeometry
			PointCloud4 = new THREE.PointCloud( bgeometryP4, particle4ShaderMaterial );

			PointCloud4.dynamic = true;
			PointCloud4.sortParticles = true;
			PointCloud4.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud4 );
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for PN particles
			bgeometryP5 = new THREE.BufferGeometry();
			
			bgeometryP5.dynamic = true;
			bgeometryP5.attributes = {

				position: {
					itemSize: 3,
					array: new Float32Array( nbPNParticles * 3 )
				},
				ca: {
					itemSize: 3,
					array: new Float32Array( nbPNParticles * 3 )
				},
				size: {
					itemSize: 1,
					array: new Float32Array( nbPNParticles ),
					dynamic: true
				},
				compartment: {
					itemSize: 1,
					array: new Float32Array( nbPNParticles ),
					dynamic: true
				}

			}
			bgeometryP5.attributes.size.needsUpdate = true;
			bgeometryP5.attributes.position.needsUpdate = true;
			bgeometryP5.attributes.ca.needsUpdate = true;
			bgeometryP5.attributes.compartment.needsUpdate = true;

			b5values_size = bgeometryP5.attributes.size.array;
			b5positions = bgeometryP5.attributes.position.array;
			b5values_color = bgeometryP5.attributes.ca.array;
			b5values_compartment = bgeometryP5.attributes.compartment.array;
			
			var color = new THREE.Color( 0xffffff );
					
					var color2 = new THREE.Color( 0x55ffff );
					var radius =400;
					var bv=0;
					//for( var bv = 0; bv < nbPNParticles; bv++ ) {
					/*subSystems=[];
					for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
						if (jsonObj1[bw][6]==4){
							if (jsonObj1[bw][4][1] && jsonObj1[bw][4][1][0]){
								if (subSystems.indexOf(jsonObj1[bw][4][1][0])== -1){
									subSystems.push(jsonObj1[bw][4][1][0]);
								}
							}
						}
					}*/
					//console.log(subSystems);
					// now allocate a nb of nodes by sub systems
					subSystems={};
					totalSubSystems=0;
					
					totalNbreactions=0;
					for( var bs = 0 , bww= jsonObj1.length; bs < bww; bs++ ) {
						if (jsonObj1[bs][6]==4){
							if (jsonObj1[bs][4][1] && jsonObj1[bs][4][1][0]){
								if (subSystems[jsonObj1[bs][4][1][0]]=== undefined){
									subSystems[jsonObj1[bs][4][1][0]]=1;
									totalSubSystems++;
								}
								else{
									subSystems[jsonObj1[bs][4][1][0]]++;
									totalSubSystems++;
								}
								
							}
							totalNbreactions++;
						}
					}
					totalOutsideSubSystems=totalNbreactions-totalSubSystems;
					nbSubSystems=Object.keys(subSystems).length
					if (totalOutsideSubSystems>0){
						nbAreas=nbSubSystems+1;
						subSystems["Not present"]=totalOutsideSubSystems;
					}
					else{
						nbAreas=nbSubSystems;
					}
					//console.log(subSystems);
					
					//console.log(totalSubSystems);
					//console.log(totalNbreactions);
					//console.log(totalOutsideSubSystems);
					//console.log(nbSubSystems);
					
					// if there is no subsystem identified just use standard spiral layout
					
					// if there are n subsystems then display circular region of width proportional to the nb of nodes in each subsystem
					// first make a list of widths
					// total nb of reactions will dictate the overall nb of points that must be displayed on the ring.
					// depth of the ring is 30 points. there are for 0.004 *2Pi=1.44 degrees = 250 graduations on a circle 
					var listWidthSubSystems={};
					var nbCircleGraduations=250;
					var minCircleFraction=1/nbCircleGraduations;
					var nbNodesDepth=40;
					var totalWidth=0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							var width= Math.ceil(subSystems[key]/nbNodesDepth);
							listWidthSubSystems[key]=[subSystems[key]/*nb of nodes*/,width,/*counter value*/0];
							totalWidth+=width;
						}
					}
					nbNodesDepth=Math.ceil((40*totalWidth)/244);
					listWidthSubSystems={};
					var totalWidth=0;
					var cumulativeWidth=0;
					var colorswap=1.0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							var width= Math.ceil(subSystems[key]/nbNodesDepth);
							listWidthSubSystems[key]=[subSystems[key]/*nb of nodes*/,width,cumulativeWidth,/*counter value*/0,colorswap];
							totalWidth+=width;
							cumulativeWidth+=width;
							if (colorswap==1.0){
							colorswap=0.7;
							}
							else{colorswap=1.0}
						}
					}
					
					//console.log(totalWidth);
					//console.log(listWidthSubSystems);
					/*for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							var percentage= subSystems[key]/totalNbreactions;
							if (percentage < minCircleFraction){
								percentage= minCircleFraction;
								
							}
							subSystems[key]=percentage;
							totalPercentage+=percentage;
							
							//console.log(percentage);
						}
					}
					console.log(totalPercentage);
					var toDistribute=0;
					if (totalPercentage>1){
						toDistribute= totalPercentage-1;
					}
					var nbReducable=0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							if((subSystems[key]*(1-toDistribute))>minCircleFraction){
								nbReducable++;
							}
						}
					}
					console.log(nbReducable);
					var sums=0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							if((subSystems[key]*(1-toDistribute))>minCircleFraction){
								var res=subSystems[key]*(1-(toDistribute));
								subSystems[key]=res;
								
							}
							sums+=subSystems[key];
							
							//toDistribute/nbReducable
						}
					}
					console.log(subSystems+" total: "+sums);*/
					//var cnt1=0
					//var cnt2=0;
					var localRSeparator=0;
					for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
						
						if (jsonObj1[bw][6]==4){

							b5values_size[ bv ] = 10;
							//b5values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
							
							// try to assign the compartment of the majority of the products the reaction is linked to 
							// if there is no product, assign the compartment of the majority of modifiers
							// if there is no modifier, assign the compartment of the majority of reactants
							var listProducts= jsonObj1[bw][11][0];
							var listModifiers= jsonObj1[bw][11][1];
							var listReactants= jsonObj1[bw][11][2];
							
							if (listProducts.length>0){
								var votes=[];
								for (var ncc=0;ncc<nbCompartments;ncc++){
									votes[ncc]=0;
								}
								for(var lp=0;lp<listProducts.length;lp++){
									if (mapComp[jsonObj1[listProducts[lp]][3]]>=0)
										votes[mapComp[jsonObj1[listProducts[lp]][3]]]++;
								}
								var winner= votes.indexOf(Math.max.apply( Math, votes ));
								b5values_compartment[ bv ] = winner;
								if (winner==-1){
									b5values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
								}
							} 
							else if (listModifiers.length>0){
								var votes=[];
								for (var ncc=0;ncc<nbCompartments;ncc++){
									votes[ncc]=0;
								}
								for(var lp=0;lp<listModifiers.length;lp++){
									if (mapComp[jsonObj1[listModifiers[lp]][3]]>=0)
										votes[mapComp[jsonObj1[listModifiers[lp]][3]]]++;
								}
								var winner= votes.indexOf(Math.max.apply( Math, votes ));
								b5values_compartment[ bv ] = winner;
								if (winner==-1){
									b5values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
								}
							}
							else if (listReactants.length>0){
								var votes=[];
								for (var ncc=0;ncc<nbCompartments;ncc++){
									votes[ncc]=0;
								}
								for(var lp=0;lp<listReactants.length;lp++){
									if (mapComp[jsonObj1[listReactants[lp]][3]]>=0)
										votes[mapComp[jsonObj1[listReactants[lp]][3]]]++;
								}
								var winner= votes.indexOf(Math.max.apply( Math, votes ));
								b5values_compartment[ bv ] = winner;
								if (winner==-1){
									b5values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
								}
							}
							else {
								// if no species linked, put reaction in the center
								b5values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
							}
							
							idMap[bw]=[4,bv];
							typesMap[4][bv]=bw;
							
							var rm;
							var rr; 
							
							
							
							
							if (nameModel=="Ec_iAF1260_flux2"){
								rm=bv*0.078*2*Math.PI;
								rr = ((bv*0.02)+0.35*radius)
								//b5positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
								b5positions[ bv * 3 + 1 ] = (yStartDisplacement/2)+(bv*0.04);
							}
							else{
								var yModifier=0;
								var mDepth=0;
								//rr= ((radius*1.08)-(0*0.03)+1);
								if (jsonObj1[bw][4][1] && jsonObj1[bw][4][1][0]){
									
									//console.log("increment node")
									//console.log(jsonObj1[bw][4][1][0]);
									if (listWidthSubSystems.hasOwnProperty(jsonObj1[bw][4][1][0])) {
									
										var startingW=listWidthSubSystems[jsonObj1[bw][4][1][0]][2];
										var maxWidth=listWidthSubSystems[jsonObj1[bw][4][1][0]][1];
										var maxDepth=nbNodesDepth;
										var maxNbNodes=listWidthSubSystems[jsonObj1[bw][4][1][0]][0];
										var presentIndex= listWidthSubSystems[jsonObj1[bw][4][1][0]][3];
										if (presentIndex<maxNbNodes){
										//cnt1++;
											var localWPos=0;
											
											var localRR=0;
											localWPos=Math.floor(presentIndex/maxDepth);
											//if (presentIndex>=maxDepth){
											
												localRR=presentIndex%maxDepth;
											yModifier=	localRR;
											mDepth=maxDepth;
											//}
											//else{
											//	localRR=presentIndex;
											//}
											//if(presentIndex==0){
											//	localRSeparator+=(nbCircleGraduations-totalWidth)/(2*nbAreas);//	rm=((startingW+localWPos+localRSeparator)*0.004*(2*Math.PI));
											//console.log(jsonObj1[bw][4][1][0])
											//listWidthSubSystems[jsonObj1[bw][4][1][0]][2]+=((nbCircleGraduations-totalWidth)/(nbAreas));
											//startingW=listWidthSubSystems[jsonObj1[bw][4][1][0]][2];
											//color.r-=0.01
											//}
											rm=((startingW+localRSeparator+localWPos)*0.004*(2*Math.PI));
											
											rr= ((radius-maxDepth*5)+(localRR*5));
											listWidthSubSystems[jsonObj1[bw][4][1][0]][3]++;
											color.r=listWidthSubSystems[jsonObj1[bw][4][1][0]][4];
											if (color.r==1.0){
											color.g=1.0;
											color.b=1.0;
											}
											else{
											color.g=0.4;
											color.b=1.0;
											}
										}
									}
								}
								else{
									
									//subSystems["Not present"]=totalOutsideSubSystems;
									if (listWidthSubSystems.hasOwnProperty("Not present")) {
									
									//console.log("increment not present")
										var startingW=listWidthSubSystems["Not present"][2];
										var maxWidth=listWidthSubSystems["Not present"][1];
										var maxDepth=nbNodesDepth;
										var maxNbNodes=listWidthSubSystems["Not present"][0];
										var presentIndex= listWidthSubSystems["Not present"][3];
										if (presentIndex<maxNbNodes){
										//cnt2++;
											var localWPos=0;
											var localRR=0;
											localWPos=Math.floor(presentIndex/maxDepth);
											//if (presentIndex>=maxDepth){
											
												localRR=presentIndex%maxDepth;
												yModifier=	localRR;	
												mDepth=maxDepth;
											//}
											//else{
											//	localRR=presentIndex;
											//}
											//if(presentIndex==0){
											//console.log(jsonObj1[bw][4][1][0])
											//listWidthSubSystems["Not present"][2]+=((nbCircleGraduations-totalWidth)/(nbAreas));
											//startingW=listWidthSubSystems["Not present"][2];
											//	localRSeparator+=(nbCircleGraduations-totalWidth)/(2*nbAreas);//	rm=((startingW+localWPos+localRSeparator)*0.004*(2*Math.PI));
											//}
											rm=((startingW+localRSeparator+localWPos)*0.004*(2*Math.PI));
											rr= ((radius-maxDepth*5)+(localRR*5));
											listWidthSubSystems["Not present"][3]++;
											color = new THREE.Color( 0xff0000 );
										}
									}
								}
								//console.log(listWidthSubSystems);
							
								//rm=bv*0.004*2*Math.PI;
								//rr= ((radius*1.08)-(bv*0.03)+1);
								
								//b5positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
								//b5positions[ bv * 3 + 1 ] = 0-(bv*0.03);
								b5positions[ bv * 3 + 1 ] = yStartDisplacement-(mDepth*4)+(yModifier*4);
								//console.log(jsonObj1[bw][4][1][0])
							}
							b5positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							b5positions[ bv * 3 + 2 ] = Math.sin(rm) *rr;
							
							
							b5values_color[ bv * 3 + 0 ] = color.r;
							b5values_color[ bv * 3 + 1 ] = color.g;
							b5values_color[ bv * 3 + 2 ] = color.b;
							bv++;
						}
					}
					//console.log("increment"+cnt1 + "  " +cnt2)
					startModelReactions=bv;
					for( var bw = jsonObj1.length , bww= jsonObj1.length+10000; bw < bww; bw++ ) {
						
						b5values_size[ bv ] = 30;
						
						b5values_compartment[ bv ] = -1;
						idMap[bw]=[4,bv];
						typesMap[4][bv]=bw;
						
						
						
						//radius=900;
						var rm=(bw-jsonObj1.length)*0.008*2*Math.PI;
						var rr = ((radius)-((bw-jsonObj1.length)*0.3)+1)
						//b5positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius+900;
						b5positions[ bv * 3 + 0 ] = (Math.cos(rm) *rr)+1800;
						//b5positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
						b5positions[ bv * 3 + 1 ] = yStartDisplacement/2-180;
						
						b5positions[ bv * 3 + 2 ] = ((Math.random() * 2 - 1) * radius)+50000;
						
						
						//if ( positions[ bv * 3 + 0 ] < 0 )
						//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
						//else
						//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
						b5values_color[ bv * 3 + 0 ] = color2.r;
						b5values_color[ bv * 3 + 1 ] = color2.g;
						b5values_color[ bv * 3 + 2 ] = color2.b;
						bv++;
					}
					endModelReactions=bv;
			
			// associate first particle system with bufferGeometry
			PointCloud5 = new THREE.PointCloud( bgeometryP5, particle5ShaderMaterial );

			PointCloud5.dynamic = true;
			PointCloud5.sortParticles = true;
			PointCloud5.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud5 );
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for PN particles
			bgeometryP6 = new THREE.BufferGeometry();
			
			bgeometryP6.dynamic = true;
			bgeometryP6.attributes = {

				position: {
					itemSize: 3,
					array: new Float32Array( nbLogParticles * 3 )
				},
				ca: {
					itemSize: 3,
					array: new Float32Array( nbLogParticles * 3 )
				},
				size: {
					itemSize: 1,
					array: new Float32Array( nbLogParticles ),
					dynamic: true
				},
				compartment: {
					itemSize: 1,
					array: new Float32Array( nbLogParticles ),
					dynamic: true
				}

			}
			bgeometryP6.attributes.size.needsUpdate = true;
			bgeometryP6.attributes.position.needsUpdate = true;
			bgeometryP6.attributes.ca.needsUpdate = true;
			bgeometryP6.attributes.compartment.needsUpdate = true;

			b6values_size = bgeometryP6.attributes.size.array;
			b6positions = bgeometryP6.attributes.position.array;
			b6values_color = bgeometryP6.attributes.ca.array;
			b6values_compartment = bgeometryP6.attributes.compartment.array;
			
			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xffffff );;
			var radius =400;
			for( var bv = 0; bv < nbLogParticles; bv++ ) {
			

				b6values_size[ bv ] = 10;
				b6values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;

				b6positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius;
				//b6positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
				b6positions[ bv * 3 + 1 ] = yStartDisplacement;
				
				b6positions[ bv * 3 + 2 ] = (Math.random() * 2 - 1) * radius;
				
				
				//if ( positions[ bv * 3 + 0 ] < 0 )
				//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
				//else
				//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
				b6values_color[ bv * 3 + 0 ] = color.r;
				b6values_color[ bv * 3 + 1 ] = color.g;
				b6values_color[ bv * 3 + 2 ] = color.b;

			}
			
			
			// associate first particle system with bufferGeometry
			PointCloud6 = new THREE.PointCloud( bgeometryP6, particle6ShaderMaterial );

			PointCloud6.dynamic = true;
			PointCloud6.sortParticles = true;
			PointCloud6.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud6 );
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for PN particles
			bgeometryP7 = new THREE.BufferGeometry();
			
			bgeometryP7.dynamic = true;
			bgeometryP7.attributes = {

				position: {
					itemSize: 3,
					array: new Float32Array( nbCoarseParticles * 3 )
				},
				ca: {
					itemSize: 3,
					array: new Float32Array( nbCoarseParticles * 3 )
				},
				size: {
					itemSize: 1,
					array: new Float32Array( nbCoarseParticles ),
					dynamic: true
				},
				compartment: {
					itemSize: 1,
					array: new Float32Array( nbCoarseParticles ),
					dynamic: true
				}

			}
			bgeometryP7.attributes.size.needsUpdate = true;
			bgeometryP7.attributes.position.needsUpdate = true;
			bgeometryP7.attributes.ca.needsUpdate = true;
			bgeometryP7.attributes.compartment.needsUpdate = true;

			b7values_size = bgeometryP7.attributes.size.array;
			b7positions = bgeometryP7.attributes.position.array;
			b7values_color = bgeometryP7.attributes.ca.array;
			b7values_compartment = bgeometryP7.attributes.compartment.array;
			
			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xffffff );;
			var radius =400;
			for( var bv = 0; bv < nbCoarseParticles; bv++ ) {
			

				b7values_size[ bv ] = 10;
				b7values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;

				b7positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius;
				//b7positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
				b7positions[ bv * 3 + 1 ] = yStartDisplacement;
				
				b7positions[ bv * 3 + 2 ] = (Math.random() * 2 - 1) * radius;
				
				
				//if ( positions[ bv * 3 + 0 ] < 0 )
				//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
				//else
				//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
				b7values_color[ bv * 3 + 0 ] = color.r;
				b7values_color[ bv * 3 + 1 ] = color.g;
				b7values_color[ bv * 3 + 2 ] = color.b;

			}
			
			
			// associate first particle system with bufferGeometry
			PointCloud7 = new THREE.PointCloud( bgeometryP7, particle7ShaderMaterial );

			PointCloud7.dynamic = true;
			PointCloud7.sortParticles = true;
			PointCloud7.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud7 );
			
			// populates second buffer geometry for lines  with coordinates, colors, and size
			//segmentPts = 20000;
			bgeometry2 = new THREE.BufferGeometry();
			bgeometry2.attributes = {
				position: {
					itemSize: 3,
					array: new Float32Array((segmentPts+10000) * 3)
				},
				ca: {
					itemSize: 3,
					array: new Float32Array((segmentPts+10000) * 3)
				},
				op: {
					itemSize: 1,
					array: new Float32Array( segmentPts+10000  ),
					dynamic: true
				},
				compartment: {
					itemSize: 2,
					array: new Float32Array( (segments+5000) * 2 ),
					dynamic: true
				}
				,flux: {
					itemSize: 1,
					array: new Float32Array( segments+5000 ),
					dynamic: true
				}
				,bounds: {
					itemSize: 2,
					array: new Float32Array( (segments+5000) * 2 ),
					dynamic: true
				}
			};
				
				
			bgeometry2.attributes.position.needsUpdate = true;
			bgeometry2.attributes.ca.needsUpdate = true;
			bgeometry2.attributes.compartment.needsUpdate = true;
			bgeometry2.attributes.op.needsUpdate = true;

			b2lpositions = bgeometry2.attributes.position.array;
				//var colors = bgeometry.attributes.color.array;
			b2lcolors = bgeometry2.attributes.ca.array;
			b2lcompartments=bgeometry2.attributes.compartment.array;
			b2lopacity = bgeometry2.attributes.op.array;
			var r = 800;
			var col = new THREE.Color( 0x00ffff );
			var col2 = new THREE.Color( 0x55ff55 );
			
			var iv=0;
			for ( var i = 0; i < segments; i ++ ) {
			
				var t1 = jsonObj1[jsonObj2[i][0]][6]
				var t2 = jsonObj1[jsonObj2[i][1]][6]
				var ivList=[]
				
				if (t1==2){
					b2lpositions[ (iv * 3)+0 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
					b2lpositions[ (iv * 3) + 1 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
					b2lpositions[ (iv * 3) + 2 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
					b2lcompartments[ (i*2)+0 ] = b3values_compartment[ (idMap[jsonObj2[i][0]][1]) ];
					b2lopacity[iv]=0.25;
					b2lcolors[ iv * 3 ] = col.r;
					b2lcolors[ iv * 3 + 1 ] = col.g;
					b2lcolors[ iv * 3 + 2 ] = col.b;
					ivList.push(iv)
					//linesMap[i]=iv
					
					iv++;
				}
				else if (t1==4){
					b2lpositions[ (iv * 3)+0 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
					b2lpositions[ (iv * 3) + 1 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
					b2lpositions[ (iv * 3) + 2 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
					b2lcompartments[ (i*2)+0 ] = b5values_compartment[ (idMap[jsonObj2[i][0]][1]) ];
					b2lopacity[iv]=0.25;
					b2lcolors[ iv * 3 ] = col.r;
					b2lcolors[ iv * 3 + 1 ] = col.g;
					b2lcolors[ iv * 3 + 2 ] = col.b;
					//linesMap[i]=iv
					ivList.push(iv)
					iv++;
				}
				if (t2 ==2){
					b2lpositions[ (iv * 3)+0 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
					b2lpositions[ (iv * 3) + 1 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
					b2lpositions[ (iv * 3) + 2 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;
					b2lcompartments[ (i*2)+1 ] = b3values_compartment[ (idMap[jsonObj2[i][1]][1]) ];
					b2lopacity[iv]=0.25;
					b2lcolors[ iv * 3 ] = col.r;
					b2lcolors[ iv * 3 + 1 ] = col.g;
					b2lcolors[ iv * 3 + 2 ] = col.b;
					//linesMap[i]=iv
					ivList.push(iv)
					iv++;
				}
				else if (t2 ==4){
					b2lpositions[ (iv * 3)+0 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
					b2lpositions[ (iv * 3) + 1 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
					b2lpositions[ (iv * 3) + 2 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;
					b2lcompartments[ (i*2)+1 ] = b5values_compartment[ (idMap[jsonObj2[i][1]][1]) ];
					b2lopacity[iv]=0.25;
					b2lcolors[ iv * 3 ] = col.r;
					b2lcolors[ iv * 3 + 1 ] = col.g;
					b2lcolors[ iv * 3 + 2 ] = col.b;
					//linesMap[i]=iv
					ivList.push(iv)
					iv++;
				}
				linesMap[i]=ivList
			}
			var radius=400;
			extraLinesCnt=iv;
			for ( var i = segments; i < segments+maxNbTokenModel; i ++ ) {
				
					b2lpositions[ (iv * 3)+0 ] = (Math.random() * 2 - 1) * radius;
					b2lpositions[ (iv * 3) + 1 ] = 80;
					b2lpositions[ (iv * 3) + 2 ] = ((Math.random() * 2 - 1) * radius)+50000;
					b2lcompartments[ (i*2)+0 ] = -1;
					b2lopacity[iv]=0.25;
					b2lcolors[ iv * 3 ] = col2.r;
					b2lcolors[ iv * 3 + 1 ] = col2.g;
					b2lcolors[ iv * 3 + 2 ] = col2.b;
					ivList.push(iv)
					//linesMap[i]=iv
					
					iv++;
				
				
				
			}
			//for ( var i = 0; i < segmentPts; i ++ ) {
			//if (i<50)
			//	console.log(i+" -- "+b1values_compartment[i]);
			//}
			
			bgeometry2.computeBoundingSphere();
		//console.log(bgeometry2);
			mesh = new THREE.Line( bgeometry2, linesShaderMaterial,THREE.LinePieces );
			scene.add( mesh );
			
			// create and populate geometry with token particles coordinates, colors, and size
			var radius = 300;
			//tokenGeometry = new THREE.CubeGeometry( 0.8 * radius, 0.8 * radius, 0.8 * radius, 150, 100, 1 );
			// populate token geometry with "start" extremities of line segmentPts
			tokenGeometry = new THREE.Geometry();
			for ( var i = 0; i < segmentPts; i +=2 ) {
				tokenGeometry.vertices.push(new THREE.Vector3(b2lpositions[ (i * 3) ]+0,b2lpositions[ (i * 3) + 1 ]+0,b2lpositions[ (i * 3) + 2 ]+0));
			}
			// add models tokens
			for ( var i = segmentPts; i < segmentPts+maxNbTokenModel; i +=2 ) {
				tokenGeometry.vertices.push(new THREE.Vector3(b2lpositions[ (i * 3) ]+0,b2lpositions[ (i * 3) + 1 ]+0,b2lpositions[ (i * 3) + 2 ]+0));
				
			}
			//var v1 = new THREE.Vector3(0,0,0);
			//var v2 = new THREE.Vector3(0,500,0);
			//var v3 = new THREE.Vector3(0,500,500);

			
			//tokenShaderMaterial.blending = THREE.AdditiveBlending; // "glowing" particles
			tokenPS = new THREE.PointCloud( tokenGeometry, tokenShaderMaterial );
			//tokenPS = new THREE.PointCloud( tokenGeometry, spriteMaterial );
			tokenPS.dynamic = true;
			//sphere.sortParticles = true;

			tvertices = tokenPS.geometry.vertices;
			tvalues_size = tokenAttributes.size.value;
			tvalues_color = tokenAttributes.ca.value;
			tvalues_p = tokenAttributes.endPosition.value;
			for( var v = 0, vv= tvertices.length; v < vv; v++ ) {

				tvalues_size[ v ] = 5;
				tvalues_color[ v ] = new THREE.Color( 0xff7777 );
				//tvalues_p[v]=new THREE.Vector3( 600+(Math.random() * 2 - 1) * radius, (Math.random() * 2 - 1) * radius , (Math.random() * 2 - 1) * radius );	
				//tvalues_p[v]=new THREE.Vector3(b2positions[ (v+1) * 3 ],b2positions[ (v+1) * 3 + 1 ],b2positions[ (v+1) * 3 + 2 ]);
			}
			//for( var v = tvertices.length-2500, vv= tvertices.length; v < vv; v++ ) {

			//	tvalues_size[ v ] = 15;
			//	tvalues_color[ v ] = new THREE.Color( 0xff00ff );
				//tvalues_p[v]=new THREE.Vector3( 600+(Math.random() * 2 - 1) * radius, (Math.random() * 2 - 1) * radius , (Math.random() * 2 - 1) * radius );	
				//tvalues_p[v]=new THREE.Vector3(b2positions[ (v+1) * 3 ],b2positions[ (v+1) * 3 + 1 ],b2positions[ (v+1) * 3 + 2 ]);
			//}
			
			for ( var i = 1; i < segmentPts; i +=2 ) {
				tvalues_p.push(new THREE.Vector3(b2lpositions[ i * 3 ],b2lpositions[ i * 3 + 1 ],b2lpositions[ i * 3 + 2 ]+0));
			}
			for ( var i = segmentPts+1; i < segmentPts+maxNbTokenModel; i +=2 ) {
				tvalues_p.push(new THREE.Vector3(b2lpositions[ i * 3 ],b2lpositions[ i * 3 + 1 ],b2lpositions[ i * 3 + 2 ]+0));
			}
			
			//sphere.geometry.__dirtyVertices = true;
			scene.add( tokenPS );
			
			
			
			
			
			// outline mesh for lines
			
			lineGeometry = new THREE.Geometry();
			lineGeometry.vertices.push(new THREE.Vector3(-10000, -10000, -50000));
			lineGeometry.vertices.push(new THREE.Vector3(-10000, -10000, -51000));
			lineGeometry.verticesNeedUpdate = true;
			
			outlineMaterial1 = new THREE.MeshBasicMaterial( { color: 0xff0000} );			
			outlineMesh1 = new THREE.Line( lineGeometry, outlineMaterial1 );	
			//outlineMesh1.scale.multiplyScalar(1.002);
			scene.add( outlineMesh1 );
			
			
			
			var spriteMaterial = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/glow.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false, blending: THREE.AdditiveBlending
			});
			sprite = new THREE.Sprite( spriteMaterial );
			sprite.scale.set(8, 8, 8);
			//crateGlow.add(sprite); // this centers the glow at the mesh
			if (marker==0){
			sprite.position.set(-50000,-10000,10000);
			//sprite.transparent=true;
			}		
			scene.add( sprite );
			
			
			var spriteMaterial2 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/tg2.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false//, blending: THREE.AdditiveBlending
			});
			for (var i=0;i<nbSpritesSelected;i++){
				spritesSelected[i] = new THREE.Sprite( spriteMaterial2 );
				spritesSelected[i].scale.set(100, 100, 100);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				spritesSelected[i].position.set(-50000,-10000,10000);
				
					
				scene.add( spritesSelected[i] );
			}
			
			var spriteMaterial22 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/tg2.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false//, blending: THREE.AdditiveBlending
			});
			for (var i=0;i<modelnbSpritesSelected;i++){
				modelspritesSelected[i] = new THREE.Sprite( spriteMaterial22 );
				modelspritesSelected[i].scale.set(100, 100, 100);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				modelspritesSelected[i].position.set(-50000,-10000,10000);
				
					
				scene.add( modelspritesSelected[i] );
			}
			
			
			
			var spriteMaterial3 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/square_canvas.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false
			});
			for (var i=0;i<nbModelReactionLocators;i++){
				modelReactionLocators[i] = new THREE.Sprite( spriteMaterial3 );
				modelReactionLocators[i].scale.set(40, 40, 40);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				modelReactionLocators[i].position.set(-50000,-10000,10000);
				//modelReactionLocators[i].position.set(400,400,200*i);
					
				scene.add( modelReactionLocators[i] );
			}
			
			var spriteMaterial4 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/product.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false
			});
			for (var i=0;i<nbModelReactionLocators;i++){
				modelProductLocators[i] = new THREE.Sprite( spriteMaterial4 );
				modelProductLocators[i].scale.set(40, 40, 40);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				modelProductLocators[i].position.set(-50000,-10000,10000);
				//modelProductLocators[i].position.set(400,400,200*i);
					
				scene.add( modelProductLocators[i] );
			}
			
			var spriteMaterial5 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/reactant2.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false
			});
			for (var i=0;i<nbModelReactionLocators;i++){
				modelReactantLocators[i] = new THREE.Sprite( spriteMaterial5 );
				modelReactantLocators[i].scale.set(40, 40, 40);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				modelReactantLocators[i].position.set(-50000,-10000,10000);
				//modelProductLocators[i].position.set(400,400,200*i);
					
				scene.add( modelReactantLocators[i] );
			}
			
			var spriteMaterial6 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/modifier2.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false
			});
			for (var i=0;i<nbModelReactionLocators;i++){
				modelModifierLocators[i] = new THREE.Sprite( spriteMaterial6 );
				modelModifierLocators[i].scale.set(40, 40, 40);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				modelModifierLocators[i].position.set(-50000,-10000,10000);
				//modelProductLocators[i].position.set(400,400,200*i);
					
				scene.add( modelModifierLocators[i] );
			}
			
			
			// add dynamic texture on plan 
			// MESHES WITH ANIMATED TEXTURES!
	
			/*var runnerTexture = new THREE.ImageUtils.loadTexture( 'mrdoob-three.js-r67/examples/textures/run3.png' );
			animatorT1 = new TextureAnimator( runnerTexture, 9, 1, 9, 30 ); // texture, #horiz, #vert, #total, duration.
			var runnerMaterial = new THREE.MeshBasicMaterial( { map: runnerTexture, side:THREE.DoubleSide } );
			var runnerGeometry = new THREE.PlaneGeometry(400, 10, 1, 1);
			var runner = new THREE.Mesh(runnerGeometry, runnerMaterial);
			runner.position.set(0,800,1500);
			runner.rotation.x -= (90*(Math.PI / 180));
			scene.add(runner);*/
			
			// add an array of planes that will be superimposed on lines to express flows
			var planeTexture = new THREE.ImageUtils.loadTexture( '/images/glow3.png' );
			//var planeTexture = new THREE.ImageUtils.loadTexture( 'mrdoob-three.js-r67/examples/textures/sprites/small-spark.png' );
			var planeMaterial = new THREE.MeshBasicMaterial( { map: planeTexture ,side: THREE.DoubleSide}  );
			planeMaterial.blending=THREE.AdditiveBlending;
			//planeMaterial.transparent = true;
			//planeMaterial.opacity = 0.6;
			for(var i=0;i<nbModelPlanesFlow;i++){
				var planeGeometry = new THREE.PlaneGeometry(400, 5, 1, 1);
				planeMesh[i] = new THREE.Mesh(planeGeometry, planeMaterial);
				planeMesh[i].position.set(0,0,150000);
				planeMesh[i].geometry.dynamic = true;
				planeMesh[i].geometry.verticesNeedUpdate = true;
				planeMesh[i].frustumCulled = false;
				scene.add(planeMesh[i]);	
			}
			
			// add planar stuff for demonstration
			var KeggMapTexture = new THREE.ImageUtils.loadTexture( '/images/keggmap-big.png' );
			var KeggMapMaterial = new THREE.MeshBasicMaterial( { map: KeggMapTexture /*,side: THREE.DoubleSide*/}  );
			var KeggMapGeometry = new THREE.PlaneGeometry( 900, 547, 0, 0 ) // size image 2587 1575
			var KeggMapPlan = new THREE.Mesh( KeggMapGeometry, KeggMapMaterial );
			KeggMapPlan.position.set(3000, 200, 0 );
			KeggMapPlan.rotation.x -= (90*(Math.PI / 180));
			KeggMapPlan.rotation.z += (90*(Math.PI / 180));
			KeggMapPlan.name="mapkegg";
			scene.add( KeggMapPlan );
			
			
			//geometryLineChart= new THREE.BufferGeometry();
			//geometryLineChart.attributes = {
			//	position: {
			//		itemSize: 3,
			//		array: new Float32Array((chartSegmentPts) * 3)
			//	},
			//	ca: {
			//		itemSize: 3,
			//		array: new Float32Array((chartSegmentPts) * 3)
			//	}
			//};
			//var col = new THREE.Color( 0xff0000 );
			//chartPositions = geometryLineChart.attributes.position.array;
			//chartColors = geometryLineChart.attributes.ca.array;
			//var iv=0;
			//for ( var i = 0; i < chartSegment; i ++ ) {
			//	chartPositions[ (iv * 3)+0 ] = 50400;
			//	chartPositions[ (iv * 3) + 1 ] = 0;
			//	chartPositions[ (iv * 3) + 2 ] = -50400;
				//chartColors[ iv * 3 ] = col.r;
				//chartColors[ iv * 3 + 1 ] = col.g;
				//chartColors[ iv * 3 + 2 ] = col.b;
			//	iv++;
			//	chartPositions[ (iv * 3)+0 ] = 50400;
			//	chartPositions[ (iv * 3) + 1 ] = 0;
			//	chartPositions[ (iv * 3) + 2 ] = -50400;
				//chartColors[ iv * 3 ] = col.r;
				//chartColors[ iv * 3 + 1 ] = col.g;
				//chartColors[ iv * 3 + 2 ] = col.b;
			//	iv++
			//}
			//geometryLineChart.computeBoundingSphere();
			//var lineChartMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000} );
			//meshLineChart = new THREE.Line( geometryLineChart, lineChartMaterial,THREE.LinePieces);
			//scene2.add( meshLineChart );
			
			/*
			// create mesh of lines for kegg 3d bar chart 
			geometryKegg = new THREE.BufferGeometry();
			keggSegment = 1000;
			keggSegmentPts = keggSegment*2;
			geometryKegg.attributes = {
				position: {
					itemSize: 3,
					array: new Float32Array((keggSegmentPts) * 3)
				},
				ca: {
					itemSize: 3,
					array: new Float32Array((keggSegmentPts) * 3)
				}
			};
			var col = new THREE.Color( 0xff0000 );
			keggPositions = geometryKegg.attributes.position.array;
			keggColors = geometryKegg.attributes.ca.array;
			var iv=0;
			for ( var i = 0; i < keggSegment; i ++ ) {
				keggPositions[ (iv * 3)+0 ] = 50000;
				keggPositions[ (iv * 3) + 1 ] = 0;
				keggPositions[ (iv * 3) + 2 ] = -50000;
				keggColors[ iv * 3 ] = col.r;
				keggColors[ iv * 3 + 1 ] = col.g;
				keggColors[ iv * 3 + 2 ] = col.b;
				iv++;
				keggPositions[ (iv * 3)+0 ] = 50000;
				keggPositions[ (iv * 3) + 1 ] = 800;
				keggPositions[ (iv * 3) + 2 ] = -50000;
				keggColors[ iv * 3 ] = col.r;
				keggColors[ iv * 3 + 1 ] = col.g;
				keggColors[ iv * 3 + 2 ] = col.b;
				iv++
			}
			geometryKegg.computeBoundingSphere();
			//var meshKegg = new THREE.Line( geometryKegg, keggLinesShaderMaterial,THREE.LinePieces );
			var keggoutlineMaterial1 = new THREE.MeshBasicMaterial( { color: 0xff0000} );
			var meshKegg = new THREE.Line( geometryKegg, keggoutlineMaterial1,THREE.LinePieces );
				
			scene.add( meshKegg );
			*/
			
			// add keegmap cubes instead
			
			var geometry = new THREE.BoxGeometry( 1, 1, 1 );
			
			for ( var i = 0; i < keggSegment; i ++ ) {
				var material = new THREE.MeshBasicMaterial( {color: 0xff0000} );
				cubesGeometry[i] = new THREE.Mesh( geometry, material );
				cubesGeometry[i].position.x=50000;
				cubesGeometry[i].position.y=200;
				cubesGeometry[i].position.z=-50000;
				cubesGeometry[i].name="k"+i;
				scene.add( cubesGeometry[i] );
			}
			
			//nbOrganelles=7;
			var canvasSize=900
			
			for (var i=0;i<nbOrganelles;i++){
				arraymaterial[i] = new THREE.MeshBasicMaterial( { color: 0x1111ff, side: THREE.DoubleSide } );
				var o1 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
				o1.applyMatrix( new THREE.Matrix4().makeTranslation(0, canvasSize/2, 0) );
				var o2 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
				o2.applyMatrix( new THREE.Matrix4().makeTranslation(0, -canvasSize/2, 0) );
				var o3 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
				o3.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
				o3.applyMatrix( new THREE.Matrix4().makeTranslation(canvasSize/2, 0, 0) );
				var o4 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
				o4.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
				o4.applyMatrix( new THREE.Matrix4().makeTranslation(-canvasSize/2, 0, 0) );
				o1.merge(o2);
				o1.merge(o3);
				o1.merge(o4);
				organelles[i] = new THREE.Mesh( o1, arraymaterial[i] );
				//organelles[i].position.set( Math.sin((2*Math.PI)/nbOrganelles*i)*scaleExplosion, -10, Math.cos((2*Math.PI)/nbOrganelles*i)*scaleExplosion );
				organelles[i].name="c"+i;
				organelles[i].position.set(0, yStartDisplacement, 0 );
				organelles[i].rotation.x += (90*(Math.PI / 180));
				scene.add( organelles[i] );
			}
			
			
			
			// add planar stuff for demonstration
			//var material2 = new THREE.MeshBasicMaterial( { color: 0x1111ff, side: THREE.DoubleSide } );
			arraymaterial[nbOrganelles] = new THREE.MeshBasicMaterial( { color: 0x1111ff, side: THREE.DoubleSide } );
			var n1 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			n1.applyMatrix( new THREE.Matrix4().makeTranslation(0, canvasSize/2, 0) );
			var n2 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			n2.applyMatrix( new THREE.Matrix4().makeTranslation(0, -canvasSize/2, 0) );
			var n3 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			n3.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
			n3.applyMatrix( new THREE.Matrix4().makeTranslation(canvasSize/2, 0, 0) );
			var n4 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			n4.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
			n4.applyMatrix( new THREE.Matrix4().makeTranslation(-canvasSize/2, 0, 0) );
			n1.merge(n2);
				n1.merge(n3);
				n1.merge(n4);
			//var n3 = new THREE.PlaneGeometry( 1000, 10, 1, 1 )
			//var n4 = new THREE.PlaneGeometry( 1000, 10, 1, 1 )
			//nucleus = new THREE.Mesh( new THREE.PlaneGeometry( 1000, 1000, 1, 1 ), material1 );
			nucleus = new THREE.Mesh( n1, arraymaterial[nbOrganelles] );
			nucleus.name="c"+nbOrganelles;
			//THREE.GeometryUtils.merge(n2, nucleus);
			nucleus.position.set( 0, yStartDisplacement, 0 );
			nucleus.rotation.x += (90*(Math.PI / 180));
			scene.add( nucleus );
			
			// add planar stuff for demonstration
			//var material2 = new THREE.MeshBasicMaterial( { color: 0x1f51ff, side: THREE.DoubleSide } );
			arraymaterial[nbOrganelles+1] = new THREE.MeshBasicMaterial( { color: 0x1111ff, side: THREE.DoubleSide } );
			var c1 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			c1.applyMatrix( new THREE.Matrix4().makeTranslation(0, canvasSize/2, 0) );
			var c2 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			c2.applyMatrix( new THREE.Matrix4().makeTranslation(0, -canvasSize/2, 0) );
			var c3 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			c3.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
			c3.applyMatrix( new THREE.Matrix4().makeTranslation(canvasSize/2, 0, 0) );
			var c4 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			c4.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
			c4.applyMatrix( new THREE.Matrix4().makeTranslation(-canvasSize/2, 0, 0) );
			c1.merge(c2);
			c1.merge(c3);
			c1.merge(c4);
			cytoplasm = new THREE.Mesh( c1, arraymaterial[nbOrganelles+1] );
			cytoplasm.name="c"+(nbOrganelles+1);
			cytoplasm.position.set( 0, yStartDisplacement, 0 );
			cytoplasm.rotation.x += (90*(Math.PI / 180));
			scene.add( cytoplasm );
			
			// add planar stuff for demonstration
			//var material3 = new THREE.MeshBasicMaterial( { color: 0x1f511f, side: THREE.DoubleSide } );
			arraymaterial[nbOrganelles+2] = new THREE.MeshBasicMaterial( { color: 0x1111ff, side: THREE.DoubleSide } );
			var e1 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			e1.applyMatrix( new THREE.Matrix4().makeTranslation(0, canvasSize/2, 0) );
			var e2 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			e2.applyMatrix( new THREE.Matrix4().makeTranslation(0, -canvasSize/2, 0) );
			var e3 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			e3.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
			e3.applyMatrix( new THREE.Matrix4().makeTranslation(canvasSize/2, 0, 0) );
			var e4 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			e4.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
			e4.applyMatrix( new THREE.Matrix4().makeTranslation(-canvasSize/2, 0, 0) );
			e1.merge(e2);
			e1.merge(e3);
			e1.merge(e4);
			
			ECM = new THREE.Mesh( e1, arraymaterial[nbOrganelles+2] );
			ECM.name="c"+(nbOrganelles+2);
			ECM.position.set( 0, yStartDisplacement, 0 );
			ECM.rotation.x += (90*(Math.PI / 180));
			scene.add( ECM );
			
			
			
			// create skybox
			var mimagePrefix = "/images/";
			var mdirections  = ["p2", "p2", "p2", "p2", "p2", "p2"];
			var mimageSuffix = ".png";
			var mskyGeometry = new THREE.BoxGeometry( 29000, 29000, 29000 );	
			//var cubePath = "/rsi/static/tex/cube/Grid3/";
            //var cubeFormat = ".jpg";
            //var cubeFaces = [cubePath + 'px' + cubeFormat, cubePath + 'nx' + cubeFormat, cubePath + 'py' + cubeFormat, cubePath + 'ny' + cubeFormat, cubePath + 'pz' + cubeFormat, cubePath + 'nz' + cubeFormat];
            //this.gridCubeTex = THREE.ImageUtils.loadTextureCube(cubeFaces);
			var mmaterialArray = [];
			for (var i = 0; i < 6; i++)
				mmaterialArray.push( new THREE.MeshBasicMaterial({
					map: THREE.ImageUtils.loadTexture( mimagePrefix + mdirections[i] + mimageSuffix ),
					side: THREE.BackSide
				}));
			var mskyMaterial = new THREE.MeshFaceMaterial( mmaterialArray );
			var mskyBox = new THREE.Mesh( mskyGeometry, mskyMaterial );
			mskyBox.name="skybox"
			scene.add( mskyBox );
			
			
			
			// add arrows
			//var material3 = new THREE.MeshBasicMaterial( { color: 0x1f511f, side: THREE.DoubleSide } );
			//var arrow1 = cylinderMesh(new THREE.Vector3(0, 30, 0),new THREE.Vector3(200,200, 0),material3);
			//scene.add( arrow1 );
			
			// function to create a 3d arrow
			
			if (nbPlacesModel!=0 && nbReactionsModel!=0){
			
				var cnt1=0;
				var cnt2=0;
				var cnt=0;
				
				//var ln1 = scene.children[2].geometry.attributes.size.array.length-5000; 
				//var ln2 = scene.children[4].geometry.attributes.size.array.length-5000; 
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				//console.log(ln1)
				//console.log(startModelPlaces)
				for (var i= 0; i<selectedModelNodes.length;i++){
					if (selectedModelNodes[i][5]==2 ){
						//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]=((Math.random() * 2 - 1) * 400);
						var rm=cnt1*0.008*2*Math.PI;
						//radius=900;
						var rr = ((radius*1.48)-(cnt1*0.2)+1)
						scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]= (Math.cos(rm) *rr)+900;
						scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (Math.sin(rm) *rr);
						scene.children[2].geometry.attributes.compartment.array[(ln1+cnt1)]= selectedModelNodes[i][2];
						//scene.children[2].geometry.attributes.compartment.array[(ln1+cnt1)]= Math.floor(Math.random()*nbCompartments);
						idMap[jsonObj1.length+cnt]=[2,cnt1+ln1]
						//typesMap[2][cnt1]=i;
						cnt1++;
						cnt++;
					}
					else if (selectedModelNodes[i][5]==4 ){
						//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=((Math.random() * 2 - 1) * 400);
						var rm=cnt2*0.008*2*Math.PI;
						//radius=600;
						var rr = ((radius*1.480)-(cnt2*0.2)+1)
						scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(Math.cos(rm) *rr)+1800;
						scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(Math.sin(rm) *rr);
						scene.children[4].geometry.attributes.compartment.array[(ln2+cnt2)]= selectedModelNodes[i][2];
						//scene.children[4].geometry.attributes.compartment.array[(ln2+cnt2)]= Math.floor(Math.random()*nbCompartments);
						idMap[jsonObj1.length+cnt]=[4,cnt2+ln2]
						//typesMap[4][cnt2]=i;
						cnt2++;
						cnt++;
					}
				}
				//console.log(cnt1)
				//console.log(cnt2)
				scene.children[2].geometry.attributes.compartment.needsUpdate = true;
				scene.children[4].geometry.attributes.compartment.needsUpdate = true;
				scene.children[2].geometry.attributes.position.needsUpdate = true;
				scene.children[4].geometry.attributes.position.needsUpdate = true;
				
				var col2 = new THREE.Color( 0xffa500 );
				
				
				//console.log(selectedModelNodes)
				//for (var s= 0; s<selectedModelEdges.length;s++){
				//	if (selectedModelEdges[s][0]==108){
				//	console.log(s)
				//	}
				//}
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					if (sim2==2){
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
					}
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					if (sim2==2){
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
					}
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				selectedLinesPathsIds=[]
				for (var i=0; i<selectedLinesPaths.length;i++){
					for (var j=0;j<linesMap[selectedLinesPaths[i]].length;j+=1){
						selectedLinesPathsIds.push(linesMap[selectedLinesPaths[i]][j])
					}
				}
				selectedLinesPathsIds = unique(selectedLinesPathsIds)
				for (var i=0;i<selectedLinesPathsIds.length;i+=1){
					scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] +=50000;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
					
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+50000;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+50000;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				//tokenUniforms.mixAmount.value = 0.0;
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.mixAmount.value[ii] = 0.0;
					ii++;
				}
				tokenAttributes.mixAmount.needsUpdate = true;
			}	
			
			
			
			// css 3d elements
			/*cssScene = new THREE.Scene();
			var cssText="Id:"
			var element = document.createElement( 'div' );
			element.className = 'element';
			element.style.backgroundColor = 'rgba(0,127,127,' + ( Math.random() * 0.5 + 0.25 ) + ')';
			var number = document.createElement( 'div' );
			number.className = 'number';
			number.textContent = "Object";
			element.appendChild( number );
			var symbol = document.createElement( 'div' );
			symbol.className = 'symbol';
			symbol.textContent = cssText;
			element.appendChild( symbol );
			var details = document.createElement( 'div' );
			details.className = 'details';
			//details.innerHTML = '<br>Type:';
			details.textContent = "Type:";
			element.appendChild( details );

			cssObject = new THREE.CSS3DObject( element );
			cssObject.position.x = 0;
			cssObject.position.y = 0;
			cssScene.add(cssObject);
			cssObjects.push( cssObject );	
			rendererCSS	= new THREE.CSS3DRenderer();
			rendererCSS.setSize( 200, 200 );
			rendererCSS.domElement.style.position = 'absolute';
			rendererCSS.domElement.style.top	  = 0;
			rendererCSS.domElement.style.margin	  = 0;
			rendererCSS.domElement.style.padding  = 0;
			document.body.appendChild( rendererCSS.domElement );*/
					
			// add css object spreadsheet webpage
			//cssScene2 = new THREE.Scene();
			//var planeWidth = 360;
			//var planeHeight = 380;
			//element1	= document.createElement('iframe')
			//element1.src	= "slickgrid131.html"
			//var element1Width = 624;
			// force iframe to have same relative dimensions as planeGeometry
			//var aspectRatio = planeHeight / planeWidth;
			//var element1Height = element1Width * aspectRatio;
			//element1.style.width  = element1Width + "px";
			//element1.style.height = element1Height + "px";
			//var obj = new THREE.CSS3DObject( element1 );
			//obj.position.x = -window.innerWidth*1.5;
			//obj.position.y = 0;
			//obj.position.z = -550;
			//obj.rotation.y += (-90*(Math.PI / 180));
			//cssScene2.add( obj );	
			/*
			var elementLink = document.createElement( 'div' );
			//elementLink.style.background="#dddddd";
			elementLink.style.padding="3px";
			elementLink.style.color="white";
			elementLink.style.font="italic bold 10px arial,serif";
			elementLink.style.zIndex="1";
			var allL=''
			allL=allL+'<p align="left"><a href="'+null+'" target="_blank" id="myLink">'+myLinkName[0]+'</a>'
			for (var ln=0;ln<10;ln++){
				allL=allL+'<p align="left"><a href="'+myLink[ln]+'" target="_blank" id="myLink'+ln+'">'+myLink[ln]+'</a>'
			}
			
			//elementLink.innerHTML='<a href="'+myLink[0]+'" target="_blank" id="myLink0">'+myLinkName+'</a>'
			elementLink.innerHTML=allL
			var objLink = new THREE.CSS3DObject( elementLink);			
			objLink.position.x = 350;
			objLink.position.y = 140;
			objLink.position.z = -500;
			cssScene2.add(objLink);
			*/
			
			// create a renderer for CSS
			//rendererCSS2	= new THREE.CSS3DRenderer();
			//rendererCSS2.setSize( window.innerWidth, window.innerHeight );
			//rendererCSS2.setSize( 280, 300 );
			//rendererCSS2.domElement.style.position = 'absolute';
			//rendererCSS2.domElement.style.top	  = 0;
			//rendererCSS2.domElement.style.margin	  = 0;
			//rendererCSS2.domElement.style.padding  = 0;
					
					
					
					
					
			/*cssScene3 = new THREE.Scene();
			var element3 = document.createElement( 'div' );
			element3.style.background="#dddddd";
			element3.style.padding="3px";
			element3.style.color="black";
			element3.style.zIndex="1";
			element3.innerHTML='Input: <input type="text" id="txtSearch">';
			//element3.style.width  = 100 + "px";
			//element3.style.height = 30 + "px";
			var obj3 = new THREE.CSS3DObject( element3);			
			obj3.position.x = 100;
			obj3.position.y = 0;
			obj3.position.z = 220;
			cssScene3.add(obj3);
			cssObjects3.push( obj3 );			
			rendererCSS3	= new THREE.CSS3DRenderer();
			rendererCSS3.setSize( 500, 25 );
			rendererCSS3.domElement.style.position = 'absolute';
			rendererCSS3.domElement.style.top	  = 0;
			
			rendererCSS3.domElement.style.margin	  = 0;
			rendererCSS3.domElement.style.padding  = 0;
			*/
			
			
			projector = new THREE.Projector();
			raycaster = new THREE.Raycaster();
			
			//renderer = new THREE.WebGLRenderer( { alpha: false } );
			//renderer.setSize( WIDTH, HEIGHT );
			
			//ray = new THREE.Ray();
			

			renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
			//renderer.sortObjects = false;
			renderer.setSize( window.innerWidth, window.innerHeight );
			//renderer.setSize( parseInt(window.innerWidth*0.99), window.innerHeight );
			
			pip = document.createElement('div');
			pip.style.width = window.innerWidth*0.6;
			pip.style.height = window.innerHeight*0.15;
			pip.style.position = 'absolute';
			pip.style.backgroundColor = 'black';
			pip.style.borderRadius = "5px";
			pip.style.border = '2px solid white';
			pip.style.padding = "0px 20px";
			pip.style.left = "2000px";
			pip.style.top = "2000px";
			document.body.appendChild(pip);
			
			renderer2 = new THREE.WebGLRenderer({ antialias: true, alpha: false });
			//renderer.sortObjects = false;
			renderer2.setSize( window.innerWidth*0.6, window.innerHeight*0.15 );
			pip.appendChild(renderer2.domElement);
			
			//var container2 = document.createElement( 'div' );
			//document.body.appendChild(container2);
			//container2.appendChild( rendererCSS3.domElement );
			
			var container = document.getElementById( 'container' );
			
			container.appendChild( renderer.domElement );
			positionContainer = $("#container").position();//$("#showresult").position().top + $("#showresult").height()+$("#visualisation").height()
			var menu = document.getElementById( 'menu' )
			menu.style.position="absolute";
			menu.style.right="0px";
			menu.style.bottom=(0-positionContainer.top)+"px";//(positionContainer.top-positionContainer.height-30)+"px";
			contYPos = $("#showresult").position().top + $("#showresult").height()+($("#visualisation").height()/2);
			halfHeight = ($("#showresult").height()+$("#visualisation").height())/2;
			halfvis=($("#visualisation").height()/2);
			//console.log( "left: " + position.left + ", top: " + position.top );
			
			//container.appendChild( rendererCSS2.domElement );
			
			
			controls = new THREE.OrbitControls( camera, container  );
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;
				
			
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			
			container.appendChild( stats.domElement );
			stats.domElement.style.top = ($("#container").height()-60)+'px';
			// add grid for graph...
			/*var gridYZ = new THREE.GridHelper(50, 10);
			gridYZ.position.set( 1000,100,100 );
			gridYZ.rotation.y = Math.PI/2;
			gridYZ.setColors( new THREE.Color(0x660000), new THREE.Color(0x660000) );
			scene.add(gridYZ);*/

			//
			//renderer.domElement.addEventListener( 'mousemove', onMouseMove );
			
			
			
			
			//gui = new dat.GUI();
			
			
			function stopEvents(){
				stopThreeJsMouseEvent=true;
			}
			function resumeEvents(){
				stopThreeJsMouseEvent=false;
			}
			//gui.domElement.onmouseenter = stopEvents;
			//gui.domElement.onmouseleave = resumeEvents;
			
			
			
	
			//parameters = 
			//{
			//	size:8,
			//	x: 0, y: 30, z: 0,
				//x1: 0, y1: 30, z1: 0, 
				//x2: 0, y2: 30, z2: 0,
			//	color: "#ff0000", // color (change "#" to "0x")
				//opacity: 1, 
			//	visible: true,
				//material: "Phong",
				//reset: function() { resetCube() },
			//	name: "something"
				
			//};
			/*
			var FParameters = function() {
				this.size=8;
				this.x=0;
				this.y=0;
				this.z=0;
				this.color= "#ff0000";
				this.visible=true;
				this.name="";
			}
			
			parameters= new FParameters();
			
			var folder1 = gui.addFolder('Position element');
			var guiX = folder1.add( parameters, 'x' ).min(-800).max(800).step(10).listen();
			var guiY = folder1.add( parameters, 'y' ).min(-800).max(800).step(10).listen();
			var guiZ = folder1.add( parameters, 'z' ).min(-800).max(800).step(10).listen();
			guiX.onChange(function(value){   
				if(closestType>=0 && closestType<7){
					scene.children[closestType].geometry.attributes.position.array[closestid*3+0]=value;
					scene.children[closestType].geometry.attributes.position.needsUpdate = true;
				}
			});
			guiY.onChange(function(value){   
				if(closestType>=0 && closestType<7){
					scene.children[closestType].geometry.attributes.position.array[closestid*3+1]=value;
					scene.children[closestType].geometry.attributes.position.needsUpdate = true;
				}
			});
			guiZ.onChange(function(value){ 
				if(closestType>=0 && closestType<7){			
					scene.children[closestType].geometry.attributes.position.array[closestid*3+2]=value;
					scene.children[closestType].geometry.attributes.position.needsUpdate = true;
				}
			});
			
			// add a re-size gui element. When size changed, particle size updated...
			sizeParticleGuiElem = gui.add( parameters, 'size').min(5).max(80).step(1).listen().name("size");
			
			sizeParticleGuiElem.onChange(function(value) {
				if(closestType>=0 && closestType<7){	
					scene.children[closestType].geometry.attributes.size.array[closestid]=value;
					scene.children[closestType].geometry.attributes.size.needsUpdate = true;
				}
			});
			
			
			
			colorParticleGuiElem = gui.addColor( parameters, 'color' ).name('Color').listen();
			colorParticleGuiElem.onChange(function(value){
				if(closestType>=0 && closestType<7){	
				//controls = undefined;
					colorParticleGui.setHex( value.replace("#", "0x") );
					scene.children[closestType].geometry.attributes.ca.array[closestid*3+0]=colorParticleGui.r;	
					scene.children[closestType].geometry.attributes.ca.array[closestid*3+1]=colorParticleGui.g;	
					scene.children[closestType].geometry.attributes.ca.array[closestid*3+2]=colorParticleGui.b;					
					scene.children[closestType].geometry.attributes.ca.needsUpdate = true;	
				}
				if(closestType==7){	
				//controls = undefined;
					colorParticleGui.setHex( value.replace("#", "0x") );
					scene.children[closestType].geometry.attributes.ca.array[closestid*3+0]=colorParticleGui.r;	
					scene.children[closestType].geometry.attributes.ca.array[closestid*3+1]=colorParticleGui.g;	
					scene.children[closestType].geometry.attributes.ca.array[closestid*3+2]=colorParticleGui.b;	
					scene.children[closestType].geometry.attributes.ca.array[(closestid+1)*3+0]=colorParticleGui.r;	
					scene.children[closestType].geometry.attributes.ca.array[(closestid+1)*3+1]=colorParticleGui.g;	
					scene.children[closestType].geometry.attributes.ca.array[(closestid+1)*3+2]=colorParticleGui.b;	
					scene.children[closestType].geometry.attributes.ca.needsUpdate = true;	
				}
			});
			gui.add( parameters, 'name' ).name("type").listen();
			
			gui.open();
			*/
			/*var FParameters = function() {
				this.models="";
			}
			var parameters= new FParameters();
			var chooseModel=gui.add(parameters, 'models', simpleListModels );
			chooseModel.onChange(function(newValue) {
				if (newValue!="none"){
					// ask server to send model file...
					socket.emit('request-model', [ newValue, myusername]);
					//xhttp.open("GET","models/"+newValue+".json",false);
					//xhttp.send();
					//selectedModel=JSON.parse(xhttp.responseText);
					//console.log("getting model data from : "+newValue+"_model.json" );
					
				}
				else{
					selectedModel=[[],[],[],[]];
					updatedModel=true;
					
				}
				
				
			});
			gui.open();
			*/
			//selectedModel=
			
			window.addEventListener( 'resize', onWindowResize, false );
			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			document.addEventListener( 'mousedown', onDocumentMouseDown, false );
			document.addEventListener( 'mouseup', onDocumentMouseUp, false );
			
			
			var button = document.getElementById( 'view4' );
			button.addEventListener( 'click', function ( event ) {
				//console.log("view3");
				
				if (toggledLines==0){
					//console.log(scene.children[7].geometry.attributes.compartment.array.length);
					//for ( var iv = 0; iv < scene.children[7].geometry.attributes.position.array.length; iv +=2) {
					for ( var iv = 0; iv <extraLinesCnt; iv +=2) {
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] -=50000;
						scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] -=50000;
					}
					
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					toggledLines=1
				}
				else{
					//for ( var iv = 0; iv < scene.children[7].geometry.attributes.position.array.length; iv +=2) {
					for ( var iv = 0; iv <extraLinesCnt; iv +=2) {
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] +=50000;
						scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] +=50000;
					}
					
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					
					
					toggledLines=0
				}

			}, false );
			
			var button = document.getElementById( 'view5' );
		button.addEventListener( 'click', function ( event ) {
			//console.log("view3");
			
			if (toggledToken==0){
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					//scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y-=50000;
					//scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					//tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y-=50000;
					//tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				//tokenUniforms.mixAmount.value = 0.0;
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.mixAmount.value[ii] = 0.0;
					ii++;
				}
				tokenAttributes.mixAmount.needsUpdate = true;
				toggledToken=1
			}
			else{
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					//scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y+=50000;
					//scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					//tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y+=50000;
					//tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				//tokenUniforms.mixAmount.value = 0.0;
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.mixAmount.value[ii] = 0.0;
					ii++;
				}
				tokenAttributes.mixAmount.needsUpdate = true;
				toggledToken=0
			}

		}, false );
		
		var button = document.getElementById( 'view2' );
				button.addEventListener( 'click', function ( event ) {
				
				if (exploded==false){
				
				focus_label=0;
				
				//console.log(nbOrganelles)
				for (var i=0;i<nbOrganelles;i++){
					organelles[i].position.set( Math.sin((2*Math.PI)/nbOrganelles*i)*scaleExplosion, yStartDisplacement, Math.cos((2*Math.PI)/nbOrganelles*i)*scaleExplosion );
					
				}
				//if (selectedModel[0][0]=="Ecoli2.0"){
									
				//}
				
				nucleus.position.set( 0, yStartDisplacement+1000, 0 );
				cytoplasm.position.set( 0, yStartDisplacement-1000, 0 );
				ECM.position.set( 0, yStartDisplacement-3000, 0 );
				if (nameModel=="Ec_iAF1260_flux2"){
					nucleus.position.set( 0, yStartDisplacement+0, 1000 );
					cytoplasm.position.set( 0, yStartDisplacement+0, 0 );
					ECM.position.set( 0, yStartDisplacement+0, -1000 );
				}
				
				//console.log("view2");
				for (var c=0;c<7;c++){
					
						for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
							for (var g=0;g<nbOrganelles;g++){
								if (scene.children[c].geometry.attributes.compartment.array[h]==g){
								//console.log(g)
									scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*scaleExplosion;
									scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*scaleExplosion;
								}
								
							}
							if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles){
								if (nameModel=="Ec_iAF1260_flux2"){
									scene.children[c].geometry.attributes.position.array[h*3+2]+=1000;
								}
								else{
									scene.children[c].geometry.attributes.position.array[h*3+1]+=(1000);
								}
									
									//scene.children[c].geometry.attributes.position.array[h*3+0]=scene.children[c].geometry.attributes.position.array[h*3+0]*2;
									//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
									//scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*2000;
							}
							if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles+1){
								if (nameModel=="Ec_iAF1260_flux2"){
									//scene.children[c].geometry.attributes.position.array[h*3+2]-=1000;
								}
								else{
									scene.children[c].geometry.attributes.position.array[h*3+1]-=(1000);
								}
								
								//scene.children[c].geometry.attributes.position.array[h*3+0]+=2000;
								//scene.children[c].geometry.attributes.position.array[h*3+2]*=6;
									//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
									//scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*2000;
							}
							if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles+2){
								if (nameModel=="Ec_iAF1260_flux2"){
									scene.children[c].geometry.attributes.position.array[h*3+2]-=1000;
								}
								else{
									scene.children[c].geometry.attributes.position.array[h*3+1]-=(3000);
								}
								
								//scene.children[c].geometry.attributes.position.array[h*3+0]-=2000;
								//scene.children[c].geometry.attributes.position.array[h*3+2]*=9;
									//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
									//scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*2000;
							}
							
							//b2compartments[ (i * 2)+0 ] = b1values_compartment[ i  ];
							//b2compartments[ (i * 2)+1 ] = b1values_compartment[ i+1  ];
							
						}
					
					
					scene.children[c].geometry.attributes.position.needsUpdate = true;
				}
				
				var iv=0;
				for ( var i = 0; i < segments; i ++ ) {
					var t1 = jsonObj1[jsonObj2[i][0]][6]
					var t2 = jsonObj1[jsonObj2[i][1]][6]
					//console.log(t1)
					//console.log(t2)
					//var ivList=[]
					var doIt=0
					if (t1==2){
						//console.log(idMap[jsonObj2[i][0]][1])
						scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;					
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
						
						iv++;
					}
					else if (t1==4){
						//console.log(idMap[jsonObj2[i][0]][1])
						scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
						iv++;
					}
					if (t2 ==2){
						scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;						
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;	
						iv++;
					}
					else if (t2 ==4){
						scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;				
						iv++;
					}
					
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				///////////////////////
				
				if (selectedModelNodes){
					var cnt1=0;
					var cnt2=0;
					var cnt=0;
					var ln1 = scene.children[2].geometry.attributes.size.array.length-10000;
					var ln2 = scene.children[4].geometry.attributes.size.array.length-10000;
					
					for (var mi= 0; mi<selectedModelNodes.length;mi++){
						if (selectedModelNodes[mi][5]==2 ){
							if (selectedModelNodes[mi][2]<nbOrganelles && selectedModelNodes[mi][2]>=0){
								
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*selectedModelNodes[mi][2])*scaleExplosion;
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*selectedModelNodes[mi][2])*scaleExplosion;
								cnt++;
								cnt1++;
							}
							else if (selectedModelNodes[mi][2]==nbOrganelles){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]+=1000;
								cnt++;
								cnt1++;
							}
							else if (selectedModelNodes[mi][2]==nbOrganelles+1){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]-=1000;
								cnt++;
								cnt1++;
							}
							else if (selectedModelNodes[mi][2]==nbOrganelles+2){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]-=3000;
								cnt++;
								cnt1++;
							}
						}
						else if (selectedModelNodes[mi][5]==4 ){
							if (selectedModelNodes[mi][2]<nbOrganelles && selectedModelNodes[mi][2]>=0){
								
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*selectedModelNodes[mi][2])*scaleExplosion;
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*selectedModelNodes[mi][2])*scaleExplosion;
								cnt++;
								cnt2++;
							}
							else if (selectedModelNodes[mi][2]==nbOrganelles){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]+=1000;
								cnt++;
								cnt2++;
							}
							else if (selectedModelNodes[mi][2]==nbOrganelles+1){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]-=1000;
								cnt++;
								cnt2++;
							}
							else if (selectedModelNodes[mi][2]==nbOrganelles+2){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]-=3000;
								cnt++;
								cnt2++;
							}
						}
						
					}
					scene.children[2].geometry.attributes.compartment.needsUpdate = true;
					scene.children[4].geometry.attributes.compartment.needsUpdate = true;
					scene.children[2].geometry.attributes.position.needsUpdate = true;
					scene.children[4].geometry.attributes.position.needsUpdate = true;
					
					var col2 = new THREE.Color( 0xffa500 );
					
					
					
					var count=0;
					for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
						var t1;
						var t2;
						var pt1;
						var pt2;
						var sim1=1;
						var sim2=1;
						pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
						sim1 = idMap[pt1][0]
						t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
						if (selectedModelEdges[iv-extraLinesCnt][3]==2){
							//console.log("link between model and metabolic nodes")
							
							if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
								pt2=selectedModelEdges[iv-extraLinesCnt][1];
							}
							else{
								pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
							}
							t2 = jsonObj1[pt2][6]
							sim2=2;
						}
						else{
							//console.log("link between model nodes")
							if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
								pt2=selectedModelEdges[iv-extraLinesCnt][1];
							}
							else{
								pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
							}
							t2 = selectedModelNodes[pt2][5];
						}
						if (sim2!=2){
							pt2+=jsonObj1.length;
							//console.log(idMap[pt2]);
						}
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
						if (sim2==2){
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
						}
						count+=1;
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
						if (sim2==2){
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
						}
						count+=1;
					}
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					scene.children[7].geometry.attributes.ca.needsUpdate = true;
				}	
				
				if (toggledLines==1){
					for ( var iv = 0; iv < extraLinesCnt; iv +=2) {
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] -=50000;
						scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] -=50000;
					}
					
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					
					
					
				}
				
				
				selectedLinesPathsIds=[]
				for (var i=0; i<selectedLinesPaths.length;i++){
					for (var j=0;j<linesMap[selectedLinesPaths[i]].length;j+=1){
						selectedLinesPathsIds.push(linesMap[selectedLinesPaths[i]][j])
					}
				}
				selectedLinesPathsIds = unique(selectedLinesPathsIds)
				for (var i=0;i<selectedLinesPathsIds.length;i+=1){
					scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] +=50000;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
					
				//var ii=0;
				//for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
				//	scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
				//	scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
				//	scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
				//	ii++;
				//}
				//console.log(tokenAttributes.endPosition.value[0]);
				//var ii=0;
				//for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				//	tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
				//	tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
				//	tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
				//	ii++;
				//}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				//tokenUniforms.mixAmount.value = 0.0;
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.mixAmount.value[ii] = 0.0;
					ii++;
				}
				tokenAttributes.mixAmount.needsUpdate = true;
				//scene.children[8].geometry.attributes.endPosition.needsUpdate = true;
				
				var createArrow = function ( width, length ) {
					var c1Geometry = new THREE.CylinderGeometry(width, width, length, 5, 5);
					var c2Geometry = new THREE.CylinderGeometry( 0, width*2.0, length/3, 5, 1 );		
					c2Geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, length/2+(length/6), 0 ) );	
					var c3Geometry = new THREE.CylinderGeometry( 0, width*2.0, length/3, 5, 1 );	
					//c3Geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, -length/2, 0 ) );
					c3Geometry.applyMatrix( new THREE.Matrix4().makeRotationZ( -Math.PI ));
					c3Geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, -(length/2+(length/6)), 0 ) );
					c1Geometry.merge(c2Geometry);
					c1Geometry.merge(c3Geometry);
					c1Geometry.applyMatrix( new THREE.Matrix4().makeRotationX( Math.PI/2 ));
					var cylinder = new THREE.Mesh(c1Geometry, new THREE.MeshNormalMaterial());
					return cylinder;
				}
				// create arrows between compartments
				// create arrows between organellels
				var scaleArrowsBase = scaleExplosion/1000;
				var cntArrows=0;
				for (var i=0;i<nbOrganelles;i++){
				
					arrows[cntArrows] = createArrow(20,400);
					scene.add( arrows[cntArrows] );
					// shorten length
					arrows[cntArrows].scale.z=scaleArrowsBase*0.9;
					//cylinder.rotateX(Math.PI/2);
					
					var p2 = new THREE.Vector3(0,1000,0);
					arrows[cntArrows].position.set( ((Math.sin((2*Math.PI)/nbOrganelles*i)*scaleExplosion)+p2.x)/2, (0+p2.y)/2, ((Math.cos((2*Math.PI)/nbOrganelles*i)*scaleExplosion)+p2.z)/2); 
					arrows[cntArrows].lookAt(p2);
					cntArrows++;
					
					for (var ii=0;ii<nbOrganelles;ii++){
						if (i!=ii){
							arrows[cntArrows] = createArrow(20,400);
							scene.add( arrows[cntArrows] );
							// shorten length
							//cylinder.scale.y=0.5;
							//cylinder.rotateX(Math.PI/2);
							arrows[cntArrows].scale.z=scaleArrowsBase;
							if (Math.abs(i-ii)>=2 && Math.abs(i-ii)<(nbOrganelles-1)){
								arrows[cntArrows].scale.z=scaleArrowsBase*1.3;
							}
							var p3 = new THREE.Vector3((Math.sin((2*Math.PI)/nbOrganelles*i)*scaleExplosion),0,(Math.cos((2*Math.PI)/nbOrganelles*i)*scaleExplosion));
							arrows[cntArrows].position.set( ((Math.sin((2*Math.PI)/nbOrganelles*i)*scaleExplosion)+(Math.sin((2*Math.PI)/nbOrganelles*(ii))*scaleExplosion))/2, (0+0)/2, ((Math.cos((2*Math.PI)/nbOrganelles*i)*scaleExplosion)+(Math.cos((2*Math.PI)/nbOrganelles*(ii))*scaleExplosion))/2); 
							arrows[cntArrows].lookAt(p3);
							cntArrows++;
						}
					}
					
					arrows[cntArrows] = createArrow(20,400);
					scene.add( arrows[cntArrows] );
					// shorten length
					arrows[cntArrows].scale.z=scaleArrowsBase*0.9;
					//cylinder.rotateX(Math.PI/2);
					
					var p3 = new THREE.Vector3(0,-1000,0);
					arrows[cntArrows].position.set( ((Math.sin((2*Math.PI)/nbOrganelles*i)*scaleExplosion)+p3.x)/2, (0+p3.y)/2, ((Math.cos((2*Math.PI)/nbOrganelles*i)*scaleExplosion)+p3.z)/2); 
					arrows[cntArrows].lookAt(p3);
					cntArrows++;
					arrows[cntArrows] = createArrow(20,400);
					scene.add( arrows[cntArrows] );
					// shorten length
					arrows[cntArrows].scale.z=scaleArrowsBase;
					//cylinder.rotateX(Math.PI/2);
					
					var p4 = new THREE.Vector3(0,-3000,0);
					arrows[cntArrows].position.set( ((Math.sin((2*Math.PI)/nbOrganelles*i)*scaleExplosion)+p4.x)/2, (0+p4.y)/2, ((Math.cos((2*Math.PI)/nbOrganelles*i)*scaleExplosion)+p4.z)/2); 
					arrows[cntArrows].lookAt(p4);	
					cntArrows++;
				}
				
				arrows[cntArrows] = createArrow(20,400);
				scene.add( arrows[cntArrows] );
				// shorten length
				//c5.scale.z=scaleArrowsBase*0.65;
				//cylinder.rotateX(Math.PI/2);
				var p5 = new THREE.Vector3(0,-1000,0);
				arrows[cntArrows].position.set( (0+p5.x)/2, (2000+p5.y)/2, (0+p5.z)/2); 
				arrows[cntArrows].lookAt(p5);
				cntArrows++;
				arrows[cntArrows] = createArrow(20,400);
				scene.add( arrows[cntArrows] );
				// shorten length
				//c6.scale.z=scaleArrowsBase*0.65;
				//cylinder.rotateX(Math.PI/2);
				var p6 = new THREE.Vector3(0,-3000,0);
				arrows[cntArrows].position.set( (0+p6.x)/2, (-1000+p6.y)/2.5, (0+p6.z)/2); 
				arrows[cntArrows].lookAt(p6);
				
				for (var i=0; i<arrows.length;i++){
					arrows[i].position.z-=50000;
				}
				
				
				/*if(typeof(Storage)!=="undefined") {
					//if(resetSpreadsheet==true){localStorage.selection=="";}
					if(resetSpreadsheet==true){localStorage.selection=[];}
					if (localStorage.selection==""){
						mselectedList=[]
							//console.log("empty")
							for (var i =0;i<spritesSelected.length;i++){		
								spritesSelected[i].position.set(-50000,-10000,10000);
							}
						
					}
					if (localStorage.selection.length>0){
						//console.log(mselectedList); 
						//console.log(localStorage.selection.split(",").map(function(x){return parseInt(x)})); 
						var tmpS= localStorage.selection.split(",").map(function(x){return parseInt(x)});
						
						
						//	console.log(localStorage.selection); 
						mselectedList=[];
						for (var i =0;i<tmpS.length;i++){
						mselectedList[i] =tmpS[i];
						}
						console.log(mselectedList); 
						// highlight selection
						for (var i =0;i<spritesSelected.length;i++){		
							spritesSelected[i].position.set(-50000,-10000,10000);
						}
						for (var i =0;i<mselectedList.length;i++){
							//for (var j =0;j<spritesSelected.length;j++){
							if (i<spritesSelected.length){
								//spritesSelected
								//console.log(idMap[mselectedList[i]])
								var a1 = scene.children[idMap[mselectedList[i]][0]].geometry.attributes.position.array;
								spritesSelected[i].position.set(a1[idMap[mselectedList[i]][1]*3],a1[idMap[mselectedList[i]][1]*3+1],a1[idMap[mselectedList[i]][1]*3+2]);	
							}
							
						}
						
					}			  
				} */
				}
				exploded=true;
				focus_label=0;
				}, false );
			
			var button = document.getElementById( 'view1' );
			button.addEventListener( 'click', function ( event ) {
				if (exploded==true){
					for (var i=0;i<nbOrganelles;i++){
						organelles[i].position.set( 0, yStartDisplacement, 0 );
					}
					nucleus.position.set( 0, yStartDisplacement, 0 );
					cytoplasm.position.set( 0, yStartDisplacement, 0 );
					ECM.position.set( 0, yStartDisplacement, 0 );
					//console.log(allDragged)
					if (nameModel=="Ec_iAF1260_flux2"){
						for (var c=0;c<7;c++){
							
								for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
									for (var g=0;g<nbOrganelles;g++){
										if (scene.children[c].geometry.attributes.compartment.array[h]==g){
											var flg=-1;
											for (var dr=0;dr<allDragged.length;dr++){
												if (allDragged[dr].indexOf(g)>-1){
													flg = dr;
													
												}
											}
											
											if (flg==-1){
												scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*g)*scaleExplosion;
												scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*g)*scaleExplosion;
											}
											else{
												if (flg<nbOrganelles){
													scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*flg)*scaleExplosion;
													scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*flg)*scaleExplosion;
												}
												if (flg>=nbOrganelles){
													scene.children[c].geometry.attributes.position.array[h*3+1]-=yStartDisplacement;
												}
												
											}
											
										}
									}
									if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles){
											//scene.children[c].geometry.attributes.position.array[h*3+1]0;
											//scene.children[c].geometry.attributes.position.array[h*3+0]=scene.children[c].geometry.attributes.position.array[h*3+0]*2;
											//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
											scene.children[c].geometry.attributes.position.array[h*3+2]-=1000;
									}
									//if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles+1){
										//scene.children[c].geometry.attributes.position.array[h*3+1]+=1000;
										//scene.children[c].geometry.attributes.position.array[h*3+0]+=2000;
										//scene.children[c].geometry.attributes.position.array[h*3+2]*=6;
											//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
									//		scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*2000;
									//}
									if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles+2){
										//scene.children[c].geometry.attributes.position.array[h*3+1]+=3000;
										//scene.children[c].geometry.attributes.position.array[h*3+0]-=2000;
										//scene.children[c].geometry.attributes.position.array[h*3+2]*=9;
											//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
											scene.children[c].geometry.attributes.position.array[h*3+2]+=1000;
									}
									
									//b2compartments[ (i * 2)+0 ] = b1values_compartment[ i  ];
									//b2compartments[ (i * 2)+1 ] = b1values_compartment[ i+1  ];
									
								}
								
							
							
							scene.children[c].geometry.attributes.position.needsUpdate = true;
						}
					}
					else{
						for (var c=0;c<7;c++){
							
								for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
									for (var g=0;g<nbOrganelles;g++){
										if (scene.children[c].geometry.attributes.compartment.array[h]==g){
											var flg=-1;
											for (var dr=0;dr<allDragged.length;dr++){
												if (allDragged[dr].indexOf(g)>-1){
													flg = dr;
													
												}
											}
											
											if (flg==-1){
												scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*g)*scaleExplosion;
												scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*g)*scaleExplosion;
											}
											else{
												if (flg<nbOrganelles){
													scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*flg)*scaleExplosion;
													scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*flg)*scaleExplosion;
												}
												if (flg>=nbOrganelles){
													scene.children[c].geometry.attributes.position.array[h*3+1]-=yStartDisplacement;
												}
												
											}
											
										}
									}
									if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles){
											scene.children[c].geometry.attributes.position.array[h*3+1]-=1000;
											//scene.children[c].geometry.attributes.position.array[h*3+0]=scene.children[c].geometry.attributes.position.array[h*3+0]*2;
											//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
											//scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*2000;
									}
									if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles+1){
										scene.children[c].geometry.attributes.position.array[h*3+1]+=1000;
										//scene.children[c].geometry.attributes.position.array[h*3+0]+=2000;
										//scene.children[c].geometry.attributes.position.array[h*3+2]*=6;
											//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
											//scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*2000;
									}
									if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles+2){
										scene.children[c].geometry.attributes.position.array[h*3+1]+=3000;
										//scene.children[c].geometry.attributes.position.array[h*3+0]-=2000;
										//scene.children[c].geometry.attributes.position.array[h*3+2]*=9;
											//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
											//scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*2000;
									}
									
									//b2compartments[ (i * 2)+0 ] = b1values_compartment[ i  ];
									//b2compartments[ (i * 2)+1 ] = b1values_compartment[ i+1  ];
									
								}
								
							
							
							scene.children[c].geometry.attributes.position.needsUpdate = true;
						}
					}
					
					for (var dr=0;dr<allDragged.length;dr++){
								allDragged[dr]=[];
					}
					//else if (allDragged[ni].indexOf(scene.children[c].geometry.attributes.compartment.array[h])>-1 && tmp1.indexOf(scene.children[c].geometry.attributes.compartment.array[h])>-1){
					
					
					
					var iv=0;
					for ( var i = 0; i < segments; i ++ ) {
						var t1 = jsonObj1[jsonObj2[i][0]][6]
						var t2 = jsonObj1[jsonObj2[i][1]][6]
						//var ivList=[]
						if (t1==2){
							scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;						
							iv++;
						}
						else if (t1==4){
							scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
							iv++;
						}
						if (t2 ==2){
							scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;
							iv++;
						}
						else if (t2 ==4){
							scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;
							iv++;
						}
						
						

					}
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					var cnt1=0;
					var cnt2=0;
					var cnt=0;
					var ln1 = scene.children[2].geometry.attributes.size.array.length-10000;
					var ln2 = scene.children[4].geometry.attributes.size.array.length-10000;
					if(selectedModelNodes){
					for (var i= 0; i<selectedModelNodes.length;i++){
						if (selectedModelNodes[i][5]==2 ){
							if (selectedModelNodes[i][2]<nbOrganelles && selectedModelNodes[i][2]>=0){
								
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*selectedModelNodes[i][2])*scaleExplosion;
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*selectedModelNodes[i][2])*scaleExplosion;
								cnt++;
								cnt1++;
							}
							else if (selectedModelNodes[i][2]==nbOrganelles){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]-=1000;
								cnt++;
								cnt1++;
							}
							else if (selectedModelNodes[i][2]==nbOrganelles+1){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]+=1000;
								cnt++;
								cnt1++;
							}
							else if (selectedModelNodes[i][2]==nbOrganelles+2){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]+=3000;
								cnt++;
								cnt1++;
							}
						}
						else if (selectedModelNodes[i][5]==4 ){
							if (selectedModelNodes[i][2]<nbOrganelles && selectedModelNodes[i][2]>=0){
								
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*selectedModelNodes[i][2])*scaleExplosion;
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*selectedModelNodes[i][2])*scaleExplosion;
								cnt++;
								cnt2++;
							}
							else if (selectedModelNodes[i][2]==nbOrganelles){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]-=1000;
								cnt++;
								cnt2++;
							}
							else if (selectedModelNodes[i][2]==nbOrganelles+1){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]+=1000;
								cnt++;
								cnt2++;
							}
							else if (selectedModelNodes[i][2]==nbOrganelles+2){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]+=3000;
								cnt++;
								cnt2++;
							}
						}
						
					}
					}
					scene.children[2].geometry.attributes.compartment.needsUpdate = true;
					scene.children[4].geometry.attributes.compartment.needsUpdate = true;
					scene.children[2].geometry.attributes.position.needsUpdate = true;
					scene.children[4].geometry.attributes.position.needsUpdate = true;
					
					var col2 = new THREE.Color( 0xffa500 );
					
					
					
					//console.log(nbEdgesModel)
					var count=0;
					for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
						var t1;
						var t2;
						var pt1;
						var pt2;
						var sim1=1;
						var sim2=1;
						pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
						sim1 = idMap[pt1][0]
						t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
						if (selectedModelEdges[iv-extraLinesCnt][3]==2){
							//console.log("link between model and metabolic nodes")
							
							if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
								pt2=selectedModelEdges[iv-extraLinesCnt][1];
							}
							else{
								pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
							}
							t2 = jsonObj1[pt2][6]
							sim2=2;
						}
						else{
							//console.log("link between model nodes")
							if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
								pt2=selectedModelEdges[iv-extraLinesCnt][1];
							}
							else{
								pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
							}
							t2 = selectedModelNodes[pt2][5];
						}
						if (sim2!=2){
							pt2+=jsonObj1.length;
							//console.log(idMap[pt2]);
						}
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
						if (sim2==2){
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
						}
						count+=1;
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
						if (sim2==2){
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
						}
						count+=1;
					}
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					scene.children[7].geometry.attributes.ca.needsUpdate = true;
					
					if (toggledLines==1){
						for ( var iv = 0; iv < extraLinesCnt; iv +=2) {
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] -=50000;
							scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] -=50000;
						}
						
						scene.children[7].geometry.attributes.position.needsUpdate = true;
						
						
						
					}
					
					
					selectedLinesPathsIds=[]
					for (var i=0; i<selectedLinesPaths.length;i++){
						for (var j=0;j<linesMap[selectedLinesPaths[i]].length;j+=1){
							selectedLinesPathsIds.push(linesMap[selectedLinesPaths[i]][j])
						}
					}
					selectedLinesPathsIds = unique(selectedLinesPathsIds)
					for (var i=0;i<selectedLinesPathsIds.length;i+=1){
						scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] +=50000;
					}
					scene.children[7].geometry.attributes.position.needsUpdate = true;
						
					var ii=0;
					for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					
						scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
						scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
						scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
						ii++;
					}
					//console.log(tokenAttributes.endPosition.value[0]);
					var ii=0;
					for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
						tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
						tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
						tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
						
						ii++;
					}
					//tokenUniforms.mixAmount.value = 0.0;
					var ii=0;
					for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
						tokenAttributes.mixAmount.value[ii] = 0.0;
						ii++;
					}
					tokenAttributes.mixAmount.needsUpdate = true;
					//console.log(tokenAttributes.endPosition.value[0]);
					scene.children[8].geometry.verticesNeedUpdate = true;
					tokenAttributes.endPosition.needsUpdate = true;
					
						//var lookPosition  = new THREE.Vector3(Math.sin((2*Math.PI)/nbOrganelles*0)*scaleExplosion, 1100, Math.cos((2*Math.PI)/nbOrganelles*0)*scaleExplosion);
						//var lookTarget = new THREE.Vector3(Math.sin((2*Math.PI)/nbOrganelles*0)*scaleExplosion, -10, Math.cos((2*Math.PI)/nbOrganelles*0)*scaleExplosion);
						//cameraGoTo(lookPosition, lookTarget);
					for (var i=0; i<arrows.length;i++){
						arrows[i].position.z-=50000;
					}
					/*if(typeof(Storage)!=="undefined") {
						//if(resetSpreadsheet==true){localStorage.selection=="";}
						if(resetSpreadsheet==true){localStorage.selection=[];}
						if (localStorage.selection==""){
							mselectedList=[]
								//console.log("empty")
								for (var i =0;i<spritesSelected.length;i++){		
									spritesSelected[i].position.set(-50000,-10000,10000);
								}
							
						}
						if (localStorage.selection.length>0){
							//console.log(mselectedList); 
							//console.log(localStorage.selection.split(",").map(function(x){return parseInt(x)})); 
							var tmpS= localStorage.selection.split(",").map(function(x){return parseInt(x)});
							
							
							//	console.log(localStorage.selection); 
							mselectedList=[];
							for (var i =0;i<tmpS.length;i++){
							mselectedList[i] =tmpS[i];
							}
							console.log(mselectedList); 
							// highlight selection
							for (var i =0;i<spritesSelected.length;i++){		
								spritesSelected[i].position.set(-50000,-10000,10000);
							}
							for (var i =0;i<mselectedList.length;i++){
								//for (var j =0;j<spritesSelected.length;j++){
								if (i<spritesSelected.length){
									//spritesSelected
									//console.log(idMap[mselectedList[i]])
									var a1 = scene.children[idMap[mselectedList[i]][0]].geometry.attributes.position.array;
									spritesSelected[i].position.set(a1[idMap[mselectedList[i]][1]*3],a1[idMap[mselectedList[i]][1]*3+1],a1[idMap[mselectedList[i]][1]*3+2]);	
								}
								
							}
							
						}			  
					}*/
					exploded=false;
				}
			}, false );
			
			
		}
		
		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		}
		
		function onDocumentMouseMove( event ) {
		
			//event.preventDefault();
			//position = window.pageYOffset+$("#container").position();//+;
			
			mouse.x = ( (event.clientX+window.pageXOffset) / window.innerWidth ) * 2 - 1;
			mouse.y = - ( (event.clientY-$("#container").position().top+window.pageYOffset) / window.innerHeight ) * 2 + 1;

		}
		
		function unique(a){
			var arr = [];
			for (var i=0;i<a.length;i++){
				if ( arr.indexOf(a[i]) == -1){
					arr.push(a[i]);
				}
			}
			return arr
		}
		
		function onDocumentMouseDown( event ) {

				//event.preventDefault();
				
				switch ( event.button ) {
					case 0: // left 
					
						if	((isOnParticle==1) && (hoveredType>=0) && (stopThreeJsMouseEvent==false) ){
							closestid =closest;
							closestType=hoveredType;
							//parameters.size=scene.children[closestType].geometry.attributes.size.array[closestid];
							//colorParticleGui.r=scene.children[closestType].geometry.attributes.ca.array[closestid*3+0];
							//colorParticleGui.g=scene.children[closestType].geometry.attributes.ca.array[closestid*3+1];
							//colorParticleGui.b=scene.children[closestType].geometry.attributes.ca.array[closestid*3+2];
							//parameters.color='#' +('000000'+colorParticleGui.getHex().toString(16)).slice(-6);
							
							//myLinkName=""+jsonObj1[typesMap[closestType][closestid]][2]
							//var mlTile= document.getElementById( 'myLink' )
							//mlTile.innerHTML=myLinkName
							//mlTile.href=null
							//var ml=[]
							//for (var ln =0; ln<10;ln++){
								//ml[ln] = document.getElementById( 'myLink'+ln )
								
							//}
							
							//ml.innerHTML=myLinkName
							
							//for (var ln =0; ln<10;ln++){
							//	myLink[ln]=null
								//myLink[ln]=jsonObj1[typesMap[closestType][closestid]].encodedBy[ln]
								//ml[ln].innerHTML=""
								//ml[ln].href=myLink[ln]
							//}
							//console.log(closestid)
							//console.log(typesMap[closestType][closestid])
							
							
							//var dat =typesMap[listretPointsTypes[myr]][closest];
							//if(jsonObj1[dat]){
							//	stringTxt = jsonObj1[dat][0]+" "+jsonObj1[dat][2];
							//	if (jsonObj1[dat][4][1] && jsonObj1[dat][4][1][0]){
							//		stringTxt = jsonObj1[dat][0]+" "+jsonObj1[dat][2]+" ("+jsonObj1[dat][4][1][0]+")";
							//	}
								
							//}
							//else{
							//	if (listretPointsTypes[myr]==2){																
							//		stringTxt = " "+selectedModelNodes[dat-jsonObj1.length][1];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
							//	}
							//	else if (listretPointsTypes[myr]==4){											
							//			stringTxt = " "+selectedModelNodes[nbPlacesModel+dat-jsonObj1.length][1];
							//	}
								//else{stringTxt = " ";}
							//}
							
							//console.log(jsonObj1[typesMap[closestType][closestid]])
							var nbS2=0
							try{
								text0.innerHTML = ""+jsonObj1[typesMap[closestType][closestid]][2];
								text0.style.top = contYPos-halfHeight +10+ 'px';
								text0.style.left = 20 + 'px';
								
								
								var txtListGenes = '<ul style="margin-left:0em;padding-left:1.3em;height:50px;">';
								for (var ln =0; ln<jsonObj1[typesMap[closestType][closestid]][4][0].length;ln++){
									myLink[ln]=jsonObj1[typesMap[closestType][closestid]][4][0][ln]
									//ml[ln].innerHTML=myLink[ln].substring(myLink[ln].lastIndexOf("/")+1);;
									txtListGenes += '<li ><a href="'+myLink[ln]+'" target="_blank">'+myLink[ln].substring(myLink[ln].lastIndexOf("/")+1);+'</a></li>';
									//ml[ln].href=myLink[ln]
								}
								txtListGenes += '</ul>';
								listGenesContent.innerHTML = txtListGenes;
								if (jsonObj1[typesMap[closestType][closestid]][4][0].length<=0){
									listGenes.style.top = 2000 + 'px';
									listGenes.style.left = 2000 + 'px';
								}else{
									listGenes.style.top = (text0.clientHeight+contYPos-halfHeight) +40+ 'px';
									listGenes.style.left = 20 + 'px';
									//text0.style.top = (listGenes.clientHeight+positionContainer.top) + 'px';
								}
							}
							catch(e){
								var stringTxt;
								var tpId;
								if (closestType==2){	
									tpId=typesMap[closestType][closestid]-jsonObj1.length;					
									stringTxt = " "+selectedModelNodes[tpId][1];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
								}
								else if (closestType==4){	
									tpId=nbPlacesModel+typesMap[closestType][closestid]-jsonObj1.length;
									stringTxt = " "+selectedModelNodes[tpId][1];
								}
								text0.innerHTML = ""+stringTxt;//selectedModelNodes[typesMap[closestType][closestid]-jsonObj1.length];
								text0.style.top = contYPos-halfHeight +10+ 'px';
								text0.style.left = 20 + 'px';
								var identifier=typesMap[closestType][closestid]
								var txtListLinks = '<ul style="margin-left:0em;padding-left:1.3em;height:150px;">';
								if (selectedModelNodesPaths.indexOf(tpId)!=-1){
									selectedModelNodesPaths.splice(selectedModelNodesPaths.indexOf(tpId),1)
								}
								else{
									selectedModelNodesPaths.push(tpId)
									for (var i=0; i<selectedModelEdges.length;i++){
										if (selectedModelEdges[i][0]==tpId){
												
												// if selectedModelEdges[i][2]=0 then reactant , if 2 then modifier, if 1 then product
												if(selectedModelEdges[i][2]==0){
													txtListLinks += '<li >'+"transition with consumed pre-place: "+selectedModelNodes[selectedModelEdges[i][1]][1]+'</li>';
													nbS2+=1;
												}
												else if (selectedModelEdges[i][2]==1){
													txtListLinks += '<li >'+"transition with non-consumed pre-place: "+selectedModelNodes[selectedModelEdges[i][1]][1]+'</li>';
													nbS2+=1;
												}
												else if (selectedModelEdges[i][2]==2){
													txtListLinks += '<li >'+"transition with product post-place: "+selectedModelNodes[selectedModelEdges[i][1]][1]+'</li>';
													nbS2+=1;
												}
												else{
													txtListLinks += '<li >'+"place linked to metabolic network: "+jsonObj1[selectedModelEdges[i][1]][2]+'</li>';
													nbS2+=1;
												}
										}
										if (selectedModelEdges[i][1]==tpId){
												// if selectedModelEdges[i][2]=0 then reactant , if 2 then modifier, if 1 then product
												if(selectedModelEdges[i][2]==0){
													txtListLinks += '<li >'+"as consumed pre-place in transition: "+selectedModelNodes[selectedModelEdges[i][0]][1]+'</li>';
													nbS2+=1;
												}
												else if (selectedModelEdges[i][2]==1){
													txtListLinks += '<li >'+"as non-consumed pre-place in transition: "+selectedModelNodes[selectedModelEdges[i][0]][1]+'</li>';
													nbS2+=1;
												}
												else if (selectedModelEdges[i][2]==2){
													txtListLinks += '<li >'+"as post-place in transition: "+selectedModelNodes[selectedModelEdges[i][0]][1]+'</li>';
													nbS2+=1;
												}
												else{
													txtListLinks += '<li >'+"as anomaly: "+selectedModelEdges[i]+'</li>';
													nbS2+=1;
												}
										}
									}
									txtListLinks += '</ul>';
									//console.log(txtListLinks);
									listLinksContent.innerHTML =txtListLinks;
								}
								
							}
							
							var nbS=0
							var txtListLinks2 = '<ul style="margin-left:0em;padding-left:1.3em;height:150px;">';
							var identifier=typesMap[closestType][closestid]
							
							//console.log(selectedModelEdges[iv-extraLinesCnt][1]);
							
							
							/*if (selectedModelNodesPaths.indexOf(identifier-jsonObj1.length)!=-1){
								selectedModelNodesPaths.splice(selectedModelNodesPaths.indexOf(identifier-jsonObj1.length),1)
								for (var i=0; i<selectedModelEdges.length;i++){
									if (selectedModelEdges[i][0]==identifier-jsonObj1.length){
										selectedModelLinesPaths.splice(selectedModelLinesPaths.indexOf(i),1)
									}
									if (selectedModelEdges[i][1]==identifier-jsonObj1.length){
										selectedModelLinesPaths.splice(selectedModelLinesPaths.indexOf(i),1)
									}
								}
							} else{
								selectedModelNodesPaths.push(identifier-jsonObj1.length)
								for (var i=0; i<selectedModelEdges.length;i++){
									if (selectedModelEdges[i][0]==identifier-jsonObj1.length){
										selectedModelLinesPaths.push(i)
										txtListLinks += '<li >'+selectedModelNodes[selectedModelEdges[i][1]][1]+'</li>';
										nbS+=1;
									}
									if (selectedModelEdges[i][1]==identifier){
										selectedModelLinesPaths.push(i)
										txtListLinks += '<li >'+selectedModelNodes[selectedModelEdges[i][1]][1]+'</li>';
										nbS+=1;
									}
								}
					
							}*/
							
							if (selectedNodesPaths.indexOf(identifier)!=-1){
								selectedNodesPaths.splice(selectedNodesPaths.indexOf(identifier),1)
								for (var i=0; i<jsonObj2.length;i++){
									if (jsonObj2[i][0]==identifier){
										selectedLinesPaths.splice(selectedLinesPaths.indexOf(i),1)
									}
									if (jsonObj2[i][1]==identifier){
										selectedLinesPaths.splice(selectedLinesPaths.indexOf(i),1)
									}
								}
							} else{
								selectedNodesPaths.push(identifier)
								for (var i=0; i<jsonObj2.length;i++){
									if (jsonObj2[i][0]==identifier){
										selectedLinesPaths.push(i)
										txtListLinks2 += '<li >'+jsonObj1[jsonObj2[i][1]][2]+'</li>';
										nbS+=1;
									}
									if (jsonObj2[i][1]==identifier){
										selectedLinesPaths.push(i)
										txtListLinks2 += '<li >'+jsonObj1[jsonObj2[i][0]][2]+'</li>';
										nbS+=1;
									}
								}
					
							}
							for (var i=0; i<selectedLinesPathsIds.length;i++){
								scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] -=50000;
							}
							selectedLinesPathsIds=[]
							for (var i=0; i<selectedLinesPaths.length;i++){
								for (var j=0;j<linesMap[selectedLinesPaths[i]].length;j+=1){
									selectedLinesPathsIds.push(linesMap[selectedLinesPaths[i]][j])
								}
							}
							selectedLinesPathsIds = unique(selectedLinesPathsIds)
							for (var i=0;i<selectedLinesPathsIds.length;i+=1){
								scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] +=50000;
							}
							scene.children[7].geometry.attributes.position.needsUpdate = true;
							txtListLinks2 += '</ul>';
							//
							if (nbS==0 && nbS2==0){
								listLinks.style.top = 2000 + 'px';
								listLinks.style.left = 2000 + 'px';
							}else{
								if (nbS!=0){
									listLinksContent.innerHTML =txtListLinks2;
								}
								
								//listLinksContent.width=$("#container").width;
								//listLinksContent.height=$("#container").height+positionContainer.top;
								//listLinks.width=$("#container").width;
								//listLinks.height=$("#container").height+positionContainer.top;
								//listLinks.style.width=$("#container").width;
								//listLinks.style.height=$("#container").style.height;
								listLinks.style.overflow="auto";
								listLinks.style.top = (listGenes.clientHeight+contYPos-halfHeight)+40 + 'px';
								listLinks.style.left = 20 + 'px';
							}
							//console.log(selectedLinesPathsIds)
						}
						else if (isOnLine==1 && isOnParticle==0 && stopThreeJsMouseEvent==false){
							parameters.name="line";
							closestType=hoveredType;
							closestid =closestLine;
							parameters.size=0;
							
							colorParticleGui.r=scene.children[closestType].geometry.attributes.ca.array[closestid*3+0];
							colorParticleGui.g=scene.children[closestType].geometry.attributes.ca.array[closestid*3+1];
							colorParticleGui.b=scene.children[closestType].geometry.attributes.ca.array[closestid*3+2];
							parameters.color='#' +('000000'+colorParticleGui.getHex().toString(16)).slice(-6);
							
						}
						else{
							var onDraggableNb = 0;
							for (var ni=0;ni<nbCompartments;ni++){
								if (onCompartments[ni]==true){
									draggingCompartments[ni]=true;
									onDraggableNb+=1;
									controls.noRotate=true;
									// change mouse cursor shape 
									
									
								}
								
							}
							//if(onDraggableNb>1){
							//	container.style.cursor = 'pointer';
							//}
							//else{
							//	container.style.cursor = 'auto';
							//}
							//if(onDraggableNb>1){
							//			container.style.cursor = 'pointer';
							//		}
							//if(onDraggableNb>0){
							//container.style.cursor = 'pointer';
								//container.style.cursor = 'auto';
							//	controls.noRotate=true;
							//	if(onDraggableNb>1){
							//		container.style.cursor = 'pointer';
							//	}
							//	else{container.style.cursor = 'auto';}
							//}
							//else{
							//container.style.cursor = 'auto';
							//}
						}
							//parameters.name="";
						break;
					case 1: // middle
						break;
					case 2: // right
						break;
				}
				
					
				

				
			}
		function onDocumentMouseUp( event ) {
			switch ( event.button ) {
			
				case 0:
						//mpressed=false;
					//if	((isOnParticle==1) && (hoveredType>=0) && (stopThreeJsMouseEvent==false) ){
						//stopThreeJsMouseEvent=false;
						var dragged=-1;
						
						for (var ni=0;ni<nbCompartments;ni++){
							if (draggingCompartments[ni]==true){
								dragged=ni;
								
							}
						}
						if (dragged!=-1){
							
							for (var ni=0;ni<nbCompartments;ni++){
								if (onCompartments[ni]==true){
									tmp1=[]
									for (var d=0;d<allDragged.length;d++){
										if (d==dragged && allDragged[d].length>0){
											for (var di=0;di<allDragged[d].length;di++){allDragged[ni].push(allDragged[d][di]);tmp1.push(allDragged[d][di])}
											
											allDragged[d]=[];
											
										}
									}
									allDragged[ni].push(dragged);
									console.log("dragging "+ dragged+" to "+ni);										
									// code to merge compartments...
									var answer = confirm ("Proceed with merging compartments?")
									if (answer){
										//alert ("Merged")
										//console.log(nbOrganelles)
										//for (var i=0;i<nbOrganelles;i++){
										//txtComp[dragged].style.top = 2000 + 'px';
										//txtComp[dragged].style.left = 2000 + 'px';
										
										//console.log(allDragged)
										//console.log("view2");
										var error=false;
										for (var c=0;c<7;c++){
												
												for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
													if (dragged<nbOrganelles && ni<nbOrganelles){
															if (scene.children[c].geometry.attributes.compartment.array[h]==dragged){
																scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*ni)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*ni)*scaleExplosion;
															}
															else if (allDragged[ni].indexOf(scene.children[c].geometry.attributes.compartment.array[h])>-1 && tmp1.indexOf(scene.children[c].geometry.attributes.compartment.array[h])>-1){
																//var mflag=false;
																//for (var d=0;d<allDragged.length;d++){
																//	if allDragged[ni].indexOf(d)
																//}
															//console.log(g) &&(allDragged[ni][allDragged[ni].length-1]==g)
																scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*ni)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*ni)*scaleExplosion;
															}
															
														
													}
													else if (dragged<nbOrganelles && ni==nbOrganelles){
														//for (var g=0;g<nbOrganelles;g++){
															if (scene.children[c].geometry.attributes.compartment.array[h]==dragged){
															//console.log(g)
																scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+1]=1000;
															}
															else if (allDragged[ni].indexOf(scene.children[c].geometry.attributes.compartment.array[h])>-1 && tmp1.indexOf(scene.children[c].geometry.attributes.compartment.array[h])>-1){							
																scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+1]=1000;
															}
														//}
													}
													else if (dragged<nbOrganelles && ni==nbOrganelles+1){
														//for (var g=0;g<nbOrganelles;g++){
															if (scene.children[c].geometry.attributes.compartment.array[h]==dragged){
															//console.log(g)
																scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+1]=-1000;
															}
															else if (allDragged[ni].indexOf(scene.children[c].geometry.attributes.compartment.array[h])>-1 && tmp1.indexOf(scene.children[c].geometry.attributes.compartment.array[h])>-1){							
																scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+1]=-1000;
															}
														//}
													}
													else if (dragged<nbOrganelles && ni==nbOrganelles+2){
														//for (var g=0;g<nbOrganelles;g++){
															if (scene.children[c].geometry.attributes.compartment.array[h]==dragged){
															//console.log(g)
																scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+1]=-3000;
															}
															else if (allDragged[ni].indexOf(scene.children[c].geometry.attributes.compartment.array[h])>-1 && tmp1.indexOf(scene.children[c].geometry.attributes.compartment.array[h])>-1){							
																scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+1]=-3000;
															}
														//}
													}
													else{
														error=true;
													}
													/*if (dragged==nbOrganelles){
														if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles){
																scene.children[c].geometry.attributes.position.array[h*3+1]=1000;
																//scene.children[c].geometry.attributes.position.array[h*3+0]=scene.children[c].geometry.attributes.position.array[h*3+0]*2;
																//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
																//scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*2000;
														}
													}
													if (dragged==nbOrganelles+1){
														if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles+1){
															scene.children[c].geometry.attributes.position.array[h*3+1]=-1000;
															//scene.children[c].geometry.attributes.position.array[h*3+0]+=2000;
															//scene.children[c].geometry.attributes.position.array[h*3+2]*=6;
																//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
																//scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*2000;
														}
													}
													if (dragged==nbOrganelles+2){
														if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles+2){
															scene.children[c].geometry.attributes.position.array[h*3+1]=-3000;
															//scene.children[c].geometry.attributes.position.array[h*3+0]-=2000;
															//scene.children[c].geometry.attributes.position.array[h*3+2]*=9;
																//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
																//scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*2000;
														}
													}*/
													
													//b2compartments[ (i * 2)+0 ] = b1values_compartment[ i  ];
													//b2compartments[ (i * 2)+1 ] = b1values_compartment[ i+1  ];
													
												}
											
											
											scene.children[c].geometry.attributes.position.needsUpdate = true;
										}
										if (error){
											alert("You can only merge an organelle with the nucleus,\n the cytoplasm, the extracelluar matrix or another organelle.")
										}
										else{
										if (dragged<nbOrganelles){
											organelles[dragged].position.set( -500000, 500000, -500000 );
										}
										if(dragged==nbOrganelles){
											nucleus.position.set( -500000, 500000, -500000 );
										}
										if(dragged==nbOrganelles+1){
											cytoplasm.position.set( -500000, 500000, -500000 );
										}
										if(dragged==nbOrganelles+2){
											ECM.position.set( -500000, 500000, -500000 );
										}
										var iv=0;
										if (dragged<nbOrganelles){
										for ( var i = 0; i < segments; i ++ ) {
											var t1 = jsonObj1[jsonObj2[i][0]][6]
											var t2 = jsonObj1[jsonObj2[i][1]][6]
											//console.log(t1)
											//console.log(t2)
											//var ivList=[]
											var doIt=0
											if (t1==2){
												//console.log(idMap[jsonObj2[i][0]][1])
												//console.log(idMap[jsonObj2[i][0]])
												scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
												scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;					
												scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
												
												iv++;
												
											}
											else if (t1==4){
											//console.log(idMap[jsonObj2[i][0]])
												//console.log(idMap[jsonObj2[i][0]][1])
												scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
												scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
												scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
												iv++;
											}
											if (t2 ==2){
											//console.log(idMap[jsonObj2[i][1]])
												scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
												scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;						
												scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;	
												iv++;
											}
											else if (t2 ==4){
											//console.log(idMap[jsonObj2[i][1]])
												scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
												scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
												scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;				
												iv++;
											}
											
										}
										
										scene.children[7].geometry.attributes.position.needsUpdate = true;
										
										selectedLinesPathsIds=[]
										for (var i=0; i<selectedLinesPaths.length;i++){
											for (var j=0;j<linesMap[selectedLinesPaths[i]].length;j+=1){
												selectedLinesPathsIds.push(linesMap[selectedLinesPaths[i]][j])
											}
										}
										selectedLinesPathsIds = unique(selectedLinesPathsIds)
										for (var i=0;i<selectedLinesPathsIds.length;i+=1){
											scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] +=50000;
										}
										scene.children[7].geometry.attributes.position.needsUpdate = true;
											
										var ii=0;
										for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
										
											scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
											scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
											scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
											ii++;
										}
										//console.log(tokenAttributes.endPosition.value[0]);
										var ii=0;
										for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
											tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
											tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
											tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
											ii++;
										}
										//console.log(tokenAttributes.endPosition.value[0]);
										scene.children[8].geometry.verticesNeedUpdate = true;
										tokenAttributes.endPosition.needsUpdate = true;
										//tokenUniforms.mixAmount.value = 0.0;
										var ii=0;
										for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
											tokenAttributes.mixAmount.value[ii] = 0.0;
											ii++;
										}
										tokenAttributes.mixAmount.needsUpdate = true;
										}
										}
										}
									//else
									//	alert ("Merge cancelled")
									for (var ni1=0;ni1<nbCompartments;ni1++){
										draggingCompartments[ni1]=false;
									}
						
								}
							}
						}
						//controls.enabled=true;
						controls.noRotate=false;
						
						
						
						//console.log(controls)
					//}
					break;
				case 1: // middle
					break;
				case 2: // right
					break;
			}
		}
		//function onMouseMove( e ) {

		//		mouse.x = e.clientX;
		//		mouse.y = e.clientY;

		//	}
		function animate() {

			requestAnimationFrame( animate );

			render();
			
			
			
			stats.update();

		}
		
		function toXYCoords (pos) {
			var vector = projector.projectVector(pos.clone(), camera);
			vector.x = (vector.x + 1)/2 * window.innerWidth;
			vector.y = -(vector.y - 1)/2 * window.innerHeight;
			return vector;
		}

		function render() {
			//var delta = clock.getDelta(); 
			//animatorT1.update(1500 * delta);
			
			//cssScene2.children[0].direction=camera.direction;
			//element1.position.x = camera.position.x;
			//element1.position.y = camera.position.y;
			//element1.position.z = camera.position.z;
			controls.update();
			keyboard.update();
			
			
			if ( keyboard.pressed("A") ) {
			
				controls.panLeft(5* controls.zoomScale());
			}
			if ( keyboard.pressed("D") ) {
				controls.panLeft(-5* controls.zoomScale());
			}
				
			if ( keyboard.pressed("W") ) {
				controls.panUp(5* controls.zoomScale());
			}
				
			if ( keyboard.pressed("S") ){
				controls.panUp(-5* controls.zoomScale());
			} 
			
			if ( keyboard.pressed("X") ) {
				controls.dollyIn();
			}
				
			if ( keyboard.pressed("Z") ){
				//controls.pan(-5* controls.zoomScale(),0);
				controls.dollyOut();
			} 
			if ( keyboard.down("1") ){
				if (linesShaderMaterial.depthTest){
					linesShaderMaterial.depthTest = false;
				}
				else{
					linesShaderMaterial.depthTest = true;
				}
			} 
			if ( keyboard.down("2") ){
				if (linesShaderMaterial.blending){
					linesShaderMaterial.blending = false;
				}
				else{
					linesShaderMaterial.blending = THREE.AdditiveBlending;
				}
			} 
			if ( keyboard.down("3") ){
				if (linesShaderMaterial.transparent){
					linesShaderMaterial.transparent = false;
				}
				else{
					linesShaderMaterial.transparent = true;
				}
			} 
			if ( keyboard.down("]") ){
				for (var i=0;i<segmentPts;i++){
				//for (var i=0;i<b2lopacity.length;i++){
					if (b2lopacity[i]<1.0){
					b2lopacity[i]+=0.05;
					}
				}
				scene.children[7].geometry.attributes.op.needsUpdate = true;
				//if (linesUniforms.opacity.value<1.0){
				//	linesUniforms.opacity.value+=0.05;
				//}
				//console.log("opacity: "+linesUniforms.opacity.value);
				//consol.log("+")
					//linesShaderMaterial.transparent = false;
					//linesShaderMaterial.linesUniforms.attributes.opacity+=0.1;
				//linesUniforms.opacity.value=1.0;
				//linesUniforms.opacity.value+=0.05;
				//linesUniforms.color.value.offsetHSL( 0.0005, 0, 0 );
				//linesUniforms.amplitude.value+=0.1;
			} 
			if ( keyboard.down("[")){//linesShaderMaterial.opacity-=0.1;
				//if (linesUniforms.opacity.value>0.0){
				//	linesUniforms.opacity.value-=0.05;
				//}
				for (var i=0;i<segmentPts;i++){
				//for (var i=0;i<b2lopacity.length;i++){
					if (b2lopacity[i]>0.0){
					b2lopacity[i]-=0.05;
					}
				}
				scene.children[7].geometry.attributes.op.needsUpdate = true;
				//console.log("opacity: "+linesUniforms.opacity.value);
					//linesUniforms.opacity.value-=0.05;
					//linesUniforms.color.value.offsetHSL( -0.0005, 0, 0 );
					//linesUniforms.amplitude.value-=0.1;
			} 
				
			
				
			if (updatedListModels==true){
				console.log("changing models from updated listmodels");
				// update list of all models
				simpleListModels=["none"];
				for (var i =0;i< listModels.length;i++){
					simpleListModels.push(listModels[i][0]);
				}
				
				var listBoxModels=document.getElementById("listModels");
				var stringlist="";
				for (var i =0;i< simpleListModels.length;i++){
					stringlist+='<option value="'+simpleListModels[i]+'">'+simpleListModels[i]+'</option>';	
				}
				listBoxModels.innerHTML = stringlist;	
				// file list of metabolic files
				listMetabolicFiles = [];
				for (var i =0;i< listModels.length;i++){
					if (listMetabolicFiles.indexOf(listModels[i][4])<0){
						listMetabolicFiles.push(listModels[i][4]);
					}
				}
				
				//var listBoxMetabolic=document.getElementById("listMetabolic");
				//var stringlist="";
				//for (var i =0;i< listMetabolicFiles.length;i++){
				//	stringlist+='<option value="'+listMetabolicFiles[i]+'">'+listMetabolicFiles[i]+'</option>';	
				//}
				//listBoxMetabolic.innerHTML = stringlist;
				
				
				updatedListModels=false;
			}
			//
			if (updatedModel==true){
				resetSpreadsheet=true;
				//for (var i =0;i<spritesSelected.length;i++){		
				//		spritesSelected[i].position.set(-50000,-10000,50000);
				//	}
				//localStorage.selection=="";
				//mselectedList=[];
					//console.log("empty")
					
				
			
				//localStorage.selection=="";
				//mselectedList=[];
				//for (var i =0;i<spritesSelected.length;i++){		
				//	spritesSelected[i].position.set(-50000,-10000,10000);
				//	spritesSelected[i].scale.set(100, 100, 100);
				//}
				var fValue = document.getElementById("listModels").value;
			    var iv=0;
				if (fValue!="none"){
					
					
					// erase stuff first
					var lll=bgeometryP3.attributes.position.array.length;
					for (var ml =0;ml<lll;ml+=3){
						bgeometryP3.attributes.position.array[ml]+=50000;
					}
					var lll=bgeometryP5.attributes.position.array.length;
					for (var ml =0;ml<lll;ml+=3){
						bgeometryP5.attributes.position.array[ml]+=50000;
					}
					// erase lines 
					var iv=0;
					for ( var i = 0; i < segments; i ++ ) {
						var t1 = jsonObj1[jsonObj2[i][0]][6]
						var t2 = jsonObj1[jsonObj2[i][1]][6]
						//console.log(t1)
						//console.log(t2)
						//var ivList=[]
						var doIt=0
						if (t1==2){
							//console.log(idMap[jsonObj2[i][0]][1])
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] +=50000.0;
							
							iv++;
						}
						else if (t1==4){
							//console.log(idMap[jsonObj2[i][0]][1])
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] =50000.0;
							iv++;
						}
						if (t2 ==2){
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ]=50000.0;
							iv++;
						}
						else if (t2 ==4){
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] =50000.0;			
							iv++;
						}
						
					}
					for ( var i = segments; i < segments+5000; i ++ ) {
							//b2lpositions[ (iv * 3)+0 ] = 0;
							//b2lpositions[ (iv * 3) + 1 ] = 80;
							b2lpositions[ (iv * 3) + 2 ] = 50000;
							iv++;
					}
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					bgeometry2.attributes.position.needsUpdate = true;
					
					var ii=0;
					for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					
						//scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
						//scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
						scene.children[8].geometry.vertices[ii].z=50000;
						ii++;
					}
					//console.log(tokenAttributes.endPosition.value[0]);
					var ii=0;
					for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
						//tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
						//tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
						tokenAttributes.endPosition.value[ii].z=50000;
						ii++;
					}
					//console.log(tokenAttributes.endPosition.value[0]);
					scene.children[8].geometry.verticesNeedUpdate = true;
					tokenAttributes.endPosition.needsUpdate = true;
					//tokenUniforms.mixAmount.value = 0.0;
					var ii=0;
					for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
						tokenAttributes.mixAmount.value[ii] = 0.0;
						ii++;
					}
					tokenAttributes.mixAmount.needsUpdate = true;
					// erase tokens
					
					
					//var lll=bgeometry2.attributes.position.array.length;
					//for (var ml =0;ml<lll;ml+=3){
					//	bgeometry2.attributes.position.array[ml]+=50000;
					//}
					
					//var lll=bgeometry2.attributes.position.array.length;
					//for (var ml =0;ml<lll;ml+=3){
					//	bgeometry2.attributes.position.array[ml]+=50000;
					//}
					
					//for ( var iv = extraLinesCnt; iv <extraLinesCnt+2000; iv +=2) {
					//		scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+50000;	
					//		scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+50000;	
					//}
					
				
					xhttp.open("GET","sbml/"+selectedModel[0][4]+"_metabolic_net.json",false);
					xhttp.send();
					selectedMetabolicData = JSON.parse(xhttp.responseText);
					console.log("getting metabolic data from new metabolic file");
					//console.log(selectedMetabolicData);
					//console.log(selectedModel[0]);
					metabolicCompartments = selectedMetabolicData[0];
					
					oldNbOrganelles=nbOrganelles;
					oldNbCompartments=nbCompartments;
					
					nbCompartments=metabolicCompartments.length
					
					nbOrganelles=nbCompartments-3;
					if (selectedModel[0][0]=="Ecoli2.0"){
						mapComp = {'-1':-1, Extra_organism:0 ,Periplasm:1 ,Cytosol:2}
						nameComp = ["Extra_organism","Periplasm","Cytosol" ];	
						element1.src	= "slickgrid132E.html"	
					}
					
					else if (selectedModel[0][0]=="HepatocyteQSSPN"){
						mapComp = {'-1':-1, GolErMi:0 ,bile:1 ,lyso:2 ,mito:3 ,peroxy:4 ,nuc:5 ,cyto:6 ,ext:7 }
						nameComp = ["GolErMi","bile","lysosome","mytochodria","peroxisome", "nucleus", "cytoplasm" ,"extra-cellular" ];	
						element1.src	= "slickgrid13HP.html"	
					}
					else{
						mapComp = {'-1':-1, g:0 ,r:1 ,l:2 ,m:3 ,x:4 ,n:5 ,c:6 ,e:7 }
						nameComp = ["golgi","ER","lysosome","mytochodria","peroxisome", "nucleus", "cytoplasm" ,"extra-cellular" ];		
						element1.src	= "slickgrid131.html"						
					}
					clearedTokenIndex=[];
					stackTokenModel=[];
					tokenStackCount=0;
					simTimer=0;
					simulationIsOn=false;
					simulationIsPaused==false;
					sliderElement.value=simTimer;
					timerElement.innerHTML="0";
					
					metabolicNodes = selectedMetabolicData[1];
					metabolicEdges = selectedMetabolicData[2];
					jsonObj1=metabolicNodes
					jsonObj2=metabolicEdges
					mnbDNA=0;
					mnbRNA=0;
					mnbProt=0;
					mnbDegProd=0;
					mnbPN=0;
					mnbLog=0;
					mnbCoarse=0;
					for (var i = 0, ii= jsonObj1.length;i<ii;i++){
						if (jsonObj1[i][6]==0){
							mnbDNA++;
						}
						if (jsonObj1[i][6]==1){
							mnbRNA++;
						}
						if (jsonObj1[i][6]==2){
							mnbProt++;
						}
						if (jsonObj1[i][6]==3){
							mnbDegProd++;
						}
						if (jsonObj1[i][6]==4){
							mnbPN++;
						}
						if (jsonObj1[i][6]==5){
							mnbLog++;
						}
						if (jsonObj1[i][6]==6){
							mnbCoarse++;
						}
					}
					nbDNAParticles=mnbDNA; // nb of DNA elements
					nbRNAParticles=mnbRNA; // nb of RNA elements
					nbProtParticles=mnbProt+10000; // nb of proteins
					nbDegradParticles=mnbDegProd; // nb of degradation products
					nbPNParticles=mnbPN+10000; // nb of PN standard places
					nbLogParticles=mnbLog; // nb of logical PN places
					nbCoarseParticles=mnbCoarse; // nb of PN coarse transitions
			
					idMap=[];
					typesMap=[];
					for (var im=0;im<7;im++){
						typesMap[im]=[];
					};
					reactionMap=[];
			
					segments =jsonObj2.length;
					//var segments =0;
					segmentPts =segments*2;
					
					
					
					/////////////////////////////////////////////
					// defines first buffergeometry for protein particles
					
					
					
					
					
					bgeometryP3.attributes.size.needsUpdate = true;
					bgeometryP3.attributes.position.needsUpdate = true;
					bgeometryP3.attributes.ca.needsUpdate = true;
					bgeometryP3.attributes.compartment.needsUpdate = true;

					//b3values_size = bgeometryP3.attributes.size.array;
					//b3positions = bgeometryP3.attributes.position.array;
					//b3values_color = bgeometryP3.attributes.ca.array;
					//b3values_compartment = bgeometryP3.attributes.compartment.array;
					
					
					
					// populates first buffer geometry for particles with coordinates, colors, and size
					var color = new THREE.Color( 0xff9900 );;
					var color2 = new THREE.Color( 0x55ff55 );
					var radius =400;
					var bv=0;
					//for( var bv = 0; bv < nbProtParticles; bv++ ) {
						for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
							if (jsonObj1[bw][6]==2){
								b3values_size[ bv ] = 10;
								//b3values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
								b3values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
								idMap[bw]=[2,bv];
								typesMap[2][bv]=bw;
								
								var rm;
								var rr;
								
								if (selectedModel[0][0]=="HepatocyteQSSPN"){
									rm=bv*0.078*2*Math.PI;
									rr = ((bv*0.02)+0.35*radius)
									b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
									b3positions[ bv * 3 + 1 ] = 0+(bv*0.05);
								}
								else if (selectedModel[0][0]=="Ecoli2.0"){
									rm=bv*0.004*2*Math.PI;
									rr = ((radius*1.08)-(bv*0.03)+1)
									b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
									b3positions[ bv * 3 + 1 ] = 0-(bv*0.03);

								}
								else{
									rm=bv*0.008*2*Math.PI;
									rr = ((bv*0.02)+0.05*radius);
									b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
									b3positions[ bv * 3 + 1 ] = 0+(bv*0.02);
								}
								
								b3positions[ bv * 3 + 2 ] = Math.sin(rm) *rr;
								
								b3values_color[ bv * 3 + 0 ] = color.r;
								b3values_color[ bv * 3 + 1 ] = color.g;
								b3values_color[ bv * 3 + 2 ] = color.b;
								bv++;
							}
						}
						startModelPlaces=bv;
						for( var bw = jsonObj1.length , bww= jsonObj1.length+10000; bw < bww; bw++ ) {
								
				
							//if (jsonObj1[bw][6]==2){
								b3values_size[ bv ] = 30;
								//b3values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
								b3values_compartment[ bv ] = -1;
								//idMap[bw]=[2,bv];
								//typesMap[2][bv]=bw;
								idMap[bw]=[2,bv];
								typesMap[2][bv]=bw;
								//var rm=(bw-jsonObj1.length)*0.078*2*Math.PI;
								//var	rr = (((bw-jsonObj1.length)*0.02)+0.95*radius)
								//radius=900;
								var rm=(bw-jsonObj1.length)*0.008*2*Math.PI;
								var rr = ((radius*1.08)-((bw-jsonObj1.length)*0.3)+1)
								b3positions[ bv * 3 + 0 ] = (Math.cos(rm) *rr)+900;
								//b3positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius+900;
								//b3positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
								b3positions[ bv * 3 + 1 ] = 80;
								b3positions[ bv * 3 + 2 ] = ((Math.random() * 2 - 1) * radius)+50000;
								//b3positions[ bv * 3 + 2 ] = (Math.sin(rm) *rr)+50000;
								
								//if ( positions[ bv * 3 + 0 ] < 0 )
								//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
								//else
								//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
								b3values_color[ bv * 3 + 0 ] = color2.r;
								b3values_color[ bv * 3 + 1 ] = color2.g;
								b3values_color[ bv * 3 + 2 ] = color2.b;
								bv++;
							//}
						}
						endModelPlaces=bv;
					//}
				
				
					// associate first particle system with bufferGeometry
					//PointCloud3 = new THREE.PointCloud( bgeometryP3, particle3ShaderMaterial );

					PointCloud3.dynamic = true;
					PointCloud3.sortParticles = true;
					PointCloud3.geometry.__dirtyVertices = true;
					
					
					
					
					bgeometryP5.attributes.size.needsUpdate = true;
					bgeometryP5.attributes.position.needsUpdate = true;
					bgeometryP5.attributes.ca.needsUpdate = true;
					bgeometryP5.attributes.compartment.needsUpdate = true;

					//b5values_size = bgeometryP5.attributes.size.array;
					//b5positions = bgeometryP5.attributes.position.array;
					//b5values_color = bgeometryP5.attributes.ca.array;
					//b5values_compartment = bgeometryP5.attributes.compartment.array;
					
					// populates first buffer geometry for particles with coordinates, colors, and size
					var color = new THREE.Color( 0xffffff );
					
					var color2 = new THREE.Color( 0x55ffff );
					var radius =400;
					var bv=0;
					//for( var bv = 0; bv < nbPNParticles; bv++ ) {
					/*subSystems=[];
					for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
						if (jsonObj1[bw][6]==4){
							if (jsonObj1[bw][4][1] && jsonObj1[bw][4][1][0]){
								if (subSystems.indexOf(jsonObj1[bw][4][1][0])== -1){
									subSystems.push(jsonObj1[bw][4][1][0]);
								}
							}
						}
					}*/
					//console.log(subSystems);
					// now allocate a nb of nodes by sub systems
					subSystems={};
					totalSubSystems=0;
					
					totalNbreactions=0;
					for( var bs = 0 , bww= jsonObj1.length; bs < bww; bs++ ) {
						if (jsonObj1[bs][6]==4){
							if (jsonObj1[bs][4][1] && jsonObj1[bs][4][1][0]){
								if (subSystems[jsonObj1[bs][4][1][0]]=== undefined){
									subSystems[jsonObj1[bs][4][1][0]]=1;
									totalSubSystems++;
								}
								else{
									subSystems[jsonObj1[bs][4][1][0]]++;
									totalSubSystems++;
								}
								
							}
							totalNbreactions++;
						}
					}
					totalOutsideSubSystems=totalNbreactions-totalSubSystems;
					nbSubSystems=Object.keys(subSystems).length
					if (totalOutsideSubSystems>0){
						nbAreas=nbSubSystems+1;
						subSystems["Not present"]=totalOutsideSubSystems;
					}
					else{
						nbAreas=nbSubSystems;
					}
					console.log(subSystems);
					
					//console.log(totalSubSystems);
					//console.log(totalNbreactions);
					//console.log(totalOutsideSubSystems);
					//console.log(nbSubSystems);
					
					// if there is no subsystem identified just use standard spiral layout
					
					// if there are n subsystems then display circular region of width proportional to the nb of nodes in each subsystem
					// first make a list of widths
					// total nb of reactions will dictate the overall nb of points that must be displayed on the ring.
					// depth of the ring is 30 points. there are for 0.004 *2Pi=1.44 degrees = 250 graduations on a circle 
					var listWidthSubSystems={};
					var nbCircleGraduations=250;
					var minCircleFraction=1/nbCircleGraduations;
					var nbNodesDepth=40;
					var totalWidth=0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							var width= Math.ceil(subSystems[key]/nbNodesDepth);
							listWidthSubSystems[key]=[subSystems[key]/*nb of nodes*/,width,/*counter value*/0];
							totalWidth+=width;
						}
					}
					nbNodesDepth=Math.ceil((40*totalWidth)/244);
					listWidthSubSystems={};
					var totalWidth=0;
					var cumulativeWidth=0;
					var colorswap=1.0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							var width= Math.ceil(subSystems[key]/nbNodesDepth);
							listWidthSubSystems[key]=[subSystems[key]/*nb of nodes*/,width,cumulativeWidth,/*counter value*/0,colorswap];
							totalWidth+=width;
							cumulativeWidth+=width;
							if (colorswap==1.0){
							colorswap=0.7;
							}
							else{colorswap=1.0}
						}
					}
					
					//console.log(totalWidth);
					//console.log(listWidthSubSystems);
					/*for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							var percentage= subSystems[key]/totalNbreactions;
							if (percentage < minCircleFraction){
								percentage= minCircleFraction;
								
							}
							subSystems[key]=percentage;
							totalPercentage+=percentage;
							
							//console.log(percentage);
						}
					}
					console.log(totalPercentage);
					var toDistribute=0;
					if (totalPercentage>1){
						toDistribute= totalPercentage-1;
					}
					var nbReducable=0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							if((subSystems[key]*(1-toDistribute))>minCircleFraction){
								nbReducable++;
							}
						}
					}
					console.log(nbReducable);
					var sums=0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							if((subSystems[key]*(1-toDistribute))>minCircleFraction){
								var res=subSystems[key]*(1-(toDistribute));
								subSystems[key]=res;
								
							}
							sums+=subSystems[key];
							
							//toDistribute/nbReducable
						}
					}
					console.log(subSystems+" total: "+sums);*/
					//var cnt1=0
					//var cnt2=0;
					var localRSeparator=0;
					for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
						
						if (jsonObj1[bw][6]==4){

							b5values_size[ bv ] = 10;
							//b5values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
							
							// try to assign the compartment of the majority of the products the reaction is linked to 
							// if there is no product, assign the compartment of the majority of modifiers
							// if there is no modifier, assign the compartment of the majority of reactants
							var listProducts= jsonObj1[bw][11][0];
							var listModifiers= jsonObj1[bw][11][1];
							var listReactants= jsonObj1[bw][11][2];
							
							if (listProducts.length>0){
								var votes=[];
								for (var ncc=0;ncc<nbCompartments;ncc++){
									votes[ncc]=0;
								}
								for(var lp=0;lp<listProducts.length;lp++){
									if (mapComp[jsonObj1[listProducts[lp]][3]]>=0)
										votes[mapComp[jsonObj1[listProducts[lp]][3]]]++;
								}
								var winner= votes.indexOf(Math.max.apply( Math, votes ));
								b5values_compartment[ bv ] = winner;
								if (winner==-1){
									b5values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
								}
							} 
							else if (listModifiers.length>0){
								var votes=[];
								for (var ncc=0;ncc<nbCompartments;ncc++){
									votes[ncc]=0;
								}
								for(var lp=0;lp<listModifiers.length;lp++){
									if (mapComp[jsonObj1[listModifiers[lp]][3]]>=0)
										votes[mapComp[jsonObj1[listModifiers[lp]][3]]]++;
								}
								var winner= votes.indexOf(Math.max.apply( Math, votes ));
								b5values_compartment[ bv ] = winner;
								if (winner==-1){
									b5values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
								}
							}
							else if (listReactants.length>0){
								var votes=[];
								for (var ncc=0;ncc<nbCompartments;ncc++){
									votes[ncc]=0;
								}
								for(var lp=0;lp<listReactants.length;lp++){
									if (mapComp[jsonObj1[listReactants[lp]][3]]>=0)
										votes[mapComp[jsonObj1[listReactants[lp]][3]]]++;
								}
								var winner= votes.indexOf(Math.max.apply( Math, votes ));
								b5values_compartment[ bv ] = winner;
								if (winner==-1){
									b5values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
								}
							}
							else {
								// if no species linked, put reaction in the center
								b5values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
							}
							
							idMap[bw]=[4,bv];
							typesMap[4][bv]=bw;
							
							var rm;
							var rr; 
							
							
							
							
							if (selectedModel[0][0]=="Ecoli2.0"){
								rm=bv*0.078*2*Math.PI;
								rr = ((bv*0.02)+0.35*radius)
								//b5positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
								b5positions[ bv * 3 + 1 ] = 0+(bv*0.04);
							}
							else{
								//rr= ((radius*1.08)-(0*0.03)+1);
								if (jsonObj1[bw][4][1] && jsonObj1[bw][4][1][0]){
									
									//console.log("increment node")
									//console.log(jsonObj1[bw][4][1][0]);
									if (listWidthSubSystems.hasOwnProperty(jsonObj1[bw][4][1][0])) {
									
										var startingW=listWidthSubSystems[jsonObj1[bw][4][1][0]][2];
										var maxWidth=listWidthSubSystems[jsonObj1[bw][4][1][0]][1];
										var maxDepth=nbNodesDepth;
										var maxNbNodes=listWidthSubSystems[jsonObj1[bw][4][1][0]][0];
										var presentIndex= listWidthSubSystems[jsonObj1[bw][4][1][0]][3];
										if (presentIndex<maxNbNodes){
										//cnt1++;
											var localWPos=0;
											var localRR=0;
											localWPos=Math.floor(presentIndex/maxDepth);
											//if (presentIndex>=maxDepth){
												
												localRR=presentIndex%maxDepth;
											//}
											//else{
											//	localRR=presentIndex;
											//}
											//if(presentIndex==0){
											//	localRSeparator+=(nbCircleGraduations-totalWidth)/(2*nbAreas);//	rm=((startingW+localWPos+localRSeparator)*0.004*(2*Math.PI));
											//console.log(jsonObj1[bw][4][1][0])
											//listWidthSubSystems[jsonObj1[bw][4][1][0]][2]+=((nbCircleGraduations-totalWidth)/(nbAreas));
											//startingW=listWidthSubSystems[jsonObj1[bw][4][1][0]][2];
											//color.r-=0.01
											//}
											rm=((startingW+localRSeparator+localWPos)*0.004*(2*Math.PI));
											
											rr= ((radius-maxDepth*5)+(localRR*5));
											listWidthSubSystems[jsonObj1[bw][4][1][0]][3]++;
											color.r=listWidthSubSystems[jsonObj1[bw][4][1][0]][4];
											if (color.r==1.0){
											color.g=1.0;
											color.b=1.0;
											}
											else{
											color.g=0.4;
											color.b=1.0;
											}
										}
									}
								}
								else{
									
									//subSystems["Not present"]=totalOutsideSubSystems;
									if (listWidthSubSystems.hasOwnProperty("Not present")) {
									
									//console.log("increment not present")
										var startingW=listWidthSubSystems["Not present"][2];
										var maxWidth=listWidthSubSystems["Not present"][1];
										var maxDepth=nbNodesDepth;
										var maxNbNodes=listWidthSubSystems["Not present"][0];
										var presentIndex= listWidthSubSystems["Not present"][3];
										if (presentIndex<maxNbNodes){
										//cnt2++;
											var localWPos=0;
											var localRR=0;
											localWPos=Math.floor(presentIndex/maxDepth);
											//if (presentIndex>=maxDepth){
												
												localRR=presentIndex%maxDepth;
											//}
											//else{
											//	localRR=presentIndex;
											//}
											//if(presentIndex==0){
											//console.log(jsonObj1[bw][4][1][0])
											//listWidthSubSystems["Not present"][2]+=((nbCircleGraduations-totalWidth)/(nbAreas));
											//startingW=listWidthSubSystems["Not present"][2];
											//	localRSeparator+=(nbCircleGraduations-totalWidth)/(2*nbAreas);//	rm=((startingW+localWPos+localRSeparator)*0.004*(2*Math.PI));
											//}
											rm=((startingW+localRSeparator+localWPos)*0.004*(2*Math.PI));
											rr= ((radius-maxDepth*5)+(localRR*5));
											listWidthSubSystems["Not present"][3]++;
											color = new THREE.Color( 0xff0000 );
										}
									}
								}
								//console.log(listWidthSubSystems);
							
								//rm=bv*0.004*2*Math.PI;
								//rr= ((radius*1.08)-(bv*0.03)+1);
								
								//b5positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
								//b5positions[ bv * 3 + 1 ] = 0-(bv*0.03);
								b5positions[ bv * 3 + 1 ] = 0-(0*0.03);
								//console.log(jsonObj1[bw][4][1][0])
							}
							b5positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							b5positions[ bv * 3 + 2 ] = Math.sin(rm) *rr;
							
							
							b5values_color[ bv * 3 + 0 ] = color.r;
							b5values_color[ bv * 3 + 1 ] = color.g;
							b5values_color[ bv * 3 + 2 ] = color.b;
							bv++;
						}
					}
					//console.log("increment"+cnt1 + "  " +cnt2)
					startModelReactions=bv;
					for( var bw = jsonObj1.length , bww= jsonObj1.length+10000; bw < bww; bw++ ) {
						
						b5values_size[ bv ] = 30;
						
						b5values_compartment[ bv ] = -1;
						idMap[bw]=[4,bv];
						typesMap[4][bv]=bw;
						
						
						
						//radius=900;
						var rm=(bw-jsonObj1.length)*0.008*2*Math.PI;
						var rr = ((radius*0.78)-((bw-jsonObj1.length)*0.3)+1)
						//b5positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius+900;
						b5positions[ bv * 3 + 0 ] = (Math.cos(rm) *rr)+1800;
						//b5positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
						b5positions[ bv * 3 + 1 ] = 180;
						
						b5positions[ bv * 3 + 2 ] = ((Math.random() * 2 - 1) * radius)+50000;
						
						
						//if ( positions[ bv * 3 + 0 ] < 0 )
						//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
						//else
						//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
						b5values_color[ bv * 3 + 0 ] = color2.r;
						b5values_color[ bv * 3 + 1 ] = color2.g;
						b5values_color[ bv * 3 + 2 ] = color2.b;
						bv++;
					}
					endModelReactions=bv;
					
					// associate first particle system with bufferGeometry
					PointCloud5 = new THREE.PointCloud( bgeometryP5, particle5ShaderMaterial );

					PointCloud5.dynamic = true;
					PointCloud5.sortParticles = true;
					PointCloud5.geometry.__dirtyVertices = true;
				
					//console.log("changing model file representation");
					
					
					
					bgeometry2.attributes.position.needsUpdate = true;
					bgeometry2.attributes.ca.needsUpdate = true;
					bgeometry2.attributes.compartment.needsUpdate = true;

					//b2lpositions = bgeometry2.attributes.position.array;
						//var colors = bgeometry.attributes.color.array;
					//b2lcolors = bgeometry2.attributes.ca.array;
					//b2lcompartments=bgeometry2.attributes.compartment.array;
					
					var r = 800;
					var col = new THREE.Color( 0x00ffff );
					var col2 = new THREE.Color( 0x55ff55 );
					
					var iv=0;
					for ( var i = 0; i < segments; i ++ ) {
						
						var t1 = jsonObj1[jsonObj2[i][0]][6]
						var t2 = jsonObj1[jsonObj2[i][1]][6]
						var ivList=[]
						if (t1==2){
							b2lpositions[ (iv * 3)+0 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
							b2lpositions[ (iv * 3) + 1 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
							b2lpositions[ (iv * 3) + 2 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
							b2lcompartments[ (i*2)+0 ] = b3values_compartment[ (idMap[jsonObj2[i][0]][1]) ];
							b2lcolors[ iv * 3 ] = col.r;
							b2lcolors[ iv * 3 + 1 ] = col.g;
							b2lcolors[ iv * 3 + 2 ] = col.b;
							ivList.push(iv)
							//linesMap[i]=iv
							
							iv++;
						}
						else if (t1==4){
							b2lpositions[ (iv * 3)+0 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
							b2lpositions[ (iv * 3) + 1 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
							b2lpositions[ (iv * 3) + 2 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
							b2lcompartments[ (i*2)+0 ] = b5values_compartment[ (idMap[jsonObj2[i][0]][1]) ];
							b2lcolors[ iv * 3 ] = col.r;
							b2lcolors[ iv * 3 + 1 ] = col.g;
							b2lcolors[ iv * 3 + 2 ] = col.b;
							//linesMap[i]=iv
							ivList.push(iv)
							iv++;
						}
						if (t2 ==2){
							b2lpositions[ (iv * 3)+0 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
							b2lpositions[ (iv * 3) + 1 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
							b2lpositions[ (iv * 3) + 2 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;
							b2lcompartments[ (i*2)+1 ] = b3values_compartment[ (idMap[jsonObj2[i][1]][1]) ];
							b2lcolors[ iv * 3 ] = col.r;
							b2lcolors[ iv * 3 + 1 ] = col.g;
							b2lcolors[ iv * 3 + 2 ] = col.b;
							//linesMap[i]=iv
							ivList.push(iv)
							iv++;
						}
						else if (t2 ==4){
							b2lpositions[ (iv * 3)+0 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
							b2lpositions[ (iv * 3) + 1 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
							b2lpositions[ (iv * 3) + 2 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;
							b2lcompartments[ (i*2)+1 ] = b5values_compartment[ (idMap[jsonObj2[i][1]][1]) ];
							b2lcolors[ iv * 3 ] = col.r;
							b2lcolors[ iv * 3 + 1 ] = col.g;
							b2lcolors[ iv * 3 + 2 ] = col.b;
							//linesMap[i]=iv
							ivList.push(iv)
							iv++;
						}
						linesMap[i]=ivList
					}
					
					var radius=400;
					extraLinesCnt=iv;
					for ( var i = segments; i < segments+5000; i ++ ) {
						
							b2lpositions[ (iv * 3)+0 ] = (Math.random() * 2 - 1) * radius;
							b2lpositions[ (iv * 3) + 1 ] = 80;
							b2lpositions[ (iv * 3) + 2 ] = ((Math.random() * 2 - 1) * radius)+50000;
							b2lcompartments[ (i*2)+0 ] = -1;
							b2lcolors[ iv * 3 ] = col2.r;
							b2lcolors[ iv * 3 + 1 ] = col2.g;
							b2lcolors[ iv * 3 + 2 ] = col2.b;
							ivList.push(iv)
							//linesMap[i]=iv
							
							iv++;
						
						
						
					}
					
					
					
					// do the token thing
					/*var ii=0;
					for ( var i = segmentPts; i <segmentPts+5000 ; i +=2 ) {
					
						scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
						scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
						scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
						ii++;
					}
					//console.log(tokenAttributes.endPosition.value[0]);
					var ii=0;
					for ( var i = segmentPts+1; i <segmentPts+5000 ; i +=2 ) {
						tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
						tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
						tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
						ii++;
					}
					//console.log(tokenAttributes.endPosition.value[0]);
					scene.children[8].geometry.verticesNeedUpdate = true;
					tokenAttributes.endPosition.needsUpdate = true;
					//tokenUniforms.mixAmount.value = 0.0;
					var ii=0;
					for ( var i = 1; i <segmentPts+5000 ; i +=2 ) {
						tokenAttributes.mixAmount.value[ii] = 0.0;
						ii++;
					}
					tokenAttributes.mixAmount.needsUpdate = true;
					*/
					
					//for ( var i = 0; i < segmentPts; i ++ ) {
					//if (i<50)
					//	console.log(i+" -- "+b1values_compartment[i]);
					//}
					
					//bgeometry2.computeBoundingSphere();
				//console.log(bgeometry2);
					//mesh = new THREE.Line( bgeometry2, linesShaderMaterial,THREE.LinePieces );
					
					//var radius = 300;
					//tokenGeometry = new THREE.CubeGeometry( 0.8 * radius, 0.8 * radius, 0.8 * radius, 150, 100, 1 );
					// populate token geometry with "start" extremities of line segmentPts
					//tokenGeometry = new THREE.Geometry();
					
					//for ( var i = 0; i < segmentPts; i +=2 ) {
					//	tokenGeometry.vertices.push(new THREE.Vector3(b2lpositions[ (i * 3) ]+0,b2lpositions[ (i * 3) + 1 ]+0,b2lpositions[ (i * 3) + 2 ]+0));
					//}
					//var v1 = new THREE.Vector3(0,0,0);
					//var v2 = new THREE.Vector3(0,500,0);
					//var v3 = new THREE.Vector3(0,500,500);

					//geom.vertices.push(v1);
					//geom.vertices.push(v2);
					//geom.vertices.push(v3);
					
					//tokenPS = new THREE.PointCloud( tokenGeometry, tokenShaderMaterial );
					//tokenPS.dynamic = true;
					//sphere.sortParticles = true;

					//var tvertices = tokenPS.geometry.vertices;
					//var tvalues_size = tokenAttributes.size.value;
					//var tvalues_color = tokenAttributes.ca.value;
					//var tvalues_p = tokenAttributes.endPosition.value;
					//for( var v = 0, vv= tvertices.length; v < vv; v++ ) {

					//	tvalues_size[ v ] = 5;
					//	tvalues_color[ v ] = new THREE.Color( 0xff0000 );
						//tvalues_p[v]=new THREE.Vector3( 600+(Math.random() * 2 - 1) * radius, (Math.random() * 2 - 1) * radius , (Math.random() * 2 - 1) * radius );	
						//tvalues_p[v]=new THREE.Vector3(b2positions[ (v+1) * 3 ],b2positions[ (v+1) * 3 + 1 ],b2positions[ (v+1) * 3 + 2 ]);
					//}
					//for ( var i = 1; i < segmentPts; i +=2 ) {
					//	tvalues_p.push(new THREE.Vector3(b2lpositions[ i * 3 ],b2lpositions[ i * 3 + 1 ],b2lpositions[ i * 3 + 2 ]));
					//}
					
					
					
					
					// remake organelles containers
					//oldNbOrganelles=nbOrganelles;
					//var	oldNbCompartments=nbCompartments;
					for (var i=0;i<oldNbOrganelles;i++){
					//organelles[i].position.set(-50000, 50000, 0 );
					//if (selectedModel[0][0]=="Ecoli2.0"){
					//				organelles[i].position.set(-50000, 50000, 50000 );
					//}
					
						scene.remove( organelles[i] );
					}
					
					//organelles[nbOrganelles].position.set(-50000, 50000, 50000 );
					//organelles[nbOrganelles+1].position.set(-50000, 50000, 50000 );
					//organelles[nbOrganelles+2].position.set(-50000, 50000, 50000 );
					
					
					
					var canvasSize=900
					
					organelles=[];
					
									
					
					for (var i=0;i<nbOrganelles;i++){
						arraymaterial[i] = new THREE.MeshBasicMaterial( { color: 0x1111ff, side: THREE.DoubleSide } );
						var o1 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
						o1.applyMatrix( new THREE.Matrix4().makeTranslation(0, canvasSize/2, 0) );
						var o2 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
						o2.applyMatrix( new THREE.Matrix4().makeTranslation(0, -canvasSize/2, 0) );
						var o3 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
						o3.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
						o3.applyMatrix( new THREE.Matrix4().makeTranslation(canvasSize/2, 0, 0) );
						var o4 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
						o4.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
						o4.applyMatrix( new THREE.Matrix4().makeTranslation(-canvasSize/2, 0, 0) );
						o1.merge(o2);
						o1.merge(o3);
						o1.merge(o4);
						organelles[i] = new THREE.Mesh( o1, arraymaterial[i] );
						//organelles[i].position.set( Math.sin((2*Math.PI)/nbOrganelles*i)*scaleExplosion, -10, Math.cos((2*Math.PI)/nbOrganelles*i)*scaleExplosion );
						
						organelles[i].name="c"+i;
						organelles[i].position.set(0, 0, 0 );
						
						organelles[i].rotation.x += (90*(Math.PI / 180));
						scene.add( organelles[i] );
						
					}
					
					
					
					
					// erase stuff
					var c = 2;
						for (var h=scene.children[c].geometry.attributes.size.array.length-10000, hh=scene.children[c].geometry.attributes.size.array.length+10000;h<hh;h++){
								scene.children[c].geometry.attributes.position.array[h*3+2]=((Math.random() * 2 - 1) * 400)+50000;
								scene.children[c].geometry.attributes.compartment.array[h]= -1;
						}
						scene.children[c].geometry.attributes.position.needsUpdate = true;
						modelVisible=false;
						var c = 4;
						for (var h=scene.children[c].geometry.attributes.size.array.length-10000, hh=scene.children[c].geometry.attributes.size.array.length+10000;h<hh;h++){
								scene.children[c].geometry.attributes.position.array[h*3+2]=((Math.random() * 2 - 1) * 400)+50000;	
								scene.children[c].geometry.attributes.compartment.array[h]= -1;
						}
						scene.children[c].geometry.attributes.position.needsUpdate = true;
						//console.log(extraLinesCnt)
						//console.log(extraLinesCnt+nbReactionsModel)
						for ( var iv = extraLinesCnt; iv <extraLinesCnt+5000; iv +=2) {
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+50000;	
							scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+50000;	
						}
					
					
					
					//console.log(modelData);
					//selectedModel=modelData;
					// update model visualisation 
					// add data 
					//console.log("selectedModel "+selectedModel[4]);
					selectedModelNodes=selectedModel[2];
					selectedModelEdges=selectedModel[3];
					//console.log(selectedModelNodes);
					//console.log(selectedModelEdges);
					// in model edges, position index 2: product = 1 , preplace =2, consumed = 0
				
					nbPlacesModel=0;
					nbReactionsModel=0;
					nbEdgesModel=selectedModelEdges.length;
					
					for (var i = 0, ii= selectedModelNodes.length;i<ii;i++){
						if (selectedModelNodes[i][5]==2 ){
							nbPlacesModel++;					
						}
						if (selectedModelNodes[i][5]==4 ){
							nbReactionsModel++;
						}
					}
					//console.log("nbPlacesModel "+nbPlacesModel);
					//console.log("nbReactionsModel "+nbReactionsModel); startModelReactions startModelPlaces
					if (modelVisible==false && nbPlacesModel!=0 && nbReactionsModel!=0){
					
						var cnt1=0;
						var cnt2=0;
						var cnt=0;
						
						//var ln1 = scene.children[2].geometry.attributes.size.array.length-5000; 
						//var ln2 = scene.children[4].geometry.attributes.size.array.length-5000; 
						var ln1 = startModelPlaces;
						var ln2 = startModelReactions;
						//console.log(ln1)
						//console.log(startModelPlaces)
						for (var i= 0; i<selectedModelNodes.length;i++){
							if (selectedModelNodes[i][5]==2 ){
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]=((Math.random() * 2 - 1) * 400);
								var rm=cnt1*0.008*2*Math.PI;
								//radius=900;
								var rr = ((radius*1.08)-(cnt1*0.2)+1)
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]= (Math.cos(rm) *rr)+900;
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (Math.sin(rm) *rr);
								scene.children[2].geometry.attributes.compartment.array[(ln1+cnt1)]= selectedModelNodes[i][2];
								//scene.children[2].geometry.attributes.compartment.array[(ln1+cnt1)]= Math.floor(Math.random()*nbCompartments);
								idMap[jsonObj1.length+cnt]=[2,cnt1+ln1]
								//typesMap[2][cnt1]=i;
								cnt1++;
								cnt++;
							}
							else if (selectedModelNodes[i][5]==4 ){
								//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=((Math.random() * 2 - 1) * 400);
								var rm=cnt2*0.008*2*Math.PI;
								//radius=600;
								var rr = ((radius*0.78)-(cnt2*0.2)+1)
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(Math.cos(rm) *rr)+1800;
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(Math.sin(rm) *rr);
								scene.children[4].geometry.attributes.compartment.array[(ln2+cnt2)]= selectedModelNodes[i][2];
								//scene.children[4].geometry.attributes.compartment.array[(ln2+cnt2)]= Math.floor(Math.random()*nbCompartments);
								idMap[jsonObj1.length+cnt]=[4,cnt2+ln2]
								//typesMap[4][cnt2]=i;
								cnt2++;
								cnt++;
							}
						}
						//console.log(cnt1)
						//console.log(cnt2)
						scene.children[2].geometry.attributes.compartment.needsUpdate = true;
						scene.children[4].geometry.attributes.compartment.needsUpdate = true;
						scene.children[2].geometry.attributes.position.needsUpdate = true;
						scene.children[4].geometry.attributes.position.needsUpdate = true;
						
						var col2 = new THREE.Color( 0xffa500 );
						
						
						//console.log(selectedModelNodes)
						//for (var s= 0; s<selectedModelEdges.length;s++){
						//	if (selectedModelEdges[s][0]==108){
						//	console.log(s)
						//	}
						//}
						
						var count=0;
						for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
							var t1;
							var t2;
							var pt1;
							var pt2;
							var sim1=1;
							var sim2=1;
							pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
							sim1 = idMap[pt1][0]
							t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
							if (selectedModelEdges[iv-extraLinesCnt][3]==2){
								//console.log("link between model and metabolic nodes")
								
								if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
									pt2=selectedModelEdges[iv-extraLinesCnt][1];
								}
								else{
									pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
								}
								t2 = jsonObj1[pt2][6]
								sim2=2;
							}
							else{
								//console.log("link between model nodes")
								if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
									pt2=selectedModelEdges[iv-extraLinesCnt][1];
								}
								else{
									pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
								}
								t2 = selectedModelNodes[pt2][5];
							}
							if (sim2!=2){
								pt2+=jsonObj1.length;
								//console.log(idMap[pt2]);
							}
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
							startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
							if (sim2==2){
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
							}
							count+=1;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
							endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
							if (sim2==2){
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
							}
							count+=1;
						}
						scene.children[7].geometry.attributes.position.needsUpdate = true;
						scene.children[7].geometry.attributes.ca.needsUpdate = true;
						
						// do the token thing
						// also create a map that connect indexes
						
						/*var ii=0;
						for ( var i = segmentPts; i <segmentPts+5000 ; i +=2 ) {
							startPositionTokenMap[ii]=i;
							scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+50000;
							scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
							scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ];
							ii++;
						}
						//console.log(tokenAttributes.endPosition.value[0]);
						
						var ii=0;
						for ( var i = segmentPts+1; i <segmentPts+5000 ; i +=2 ) {
							endPositionTokenMap[ii]=i;
							tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+50000;
							tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
							tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ];
							
							ii++;
						}
						*/
						//var ii=0;
						//for ( var i = segmentPts; i <segmentPts+(nbEdgesModel) ; i ++ ) {
							//startPositionTokenMap[ii]=i;
							//scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+50000;
							//scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
							//scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ];
							
							//tokenAttributes.mixAmount.value[ii] = 0.0;
							//tokenAttributes.size.value[ii] = 30.0;
							//tokenAttributes.ca.value[ ii ] = new THREE.Color( 0xffffaa );
							
							//endPositionTokenMap[ii]=i+1;
							//tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ ((i+1) * 3) ]+50000;
							//tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ ((i+1) * 3) + 1 ]+0;
							//tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ ((i+1) * 3) + 2 ];
							
						//	ii++;
						//}
						//console.log("nb of start/end pts for tokens"+ii + "  "+(nbEdgesModel*2));
						
						//console.log(tokenAttributes.endPosition.value[0]);
						//scene.children[8].geometry.verticesNeedUpdate = true;
						//tokenAttributes.endPosition.needsUpdate = true;
						//tokenUniforms.mixAmount.value = 0.0;
						/*var ii=0;
						for ( var i = 1; i <segmentPts+5000 ; i +=2 ) {
							tokenAttributes.mixAmount.value[ii] = 0.0;
							tokenAttributes.size.value[ii] = 30.0;
							tokenAttributes.ca.value[ ii ] = new THREE.Color( 0xffaaaa );
							ii++;
						}*/
						
						//tokenAttributes.mixAmount.needsUpdate = true;
						//tokenAttributes.size.needsUpdate = true;
						//tokenAttributes.ca.needsUpdate = true;
						
						modelVisible=true;
					}
					else if ( nbPlacesModel==0 && nbReactionsModel==0){
						
						var c = 2;
						for (var h=scene.children[c].geometry.attributes.size.array.length-10000, hh=scene.children[c].geometry.attributes.size.array.length+10000;h<hh;h++){
								scene.children[c].geometry.attributes.position.array[h*3+2]=((Math.random() * 2 - 1) * 400)+50000;
								scene.children[c].geometry.attributes.compartment.array[h]= -1;
						}
						scene.children[c].geometry.attributes.position.needsUpdate = true;
						modelVisible=false;
						var c = 4;
						for (var h=scene.children[c].geometry.attributes.size.array.length-10000, hh=scene.children[c].geometry.attributes.size.array.length+10000;h<hh;h++){
								scene.children[c].geometry.attributes.position.array[h*3+2]=((Math.random() * 2 - 1) * 400)+50000;	
								scene.children[c].geometry.attributes.compartment.array[h]= -1;
						}
						scene.children[c].geometry.attributes.position.needsUpdate = true;
						//console.log(extraLinesCnt)
						//console.log(extraLinesCnt+nbReactionsModel)
						for ( var iv = extraLinesCnt; iv <extraLinesCnt+2000; iv +=2) {
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+50000;	
							scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+50000;	
						}
						
						scene.children[7].geometry.attributes.position.needsUpdate = true;
						modelVisible=false;
					}
					else{
						
						var cnt1=0;
						var cnt2=0;
						var cnt=0;
						//var ln1 = scene.children[2].geometry.attributes.size.array.length-5000;
						//var ln2 = scene.children[4].geometry.attributes.size.array.length-5000;
						var ln1 = startModelPlaces;
						var ln2 = startModelReactions;
						for (var i= 0; i<selectedModelNodes.length;i++){
							if (selectedModelNodes[i][5]==2 ){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]=((Math.random() * 2 - 1) * 400);
								scene.children[2].geometry.attributes.compartment.array[(ln1+cnt1)]= selectedModelNodes[i][2];
								//scene.children[2].geometry.attributes.compartment.array[(ln1+cnt1)]= Math.floor(Math.random()*nbCompartments);
								idMap[jsonObj1.length+cnt]=[2,cnt1+ln1]
								cnt1++;
								cnt++;
							}
							else if (selectedModelNodes[i][5]==4 ){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=((Math.random() * 2 - 1) * 400);
								scene.children[4].geometry.attributes.compartment.array[(ln2+cnt2)]= selectedModelNodes[i][2];
								//scene.children[4].geometry.attributes.compartment.array[(ln2+cnt2)]= Math.floor(Math.random()*nbCompartments);
								idMap[jsonObj1.length+cnt]=[4,cnt2+ln2]
								cnt2++;
								cnt++;
							}
						}
						scene.children[2].geometry.attributes.compartment.needsUpdate = true;
						scene.children[4].geometry.attributes.compartment.needsUpdate = true;
						scene.children[2].geometry.attributes.position.needsUpdate = true;
						scene.children[4].geometry.attributes.position.needsUpdate = true;
						
						var col2 = new THREE.Color( 0xffa500 );
						
						//var lModelNodes=[];
						
						//console.log(nbEdgesModel)
						var count=0;
						for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
							var t1;
							var t2;
							var pt1;
							var pt2;
							var sim1=1;
							var sim2=1;
							pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
							sim1 = idMap[pt1][0]
							t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
							if (selectedModelEdges[iv-extraLinesCnt][3]==2){
								//console.log("link between model and metabolic nodes")
								
								if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
									pt2=selectedModelEdges[iv-extraLinesCnt][1];
								}
								else{
									pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
								}
								t2 = jsonObj1[pt2][6]
								sim2=2;
							}
							else{
								//console.log("link between model nodes")
								if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
									pt2=selectedModelEdges[iv-extraLinesCnt][1];
								}
								else{
									pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
								}
								t2 = selectedModelNodes[pt2][5];
							}
							if (sim2!=2){
								pt2+=jsonObj1.length;
								//console.log(idMap[pt2]);
							}
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
							
							if (sim2==2){
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
							}
							count+=1;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
							
							if (sim2==2){
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
							}
							count+=1;
						}
						
						
						scene.children[7].geometry.attributes.position.needsUpdate = true;
						scene.children[7].geometry.attributes.ca.needsUpdate = true;
						
						
						//var ii=0;
						//for ( var i = segmentPts; i <segmentPts+(nbEdgesModel) ; i ++ ) {
							//startPositionTokenMap[ii]=i;
							//scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+50000;
							//scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
							//scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ];
							
							//tokenAttributes.mixAmount.value[ii] = 0.0;
							//tokenAttributes.size.value[ii] = 30.0;
							//tokenAttributes.ca.value[ ii ] = new THREE.Color( 0xffaaaa );
							
							//endPositionTokenMap[ii]=i+1;
							//tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ ((i+1) * 3) ]+50000;
							//tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ ((i+1) * 3) + 1 ]+0;
							//tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ ((i+1) * 3) + 2 ];
							
							//ii++;
						//}
					
						
						
						
						
						modelVisible=true;
					}
					
					
				}
				else{
				// erase stuff first
					var lll=bgeometryP3.attributes.position.array.length;
					for (var ml =0;ml<lll;ml+=3){
						bgeometryP3.attributes.position.array[ml]+=50000;
					}
					var lll=bgeometryP5.attributes.position.array.length;
					for (var ml =0;ml<lll;ml+=3){
						bgeometryP5.attributes.position.array[ml]+=50000;
					}
					var c = 2;
					//for (var h=scene.children[c].geometry.attributes.size.array.length-5000, hh=scene.children[c].geometry.attributes.size.array.length+5000;h<hh;h++){
					//		scene.children[c].geometry.attributes.position.array[h*3+2]=((Math.random() * 2 - 1) * 400)+50000;
					//		scene.children[c].geometry.attributes.compartment.array[h]= -1;
					//}
					scene.children[c].geometry.attributes.position.needsUpdate = true;
					//modelVisible=false;
					var c = 4;
					//for (var h=scene.children[c].geometry.attributes.size.array.length-5000, hh=scene.children[c].geometry.attributes.size.array.length+5000;h<hh;h++){
					//		scene.children[c].geometry.attributes.position.array[h*3+2]=((Math.random() * 2 - 1) * 400)+50000;	
					//		scene.children[c].geometry.attributes.compartment.array[h]= -1;
					//}
					scene.children[c].geometry.attributes.position.needsUpdate = true;
					//console.log(extraLinesCnt)
					//console.log(extraLinesCnt+nbReactionsModel)
					for ( var iv = extraLinesCnt; iv <extraLinesCnt+5000; iv +=2) {
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+50000;	
						scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+50000;	
					}
				
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					modelVisible=false;
				}
				updatedModel=false;
			}
			
			
			//if (mtween)
				//camTween.update();
			TWEEN.update();
			//var time = Date.now() * 0.005;

			//PointCloud1.rotation.z = 0.01 * time;
			if (stopThreeJsMouseEvent==false){
			if (flagPick==1){
				var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
				projector.unprojectVector( vector, camera );
				raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
				var distance=99999999;
				var listretPointsIndexes=[];
				var listretPointsDistances=[];	
				var listretPointsTypes=[];	
				var listretPointsIndexesL=[];
				var listretPointsDistancesL=[];	
				var listretPointsTypesL=[];	
				var point = new THREE.Vector3(0,0,0);		
				var myray=raycaster.ray;
				var point1 = new THREE.Vector3(0,0,0);	
				var point2 = new THREE.Vector3(0,0,0);
				
				
				for(var i=0, ii=scene.children.length;i<ii;i++){
					
					for (var partT=0;partT<7;partT++){
					// mouse hover detect particle
					if (scene.children[i] instanceof THREE.PointCloud && (i==partT)){
						var a1 = scene.children[i].geometry.attributes.position.array;
						var a2 = scene.children[i].geometry.attributes.size.array;
						particles = a2.length;
						var a3 = scene.children[i].geometry.attributes.ca.array;
						
						for(var j=0;j<particles;j++){
							point.x = (a1[j*3]);
							point.y = (a1[j*3+1]);
							point.z = (a1[j*3+2]);
							distance = myray.distanceToPoint(point);
							if ( distance <=2 ) {
								listretPointsIndexes.push(j);
								listretPointsDistances.push(distance);	
								listretPointsTypes.push(i);	
							}
						}
						
					}
					/*if (scene.children[i] instanceof THREE.Mesh ){
						for (var nc=0;nc<nbCompartments;nc++){
							if (scene.children[i] instanceof THREE.Mesh && scene.children[i].name=="c"+nc){
								//console.log(scene.children[i])
								var ptMesh = scene.children[i].position;
								var meshdistance = myray.distanceToPoint(point);
								if (meshdistance)<=2
								console.log(ptMesh)
							}
						}
					}*/
					
					
					}
					var h1 = listretPointsDistances.length;
					var myr;
					var mymin = Math.min.apply(Math, listretPointsDistances);
					var v1=0;
					while(h1--){
						if (listretPointsDistances[h1]==mymin){
							myr=h1;
								}
								if (myr==h1)
									break;
								
					}						
					closest = listretPointsIndexes[myr];
					if (closest>=0){
						//console.log(listretPointsTypes[myr]);
						if (listretPointsTypes[myr]>=0)
							sprite.position.set(scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3],scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3+1],scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3+2]);	
						//console.log(closest);
						//console.log(i);
						isOnParticle=1;
							//cssObject.element.children[1].textContent=""+closest;//.element.symbol.textContent=closest;
							
							if (listretPointsTypes[myr]>=0){
								
								var pp = toXYCoords(sprite.position);
								
								if ((text1PreviousPos.x != pp.x) && (text1PreviousPos.y != pp.y)){
									//console.log(text1PreviousPos)
									//console.log(listretPointsTypes[myr])
									// display 2d text in html in screen 2s coordinate corresponding to near the 3d position... 
									//camera.updateMatrixWorld() ;
									//text1.firstChild.value=""+jsonObj1[typesMap[listretPointsTypes[myr]][closest]][2];
									text1.style.top = (pp.y+contYPos +halfvis)+ 'px';								
									text1.style.left = (pp.x -(text1.firstChild.length*8))-18+ 'px';
									text1PreviousPos = pp;
									var stringTxt="";
									var dat =typesMap[listretPointsTypes[myr]][closest];
									if(jsonObj1[dat]){
										stringTxt = jsonObj1[dat][0]+" "+jsonObj1[dat][2];
										if (jsonObj1[dat][4][1] && jsonObj1[dat][4][1][0]){
											stringTxt = jsonObj1[dat][0]+" "+jsonObj1[dat][2]+" ("+jsonObj1[dat][4][1][0]+")";
										}
										
									}
									else{
										if (listretPointsTypes[myr]==2){																
											stringTxt = " "+selectedModelNodes[dat-jsonObj1.length][1];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
										}
										else if (listretPointsTypes[myr]==4){											
												stringTxt = " "+selectedModelNodes[nbPlacesModel+dat-jsonObj1.length][1];
										}
										//else{stringTxt = " ";}
									}
									if (text1PreviousString!=stringTxt){
										text1.innerHTML=stringTxt;
										text1PreviousString=stringTxt;
									}
									//text1.innerHTML=stringTxt;
									/*else{
										//text1.innerHTML = " ";
										if (listretPointsTypes[myr]==2){												
											text1.innerHTML = " "+selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
										}
										if (listretPointsTypes[myr]==4){
											text1.innerHTML = " "+selectedModelNodes[nbPlacesModel+typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length];
										}
									}*/
									/*try{
										
									text1.innerHTML = ""+jsonObj1[typesMap[listretPointsTypes[myr]][closest]][2];		
																		
									
									}
									catch(e){
										text1.innerHTML = " ";
										try{
											//var ln1 = startModelPlaces;
											//var ln2 = startModelReactions;
											//selectedModelNodes[i][5]==2
											//var Ptype= idMap[closest][0];
											//var Pindex= idMap[closest][1];
											//text1.innerHTML = " "+idMap[closest];
											if (listretPointsTypes[myr]==2){
												
												text1.innerHTML = " "+selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
												//console.log(selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length]);
												//console.log(selectedModelNodes);
											}
											if (listretPointsTypes[myr]==4){
												text1.innerHTML = " "+selectedModelNodes[nbPlacesModel+typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length];
											//	text1.innerHTML = " "+selectedModelNodes[nbPlacesModel+typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
											}
											
											//typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length;
											//+selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
										}
										catch(e1){
											
										}
									
									}*/
								}
								else{
									text1.style.top =  (text1PreviousPos.y+contYPos +halfvis)+ 'px';								
									text1.style.left = text1PreviousPos.x -(text1.firstChild.length*8)-18+ 'px';
								}
							}
							
							//try{
							//cssObject.element.children[1].textContent=""+jsonObj1[typesMap[listretPointsTypes[myr]][closest]][2];
							//	cssObject.element.children[2].textContent=particleClass[listretPointsTypes[myr]];
								hoveredType=listretPointsTypes[myr];
								//}
							//catch(err){
							//}
					}
					else{
						sprite.position.set(-10000,-10000,-50000);
						//if (text1.style.top == (2000 + 'px')){
						//else{
						//	text1.style.top = 2000 + 'px';
						//	text1.style.left = 2000 + 'px';
						//}
						//text1.style.top = 2000 + 'px';
						//text1.style.left = 2000 + 'px';
						
						isOnParticle=0;		
						if (isOnLine==0 && noKeggCube){
						
						textk.style.top = 2000 + 'px';
						textk.style.left = 2000 + 'px';
						//cssObject.element.children[1].textContent="";
						//cssObject.element.children[2].textContent="";
						hoveredType=-1
						}
					}
					
					
					// mouse hover detect line
					//if (scene.children[i] instanceof THREE.Line && i==7){
					//		var a1 = scene.children[i].geometry.attributes.position.array;
					//		var a2 = scene.children[i].geometry.attributes.ca.array;
					//		var interSegment = new THREE.Vector3();
					//		var interRay = new THREE.Vector3();
							
					//		for(var j=0, jj= segmentPts;j<jj;j+=2){
					//			point1.x = (a1[j*3]); point1.y = (a1[(j*3)+1]); point1.z = (a1[(j*3)+2]);
					//			point2.x = (a1[(j+1)*3]); point2.y = (a1[((j+1)*3)+1]); point2.z = (a1[((j+1)*3)+2]);
					//			distance = myray.distanceSqToSegment( point1, point2, interRay, interSegment );
					//			if ( distance <=4 ) {
					//				listretPointsIndexesL.push(j);
					//				listretPointsDistancesL.push(distance);	
					//			}
					//		}
					//		var h1 = listretPointsDistancesL.length;
					//		var myr;
					//		var mymin = Math.min.apply(Math, listretPointsDistancesL);
					//		var v1=0;
					//		while(h1--){
					//			if (listretPointsDistancesL[h1]==mymin){
					//				myr=h1;
					//			}
					//			if (myr==h1)
					//				break;
									
					//			}						
					//		closestLine = listretPointsIndexesL[myr];
					//		if (closestLine>=0){
					//			isOnLine=1;
					//			if (isOnParticle==0){
					//				cssObject.element.children[1].textContent=""+closestLine;//.element.symbol.textContent=closest;
					//				cssObject.element.children[2].textContent="Line";
									
								// set position of outline mesh
					//			outlineMesh1.geometry.vertices[0].x=a1[closestLine*3]; outlineMesh1.geometry.vertices[0].y=a1[closestLine*3+1]; outlineMesh1.geometry.vertices[0].z=a1[closestLine*3+2];
					//			outlineMesh1.geometry.vertices[1].x=a1[(closestLine+1)*3]; outlineMesh1.geometry.vertices[1].y=a1[(closestLine+1)*3+1]; outlineMesh1.geometry.vertices[1].z=a1[(closestLine+1)*3+2];
					//			lineGeometry.verticesNeedUpdate = true;
					//			hoveredType=7;
					//			}
								//
					//		}
					//		else{//sprite.position.set(-10000,-10000,10000);	
					//			//cssObject.element.children[1].textContent="e";
					//			outlineMesh1.geometry.vertices[0].x=-10000; outlineMesh1.geometry.vertices[0].y=-10000; outlineMesh1.geometry.vertices[0].z=-50000;
					//			outlineMesh1.geometry.vertices[1].x=-10000; outlineMesh1.geometry.vertices[1].y=-10000; outlineMesh1.geometry.vertices[1].z=-51000;
					//			lineGeometry.verticesNeedUpdate = true;isOnLine=0;
					//		}
							
							
					//}
				}
				if (isOnParticle==0 ){
					text1.style.top = 2000 + 'px';
					text1.style.left = 2000 + 'px';
					//pip.style.top = 2000 + 'px';
					//pip.style.left = 2000 + 'px';
				}
				//else{
				//pip.style.top = 50 + 'px';
				//	pip.style.left = 25 + 'px';
				//}
				var intersects = raycaster.intersectObjects( scene.children );
				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].object ) {

						//if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
						if (INTERSECTED instanceof THREE.Mesh ){
							if (INTERSECTED.name=="c0"){
								INTERSECTED.material.color.setHex( 0xffff33 );
								onCompartments[0]=true;
								for (var ni=0;ni<nbCompartments;ni++){
									if (draggingCompartments[ni]==true){
										container.style.cursor = 'pointer';
									}
								}
								console.log(INTERSECTED.name)
							}
							else if (INTERSECTED.name=="c1"){
								INTERSECTED.material.color.setHex( 0xffff33 );
								onCompartments[1]=true;
								for (var ni=0;ni<nbCompartments;ni++){
									if (draggingCompartments[ni]==true){
										container.style.cursor = 'pointer';
									}
								}
								console.log(INTERSECTED.name)
							}
							else if (INTERSECTED.name=="c2"){
								INTERSECTED.material.color.setHex( 0xffff33 );
								onCompartments[2]=true;
								for (var ni=0;ni<nbCompartments;ni++){
									if (draggingCompartments[ni]==true){
										container.style.cursor = 'pointer';
									}
								}
								console.log(INTERSECTED.name)
							}
							else if (INTERSECTED.name=="c3"){
								INTERSECTED.material.color.setHex( 0xffff33 );
								onCompartments[3]=true;
								for (var ni=0;ni<nbCompartments;ni++){
									if (draggingCompartments[ni]==true){
										container.style.cursor = 'pointer';
									}
								}
								console.log(INTERSECTED.name)
							}
							else if (INTERSECTED.name=="c4"){
								INTERSECTED.material.color.setHex( 0xffff33 );
								onCompartments[4]=true;
								for (var ni=0;ni<nbCompartments;ni++){
									if (draggingCompartments[ni]==true){
										container.style.cursor = 'pointer';
									}
								}
								console.log(INTERSECTED.name)
							}
							else if (INTERSECTED.name=="c5"){
								INTERSECTED.material.color.setHex( 0xffff33 );
								onCompartments[5]=true;
								for (var ni=0;ni<nbCompartments;ni++){
									if (draggingCompartments[ni]==true){
										container.style.cursor = 'pointer';
									}
								}
								console.log(INTERSECTED.name)
							}
							else if (INTERSECTED.name=="c6"){
								INTERSECTED.material.color.setHex( 0xffff33 );
								onCompartments[6]=true;
								for (var ni=0;ni<nbCompartments;ni++){
									if (draggingCompartments[ni]==true){
										container.style.cursor = 'pointer';
									}
								}
								console.log(INTERSECTED.name)
							}
							else if (INTERSECTED.name=="c7"){
								INTERSECTED.material.color.setHex( 0xffff33 );
								onCompartments[7]=true;
								for (var ni=0;ni<nbCompartments;ni++){
									if (draggingCompartments[ni]==true){
										container.style.cursor = 'pointer';
									}
								}
								console.log(INTERSECTED.name)
							}
							else if (INTERSECTED.name=="c8"){
								INTERSECTED.material.color.setHex( 0xffff33 );
								onCompartments[8]=true;
								for (var ni=0;ni<nbCompartments;ni++){
									if (draggingCompartments[ni]==true){
										container.style.cursor = 'pointer';
									}
								}
								console.log(INTERSECTED.name)
							}
							//
							else if (INTERSECTED.name.charAt(0)=="k"){
								noKeggCube=false;
								INTERSECTED.material.color.setHex( 0xffdd33 );
								var pp = toXYCoords(INTERSECTED.position);
								if (textkPreviousPos != pp){
									//console.log(closest)
									//console.log(listretPointsTypes[myr])
									// display 2d text in html in screen 2s coordinate corresponding to near the 3d position... 
									//camera.updateMatrixWorld() ;
									//text1.firstChild.value=""+jsonObj1[typesMap[listretPointsTypes[myr]][closest]][2];
									textk.innerHTML = ""+keggCubesProperties[INTERSECTED.name][0]+"  - value:" + keggCubesProperties[INTERSECTED.name][1];		
									textk.style.top = pp.y +contYPos+ 'px';								
									textk.style.left = (pp.x -(text1.firstChild.length*8))+20+ 'px';
									textkPreviousPos = pp;
									
									
								}
								//console.log(keggCubesProperties[INTERSECTED.name])
							}
							else if(INTERSECTED.name=="skybox"){
								noKeggCube=true;
								INTERSECTED = null;
								container.style.cursor = 'auto';
								for (var im=0;im<nbOrganelles;im++){
									//arraymaterial[nbOrganelles].color.setHex( 0x1111ff );
									organelles[im].material.color.setHex( 0x1111ff );
								}
								nucleus.material.color.setHex( 0x1111ff );
								cytoplasm.material.color.setHex( 0x1111ff );
								ECM.material.color.setHex( 0x1111ff );
								for (var ni=0;ni<nbCompartments;ni++){
									onCompartments[ni]=false;
								}
								
								for ( var k = 0; k < previousKeggLength; k ++ ) {
									cubesGeometry[k].material.color.setHex( 0xff0000 );
								}
								
							}
							else{container.style.cursor = 'auto';
							noKeggCube=true;
							for ( var k = 0; k < previousKeggLength; k ++ ) {
								cubesGeometry[k].material.color.setHex( 0xff0000 );
							}
							}
						
						}
						//INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						//

					}

				} else {

					//if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
					noKeggCube=true;
					INTERSECTED = null;
					container.style.cursor = 'auto';
					for (var im=0;im<nbOrganelles;im++){
						//arraymaterial[nbOrganelles].color.setHex( 0x1111ff );
						organelles[im].material.color.setHex( 0x1111ff );
					}
					nucleus.material.color.setHex( 0x1111ff );
					cytoplasm.material.color.setHex( 0x1111ff );
					ECM.material.color.setHex( 0x1111ff );
					for (var ni=0;ni<nbCompartments;ni++){
						onCompartments[ni]=false;
					}
					//for ( var k = 0; k < previousKeggLength; k ++ ) {
					//	cubesGeometry[k].material.color.setHex( 0xff0000 );
					//}
					//console.log(listChangingKeggCoordinates.length);
					//for ( var k = 0; k < keggSegment.length; k ++ ) {
					//	scene.getObjectByName( "k"+k ).material.color.setHex( 0xff0000 );
						//cubesGeometry[k].material.color.setHex( 0xff0000 );
						//cubesGeometry[i].material.color.needUpdate=true;
					//}

				}
				
				flagPick=0;
				
				
			}
			else
				flagPick++;
			}	
			
			
			var t = clock.getElapsedTime();
			
			if( simulationIsOn==true && simulationIsPaused==false){
				
				//console.log(simData[1][simTimer])
				
				
				// refactor simTimer to Object.keys(simDataTime)
				//var limTimer=0;
				//if (simModeValue==0){
				//	limTimer=simData[1].length
				//}
				//if (simModeValue==1){
				var	limTimer=Object.keys(simDataTime).length
				//}
				
				if (simData && simTimer<limTimer){
					//console.log(simTimer)
					//console.log(simTimer);
					
					scene.children[7].geometry.attributes.op.needsUpdate = true;
				
					//if (simTimerPrevious!=simTimer){
					//	console.log("new timer:"+simTimerPrevious +" becomes "+simTimer)
						//for(var v=0;v<nbModelReactionLocators;v++){
						//	modelProductLocators[v].position.set(50000,50000,-50000);
						//	modelReactantLocators[v].position.set(50000,50000,-50000);
						//	modelModifierLocators[v].position.set(50000,50000,-50000);
						//}
					//	simTimerPrevious=simTimer;
					//}
					// change display of timer property
					//console.log(simDataTime[Object.keys(simDataTime)[simTimer]][0]);
					if (simModeValue==0){
						for (var i=segmentPts;i<b2lopacity.length;i++){
							if (b2lopacity[i]>0.0){
							b2lopacity[i]=0.2;
							}
						}
						for (var i=0;i<10;i++){
							planeMesh[i].material.blending=THREE.AdditiveBlending;
						}
						for (var i=0;i<tokenAttributes.size.value.length;i++){
							tokenAttributes.size.value[i]=30;
						}
						timerElement.innerHTML=""+simDataTime[Object.keys(simDataTime)[simTimer]][0][1];
						sliderElement.value=simTimer;
						simRow=[simData[1][simTimer]];
						var ln1 = startModelPlaces;
						var ln2 = startModelReactions;
						var cnt1=0;
						var cnt2 = 0;
						var min;
						var max; 
						for(var j=3;j<simData[1][simTimer].length-1;j++){
							min = simDataBounds[j-3][0];
							max = simDataBounds[j-3][1];
							var size=30;
							if ((max-min)!=0){
								size = 30+(50*(simData[1][simTimer][j]-min)/(max-min))
								if (size>80){
									size = 80;
									//console.log("biiig "+ simData[1][simTimer][j])
									}
								if (isNaN(size)){
									size=30;
									//console.log("NaN "+simData[1][simTimer][j] + " "+min+" "+max );
								}
								//console.log(size);
								for(var j1=0;j1<selectedModelNodes.length;j1++){
									if (selectedModelNodes[j1][1]==simData[0][j]){
									
										
										
										//console.log(simData[0][j]);
										if (selectedModelNodes[j1][5]==2 ){
											scene.children[2].geometry.attributes.size.array[(ln1+cnt1)]= size;
											//console.log("node place index"+(ln1+cnt1))
											//bgeometryP3.attributes.size.array[(ln1+cnt1)]= size;
											//console.log("resize place"+(cnt1))
											cnt1++;
										}
										if (selectedModelNodes[j1][5]==4 ){
											scene.children[4].geometry.attributes.size.array[(ln2+cnt2)]= size;
											//console.log("node reaction index"+(ln2+cnt2))
											//bgeometryP5.attributes.size.array[(ln2+cnt2)]= size;
											//console.log("resize reaction"+size)
											cnt2++;
										}
										
									}
								}
							}
							//console.log(window.innerWidth*0.6)
							//console.log(simFlowChart)
							var indexChart=simFlowChart-1+3;
							//console.log(simData[0][indexChart+3]);
							if (j==indexChart){
								if (simTimer==0){
									var iv=0;
									for ( var i = 0; i < chartSegment; i ++ ) {
										chartPositions[ (iv * 3)+0 ] = 50400;
										chartPositions[ (iv * 3) + 1 ] = 0;
										chartPositions[ (iv * 3) + 2 ] = -50400;
										//chartColors[ iv * 3 ] = col.r;
										//chartColors[ iv * 3 + 1 ] = col.g;
										//chartColors[ iv * 3 + 2 ] = col.b;
										iv++;
										chartPositions[ (iv * 3)+0 ] = 50400;
										chartPositions[ (iv * 3) + 1 ] = 0;
										chartPositions[ (iv * 3) + 2 ] = -50400;
										//chartColors[ iv * 3 ] = col.r;
										//chartColors[ iv * 3 + 1 ] = col.g;
										//chartColors[ iv * 3 + 2 ] = col.b;
										iv++
									}
									if (max==min){
										chartPositions[ ((simTimer*2) * 3)+0 ] = -(window.innerWidth*0.11)+((simTimer)*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(0);
										chartPositions[ ((simTimer*2+1) * 3)+0 ] = -(window.innerWidth*0.11)+(simTimer*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2+1) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2+1) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(0);
									}
									else{
										chartPositions[ ((simTimer*2) * 3)+0 ] = -(window.innerWidth*0.11)+((simTimer)*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(((simData[1][simTimer][indexChart]-min)/(max-min))*(-(window.innerHeight*0.15*0.9)));
										chartPositions[ ((simTimer*2+1) * 3)+0 ] = -(window.innerWidth*0.11)+(simTimer*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2+1) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2+1) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(((simData[1][simTimer][indexChart]-min)/(max-min))*(-(window.innerHeight*0.15*0.9)));
									}
									//console.log("value:" +simData[1][simTimer][j] + " min: " + min + " max: " + max)
									}
								else {
								//if ((((simData[1][simTimer-1][5]-min)/(max-min))*-30) != (((simData[1][simTimer][5]-min)/(max-min))*-30) && (simTimer%2==0)){
									if (max==min){
										chartPositions[ ((simTimer*2) * 3)+0 ] = -(window.innerWidth*0.11)+((simTimer-1)*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(0);
										chartPositions[ ((simTimer*2+1) * 3)+0 ] = -(window.innerWidth*0.11)+(simTimer*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2+1) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2+1) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(0);
									}
									else{
										chartPositions[ ((simTimer*2) * 3)+0 ] = -(window.innerWidth*0.11)+((simTimer-1)*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(((simData[1][simTimer-1][indexChart]-min)/(max-min))*(-(window.innerHeight*0.15*0.9)));
										chartPositions[ ((simTimer*2+1) * 3)+0 ] = -(window.innerWidth*0.11)+(simTimer*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2+1) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2+1) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(((simData[1][simTimer][indexChart]-min)/(max-min))*(-(window.innerHeight*0.15*0.9)));
									}
									//console.log("value:" +simData[1][simTimer][j] + " min: " + min + " max: " + max + " coord2:"+ simData[1][simTimer][indexChart])
									//console.log("value:"+simData[1][simTimer][indexChart]+ " normalised value: "+((simData[1][simTimer][indexChart]-min)/(max-min))+ " scale modifier"+(-(window.innerHeight*0.075)));
								//	}
								}
								geometryLineChart.attributes.position.needsUpdate = true;
							}
							
							
							// display linechart in function of timer
							
							//for ( var i = 0; i < chartSegment; i ++ ) {
							
							
							//chartPositions[ ((simTimer*2+1) * 3)+0 ] = 50000;
							//chartPositions[ ((simTimer*2+1) * 3) + 1 ] = 180;
							//chartPositions[ ((simTimer*2+1) * 3) + 2 ] = -500+(((simData[1][simTimer][5]-min)/(max-min))*-30);
							
							//chartPositions[ ((simTimer+1) * 3)+0 ] = 400+simTimer;
							//chartPositions[ ((simTimer+1) * 3) + 1 ] = 180;
							//chartPositions[ ((simTimer+1) * 3) + 2 ] = -500+(((simData[1][simTimer][5]-min)/(max-min))*-30);
							
							//for ( var i = simTimer+1; i < chartSegment*2; i ++ ) {
							//	chartPositions[ (i * 3)+0 ] = 400+simTimer;
							//	chartPositions[ (i * 3) + 1 ] = 180;
							//	chartPositions[ (i * 3) + 2 ] = -500+(((simData[1][simTimer][5]-min)/(max-min))*-30);
							//}//
								//iv++;
								//chartPositions[ (iv * 3)+0 ] = 400+simTimer+1;
								//chartPositions[ (iv * 3) + 1 ] = 0;
								//chartPositions[ (iv * 3) + 2 ] = (simData[1][simTimer+1][j]-min)/(max-min)*-400;
								
								//iv++
							//}
							//chartPositions.needsUpdate = true;
							
							//buffer_geometry.attributes.position.array;
						}
						scene.children[2].geometry.attributes.size.needsUpdate = true;
						scene.children[4].geometry.attributes.size.needsUpdate = true;
						
						//console.log();
						//var nbTokens=Object.keys(startPositionTokenMap).length;
						var triggerOnceReaction=true;
						for (var tk= 0; tk<selectedModelEdges.length;tk++){
							//console.log("aaa");
							
							// if link between model reaction and model place, create token
							if (selectedModelEdges[tk][3]==1){
								// add different possiblities from the simDataTime[Object.keys(simDataTime)[simTimer]][0][1];
								//if (selectedModelNodes[selectedModelEdges[tk][0]][1]==simData[1][simTimer][2]){
								for (var rw=0;rw<simRow.length;rw++){
									if (selectedModelNodes[selectedModelEdges[tk][0]][1]==simRow[rw][2]){
										
										//if (simRow.length>1){console.log(simRow[rw][2])}
										//if (allFalse){
										var nb;
										if (clearedTokenIndex.length>0){
											nb=clearedTokenIndex.pop();	
											stackTokenModel[nb]=[0,nb,selectedModelEdges[tk][0],selectedModelEdges[tk][1],1,true,selectedModelEdges[tk][2]];	
											//tokenAttributes.size.value[nb]=30;
											
										}
										else{
											nb=stackTokenModel.length;		
											stackTokenModel.push([0,nb,selectedModelEdges[tk][0],selectedModelEdges[tk][1],1,true,selectedModelEdges[tk][2]]);	
											//tokenAttributes.size.value[nb]=30;
										}
										// stackTokenModel element: mixamount value, id of token, pt1 model node id, pt2 model node id, type of link (1= model/model or 2 =model/sim) 
										//console.log(stackTokenModel.length)
										tokenStackCount+=1;
										tokenAttributes.mixAmount.value[nb]=0;
										//planeMesh[nb].position.set(0,0,0);
										//if(selectedModelEdges[tk][2]==0 || selectedModelEdges[tk][2]==2){
										if(selectedModelEdges[tk][2]==1 ){
											//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])]=1.0;
											//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])+1]=1.0;
											
											scene.children[8].geometry.vertices[nb].x=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) ]+0;
											scene.children[8].geometry.vertices[nb].y=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 1 ]+0;
											scene.children[8].geometry.vertices[nb].z=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 2 ]+0;
											tokenAttributes.endPosition.value[nb].x=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) ]+0;
											tokenAttributes.endPosition.value[nb].y=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 1 ]+0;
											tokenAttributes.endPosition.value[nb].z=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 2 ]+0;
											// change color
											tokenAttributes.ca.value[nb]= new THREE.Color( 0xff0000 );
											
											/*var x1= (scene.children[8].geometry.vertices[nb].x+tokenAttributes.endPosition.value[nb].x)/2;											
											var y1 = (scene.children[8].geometry.vertices[nb].y+tokenAttributes.endPosition.value[nb].y)/2;
											var z1 = (scene.children[8].geometry.vertices[nb].z+tokenAttributes.endPosition.value[nb].z)/2;
											
											var isInFlowsStack =false;
											for (var fs=0;fs<flowsStack.length;fs++){
												if (flowsStack[fs]){
													if ((flowsStack[fs][0]==x1) && (flowsStack[fs][1]==y1) && (flowsStack[fs][2]==z1) ){
														isInFlowsStack=true;
													}
												}
											}
											//console.log(isInFlowsStack)
											if (!isInFlowsStack){
												flowsStack.push([x1,y1,z1]);
												planeMesh[flowsStack.length-1].position.set(0,0,0);
												planeMesh[flowsStack.length-1].geometry.vertices[0].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[0].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[0].z=scene.children[8].geometry.vertices[nb].z-1;
												planeMesh[flowsStack.length-1].geometry.vertices[2].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[2].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[2].z=scene.children[8].geometry.vertices[nb].z+1;
												planeMesh[flowsStack.length-1].geometry.vertices[1].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[1].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[1].z=tokenAttributes.endPosition.value[nb].z-1;
												planeMesh[flowsStack.length-1].geometry.vertices[3].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[3].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[3].z=tokenAttributes.endPosition.value[nb].z+1;
												
												//planeMesh[flowsStack.length-1].scale.z=size/30;
												planeMesh[flowsStack.length-1].geometry.verticesNeedUpdate=true;
											}
											*/
											
											
											//console.log(planeMesh[0].geometry);
											
											//planeMesh[0].position.x=scene.children[8].geometry.vertices[nb].x;
											//planeMesh[0].position.y=scene.children[8].geometry.vertices[nb].y;
											//planeMesh[0].position.z=scene.children[8].geometry.vertices[nb].z;
											//planeMesh[0].geometry.__dirtyVertices = true; 
											//planeMesh[0].geometry.computeCentroids();
											//planeMesh[nb].geometry.verticesNeedUpdate=true;
										}
										// if preplace to reaction
										if(selectedModelEdges[tk][2]!=1 ){
											//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-2]=1.0;
											//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-1]=1.0;
											//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-4]=1.0;
											//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-3]=1.0;
											scene.children[8].geometry.vertices[nb].x=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) ]+0;
											scene.children[8].geometry.vertices[nb].y=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 1 ]+0;
											scene.children[8].geometry.vertices[nb].z=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 2 ]+0;
											tokenAttributes.endPosition.value[nb].x=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) ]+0;
											tokenAttributes.endPosition.value[nb].y=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 1 ]+0;
											tokenAttributes.endPosition.value[nb].z=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 2 ]+0;
											// change color
											tokenAttributes.ca.value[nb]= new THREE.Color( 0x0000ff );
											/*
											var x1= (scene.children[8].geometry.vertices[nb].x+tokenAttributes.endPosition.value[nb].x)/2;											
											var y1 = (scene.children[8].geometry.vertices[nb].y+tokenAttributes.endPosition.value[nb].y)/2;
											var z1 = (scene.children[8].geometry.vertices[nb].z+tokenAttributes.endPosition.value[nb].z)/2;
											
											var isInFlowsStack =false;
											for (var fs=0;fs<flowsStack.length;fs++){
												if (flowsStack[fs]){
													if ((flowsStack[fs][0]==x1) && (flowsStack[fs][1]==y1) && (flowsStack[fs][2]==z1) ){
														isInFlowsStack=true;
													}
												}
											}
											if (!isInFlowsStack){
												flowsStack.push([x1,y1,z1]);
												planeMesh[flowsStack.length-1].position.set(0,0,0);
												planeMesh[flowsStack.length-1].geometry.vertices[0].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[0].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[0].z=scene.children[8].geometry.vertices[nb].z-1;
												planeMesh[flowsStack.length-1].geometry.vertices[2].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[2].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[2].z=scene.children[8].geometry.vertices[nb].z+1;
												planeMesh[flowsStack.length-1].geometry.vertices[1].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[1].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[1].z=tokenAttributes.endPosition.value[nb].z-1;
												planeMesh[flowsStack.length-1].geometry.vertices[3].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[3].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[3].z=tokenAttributes.endPosition.value[nb].z+1;
												
												//planeMesh[flowsStack.length-1].scale.z=size/30;
												planeMesh[flowsStack.length-1].geometry.verticesNeedUpdate=true;
											}*/
											
											
											
										}
										
										var x1= (scene.children[8].geometry.vertices[nb].x+tokenAttributes.endPosition.value[nb].x)/2;											
										var y1 = (scene.children[8].geometry.vertices[nb].y+tokenAttributes.endPosition.value[nb].y)/2;
										var z1 = (scene.children[8].geometry.vertices[nb].z+tokenAttributes.endPosition.value[nb].z)/2;
										
										var isInFlowsStack =false;
										var indexCnt=-1;
										for (var fs=0;fs<flowsStack.length;fs++){
											if (flowsStack[fs]){
												if ((flowsStack[fs][0]==x1) && (flowsStack[fs][1]==y1) && (flowsStack[fs][2]==z1) ){
													isInFlowsStack=true;
													indexCnt=fs;
												}
											}
										}
										if (!isInFlowsStack){
											flowsStack.push([x1,y1,z1]);
											planeMesh[flowsStack.length-1].position.set(0,0,0);
											planeMesh[flowsStack.length-1].geometry.vertices[0].x=scene.children[8].geometry.vertices[nb].x;
											planeMesh[flowsStack.length-1].geometry.vertices[0].y=scene.children[8].geometry.vertices[nb].y;
											planeMesh[flowsStack.length-1].geometry.vertices[0].z=scene.children[8].geometry.vertices[nb].z-1;
											planeMesh[flowsStack.length-1].geometry.vertices[2].x=scene.children[8].geometry.vertices[nb].x;
											planeMesh[flowsStack.length-1].geometry.vertices[2].y=scene.children[8].geometry.vertices[nb].y;
											planeMesh[flowsStack.length-1].geometry.vertices[2].z=scene.children[8].geometry.vertices[nb].z+1;
											planeMesh[flowsStack.length-1].geometry.vertices[1].x=tokenAttributes.endPosition.value[nb].x;
											planeMesh[flowsStack.length-1].geometry.vertices[1].y=tokenAttributes.endPosition.value[nb].y;
											planeMesh[flowsStack.length-1].geometry.vertices[1].z=tokenAttributes.endPosition.value[nb].z-1;
											planeMesh[flowsStack.length-1].geometry.vertices[3].x=tokenAttributes.endPosition.value[nb].x;
											planeMesh[flowsStack.length-1].geometry.vertices[3].y=tokenAttributes.endPosition.value[nb].y;
											planeMesh[flowsStack.length-1].geometry.vertices[3].z=tokenAttributes.endPosition.value[nb].z+1;
											stackModel2PlaneMesh[nb]=flowsStack.length-1;
											//planeMesh[flowsStack.length-1].scale.z=size/30;
											planeMesh[flowsStack.length-1].geometry.verticesNeedUpdate=true;
										}
										else{
										if (simData[1][simTimer][j]<0){
											if(Math.abs(planeMesh[indexCnt].geometry.vertices[0].z-planeMesh[indexCnt].geometry.vertices[2].z)<20){
												planeMesh[indexCnt].geometry.vertices[0].z+=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
												planeMesh[indexCnt].geometry.vertices[2].z-=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
												planeMesh[indexCnt].geometry.vertices[1].z+=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
												planeMesh[indexCnt].geometry.vertices[3].z-=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
											}
										}
										else{
											if(Math.abs(planeMesh[indexCnt].geometry.vertices[0].z-planeMesh[indexCnt].geometry.vertices[2].z)<20){
												planeMesh[indexCnt].geometry.vertices[0].z-=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
												planeMesh[indexCnt].geometry.vertices[2].z+=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
												planeMesh[indexCnt].geometry.vertices[1].z-=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
												planeMesh[indexCnt].geometry.vertices[3].z+=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
												//console.log(Math.abs(planeMesh[indexCnt].geometry.vertices[0].z-planeMesh[indexCnt].geometry.vertices[2].z))
											}
										}
											planeMesh[indexCnt].geometry.verticesNeedUpdate=true;
										}
										// if preplace to reaction
										//if(selectedModelEdges[tk][2]==1){
										//	scene.children[8].geometry.vertices[nb].x=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) ]+0;
										//	scene.children[8].geometry.vertices[nb].y=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 1 ]+0;
										//	scene.children[8].geometry.vertices[nb].z=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 2 ]+0;
										//	tokenAttributes.endPosition.value[nb].x=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) ]+0;
										//	tokenAttributes.endPosition.value[nb].y=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 1 ]+0;
										//	tokenAttributes.endPosition.value[nb].z=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 2 ]+0;
										//}
										tokenAttributes.size.value[nb] = 30.0;
										//}
										if (tokenIDStackCount.hasOwnProperty(simRow[rw][2]) && triggerOnceReaction==true) {
												tokenIDStackCount[simRow[rw][2]][0]+=1;
												//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
												//modelReactionLocators[rw].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
												triggerOnceReaction=false;
												//console.log(tokenIDStackCount);
										}
										else{
											if( triggerOnceReaction==true){
												if(selectedModelEdges[tk][2]!=1){
													tokenIDStackCount[simRow[rw][2]]=[1,tokenAttributes.endPosition.value[nb].x,tokenAttributes.endPosition.value[nb].y,tokenAttributes.endPosition.value[nb].z];
													
												}
												if(selectedModelEdges[tk][2]==1){
													tokenIDStackCount[simRow[rw][2]]=[1,scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z];
													
												}
											//tokenIDStackCount[simRow[rw][2]]=[1,scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z];
											//modelReactionLocators[rw].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
											triggerOnceReaction=false;
											//console.log(tokenIDStackCount);
											//var vectorp = new THREE.Vector3( scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
											//vectorp.x +=10;
											//var ppv = toXYCoords(vectorp	);
											//txtReactionActivation[cntLabels].style.top = ppv.y + 'px';
											//txtReactionActivation[cntLabels].style.left = ppv.x + 'px';
											//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
											}
											
										}
										//cntLabels++;
									}
									
								}
							}
							
						}
						//console.log(flowsStack.length);
						//for (var f = 0;f<planeMesh.length;f++){
						//planeMesh[f].geometry.verticesNeedUpdate= true;
						//}
						scene.children[7].geometry.attributes.op.needsUpdate = true;
						tokenAttributes.mixAmount.needsUpdate = true;
						tokenAttributes.ca.needsUpdate = true;
						scene.children[8].geometry.verticesNeedUpdate = true;
						tokenAttributes.endPosition.needsUpdate = true;
						tokenAttributes.size.needsUpdate = true;
						simTimer++;
						//reactionIsDone=false;
					}
					if (simModeValue==1){
						//console.log(simTimer);
						//console.log(tokenAttributes.size.value.length)
						timerElement.innerHTML=""+simDataTime[Object.keys(simDataTime)[simTimer]][0][1];
						
						sliderElement.value=simTimer;
						simRow=simDataTime[Object.keys(simDataTime)[simTimer]];
						
						for (var i=segmentPts;i<b2lopacity.length;i++){
							if (b2lopacity[i]>0.0){
							b2lopacity[i]=0.2;
							}
						}
						
						for (var i=0, j=tokenAttributes.size.value.length ;i<j;i++){
							tokenAttributes.size.value[i]=80;
						}
						tokenAttributes.size.needsUpdate = true;
						
						var ln1 = startModelPlaces;
						var ln2 = startModelReactions;
						var cnt1=0;
						var cnt2 = 0;
						/*for(var j=3;j<simData[1][simTimer].length-1;j++){
							var min = simDataBounds[j-3][0];
							var max = simDataBounds[j-3][1];
							var size=30;
							if ((max-min)!=0){
								size = 30+(50*(simData[1][simTimer][j]-min)/(max-min))
								if (size>80){
									size = 80;
									//console.log("biiig "+ simData[1][simTimer][j])
									}
								if (isNaN(size)){
									size=30;
									//console.log("NaN "+simData[1][simTimer][j] + " "+min+" "+max );
								}
								//console.log(size);
								for(var j1=0;j1<selectedModelNodes.length;j1++){
									if (selectedModelNodes[j1][1]==simData[0][j]){
										//console.log(simData[0][j]);
										if (selectedModelNodes[j1][5]==2 ){
											scene.children[2].geometry.attributes.size.array[(ln1+cnt1)]= size;
											//bgeometryP3.attributes.size.array[(ln1+cnt1)]= size;
											//console.log("resize place"+(cnt1))
											cnt1++;
										}
										if (selectedModelNodes[j1][5]==4 ){
											scene.children[4].geometry.attributes.size.array[(ln2+cnt2)]= size;
											//bgeometryP5.attributes.size.array[(ln2+cnt2)]= size;
											//console.log("resize reaction"+size)
											cnt2++;
										}
									}
								}
							}
							//console.log(simData[0][j])
						}
						scene.children[2].geometry.attributes.size.needsUpdate = true;
						scene.children[4].geometry.attributes.size.needsUpdate = true;
						*/
						//console.log();
						//var nbTokens=Object.keys(startPositionTokenMap).length;
						var triggerOnceReaction=true;
						var namePresentReaction="";
						var counterReactionLinks=0;
						
							//modelProductLocators[v].position.set(50000,50000,-50000);
							//console.log(modelProductLocators[v])
						//}
						for (var tk= 0; tk<selectedModelEdges.length;tk++){
							//console.log("aaa");
							
							// if link between model reaction and model place, create token
							if (selectedModelEdges[tk][3]==1){
								// add different possiblities from the simDataTime[Object.keys(simDataTime)[simTimer]][0][1];
								//if (selectedModelNodes[selectedModelEdges[tk][0]][1]==simData[1][simTimer][2]){
								for (var rw=0;rw<simRow.length;rw++){
									if (selectedModelNodes[selectedModelEdges[tk][0]][1]==simRow[rw][2]){
										
										//if (simRow.length>1){console.log(simRow[rw-1][2]+"  "+simRow[rw][2])}
										if (allFalse){
											//console.log("allFalse is true")
											if (namePresentReaction!=simRow[rw][2]){
												namePresentReaction=simRow[rw][2];
												counterReactionLinks=1;
											}
											else{
												counterReactionLinks++;
											}
											
											var nb;
											if (clearedTokenIndex.length>0){
												nb=clearedTokenIndex.pop();	
												stackTokenModel[nb]=[0,nb,selectedModelEdges[tk][0],selectedModelEdges[tk][1],1,true,selectedModelEdges[tk][2],counterReactionLinks-1];		
												//tokenAttributes.size.value[nb]=0;
						
												//tokenStackCount-=1;								
											}
											else{
												nb=stackTokenModel.length;		
												stackTokenModel.push([0,nb,selectedModelEdges[tk][0],selectedModelEdges[tk][1],1,true,selectedModelEdges[tk][2],counterReactionLinks-1]);	
												//tokenAttributes.size.value[nb]=0;
											}
											// stackTokenModel element: mixamount value, id of token, pt1 model node id, pt2 model node id, type of link (1= model/model or 2 =model/sim) 
											//console.log(stackTokenModel.length)
											tokenStackCount+=1;
											tokenAttributes.mixAmount.value[nb]=0;
											// if reaction to post-place orient token
											if(counterReactionLinks-1==0){
												for (var ct=0;ct<10;ct++){
													planeMesh[ct].position.set(0,0,-150000);
												}
												for(var v=0;v<nbModelReactionLocators;v++){
													modelReactantLocators[v].position.set(50000,50000,-150000);
													modelModifierLocators[v].position.set(50000,50000,-150000);
												}
											}
											
											if(selectedModelEdges[tk][2]==1){
											
												//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])]=1.0;
												//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])+1]=1.0;
												
												
												
						
												scene.children[8].geometry.vertices[nb].x=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) ]+0;
												scene.children[8].geometry.vertices[nb].y=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 1 ]+0;
												scene.children[8].geometry.vertices[nb].z=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 2 ]+0;
												tokenAttributes.endPosition.value[nb].x=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) ]+0;
												tokenAttributes.endPosition.value[nb].y=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 1 ]+0;
												tokenAttributes.endPosition.value[nb].z=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 2 ]+0;
												modelProductLocators[counterReactionLinks-1].position.set(tokenAttributes.endPosition.value[nb].x,tokenAttributes.endPosition.value[nb].y,tokenAttributes.endPosition.value[nb].z);
												// change color
												tokenAttributes.ca.value[nb]= new THREE.Color( 0xff0000 );
												
					
												planeMesh[counterReactionLinks-1].position.set(0,0,0);
												planeMesh[counterReactionLinks-1].geometry.vertices[0].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[0].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[0].z=scene.children[8].geometry.vertices[nb].z-5;
												planeMesh[counterReactionLinks-1].geometry.vertices[2].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[2].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[2].z=scene.children[8].geometry.vertices[nb].z+5;
												planeMesh[counterReactionLinks-1].geometry.vertices[1].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[1].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[1].z=tokenAttributes.endPosition.value[nb].z-5;
												planeMesh[counterReactionLinks-1].geometry.vertices[3].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[3].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[3].z=tokenAttributes.endPosition.value[nb].z+5;
												planeMesh[counterReactionLinks-1].geometry.verticesNeedUpdate=true;
												//planeMesh[counterReactionLinks-1].material.transparent = true;
												//planeMesh[counterReactionLinks-1].material.opacity = 0.6;
												planeMesh[counterReactionLinks-1].material.blending=false;
											
												//console.log(tokenAttributes.ca.value[nb])
												//modelReactantLocators[counterReactionLinks-1].position.set(50000,50000,-50000);
												//modelModifierLocators[counterReactionLinks-1].position.set(50000,50000,-50000);
											}
											// if preplace to reaction
											if(selectedModelEdges[tk][2]!=1){
												//console.log(selectedModelEdges[tk][0]);
												//console.log(selectedModelEdges[tk][1]);
												//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-1]=1.0;
												//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-2]=1.0;
												//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-3]=1.0;
												//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-4]=1.0;
												scene.children[8].geometry.vertices[nb].x=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) ]+0;
												scene.children[8].geometry.vertices[nb].y=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 1 ]+0;
												scene.children[8].geometry.vertices[nb].z=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 2 ]+0;
												tokenAttributes.endPosition.value[nb].x=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) ]+0;
												tokenAttributes.endPosition.value[nb].y=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 1 ]+0;
												tokenAttributes.endPosition.value[nb].z=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 2 ]+0;
												// change color
												tokenAttributes.ca.value[nb]= new THREE.Color( 0x0000ff );
												
												planeMesh[counterReactionLinks-1].position.set(0,0,0);
												planeMesh[counterReactionLinks-1].geometry.vertices[0].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[0].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[0].z=scene.children[8].geometry.vertices[nb].z-5;
												planeMesh[counterReactionLinks-1].geometry.vertices[2].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[2].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[2].z=scene.children[8].geometry.vertices[nb].z+5;
												planeMesh[counterReactionLinks-1].geometry.vertices[1].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[1].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[1].z=tokenAttributes.endPosition.value[nb].z-5;
												planeMesh[counterReactionLinks-1].geometry.vertices[3].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[3].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[3].z=tokenAttributes.endPosition.value[nb].z+5;
												planeMesh[counterReactionLinks-1].geometry.verticesNeedUpdate=true;
												//planeMesh[counterReactionLinks-1].material.transparent = true;
												//planeMesh[counterReactionLinks-1].material.opacity = 0.6;
												planeMesh[counterReactionLinks-1].material.blending=false;
												
												if (selectedModelEdges[tk][2]==0){
													modelReactantLocators[counterReactionLinks-1].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z+10);
													//modelModifierLocators[counterReactionLinks-1].position.set(50000,50000,-50000);
													//modelProductLocators[counterReactionLinks-1].position.set(50000,50000,-50000);
												}
												if (selectedModelEdges[tk][2]==2){
													modelModifierLocators[counterReactionLinks-1].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
													//modelReactantLocators[counterReactionLinks-1].position.set(50000,50000,-50000);
													//modelProductLocators[counterReactionLinks-1].position.set(50000,50000,-50000);
												}
												
												
												
											}
											
											
											tokenAttributes.size.value[nb] = 30.0;
											// if consumed pre-place
											//if (selectedModelEdges[tk][2]==0){
														
											//	}
											// if non-consumed pre-place
											//if (selectedModelEdges[tk][2]==2){
														
											//	}
											// if postplace
											//if (selectedModelEdges[tk][2]==1){
														
											//	}
											//console.log(selectedModelEdges[tk]);
											//console.log(counterReactionLinks)
											//modelProductLocators[rw].position.set(tokenAttributes.endPosition.value[nb].x,tokenAttributes.endPosition.value[nb].y,tokenAttributes.endPosition.value[nb].z);
											
											if (tokenIDStackCount.hasOwnProperty(simRow[rw][2]) && triggerOnceReaction==true ) {
													
													tokenIDStackCount[simRow[rw][2]][0]+=1;
													if(selectedModelEdges[tk][2]!=1){
														modelReactionLocators[rw].position.set(tokenAttributes.endPosition.value[nb].x,tokenAttributes.endPosition.value[nb].y,tokenAttributes.endPosition.value[nb].z);
														//modelProductLocators[rw].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
													}
													if(selectedModelEdges[tk][2]==1){
														modelReactionLocators[rw].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
														//modelProductLocators[counterReactionLinks-1].position.set(tokenAttributes.endPosition.value[nb].x,tokenAttributes.endPosition.value[nb].y,tokenAttributes.endPosition.value[nb].z);
														
													}
													
													
													
													
													//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
													triggerOnceReaction=false;
													
											}
											else{
												
												if( triggerOnceReaction==true){
												
												//modelReactionLocators[rw].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
												if(selectedModelEdges[tk][2]!=1){
														tokenIDStackCount[simRow[rw][2]]=[1,tokenAttributes.endPosition.value[nb].x,tokenAttributes.endPosition.value[nb].y,tokenAttributes.endPosition.value[nb].z];
														modelReactionLocators[rw].position.set(tokenAttributes.endPosition.value[nb].x,tokenAttributes.endPosition.value[nb].y,tokenAttributes.endPosition.value[nb].z);
														//console.log(tokenIDStackCount[simRow[rw][2]])
													}
												if(selectedModelEdges[tk][2]==1){
														tokenIDStackCount[simRow[rw][2]]=[1,scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z];
														modelReactionLocators[rw].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
														//console.log(tokenIDStackCount[simRow[rw][2]])
													}
												triggerOnceReaction=false;
												//console.log(selectedModelEdges[tk]);
												//console.log(selectedModelEdges[tk]);
												//console.log(tokenIDStackCount);
												//var vectorp = new THREE.Vector3( scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
												//vectorp.x +=10;
												//var ppv = toXYCoords(vectorp	);
												//txtReactionActivation[cntLabels].style.top = ppv.y + 'px';
												//txtReactionActivation[cntLabels].style.left = ppv.x + 'px';
												//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
												}
												
												//var vectorp = new THREE.Vector3( scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
												//vectorp.x +=10;
												//var ppv = toXYCoords(vectorp	);
												//txtReactionActivation[cntLabels].style.top = ppv.y + 'px';
												//txtReactionActivation[cntLabels].style.left = ppv.x + 'px';
												//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
											}
											
											//cntLabels++;
										}
									}
									
								}
							}
							
						}
						//scene.children[7].geometry.attributes.op.needsUpdate = true;
						tokenAttributes.mixAmount.needsUpdate = true;
						tokenAttributes.ca.needsUpdate = true;
						scene.children[8].geometry.verticesNeedUpdate = true;
						tokenAttributes.endPosition.needsUpdate = true;
						tokenAttributes.size.needsUpdate = true;
						if (allFalse){
							
							simTimer++;
							reactionIsDone=false;
							//console.log("allfalse true and reactiondone false")
						}
						
						
						
						
					}
					if (simModeValue==2 ){
						//console.log(selectedModelNodes)
						//timerElement.innerHTML=""+simData[1][simTimer][1];
						timerElement.innerHTML=""+simDataTime[Object.keys(simDataTime)[simTimer]][0][1];
						sliderElement.value=simTimer;
						simRow=[simData[1][simTimer]];
						var ln1 = startModelPlaces;
						var ln2 = startModelReactions;
						var cnt1=0;
						var cnt2 = 0;
						for(var j=3;j<simData[1][simTimer].length-1;j++){
							var min = simDataBounds[j-3][0];
							var max = simDataBounds[j-3][1];
							var val =simData[1][simTimer][j];
							var size=30;
							if ((max-min)!=0){
								size = 30+(50*(simData[1][simTimer][j]-min)/(max-min))
								if (size>80){
									size = 80;
									//console.log("biiig "+ simData[1][simTimer][j])
									}
								if (isNaN(size)){
									size=30;
									//console.log("NaN "+simData[1][simTimer][j] + " "+min+" "+max );
								}
								
								listChangingKeggCoordinates=[];
								//console.log(size);
								for(var j1=0;j1<selectedModelNodes.length;j1++){
									if (selectedModelNodes[j1][1]==simData[0][j]){
										//console.log(simData[0][j]);
										if (selectedModelNodes[j1][5]==2 ){
											scene.children[2].geometry.attributes.size.array[(ln1+cnt1)]= size;
											//console.log(idMap[ln1+cnt1]);
											if (selectedModelNodes[j1][7]==3){
												for (var ed= 0; ed<selectedModelEdges.length;ed++){
													if ((selectedModelEdges[ed][0]==selectedModelNodes[j1][0]) && selectedModelEdges[ed][3]==2){
														//console.log(selectedModelEdges[ed][0]+"to metabolic :"+jsonObj1[selectedModelEdges[ed][1]][1])
														if (jsonObj1[selectedModelEdges[ed][1]][4][1][2] && jsonObj1[selectedModelEdges[ed][1]][4][1][2].length>0){
															//console.log(jsonObj1[selectedModelEdges[ed][1]][4][1][2])
															//listChangingKeggCoordinates.push([jsonObj1[selectedModelEdges[ed][1]][4][1][2][0],size])
															for (var kk = 0; kk<jsonObj1[selectedModelEdges[ed][1]][4][1][2].length;kk++){
																listChangingKeggCoordinates.push([jsonObj1[selectedModelEdges[ed][1]][4][1][2][kk],size-30,jsonObj1[selectedModelEdges[ed][1]][4][1][1],val])
															}
															
														}
													}
												}
												
											}
											//bgeometryP3.attributes.size.array[(ln1+cnt1)]= size;
											//console.log("resize place"+(cnt1))
											cnt1++;
										}
										if (selectedModelNodes[j1][5]==4 ){
											scene.children[4].geometry.attributes.size.array[(ln2+cnt2)]= size;
											//console.log("node reaction index"+(ln2+cnt2))
											//bgeometryP5.attributes.size.array[(ln2+cnt2)]= size;
											//console.log("resize reaction"+size)
											cnt2++;
										}
									}
								}
								if (previousKeggLength<listChangingKeggCoordinates.length){
								previousKeggLength=listChangingKeggCoordinates.length;
								}
								//console.log(listChangingKeggCoordinates)
								//console.log(listChangingKeggCoordinates.length)
								/*
								var iv =0;
								for ( var i = 0; i < keggSegment.length; i ++ ) {
									keggPositions[ (iv * 3)+0 ] = 50000;
									keggPositions[ (iv * 3) + 1 ] = 0;
									keggPositions[ (iv * 3) + 2 ] = -50000;
									//keggColors[ iv * 3 ] = col.r;
									//keggColors[ iv * 3 + 1 ] = col.g;
									//keggColors[ iv * 3 + 2 ] = col.b;
									iv++;
									keggPositions[ (iv * 3)+0 ] = 50000;
									keggPositions[ (iv * 3) + 1 ] = 0;
									keggPositions[ (iv * 3) + 2 ] = -50000;
									//keggColors[ iv * 3 ] = col.r;
									//keggColors[ iv * 3 + 1 ] = col.g;
									//keggColors[ iv * 3 + 2 ] = col.b;
									iv++
								}
								var iv =0;
								for ( var i = 0; i < listChangingKeggCoordinates.length; i ++ ) {
									keggPositions[ (iv * 3)+0 ] = (listChangingKeggCoordinates[i][0][0]*0.69605)+3000-450;
									keggPositions[ (iv * 3) + 1 ] = 200;
									keggPositions[ (iv * 3) + 2 ] = (listChangingKeggCoordinates[i][0][1]*0.69605)-273;
									//keggColors[ iv * 3 ] = col.r;
									//keggColors[ iv * 3 + 1 ] = col.g;
									//keggColors[ iv * 3 + 2 ] = col.b;
									iv++;
									keggPositions[ (iv * 3)+0 ] = (listChangingKeggCoordinates[i][0][0]*0.69605)+3000-450;
									keggPositions[ (iv * 3) + 1 ] = 200+(listChangingKeggCoordinates[i][1]*3);
									keggPositions[ (iv * 3) + 2 ] = (listChangingKeggCoordinates[i][0][1]*0.69605)-273;
									//keggColors[ iv * 3 ] = col.r;
									//keggColors[ iv * 3 + 1 ] = col.g;
									//keggColors[ iv * 3 + 2 ] = col.b;
									iv++
								}
								
								
								keggPositions.needsUpdate = true;
								geometryKegg.attributes.position.needsUpdate = true;
								*/
								//for ( var i = listChangingKeggCoordinates.length; i < 1000; i ++ ) {
								//	cubesGeometry[i].position.x=50000;
								//	cubesGeometry[i].position.y=200;
								//	cubesGeometry[i].position.z=-50000;
								//}
								//console.log(listChangingKeggCoordinates.length)
								for ( var i = 0; i < listChangingKeggCoordinates.length; i ++ ) {
			
									//console.log(cubesGeometry[i])
									//cubesGeometry[i].position.x=(listChangingKeggCoordinates[i][0][0]*0.69605)+3000-450;
									//cubesGeometry[i].position.y=200+(listChangingKeggCoordinates[i][1]*1.5);
									//cubesGeometry[i].position.z=(listChangingKeggCoordinates[i][0][1]*0.69605)-273;
									cubesGeometry[i].position.x=3000+(listChangingKeggCoordinates[i][0][1]*0.69605)-273;
									cubesGeometry[i].position.y=200+(listChangingKeggCoordinates[i][1]*1.5);
									cubesGeometry[i].position.z=-(listChangingKeggCoordinates[i][0][0]*0.69605)+450;
									
									if (listChangingKeggCoordinates[i][1]!=0){
									cubesGeometry[i].scale.y =(listChangingKeggCoordinates[i][1]*3);
									}
									else{
									cubesGeometry[i].scale.y =1;
									}
									keggCubesProperties["k"+i]=[listChangingKeggCoordinates[i][2],listChangingKeggCoordinates[i][3]]
									
								}
								//bgeometry2.attributes.ca.needsUpdate = true;
								/*var iv=0;
								for ( var i = 0; i < keggSegment; i ++ ) {
									keggPositions[ (iv * 3)+0 ] = iv*100;
									keggPositions[ (iv * 3) + 1 ] = 0;
									keggPositions[ (iv * 3) + 2 ] = iv*100;
									//keggColors[ iv * 3 ] = col.r;
									//keggColors[ iv * 3 + 1 ] = col.g;
									//keggColors[ iv * 3 + 2 ] = col.b;
									iv++;
									keggPositions[ (iv * 3)+0 ] = (iv-1)*100;
									keggPositions[ (iv * 3) + 1 ] = size;
									keggPositions[ (iv * 3) + 2 ] = (iv-1)*100;
									//keggColors[ iv * 3 ] = col.r;
									//keggColors[ iv * 3 + 1 ] = col.g;
									//keggColors[ iv * 3 + 2 ] = col.b;
									iv++
								}*/
								
							}
							//console.log(simData[0][j])
						}
						scene.children[2].geometry.attributes.size.needsUpdate = true;
						scene.children[4].geometry.attributes.size.needsUpdate = true;
						simTimer++;
					}
					//console.log(simRow)
					
					//setAttribute("value", simTimer);
					// change property of model nodes to express flux
					
					// change nodes size according to flux values (take into account boundaries as min/max values)
					
					
					
						
					
					
						
					
					
					//simTimer++;
					
				}
				else{
				
					if (tokenStackCount<=0){
						simTimer=0;
						simulationIsOn=false;
						for (var ii=0;ii<stackTokenModel.length;ii++) {
							stackTokenModel[ii][5]==false
						}
						
						
						for (var tkNb=0; tkNb< txtReactionActivation.length;tkNb++){	
							txtReactionActivation[tkNb].innerHTML = '';
						}
						for (var i=segmentPts;i<b2lopacity.length;i++){	
							b2lopacity[i]=0.7;	
						}
						scene.children[7].geometry.attributes.op.needsUpdate = true;
						allfalse=true;
						//stackTokenModel=[];
						reactionIsDone=false;
						flowsStack=[];
						for(var i=0;i<nbModelPlanesFlow;i++){
							planeMesh[i].position.set(0,0,50000);
						}
						tokenIDStackCount={};
						
						
		
					}
				}
				
				//if (simData && simTimer<simData.length){
				//	console.log(simData[simTimer])
				//}
				
			

				//tokenIDStackCount;
				//for (var reac in tokenIDStackCount) {
				//	if (tokenIDStackCount.hasOwnProperty(reac)) {
						
				//	}	
				//}
			}
			
			if (simulationIsPaused==false && tokenStackCount>0 && simulationIsOn==true){
				//console.log(tokenStackCount)
				
				for (var ii=0;ii<stackTokenModel.length;ii++) {
						
						//if (stackTokenModel[ii] && stackTokenModel[ii][0]){
							//console.log(stackTokenModel[ii][5])
							//for (var j =0;j<stackTokenModel[ii].length;j++){
							
								if (stackTokenModel[ii][0]<1 && stackTokenModel[ii][5]==true){
									//console.log(stackTokenModel[ii][0])
									//console.log(stackTokenModel[ii][6])
									if (stackTokenModel[ii][6]!=1){
										//console.log("animate ")
										if (simModeValue==0){
										stackTokenModel[ii][0]+=0.001;					
										}
										if (simModeValue==1){
										
										stackTokenModel[ii][0]+=0.025;
										}
										tokenAttributes.mixAmount.value[stackTokenModel[ii][1]]=stackTokenModel[ii][0];
									}
									if (stackTokenModel[ii][6]==1 ){
									//console.log("animate 2")
										if (simModeValue==0){
										stackTokenModel[ii][0]+=0.001;
										}
										if (simModeValue==1 && reactionIsDone){
										stackTokenModel[ii][0]+=0.025;
										}
										if (simModeValue==1 && reactionIsDone==false && stackTokenModel.length==1){
											
											stackTokenModel[ii][0]+=0.025;
											if (stackTokenModel[ii][0]>=1.0){
												modelProductLocators[stackTokenModel[ii][7]].position.set(50000,50000,-50000);
											}
										}
										tokenAttributes.mixAmount.value[stackTokenModel[ii][1]]=stackTokenModel[ii][0];
										
									}
									//console.log(stackTokenModel[ii][0]);
									
									//tokenAttributes.mixAmount.value[stackTokenModel[ii][1]]=stackTokenModel[ii][0];
								}
								//else if (stackTokenModel[ii][0]<1 && stackTokenModel[ii][5]==false){
								else if (stackTokenModel[ii][0]<1 && stackTokenModel[ii][5]==false){
								//console.log("animate 3")
									scene.children[8].geometry.vertices[stackTokenModel[ii][1]].z-=50000;
									// erase product/modifier/reactant signs if necessary
									if (stackTokenModel[ii][7]){
										if (stackTokenModel[ii][6]==0){ // reactant
											//modelReactantLocators[stackTokenModel[ii][7]].position.set(50000,50000,-50000);
										}
										else if (stackTokenModel[ii][6]==1){ // product
											modelProductLocators[stackTokenModel[ii][7]].position.set(50000,50000,-50000);
										}	
										else if (stackTokenModel[ii][6]==2){// modifier
											//modelModifierLocators[stackTokenModel[ii][7]].position.set(50000,50000,-50000);
										}
										else{}
									}
									
									//console.log(stackTokenModel[ii][0]);
									
									//tokenAttributes.mixAmount.value[stackTokenModel[ii][1]]=stackTokenModel[ii][0];
								}
								else {
									//console.log("animate 4")
									/*if (simModeValue==0 ){
										planeMesh[stackModel2PlaneMesh[ii]].geometry.vertices[0].z-=(0.03);
										planeMesh[stackModel2PlaneMesh[ii]].geometry.vertices[2].z+=(0.03);
										planeMesh[stackModel2PlaneMesh[ii]].geometry.vertices[1].z-=(0.03);
										planeMesh[stackModel2PlaneMesh[ii]].geometry.vertices[3].z+=(0.03);
										planeMesh[stackModel2PlaneMesh[ii]].geometry.verticesNeedUpdate=true;
									}*/
									
									if (stackTokenModel[ii][6]!=1 ){
										
										reactionIsDone=true;
									}
									tokenAttributes.mixAmount.value[ii]=0;
									//tokenAttributes.mixAmount.value[stackTokenModel[ii][1]]=0;
									clearedTokenIndex.push(stackTokenModel[ii][1]);
									stackTokenModel[ii][0]=0;
									
									if(tokenStackCount>0){
										tokenStackCount-=1;
									}
									stackTokenModel[ii][5]=false;
									if (stackTokenModel[ii][7] ){
										if (stackTokenModel[ii][6]==0){ // reactant
											//modelReactantLocators[stackTokenModel[ii][7]].position.set(50000,50000,-50000);
										}
										else if (stackTokenModel[ii][6]==1){ // product
											modelProductLocators[stackTokenModel[ii][7]].position.set(50000,50000,-50000);
										}	
										else if (stackTokenModel[ii][6]==2){// modifier
											//modelModifierLocators[stackTokenModel[ii][7]].position.set(50000,50000,-50000);
										}
										else{}										
									}
									//erasingArray.push(ii);
									//stackTokenModel.splice(ii,1);
									
									
									//console.log(tokenStackCount)
									//console.log(clearedTokenIndex.length);
								}
								
							
							//}

						
						//}
					
				}
				allFalse=true;
				for (var ii=0;ii<stackTokenModel.length;ii++) {
					if (stackTokenModel[ii][5]==true){
						allFalse=false;
					}
				}
				//if (stackTokenModel.length==1){
				//	reactionIsDone=true;
				//}
				
				
				//console.log(stackTokenModel.length)	
				
				
			}
			
			//for (var ii=0;ii<erasingArray.length;ii++){
			//tokenAttributes.mixAmount.value[stackTokenModel[ii][1]]=0;
			//stackTokenModel.splice(erasingArray[ii],1);
			//}
			//var t = clock.getElapsedTime();
			//tokenUniforms.mixAmount.value = 0.5 * (1.0 + Math.sin(t));
			//console.log(stackTokenModel.length)
			//tokenUniforms.mixAmount.value = 0.5 * (1.0 + Math.sin(t));
			//var ii=0;
			//for ( var i = 0; i <segmentPts ; i +=2 ) {
			//	tokenAttributes.mixAmount.value[i] = 0.5 * (1.0 + Math.sin(t));
			//}
			/*for (var ii=0;ii<stackTokenModel.length;ii++) {
				
					if (stackTokenModel[ii]){
						//for (var j =0;j<stackTokenModel[ii].length;j++){
						if (stackTokenModel[ii][0]){
							if (stackTokenModel[ii][0]<1){
								stackTokenModel[ii][0]+=0.005;
								tokenAttributes.mixAmount.value[stackTokenModel[ii][2]]=stackTokenModel[ii][j][0];
							}
							if (stackTokenModel[ii][0]>=1){
								
								//tokenAttributes.mixAmount.value[ii]=0;
								tokenAttributes.mixAmount.value[stackTokenModel[ii][2]]=0;
								stackTokenModel.splice(ii,1);
								tokenStackCount-=1;
								//console.log(tokenStackCount);
							}
						}
						//}

					
					}
				
			}*/
			
				//ii++;
			//}
			// trigger start of token from/to reactions
			//if (simData && simTimer<simData.length){
			//console.log("trigger: "+simData[1][simTimer][2])
			//}
			
			tokenAttributes.mixAmount.needsUpdate = true;
			//var tokenPoses =tokenAttributes.mixAmount.value;
			//for ( var i = 1; i <segmentPts ; i +=2 ) {
			//	
			//}
			//rendererCSS.render( cssScene, camera2 );
			//rendererCSS3.render( cssScene3, camera2 );
			//rendererCSS2.render( cssScene2, camera2 );
			renderer.render( scene, camera );
			//renderer2.render( scene2, camera2 );
			
			if (idsOfSelectedRows.length>0){
				for (var i =0;i<spritesSelected.length;i++){		
					spritesSelected[i].position.set(-50000,-10000,10000);
					spritesSelected[i].scale.set(100, 100, 100);
				}
				
				for (var i =0;i<idsOfSelectedRows.length;i++){
					if (i<spritesSelected.length){
						var a1 = scene.children[idMap[idsOfSelectedRows[i]][0]].geometry.attributes.position.array;
						//console.log(idMap[idsOfSelectedRows[i]])
						spritesSelected[i].position.set(a1[idMap[idsOfSelectedRows[i]][1]*3],a1[idMap[idsOfSelectedRows[i]][1]*3+1],a1[idMap[idsOfSelectedRows[i]][1]*3+2]);			
					}
				}
				for (var i =0;i<idsOfSelectedRows.length;i++){
					//for (var j =0;j<spritesSelected.length;j++){
					if (i<spritesSelected.length){
						var dx= camera.position.x-spritesSelected[i].position.x
						var dy= camera.position.y-spritesSelected[i].position.y
						var dz= camera.position.z-spritesSelected[i].position.z
						var dc = Math.sqrt(((dx*dx) + (dy*dy)))
						var ds = Math.sqrt((dc*dc) + (dz*dz))
						var mult = ((ds/100)*5)+20
						spritesSelected[i].scale.set(mult, mult, mult);
					}
				}
			}
			else{
				for (var i =0;i<spritesSelected.length;i++){		
					spritesSelected[i].position.set(-50000,-10000,10000);
					spritesSelected[i].scale.set(100, 100, 100);
				}
			}
			
			if (idsOfModelSelectedRows.length>0){
				for (var i =0;i<modelspritesSelected.length;i++){		
					modelspritesSelected[i].position.set(-50000,-10000,10000);
					modelspritesSelected[i].scale.set(100, 100, 100);
				}
				var anb=jsonObj1.length;
				for (var i =0;i<idsOfModelSelectedRows.length;i++){
					if (i<modelspritesSelected.length){
						var a1 = scene.children[idMap[parseInt(idsOfModelSelectedRows[i])+anb][0]].geometry.attributes.position.array;
						//console.log(idMap[(jsonObj1.length+1)])
						//console.log(jsonObj1.length)
						//console.log(parseInt(idsOfModelSelectedRows[i]))
						//console.log(idMap[parseInt(idsOfModelSelectedRows[i])+anb]);
						modelspritesSelected[i].position.set(a1[idMap[parseInt(idsOfModelSelectedRows[i])+anb][1]*3],a1[idMap[parseInt(idsOfModelSelectedRows[i])+anb][1]*3+1],a1[idMap[parseInt(idsOfModelSelectedRows[i])+anb][1]*3+2]);			
					}
				}
				for (var i =0;i<idsOfModelSelectedRows.length;i++){
					//for (var j =0;j<spritesSelected.length;j++){
					if (i<modelspritesSelected.length){
						var dx= camera.position.x-modelspritesSelected[i].position.x
						var dy= camera.position.y-modelspritesSelected[i].position.y
						var dz= camera.position.z-modelspritesSelected[i].position.z
						var dc = Math.sqrt(((dx*dx) + (dy*dy)))
						var ds = Math.sqrt((dc*dc) + (dz*dz))
						var mult = ((ds/100)*5)+20
						modelspritesSelected[i].scale.set(mult, mult, mult);
					}
				}
			}
			else{
				for (var i =0;i<modelspritesSelected.length;i++){		
					modelspritesSelected[i].position.set(-50000,-10000,10000);
					modelspritesSelected[i].scale.set(100, 100, 100);
				}
			}
		/*if(typeof(Storage)!=="undefined") {
			
				if(resetSpreadsheet==true){localStorage.selection=[];}
				if (localStorage.selection==""){
					mselectedList=[]
					//console.log("empty")
					for (var i =0;i<spritesSelected.length;i++){		
						spritesSelected[i].position.set(-50000,-10000,10000);
					}
				
				}
				else if (localStorage.selection.length>0 ){
					//console.log(mselectedList); 
					//console.log(localStorage.selection.split(",").map(function(x){return parseInt(x)})); 
					
					var tmpS= localStorage.selection.split(",").map(function(x){return parseInt(x)});
					
					if(!($(tmpS).not(mselectedList).length == 0 && $(mselectedList).not(tmpS).length == 0)) {
					//	console.log(localStorage.selection); 
						mselectedList=[];
						for (var i =0;i<tmpS.length;i++){
						mselectedList[i] =tmpS[i];
						}
						//console.log(mselectedList); 
						//console.log(camera.position)
						// highlight selection
						for (var i =0;i<spritesSelected.length;i++){		
							spritesSelected[i].position.set(-50000,-10000,10000);
							spritesSelected[i].scale.set(100, 100, 100);
						}
						//if(resetSpreadsheet==true){
						//resetSpreadsheet=false;
						//}
						//else{
						for (var i =0;i<mselectedList.length;i++){
							//for (var j =0;j<spritesSelected.length;j++){
							if (i<spritesSelected.length){
								//spritesSelected
								//console.log(idMap[mselectedList[i]])
								var a1 = scene.children[idMap[mselectedList[i]][0]].geometry.attributes.position.array;
								spritesSelected[i].position.set(a1[idMap[mselectedList[i]][1]*3],a1[idMap[mselectedList[i]][1]*3+1],a1[idMap[mselectedList[i]][1]*3+2]);	
								//var dx= camera.position.x-spritesSelected[i].position.x
								//var dy= camera.position.y-spritesSelected[i].position.y
								//var dz= camera.position.z-spritesSelected[i].position.z
								//var dc = Math.sqrt(((dx*dx) + (dy*dy)))
								//var ds = Math.sqrt((dc*dc) + (dz*dz))
								//var mult = ((ds/100)*5)+50
								//spritesSelected[i].scale.set(mult, mult, mult);
								//console.log(ds)
								
							}
							
						}
						
						//}
						
					}
				
					for (var i =0;i<mselectedList.length;i++){
							//for (var j =0;j<spritesSelected.length;j++){
							if (i<spritesSelected.length){
								var dx= camera.position.x-spritesSelected[i].position.x
								var dy= camera.position.y-spritesSelected[i].position.y
								var dz= camera.position.z-spritesSelected[i].position.z
								var dc = Math.sqrt(((dx*dx) + (dy*dy)))
								var ds = Math.sqrt((dc*dc) + (dz*dz))
								var mult = ((ds/100)*5)+20
								spritesSelected[i].scale.set(mult, mult, mult);
							}
					}
					   
				}
			//else if 	(resetSpreadsheet==true){
			//	for (var i =0;i<spritesSelected.length;i++){		
			//				spritesSelected[i].position.set(-50000,-10000,10000);
			//				spritesSelected[i].scale.set(100, 100, 100);
			//			}
			//	resetSpreadsheet=false;
			//}		
        }*/
		
		
		if (exploded==true && spreadsheet1Visible==false){
			
			if (focus_label==0){
				for (var i=0;i<nbOrganelles;i++){
					var vector = new THREE.Vector3( organelles[i].position.x,organelles[i].position.y,organelles[i].position.z);
					vector.x +=500;
					var pp = toXYCoords(vector	);
					txtComp[i].style.top = (pp.y+$("#showresult").position().top + $("#showresult").height()+$("#visualisation").height()) + 'px';
					txtComp[i].style.left = pp.x + 'px';
					txtComp[i].innerHTML = nameComp[i];
				}
				var vector = new THREE.Vector3( nucleus.position.x,nucleus.position.y,nucleus.position.z);
				vector.x +=500;
				var pp = toXYCoords(vector	);
				txtComp[nbOrganelles].style.top = (pp.y+$("#showresult").position().top + $("#showresult").height()+$("#visualisation").height()) + 'px';
				txtComp[nbOrganelles].style.left = pp.x + 'px';
				txtComp[nbOrganelles].innerHTML = nameComp[nbOrganelles];
				var vector = new THREE.Vector3( cytoplasm.position.x,cytoplasm.position.y,cytoplasm.position.z);
				vector.x +=500;
				var pp = toXYCoords(vector	);
				txtComp[nbOrganelles+1].style.top = (pp.y+$("#showresult").position().top + $("#showresult").height()+$("#visualisation").height()) + 'px';
				txtComp[nbOrganelles+1].style.left = pp.x + 'px';
				txtComp[nbOrganelles+1].innerHTML = nameComp[nbOrganelles+1];
				var vector = new THREE.Vector3( ECM.position.x,ECM.position.y,ECM.position.z);
				vector.x +=500;
				var pp = toXYCoords(vector	);
				txtComp[nbOrganelles+2].style.top = (pp.y+$("#showresult").position().top + $("#showresult").height()+$("#visualisation").height()) + 'px';
				txtComp[nbOrganelles+2].style.left = pp.x + 'px';
				txtComp[nbOrganelles+2].innerHTML = nameComp[nbOrganelles+2];
				for (var d=0;d<allDragged.length;d++){
				if (allDragged[d].length>0){
					for (var di=0;di<allDragged[d].length;di++){
						
						
						txtComp[allDragged[d][di]].style.top = parseInt(txtComp[d].style.top)+18*(di+1)+"px"
						txtComp[allDragged[d][di]].style.left =parseInt(txtComp[d].style.left)+"px"
						//console.log(parseInt(txtComp[d].style.left))
					}						
				}
			}
			}
			if (focus_label>=1){
				for (var i=0;i<nbOrganelles;i++){
					
					txtComp[i].style.top = 2000 + 'px';
					txtComp[i].style.left = 2000 + 'px';
					
				}
				
				txtComp[nbOrganelles].style.top = 2000 + 'px';
				txtComp[nbOrganelles].style.left = 2000 + 'px';
				
				txtComp[nbOrganelles+1].style.top = 2000 + 'px';
				txtComp[nbOrganelles+1].style.left = 2000 + 'px';
				
				txtComp[nbOrganelles+2].style.top = 2000 + 'px';
				txtComp[nbOrganelles+2].style.left = 2000 + 'px';
				var vector;
				if ((focus_label-1)<nbOrganelles){
					vector = new THREE.Vector3( organelles[focus_label-1].position.x,organelles[focus_label-1].position.y,organelles[focus_label-1].position.z);
				}
				else{
					if (focus_label-1==nbOrganelles){
						vector = new THREE.Vector3( nucleus.position.x,nucleus.position.y,nucleus.position.z);
					}
					if (focus_label-1==nbOrganelles+1){
						vector = new THREE.Vector3( cytoplasm.position.x,cytoplasm.position.y,cytoplasm.position.z);
					}
					if (focus_label-1==nbOrganelles+2){
						vector = new THREE.Vector3( ECM.position.x,ECM.position.y,ECM.position.z);
					}
					
				}
					vector.x +=500;
					var pp = toXYCoords(vector	);
					txtComp[focus_label-1].style.top = (pp.y+$("#showresult").position().top + $("#showresult").height()+$("#visualisation").height()) + 'px';
					txtComp[focus_label-1].style.left = pp.x + 'px';
					txtComp[focus_label-1].innerHTML = nameComp[focus_label-1];
				
				
				
				
			}
		}
		else{
		
			for (var i=0;i<nbOrganelles;i++){
				
				txtComp[i].style.top = 2000 + 'px';
				txtComp[i].style.left = 2000 + 'px';
				
			}
			
			txtComp[nbOrganelles].style.top = 2000 + 'px';
			txtComp[nbOrganelles].style.left = 2000 + 'px';
			
			txtComp[nbOrganelles+1].style.top = 2000 + 'px';
			txtComp[nbOrganelles+1].style.left = 2000 + 'px';
			
			txtComp[nbOrganelles+2].style.top = 2000 + 'px';
			txtComp[nbOrganelles+2].style.left = 2000 + 'px';
			
			
			
			
		}
	
		
		if 	(resetSpreadsheet==true){
		resetSpreadsheet=false;
		}
		
		var tokenIDStackCountSize=Object.keys(tokenIDStackCount).length
		if( reactionIsDone && (simModeValue==1)){
			for (var tkNb=0; tkNb< tokenIDStackCountSize;tkNb++){
				
				var tmp=tokenIDStackCount[Object.keys(tokenIDStackCount)[tkNb]];
				
				//console.log(tokenIDStackCount[tkNb])
				txtReactionActivation[tkNb].innerHTML = ''+tmp[0];
				var vectorp = new THREE.Vector3( tmp[1],tmp[2],tmp[3]);
				vectorp.x +=10;
				var ppv = toXYCoords(vectorp	);
				txtReactionActivation[tkNb].style.top = (ppv.y+$("#showresult").position().top + $("#showresult").height()+$("#visualisation").height()) + 'px';
				txtReactionActivation[tkNb].style.left = ppv.x + 'px';
									//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
				
				
				
			}
		}
		else if( simModeValue==0){
			for (var tkNb=0; tkNb< tokenIDStackCountSize;tkNb++){
				
				var tmp=tokenIDStackCount[Object.keys(tokenIDStackCount)[tkNb]];
				
				//console.log(tokenIDStackCount[tkNb])
				txtReactionActivation[tkNb].innerHTML = ''+tmp[0];
				var vectorp = new THREE.Vector3( tmp[1],tmp[2],tmp[3]);
				vectorp.x +=10;
				var ppv = toXYCoords(vectorp	);
				txtReactionActivation[tkNb].style.top = (ppv.y+$("#showresult").position().top + $("#showresult").height()+$("#visualisation").height()) + 'px';
				txtReactionActivation[tkNb].style.left = ppv.x + 'px';
									//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
				//planeMesh[tkNb].position.set(0,0,50000);
				
				
			}
		}
		else{
			for (var tkNb=0; tkNb< tokenIDStackCountSize;tkNb++){
				
				
				txtReactionActivation[tkNb].innerHTML = '';
				//var vectorp = new THREE.Vector3( tmp[1],tmp[2],tmp[3]);
				//vectorp.x +=10;
				//var ppv = toXYCoords(vectorp	);
				//txtReactionActivation[tkNb].style.top = ppv.y + 'px';
				//txtReactionActivation[tkNb].style.left = ppv.x + 'px';
									//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
				
				
				
			}
		}
		
		//meshLineChart.direction=controls.direction;
		//meshLineChart.position.x=controls.target.x;
		//meshLineChart.position.y=controls.target.y;
		//meshLineChart.position.z=controls.target.z;
		//console.log(controls.target);
		//meshLineChart.lookAt(camera.position);
			//meshLineChart.position.set(camera.position);
			//meshLineChart.position.z+=400;
			//meshLineChart.direction=camera.direction;
		//mselectedList=[]
					//console.log("empty")
		//			for (var i =0;i<spritesSelected.length;i++){		
		//				spritesSelected[i].position.set(-50000,-10000,10000);
		//			}
		//}	
		

		}
	
		
		
		
		
		
		










//console.log(qm);
//console.log(headTitles);
//console.log(results);
for (var j=0;j<results.length;j++){
	if (results[j][1]=="Time"){
		console.log(j);
	}
}



var plotchartdata0=[];
for (var i=3;i<headTitles.length;i++){
	plotchartdata0[headTitles[i]]= [];
	for (var j=0;j<results.length;j++){
		if (isNaN(results[j][1])){
			console.log("problem at time not numbered"+ results[j][1])
			}
		plotchartdata0[headTitles[i]].push([results[j][1],results[j][i]]);
	}
	
}

var plotchartdata=[];
for (var i=3;i<headTitles.length;i++){
	
	for (var j=0;j<results.length;j++){
		plotchartdata.push({ symbol: headTitles[i], date: results[j][1] , price: results[j][i], event: results[j][2] });
	}
	
}

//console.log(plotchartdata0)

var params =<%-JSON.stringify( exp.parameters) %>
console.log(params)
//var format = d3.time.format("%L");
var jsondata =[[2, 64.64], [3, 64.66], [4, 64.52], [5, 64.39], [6, 64.23], [7, 64.2], [8, 64.28], [9, 64.27], [10, 64.3], [11, 64.235], [12, 64.34], [13, 64.5], [14, 64.5499], [15, 64.67], [16, 64.7], [17, 64.78], [18, 64.81], [19, 64.68], [21, 64.72], [22, 64.8], [23, 64.87], [24, 64.77], [25, 64.715], [26, 64.57], [27, 64.77], [28, 64.65], [29, 64.78], [30, 64.81], [31, 64.76], [32, 64.78], [33, 64.77], [34, 64.69], [35, 64.69], [36, 64.62], [37, 64.57], [38, 64.57], [39, 64.59], [40, 64.56], [41, 64.62], [42, 64.67], [43, 64.62], [44, 64.67], [45, 64.54], [46, 64.52], [47, 64.5], [49, 64.5], [50, 64.52], [51, 64.52], [52, 64.52], [53, 64.41], [54, 64.36], [55, 64.305], [57, 64.34], [58, 64.34], [59, 64.38], [61, 64.35], [62, 64.35], [64, 64.35], [65, 64.35], [66, 64.32], [69, 64.3196], [70, 64.38], [71, 64.38], [72, 64.26], [73, 64.21], [74, 64.15], [75, 64.15], [76, 64.04], [77, 63.96], [78, 63.97], [79, 63.89], [80, 63.934], [81, 63.99], [82, 64.0], [83, 63.91], [84, 64.01], [86, 64.0], [87, 64.03], [88, 64.03], [89, 64.01], [91, 64.03], [92, 64.03], [93, 64.1], [94, 64.11], [95, 64.13], [96, 64.1], [97, 64.075], [98, 64.09], [99, 64.07], [100, 64.03], [101, 64.03], [102, 64.025], [104, 64.03], [105, 64.01], [106, 64.08], [108, 64.085], [109, 64.08], [110, 64.065], [111, 64.07], [112, 64.03], [113, 64.03], [114, 64.06], [115, 64.1], [116, 64.085], [117, 64.09], [118, 64.14], [120, 64.1], [121, 64.055], [122, 64.085], [123, 64.08], [124, 64.05], [125, 64.07], [126, 64.09], [127, 64.06], [128, 64.08], [129, 64.09], [130, 64.12], [131, 64.12], [132, 64.1], [133, 64.12], [134, 64.13], [135, 64.19], [136, 64.2], [137, 64.21], [138, 64.19], [139, 64.205], [140, 64.2], [141, 64.24], [142, 64.22], [143, 64.2], [144, 64.2], [145, 64.2], [146, 64.185], [147, 64.18], [148, 64.2], [149, 64.2], [150, 64.205], [151, 64.24], [152, 64.225], [153, 64.19], [154, 64.255], [155, 64.29], [156, 64.26], [157, 64.245], [158, 64.25], [159, 64.27], [160, 64.29], [161, 64.3], [162, 64.31], [164, 64.248], [165, 64.23], [166, 64.21], [167, 64.2], [168, 64.23], [169, 64.23], [170, 64.24], [173, 64.22], [174, 64.23], [176, 64.249], [177, 64.27], [178, 64.28], [180, 64.28], [181, 64.26], [182, 64.27], [185, 64.31], [186, 64.3], [187, 64.3], [188, 64.28], [191, 64.295], [192, 64.295], [194, 64.32], [195, 64.34], [196, 64.36], [197, 64.37], [198, 64.41], [199, 64.43], [200, 64.44], [201, 64.46], [202, 64.45], [203, 64.4], [204, 64.43], [205, 64.44], [206, 64.43], [207, 64.43], [208, 64.435], [209, 64.47], [212, 64.46], [213, 64.46], [214, 64.45], [215, 64.45], [216, 64.46], [217, 64.5], [218, 64.5], [219, 64.52], [220, 64.52], [221, 64.5011], [222, 64.52], [224, 64.52], [225, 64.4925], [226, 64.5], [227, 64.54], [228, 64.61], [229, 64.63], [230, 64.63], [231, 64.63], [232, 64.73], [235, 64.71], [236, 64.76], [237, 64.79], [238, 64.8], [239, 64.7675], [240, 64.71], [241, 64.67], [242, 64.69], [243, 64.66], [244, 64.66], [245, 64.62], [246, 64.645], [247, 64.62], [248, 64.61], [249, 64.59], [250, 64.59], [251, 64.59], [252, 64.59], [253, 64.59], [254, 64.59], [255, 64.58], [256, 64.62], [261, 64.655], [262, 64.65], [264, 64.64], [265, 64.65], [266, 64.59], [267, 64.56], [268, 64.57], [269, 64.59], [270, 64.585], [271, 64.56], [272, 64.54], [273, 64.56], [274, 64.57], [275, 64.59], [277, 64.59], [278, 64.61], [279, 64.64], [280, 64.65], [282, 64.69], [283, 64.67], [284, 64.68], [285, 64.66], [286, 64.64], [287, 64.58], [288, 64.55], [289, 64.55], [290, 64.55], [292, 64.5525], [293, 64.57], [294, 64.58], [295, 64.58], [296, 64.5905], [297, 64.57], [298, 64.55], [300, 64.56], [301, 64.59], [302, 64.61], [304, 64.62], [305, 64.62], [306, 64.635], [307, 64.64], [308, 64.639], [309, 64.639], [310, 64.65], [311, 64.67], [312, 64.7], [313, 64.69], [314, 64.71], [315, 64.7], [316, 64.72], [317, 64.73], [318, 64.69], [320, 64.72], [321, 64.74], [322, 64.81], [323, 64.78], [324, 64.78], [325, 64.77], [326, 64.77], [327, 64.8], [328, 64.8], [329, 64.775], [330, 64.73], [331, 64.75], [333, 64.72], [334, 64.71], [335, 64.7175], [336, 64.73], [337, 64.74], [338, 64.8], [339, 64.84], [340, 64.8], [341, 64.78], [342, 64.8], [344, 64.81], [345, 64.83], [346, 64.83], [347, 64.87], [349, 64.87], [351, 64.92], [352, 64.88], [353, 64.88], [354, 64.88], [355, 64.86], [356, 64.8699], [357, 64.805], [358, 64.81], [359, 64.8], [360, 64.74], [361, 64.75], [364, 64.8], [365, 64.78], [366, 64.79], [368, 64.805], [369, 64.78], [371, 64.795], [372, 64.78], [373, 64.76], [374, 64.77], [376, 64.78], [377, 64.78], [378, 64.7798], [379, 64.77], [380, 64.74], [381, 64.75], [382, 64.75], [383, 64.75], [384, 64.73], [385, 64.75], [386, 64.78], [387, 64.755], [388, 64.76], [393, 64.77]];
var context = cubism.context().serverDelay(Date.now())
                                .step((params['simulations_p'][nbRes][0][3]/(results.length*1.0))) // Distance between data points in milliseconds
                                .size(results.length) // Number of data points
                                .stop();   // Fetching from a static data source; don't update values
			
           d3.select("#democ").append("div") // Add a vertical rule
              .attr("class", "rule")      // to the graph
              .call(context.rule());
			//document.getElementById("democ").style.width=results.length+"px";
			//document.getElementById("democ").style.width=($("#container").width()*0.8)+"px"
			//document.getElementById("democ").style.overflow="auto";
			//console.log(results.length)
            function stock(name) { 
                return context.metric(function(start, stop, step, callback) {
				
                    //d3.json(jsondata, function(rows) {
					rows = plotchartdata0[name];
					
					var allval=[]
					for (var i =0;i<rows.length;i++){
						allval.push(rows[i][1]);
					}
					var maxval=Math.max.apply( Math, allval );
					var minval=Math.min.apply( Math, allval );
					//console.log(rows)
                        var compare = rows[0][1], value = rows[0][1], values = [value];
                        
                        // Creates an array of the price differences throughout the day
                        rows.forEach(function(d) {
						if (maxval-minval!=0){
                            values.push(value = ((d[1]-minval)/(maxval-minval)) );
							}
						else
							values.push(value = ((d[1])) );
                        }); 
                    callback(null, values); //}); 
                }, name); 
            }


            function draw_graph(stocks_list) {
                d3.select("#demo")                 // Select the div on which we want to act           
                  .selectAll(".axis")              // This is a standard D3 mechanism to
                  .data(["top"])                   // bind data to a graph. In this case
                  .enter()                         // we're binding the axes "top" and "bottom".
                  .append("div")                   // Create two divs and 
                  .attr("class", function(d) {     // give them the classes
                    return d + " axis";            // top axis and bottom axis
                  })                               // respectively 
                  .each(function(d) {              // For each of these axes,
					d3.select(this)                // draw the axes with 4 intervals
                      .call(context.axis()         // and place them in their proper places
					  .ticks(20).tickFormat(d3.time.format("%L"))
                      .orient(d));  
                  });

				
                d3.select("#demo")                 
                  .selectAll(".horizon")           
                  .data(stocks_list.map(stock))    
                  .enter()                         
                  .insert("div", ".bottom")        // Insert the graph in a div  
                  .attr("class", "horizon")        // Turn the div into
                  .call(context.horizon()          // a horizon graph
                  .format(d3.format(".1p%")));    // Format the values to 1 floating-point decimals


                context.on("focus", function(i) {
					//format = d3.format(".1f");
                    d3.selectAll(".value").style("right",                  // Make the rule coincide 
                        i == null ? null : (context.size() - i-30) + "px");//.text(format(primary.valueAt(Math.floor(i))) + "\u00B0C"); // with the mouse
						//console.log(results.length)
						if (window.event && i != null){
							$("#mytooltip")
							.html(""+i+"/"+results.length)
							.css('left', window.event.clientX+40)
							.css('top', $('#democ').position().top+($( '.axis' ).height()/2))
							//.css('top', window.event.clientY)
							.css('height', 25)
							.css('width', 80)
							.show();
						}
						else{
							$("#mytooltip").html('').hide();
						}
                });
				
				
				
				//context.on('mouseover', function(d) {
				//	$("#mytooltip")
                //      .html("<b>okok</b><br>")
				//	  .css('left', window.event.clientX+40)
                //      .css('top', window.event.clientY)
                //      .show();
				//});
				//context.on("mouseout", function(d) {
				//	$("#mytooltip").html('').hide();
			   
				//});
            } 

            
			draw_graph(headTitles.slice(3));


document.getElementById("demo").style.width=results.length+"px";
document.getElementById("democ").style.width=($("#container").width()*0.98)+"px"
document.getElementById("democ").style.left=($("#container").width()*0.01)+"px"

//document.getElementById("demo").style.overflow="scroll";

var data = plotchartdata








var margin = {top: 8, right: window.innerWidth*0.1, bottom: 2, left: window.innerWidth*0.1},
    width = window.innerWidth - margin.left - margin.right,
    height = 69 - margin.top - margin.bottom;

//var parseDate = d3.time.format("%b %Y").parse;

var x = d3.time.scale()
    .range([0, width]);

var y = d3.scale.linear()
    .range([height, 0]);

var area = d3.svg.area()
    .x(function(d) { return x(d.date); })
    .y0(height)
    .y1(function(d) { return y(d.price); });

var line = d3.svg.line()
    .x(function(d) { return x(d.date); })
    .y(function(d) { return y(d.price); });

//d3.csv("stocks.csv", type, function(error, data) {

  // Nest data by symbol.
  var symbols = d3.nest()
      .key(function(d) { return d.symbol; })
      .entries(data);

  // Compute the maximum price per symbol, needed for the y-domain.
  symbols.forEach(function(s) {
    s.maxPrice = d3.max(s.values, function(d) { return d.price; });
  });

  // Compute the minimum and maximum date across symbols.
  // We assume values are sorted by date.
  x.domain([
    d3.min(symbols, function(s) { return s.values[0].date; }),
    d3.max(symbols, function(s) { return s.values[s.values.length - 1].date; })
  ]);

  // Add an SVG element for each symbol, with the desired dimensions and margin.
  var svg = d3.select("#mygraph").selectAll("svg")
      .data(symbols)
    .enter().append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  // Add the area path elements. Note: the y-domain is set per element.
  svg.append("path")
      .attr("class", "marea")
      .attr("d", function(d) { y.domain([0, d.maxPrice]); return area(d.values); });

  // Add the line path elements. Note: the y-domain is set per element.
  svg.append("path")
      .attr("class", "mline")
      .attr("d", function(d) { y.domain([0, d.maxPrice]); return line(d.values); });

  // Add a small label for the symbol name.
  svg.append("text")
      .attr("x", width - 6)
      .attr("y", height - 6)
      .style("text-anchor", "end")
      .text(function(d) { return d.key; });
//});

function type(d) {
  d.price = +d.price;
  d.date = d.date;
  return d;
}

//console.log($("#container").height())
//console.log($("#democ").height())
//console.log($("#visualisation").height())
//console.log($("#mygraph").height())

$("#container").css({top:  $("#showresult").position().top + $("#showresult").height()+$("#visualisation").height()});
$("#mygraph").css({top:  $("#container").position().top + $("#container").height()});
$("#democ").css({top:  $("#mygraph").position().top + $("#mygraph").height()});
$("#democ2").css({top:  $("#democ").position().top + $("#democ").height()});
$("#democ3").css({top:  $("#democ2").position().top + $("#democ2").height()});
/*
var width = $("#container").width(),
    height = screen.height*0.9,
    innerRadius = 40,
    outerRadius = (screen.height*0.7)/2;
var nbAxis = 4;
var angle = d3.scale.ordinal().domain(d3.range(nbAxis+1)).rangePoints([0, 2 * Math.PI]),
    radius = d3.scale.linear().range([innerRadius, outerRadius]),
    color = d3.scale.category10().domain(d3.range(20));

var nodes = [
  {x: 0, y: .1},
  {x: 0, y: .9},
  {x: 1, y: .2},
  {x: 1, y: .3},
  {x: 2, y: .1},
  {x: 2, y: .8},
  {x: 3, y: .5},
  {x: 3, y: .6}
];

for(var j=0;j<5000;j++){
		nodes.push({x:Math.floor((Math.random() * 4) ),y:Math.random()})
}


var links = [
  {source: nodes[0], target: nodes[2]},
  {source: nodes[1], target: nodes[3]},
  {source: nodes[2], target: nodes[4]},
  {source: nodes[2], target: nodes[5]},
  {source: nodes[3], target: nodes[5]},
  {source: nodes[4], target: nodes[0]},
  {source: nodes[5], target: nodes[1]},
  {source: nodes[6], target: nodes[1]}
];

for(var j=0;j<2000;j++){
		links.push({source: nodes[Math.floor((Math.random() * nodes.length) )], target: nodes[Math.floor((Math.random() * nodes.length) )]})
}

var svg2 = d3.select("#democ2").append("svg")
    .attr("width", width)
    .attr("height", height)
  .append("g")
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
//console.log(d3.range(nbAxis))
svg2.selectAll(".hvaxis")
    .data(d3.range(nbAxis))
  .enter().append("line")
    .attr("class", "hvaxis")
    .attr("transform", function(d) { return "rotate(" + degrees(angle(d)) + ")"})
    .attr("x1", radius.range()[0])
    .attr("x2", radius.range()[1]);

svg2.selectAll(".hvlink")
    .data(links)
  .enter().append("path")
    .attr("class", "hvlink")
    .attr("d", d3.hive.link(nbAxis)
		.angle(function(d) { return angle(d.x); })
		.radius(function(d) { return radius(d.y); }))
	.on("mouseover", linkMouseover)
    .on("mouseout", mouseout)
    .style("stroke", function(d) { return color(d.source.x); });
	

	

svg2.selectAll(".hvnode")
    .data(nodes)
  .enter().append("circle")
    .attr("class", "hvnode")
    .attr("transform", function(d) { return "rotate(" + degrees(angle(d.x)) + ")"; })
    .attr("cx", function(d) { return radius(d.y); })
    .attr("r", 2.0)
    .style("fill", function(d) { return color(d.x); })
	.on("mouseover", nodeMouseover)
    .on("mouseout", mouseout);

	
function nodeMouseover(d) {
	
	var neiNodeList = [];
	svg2.selectAll(".hvlink").classed("active", function (p) {
		
		if (p.source.x == d.x && p.source.y == d.y) {
			neiNodeList.push(p.target);
		}
		if (p.target.x == d.x && p.target.y == d.y ) {
			neiNodeList.push(p.source);
		}
		return p.source === d || p.target === d;
	});
	
	d3.select(this).classed("active", true);
	//nodename.text(d.name);
	//nodehiv.text(d.type);
	//nodegender.text(capitalizeFirstLetter(d.gender));
	//nodefriends.text(d.degree + " friends");

	//var percentfemale = d3.sum(neiNodeList.map(
	//	function (d) {
	//		return d.gender == 'female';
	//	})) / neiNodeList.length;
	//var percenthiv = d3.sum(neiNodeList.map(
	//	function (d) {
	//		return d.binaryAttribute;
	//	})) / neiNodeList.length;
	//var pfemale = d3.round(100 * percentfemale, 2) + "%";
	//var phiv = d3.round(100 * percenthiv, 2) + "%";

	//nodephiv.text(phiv + " of friends are HIV-Positive");
	//nodepfemale.text(pfemale + " of friends are female");
}	
function linkMouseover(d) {
			svg2.selectAll(".hvlink").classed("active", function (p) {
                return p === d;
            });
			//d3.select(this).classed("active", true);
            svg2.selectAll(".hvnode").classed("active", function (p) {
				
                return p === d.source || p === d.target;
            });
            //name1.text(d.source.node.name).style("fill", linkColor(d.typeByGender)).style("opacity", "0.75");
            //name2.text(d.target.node.name).style("fill", linkColor(d.typeByGender)).style("opacity", "0.75");
            //gender1.text(capitalizeFirstLetter(d.source.node.gender)).style("fill", linkColor(d.typeByGender)).style("opacity", "0.75");
            //gender2.text(capitalizeFirstLetter(d.target.node.gender)).style("fill", linkColor(d.typeByGender)).style("opacity", "0.75");
            //hiv1.text(d.source.node.type).style("fill", linkColor(d.typeByGender)).style("opacity", "0.75");
            //hiv2.text(d.target.node.type).style("fill", linkColor(d.typeByGender)).style("opacity", "0.75");
            //nodehiv.text("").style("fill", linkColor(d.typeByGender)).style("opacity", "0.75").style("font-size", "34");
}
// Clear any highlighted nodes or links.
function mouseout() {
	svg2.selectAll(".active").classed("active", false);
	
	//name1.text(defaultText);
	//name2.text(defaultText);
	//gender1.text(defaultText);
	//gender2.text(defaultText);
	//hiv1.text(defaultText);
	//hiv2.text(defaultText);
	//nodename.text(defaultText);
	//nodehiv.text(defaultText).style("font-size", "16").style("fill", "white").style("opacity", "1");
	//nodegender.text(defaultText);
	//nodefriends.text(defaultText);
	//nodephiv.text(defaultText);
	//nodepfemale.text(defaultText);
}	
	
function degrees(radians) {
  return radians / Math.PI * 180 - 90;
}

*/
function selectValue(el){
		var sl = document.getElementById("defaultSlider2")
			var amountScale = 0.1+(0.9*(parseFloat(sl.value)/100));
		if (parseInt(el.value)==0){
			console.log("default layout");
			
			var cnt1=0;
			var cnt2=0;
			var cnt=0;
			var radius=400;
			//var ln1 = scene.children[2].geometry.attributes.size.array.length-5000; 
			//var ln2 = scene.children[4].geometry.attributes.size.array.length-5000; 
			var ln1 = startModelPlaces;
			var ln2 = startModelReactions;
			//console.log(ln1)
			//console.log(startModelPlaces)
			for (var i= 0; i<selectedModelNodes.length;i++){
				if (selectedModelNodes[i][5]==2 ){
					//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]=((Math.random() * 2 - 1) * 400);
					var rm=cnt1*0.008*2*Math.PI;
					//radius=900;
					var rr = ((radius*1.08)-(cnt1*0.2)+1)
					scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (Math.sin(rm) *rr);
					//scene.children[2].geometry.attributes.position.array[(ln2+cnt2)*3+0]= (Math.cos(rm) *rr)+1800;
					scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(Math.cos(rm) *rr)+900;
					cnt1++;
					cnt++;
				}
				else if (selectedModelNodes[i][5]==4 ){
					//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=((Math.random() * 2 - 1) * 400);
					var rm=cnt2*0.008*2*Math.PI;
					//radius=600;
					var rr = ((radius*1.08)-(cnt2*0.2)+1)
					scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(Math.sin(rm) *rr);
					scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]= (Math.cos(rm) *rr)+1800;
					
					cnt2++;
					cnt++;
				}
			}
			//console.log(cnt1)
			//console.log(cnt2)
			
			scene.children[2].geometry.attributes.position.needsUpdate = true;
			scene.children[4].geometry.attributes.position.needsUpdate = true;
			
			var count=0;
			for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
				var t1;
				var t2;
				var pt1;
				var pt2;
				var sim1=1;
				var sim2=1;
				pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
				sim1 = idMap[pt1][0]
				t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
				if (selectedModelEdges[iv-extraLinesCnt][3]==2){
					//console.log("link between model and metabolic nodes")
					
					if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
						pt2=selectedModelEdges[iv-extraLinesCnt][1];
					}
					else{
						pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
					}
					t2 = jsonObj1[pt2][6]
					sim2=2;
				}
				else{
					//console.log("link between model nodes")
					if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
						pt2=selectedModelEdges[iv-extraLinesCnt][1];
					}
					else{
						pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
					}
					t2 = selectedModelNodes[pt2][5];
				}
				if (sim2!=2){
					pt2+=jsonObj1.length;
					//console.log(idMap[pt2]);
				}
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
				startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
				
				count+=1;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
				endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
				
				count+=1;
			}
			scene.children[7].geometry.attributes.position.needsUpdate = true;
			scene.children[7].geometry.attributes.ca.needsUpdate = true;
			
			/*
			var ii=0;
			for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
			
				scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
				scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
				scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
				ii++;
			}
			//console.log(tokenAttributes.endPosition.value[0]);
			var ii=0;
			for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
				tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
				tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
				ii++;
			}
			//console.log(tokenAttributes.endPosition.value[0]);
			scene.children[8].geometry.verticesNeedUpdate = true;
			tokenAttributes.endPosition.needsUpdate = true;
			//tokenUniforms.mixAmount.value = 0.0;
			*/
			
		}
		else {
			console.log("other layout");
			//console.log(layouts[el.value])
			var layout_nodes_coordinates={};
			for (var i=0, j=layouts[el.value].length;i<j;i++){
				if (layouts[el.value][i]['group']=='nodes'){
					layout_nodes_coordinates[layouts[el.value][i]['data']['id']]=[layouts[el.value][i]['position']['x'],layouts[el.value][i]['position']['y'] ]
				}
			}
			//console.log(selectedModelNodes);
			var cnt1=0;
			var cnt2=0;
			var ln1 = startModelPlaces;
			var ln2 = startModelReactions;
			for (var i=0, j=selectedModelNodes.length;i<j;i++){
				if (selectedModelNodes[i][5]==2 ){
						
						if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
							scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
							scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
							//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=50;
							//console.log(scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1])
						}
						cnt1++;
				}
				if (selectedModelNodes[i][5]==4 ){
						
						if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
							scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
							scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
							//console.log(scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1])
						}
						cnt2++;
				}
				
			}
			scene.children[2].geometry.attributes.position.needsUpdate = true;
			scene.children[4].geometry.attributes.position.needsUpdate = true;
			
			var count=0;
			for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
				var t1;
				var t2;
				var pt1;
				var pt2;
				var sim1=1;
				var sim2=1;
				pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
				sim1 = idMap[pt1][0]
				t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
				if (selectedModelEdges[iv-extraLinesCnt][3]==2){
					//console.log("link between model and metabolic nodes")
					
					if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
						pt2=selectedModelEdges[iv-extraLinesCnt][1];
					}
					else{
						pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
					}
					t2 = jsonObj1[pt2][6]
					sim2=2;
				}
				else{
					//console.log("link between model nodes")
					if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
						pt2=selectedModelEdges[iv-extraLinesCnt][1];
					}
					else{
						pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
					}
					t2 = selectedModelNodes[pt2][5];
				}
				if (sim2!=2){
					pt2+=jsonObj1.length;
					//console.log(idMap[pt2]);
				}
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
				startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
				
				count+=1;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
				endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
				
				count+=1;
			}
			scene.children[7].geometry.attributes.position.needsUpdate = true;
			scene.children[7].geometry.attributes.ca.needsUpdate = true;
			
			/*
			var ii=0;
			for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
			
				scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
				scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
				scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
				ii++;
			}
			//console.log(tokenAttributes.endPosition.value[0]);
			var ii=0;
			for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
				tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
				tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
				ii++;
			}
			//console.log(tokenAttributes.endPosition.value[0]);
			scene.children[8].geometry.verticesNeedUpdate = true;
			tokenAttributes.endPosition.needsUpdate = true;*/
			//tokenUniforms.mixAmount.value = 0.0;
			
			
			//for (elem in layout_nodes_coordinates){
			//	if (layout_nodes_coordinates.hasOwnProperty(elem)){
					//layout_nodes_coordinates[elem]
			//	}
			//}
			
			//console.log(layout_nodes_coordinates);
			
		}
	}
	
	function updateSlider2(slideAmount){
			var el = document.getElementById("selectLayout")
			var amountScale = 0.1+(0.9*(parseFloat(slideAmount)/100));
			if (parseInt(el.value)==0){
				console.log("default layout");
			}
			else {
				console.log("other layout");
				//console.log(layouts[el.value])
				var layout_nodes_coordinates={};
				for (var i=0, j=layouts[el.value].length;i<j;i++){
					if (layouts[el.value][i]['group']=='nodes'){
						layout_nodes_coordinates[layouts[el.value][i]['data']['id']]=[layouts[el.value][i]['position']['x'],layouts[el.value][i]['position']['y'] ]
					}
				}
				//console.log(selectedModelNodes);
				var cnt1=0;
				var cnt2=0;
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				for (var i=0, j=selectedModelNodes.length;i<j;i++){
					if (selectedModelNodes[i][5]==2 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
							}
							cnt1++;
					}
					if (selectedModelNodes[i][5]==4 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
							}
							cnt2++;
					}
					
				}
				scene.children[2].geometry.attributes.position.needsUpdate = true;
				scene.children[4].geometry.attributes.position.needsUpdate = true;
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				/*
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;*/
				//tokenUniforms.mixAmount.value = 0.0;
				
				
				//for (elem in layout_nodes_coordinates){
				//	if (layout_nodes_coordinates.hasOwnProperty(elem)){
						//layout_nodes_coordinates[elem]
				//	}
				//}
				
				//console.log(layout_nodes_coordinates);
				
			}	
		}
		
		function updateSlider3(slideAmount){
			var el = document.getElementById("selectLayout");
			var el2= document.getElementById("defaultSlider2");
			var amountScale = 0.1+(0.9*(parseFloat(el2.value)/100));
			var distance = (parseFloat(slideAmount)/100)*200
			
			if (parseInt(el.value)==0){
				console.log("default layout");
			}
			else {
				console.log("other layout");
				//console.log(layouts[el.value])
				var layout_nodes_coordinates={};
				for (var i=0, j=layouts[el.value].length;i<j;i++){
					if (layouts[el.value][i]['group']=='nodes'){
						layout_nodes_coordinates[layouts[el.value][i]['data']['id']]=[layouts[el.value][i]['position']['x'],layouts[el.value][i]['position']['y'] ]
					}
				}
				//console.log(selectedModelNodes);
				var cnt1=0;
				var cnt2=0;
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				for (var i=0, j=selectedModelNodes.length;i<j;i++){
					if (selectedModelNodes[i][5]==2 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
								//console.log(scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1])//=50;
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=200;
							}
							cnt1++;
					}
					if (selectedModelNodes[i][5]==4 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=50;
								//console.log(scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1])//=50;
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1]=200-distance;
							}
							cnt2++;
					}
					
				}
				scene.children[2].geometry.attributes.position.needsUpdate = true;
				scene.children[4].geometry.attributes.position.needsUpdate = true;
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				
				/*var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				//tokenUniforms.mixAmount.value = 0.0;*/
				
				
				//for (elem in layout_nodes_coordinates){
				//	if (layout_nodes_coordinates.hasOwnProperty(elem)){
						//layout_nodes_coordinates[elem]
				//	}
				//}
				
				//console.log(layout_nodes_coordinates);
				
			}	
		}

///////////////////////////////////////////////////		
console.log(stats2)
if (stats2.length>0){
var margins = {
    top: 12,
    left: 450,
    right: 24,
    bottom: 24
},
legendPanel = {
    width: 180
},
width = 900- margins.left - margins.right - legendPanel.width,
    height = (names.length*20) - margins.top - margins.bottom,
    dataset = stats2,
    mseries = dataset.map(function (d) {
        return d.name;
    }),
    dataset = dataset.map(function (d) {
        return d.data.map(function (o, i) {
            // Structure it so that your numeric
            // axis (the stacked amount) is y
            return {
                y: o.nb_token,
                x: o.transition
            };
        });
    }),
    stack = d3.layout.stack();

stack(dataset);

var dataset = dataset.map(function (group) {
    return group.map(function (d) {
        // Invert the x and y values, and y0 becomes x0
        return {
            x: d.y,
            y: d.x,
            x0: d.y0
        };
    });
}),
	svg3 = d3.select("#democ2")//.append("svg")//svg = d3.select('body')
        .append('svg')
        .attr('width', width + margins.left + margins.right + legendPanel.width)
        .attr('height', height + margins.top + margins.bottom)
        .append('g')
        .attr('transform', 'translate(' + margins.left + ',' + margins.top + ')'),
    xMax = d3.max(dataset, function (group) {
        return d3.max(group, function (d) {
            return d.x + d.x0;
        });
    }),
	
    xScale = d3.scale.linear()
        .domain([0, xMax])
        .range([0, width]),
    months = dataset[0].map(function (d) {
		//if (d.y==""){console.log("empty name")}
        //return d.y.substring(0, 20);//
		return d.y ;
    }),
    //_ = console.log(months),
    yScale = d3.scale.ordinal()
        .domain(months)
        //.rangeRoundBands([0, height]),
		.rangeRoundBands([0, height*0.953], .1),
	//_ = console.log(height),
    xAxis = d3.svg.axis()
        .scale(xScale)
        .orient('bottom'),
    yAxis = d3.svg.axis()
        .scale(yScale)
        .orient('left'),
	
    colours = d3.scale.category10(),
    groups = svg3.selectAll('g')
        .data(dataset)
        .enter()
        .append('g')
        .style('fill', function (d, i) {
        return colours(i);
    }),
    rects = groups.selectAll('rect')
        .data(function (d) {
        return d;
    })
        .enter()
        .append('rect')
        .attr('x', function (d) {
        return xScale(d.x0);
    })
        .attr('y', function (d, i) {
			//console.log(yScale(d.y))
        return yScale(d.y);
    })
        .attr('height', function (d) {
        return yScale.rangeBand();
    })
        .attr('width', function (d) {
        return xScale(d.x);
    })
        .on('mouseover', function (d,i) {
        //var xPos = parseFloat(d3.select(this).attr('x')) / 2 + width / 2;
        //var yPos = parseFloat(d3.select(this).attr('y')) + yScale.rangeBand() / 2;
		//console.log(i)
		
		var tot =0;
		for (var ind=0;  ind<lengthStats; ind++){
			tot+=stats2[ind]['data'][i]['nb_token'];
		}
		var st = "name: <i>"+d.y+"</i> - nb of token: "+d.x+"/"+tot+" <br>"
		for (var ind=0;  ind<lengthStats; ind++){
			
			st +=" sample "+ind+": <b>"+stats2[ind]['data'][i]['nb_token']+"</b>";
			if (ind!=0 && (ind%9==0)){
				st +="<br> ";
			}
		}
		st +=" total: <b>"+tot+"</b>";
		$("#mtooltip")
                      .html(st)//.html("name: <i>"+d.y+"</i> - nb of token: <b>"+d.x+"</b>") // stats2[0]['data'][i]['nb_token'])
					  .css('left', window.event.clientX+40)
                      .css('top', $("#democ2").position().top +parseFloat(d3.select(this).attr('y')) + yScale.rangeBand() / 2)
					  //.css('top', $("#democ2").position().top + $("#democ2").height()+window.event.clientY)
                      .show();
        //d3.select('#mtooltip')
        //    .style('left', xPos + 'px')
        //    .style('top', yPos + 'px')
        //    .select('#value')
        //    .text(d.x);

        //d3.select('#mtooltip').classed('hidden', false);
    })
        .on('mouseout', function () {
		$("#mtooltip").html('');
		$("#mtooltip").hide();
		//document.getElementById("mytooltip").setAttribute("type", "hidden");
		//x.setAttribute("type", "hidden");
        //d3.select('#mtooltip').classed('hidden', true);
    })

    svg3.append('g')
        .attr('class', 'maxis2')
        .attr('transform', 'translate(0,' + height + ')')
        .call(xAxis);

svg3.append('g')
    .attr('class', 'maxis2')
    .call(yAxis);

svg3.append('rect')
    .attr('fill', 'yellow')
    .attr('width', 160)
    .attr('height', 30 * dataset.length)
    .attr('x', width + margins.left-450)
    .attr('y', 0);

mseries.forEach(function (s, i) {
	
    svg3.append('text')
        .attr('fill', 'black')
        .attr('x', width + margins.left + 8-450)
        .attr('y', i * 24 + 24)
        .text(s);
    svg3.append('rect')
        .attr('fill', colours(i))
        .attr('width', 60)
        .attr('height', 20)
        .attr('x', width + margins.left + 90-450)
        .attr('y', i * 24 + 6);
});		
}
</script>

