<div class='container'>
<br><br>
	<h1>QSSPN Model </h1>
	<hr>
	<h2>Name: <%= qm.name %> </h2><a href="/qsspn_model/edit/<%= qm.id %>" class="btn btn-sm btn-primary">Model Editor</a>
	<hr>
	<h2>creator: <%= qm.owner %></h2>
	
	<hr>
	<h2>Comment: </h2>
	<%= qm.comment %>
	<h2>Metabolic network: </h2>
	<%= qm.metabolic_net %>
	
	<%var data=[];
	_.each(mtb.file, function(compartment) {
		data.push(compartment);
	});
	%>
	<hr>
	<h2>users:</h2>
	<table class='table table-bordered table-condensed'>
		<tr>
			<th>Name</th>
			<th>Users</th>
		</tr>
	<%	_.each(qm.users_read, function(err,usr) {%>
		<tr> <td><%=qm.users_read[usr]%></td> <td>read-only</td> </tr>
	<%
		});
		%>
		<%	_.each(qm.users_edit, function(err,usr) {%>
		<tr> <td><%=qm.users_edit[usr]%></td> <td>editor</td> </tr>
	<%
		});
		%>
	</table>
	
	<hr>
	
	
	<nav>
		<a href="" id="menuToggle" title="show menu">
		<span class="navClosed"><i>show menu</i></span>
		</a>
		<a href="#" title="Item 1">Hide/Show</a>
		<button class="btn btn-default btn-xs" title="Make metabolic network lines invisible/visible" id="view4" style="position: relative;left: 20px;">Lines</button>
		<button class="btn btn-default btn-xs" title="Hide/show tokens (if problem, just refresh the page)" id="view5" style="position: relative;left: 20px;">Token</button>
		<br><p style="position: relative;left: 20px;color:white">Line Opacity: <input id="defaultSlider" type="range" min="0" max="100" value="25" onchange="updateSlider(this.value)" style="position: relative;left: 20px"/></p>
		
		
		<a href="#" title="Item 2">Metabolic Layout</a>
		<button class="btn btn-default btn-xs" title="Explode metabolic network by compartment (if problem, just refresh the page)" id="view2" style="position: relative;left: 20px;">explode</button>
		<button class="btn btn-default btn-xs" title="Put back initial view (if problem, just refresh the page)" id="view1" style="position: relative;left: 20px;">flatten</button>
		
		<a href="#" title="Item 3">Model Layout</a>
		<p style="position: relative;left: 20px;color:white">Choose Layout: <select name="select" id="selectLayout" onchange="selectValue(this)">
		  <option value="0" selected>Default</option> 
		</select><br> Scale: <input id="defaultSlider2" type="range" min="0" max="100" value="25" onchange="updateSlider2(this.value)" style="position: relative;left: 20px"/>
		<br> Separation between transition/places: <input id="defaultSlider3" type="range" min="0" max="100" value="25" onchange="updateSlider3(this.value)" style="position: relative;left: 20px"/>
		</p>
	</nav>
	
	<div id="menu" >
	
	
	</div>
	
	
	<div id="container"  style="position: absolute;left: 0px; overflow: inherit">  </div>
	<!--<div id="container"  style="position: absolute;left: 0.5%; overflow: inherit">  </div>-->
	<div id="advert" ></div>
	<div id="dataTable0" style="position: absolute; " align="center">
	<table id="list0"></table>
	</div>
	<div id="dataTable" style="position: absolute; " align="center">
	<table id="list4"></table>
	</div>
	
	<div id="mytooltip"></div>
	
	<div id="modelSpreadSheet" style="position: absolute;left:15%;height:5000px" ><h2>Model data</h2>
	<br><b>Places List:</b><div id="placesTable"></div>
	<br>
	<b id="t">Transitions List:</b><div id="transitionsTable"></div>
	<br><b id="t1">Pre-places List:</b><div id="prePlacesTable"></div>
	<br><b id="t1.1">Activity Table:</b><div id="activityTable"></div>
	<br><b id="t2">Consumed List:</b><div id="consumedTable"></div>
	<br><b id="t3">Post-places List:</b><div id="postPlacesTable"></div>
	<br>	
	<b id="qssf" >QSS-Fluxes:</b><div id="qssfTable"></div>			
	<br><b id="qssf1">Constraints List:</b><div id="constraintsTable"></div>	
	<br><b id="qssf1.1">Activity Table:</b><div id="constraintsActivityTable" ></div>	
	<br><b id="qssf1.2">Flux List:</b><div id="fluxListActivityTable" ></div>
	<br><b id="qssf2">Objective List:</b><div id="objectiveTable"></div>
	<br><b id="qssf2.1">Activity Table:</b><div id="objectiveActivityTable"></div>
	</div>
	<form action="/qsspn_model/update/<%= qm.id %>" id="qsspn-model-edit-form0" method="POST" class="form-inline" style="height: 80px;width: 200px;position: relative;">	
	<%
		//var InputdataJson=JSON.stringify({"places" : [], "qssf" : { "constraints" : [], "externality_tag" :null,"objectives" : []}, "transitions" : []});
		var InputdataSfba=JSON.stringify([]);
	%>
	<input type="text" name="mySpreadsheet0" id ="mySpreadsheet0" style="visibility: hidden;" value="">
	<input type="text"  name="mySpreadsheet1" id ="mySpreadsheet1" style="visibility: hidden;" value="">
	<input type="text"  name="mySpreadsheet2" id ="mySpreadsheet2" style="visibility: hidden;" value="">
	<input type="text"  name="mySpreadsheet3" id ="mySpreadsheet3" style="visibility: hidden;" value="">
	<input type="text"  name="mySpreadsheet4" id ="mySpreadsheet4" style="visibility: hidden;" value="">
	<input type="text"  name="mySpreadsheet5" id ="mySpreadsheet5" style="visibility: hidden;" value="">
	<input type="text"  name="mySpreadsheet6" id ="mySpreadsheet6" style="visibility: hidden;" value="">
	<input type="text"  name="mySpreadsheet7" id ="mySpreadsheet7" style="visibility: hidden;" value="">
	<input type="text"  name="mySpreadsheet8" id ="mySpreadsheet8" style="visibility: hidden;" value="">
	<input type="text"  name="mySpreadsheet9" id ="mySpreadsheet9" style="visibility: hidden;" value="">
	<input type="text"  name="mySfbaSpreadsheet0" id ="mySfbaSpreadsheet0" style="visibility: hidden;" value=<%=InputdataSfba%>>
	<input type="text"  name="mySfbaSpreadsheet1" id ="mySfbaSpreadsheet1" style="visibility: hidden;" value="">
	<input type="text"  name="mySfbaSpreadsheet2" id ="mySfbaSpreadsheet2" style="visibility: hidden;" value="">
	<input type="text"  name="mySfbaSpreadsheet3" id ="mySfbaSpreadsheet3" style="visibility: hidden;" value="">
	<input type="text"  name="mySfbaSpreadsheet4" id ="mySfbaSpreadsheet4" style="visibility: hidden;" value="">
	<input type="text"  name="mySfbaSpreadsheet5" id ="mySfbaSpreadsheet5" style="visibility: hidden;" value="">
	<input type="text"  name="mySfbaSpreadsheet6" id ="mySfbaSpreadsheet6" style="visibility: hidden;" value="">
	<input type="text"  name="mySfbaSpreadsheet7" id ="mySfbaSpreadsheet7" style="visibility: hidden;" value="">
	<input type="text"  name="mySfbaSpreadsheet8" id ="mySfbaSpreadsheet8" style="visibility: hidden;" value="">
	<input type="text"  name="mySfbaSpreadsheet9" id ="mySfbaSpreadsheet9" style="visibility: hidden;" value="">
	<input type="hidden" name="_csrf" value="<%= _csrf %>" />
	<input type="submit" value="Update Edited Data" class="btn btn-primary btn-block" id ="confirm" />
</form>		
</div>	

	<script type="x-shader/x-vertex" id="vertexshaderP1">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP1">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP2">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP2">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP3">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP3">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP4">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP4">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		
		<script type="x-shader/x-vertex" id="vertexshaderP5">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP5">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP6">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP6">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP7">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP7">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshader2">

			uniform float amplitude;
			attribute vec3 displacement;
			attribute vec3 ca;
			varying vec3 vColor;
			varying float opacity;
			attribute float op;
			void main() {
				vec3 newPosition = position + amplitude * displacement;
				vColor = ca;
				opacity =op;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
			}
			//uniform float amplitude;
			//attribute vec3 displacement;
			//attribute vec3 ca;
			//varying vec3 vColor;
			//void main() {
			//	vec3 newPosition = position + amplitude * displacement;
			//	vColor = ca;
			//	gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
			//}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader2">
			uniform vec3 color;
			varying float opacity;
			varying vec3 vColor;
			void main() {

				gl_FragColor = vec4( vColor * color, opacity );

			}
			//uniform vec3 color;
			//uniform float opacity;
			//varying vec3 vColor;
			//void main() {

			//	gl_FragColor = vec4( vColor * color, opacity );

			//}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshader3">

			attribute float size;
			attribute vec3 ca;
			uniform float mixAmount;
			attribute vec3 endPosition;
			varying vec3 vColor;

			void main() {

				vColor = ca;
				vec3 newPosition = mix( position, endPosition, mixAmount );
				vec4 mvPosition = modelViewMatrix * vec4( newPosition, 1.0 );

				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader3">

			uniform vec3 color;
			uniform sampler2D texture;

			varying vec3 vColor;

			void main() {

				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );

			}

		</script>
	
	<script>
		
		(function($){
			$(document).ready(function(){
			$('#menuToggle').click(function(e){
			var $parent = $(this).parent('nav');
			$parent.toggleClass("open");
			var navState = $parent.hasClass('open') ? "hide" : "show";
			$(this).attr("title", navState + " navigation");
			// Set the timeout to the animation length in the CSS.
			setTimeout(function(){
			console.log("timeout set");
			$('#menuToggle > span').toggleClass("navClosed").toggleClass("navOpen");
			}, 200);
			e.preventDefault();
			});
			});
			})(jQuery);
		
		var cbColModel, idsOfSelectedRows = [];
		var idsOfModelSelectedRows=[];
		
		//var list_compartments=<%-JSON.stringify(data[0])%>;
		//var list_nodes=<%-JSON.stringify(data[1])%>;
		//var list_edges=<%-JSON.stringify(data[2])%>;
		//console.log(list_compartments);
		//console.log(list_nodes);
		//console.log(list_edges);
		if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
		
		var renderer, renderer2, scene,scene2,  camera, stats, controls, camera2,pip;
		var element1;
		var PointCloud1, uniforms, attributes;
		var mouse = new THREE.Vector2(), INTERSECTED;
		var projector;
		//var vc1;
		var camTween;
		var mtween=false;
		var animatorT1;
		
		var allFalse= true;
		var simModeValue=0;
		var simFlowChart=0;
		var cntLabels=0;
		
		var WIDTH = window.innerWidth;
		var HEIGHT = window.innerHeight;
		var geometry;
		var bgeometryP1;
		var bgeometryP2;
		var bgeometryP3;
		var bgeometryP4;
		var bgeometryP5;
		var bgeometryP6;
		var bgeometryP7;
		
		var bgeometry2;
		var tokenGeometry;
		var tvertices ;
		var tvalues_size ;
		var tvalues_color ;
		var tvalues_p ;
		
		var geometryKegg;
		var keggSegment = 1000;
		var keggSegmentPts = keggSegment*2;
		var keggPositions;
		var keggColors;
		var listChangingKeggCoordinates=[];
		var previousKeggLength=0;
		var cubesGeometry=[];
		var keggCubesProperties={};
		var noKeggCube=true;
		
		var simTimer=0;
		var reactionIsDone=false;
		var listReactionsDone=[]
		//var simTimerPrevious=0;
		var simEnd=0;
		var simulationIsOn=false;
		var simulationIsPaused=false;
		var simRow=[];
		var simDataTime={};
		
		var scaleExplosion=3000;
		var nbCompartments=8;
		var nbOrganelles=nbCompartments-3;
		var organelles=[];
		var oldNbOrganelles=nbOrganelles;
		var	oldNbCompartments=nbCompartments;
		var nucleus;
		var cytoplasm;
		var ECM ;
		var arraymaterial=[];
		var onCompartments=[];
		for (var i=0;i<nbCompartments;i++){
			onCompartments[i]=false;
		}
		var draggingCompartments=[];
		for (var i=0;i<nbCompartments;i++){
			draggingCompartments[i]=false;
		}
		
		var particleClass = {
					0: "DNA",
					1: "RNA",
					2: "Protein",
					3: "Degradation Product",
					4: "Standard Petri Net",
					5: "Logical Transition",
					6: "Coarse Transition"
					};
		
		var particles;
		
		
		var arrows =[];
		
		
		var b1values_size;
		var b1positions;
		var b1values_color;
		var b1values_compartment;
		var particle1ShaderMaterial ;
		
		var b2values_size;
		var b2positions;
		var b2values_color;
		var b2values_compartment;
		var particle2ShaderMaterial ;
		
		var b3values_size;
		var b3positions;
		var b3values_color;
		var b3values_compartment;
		var particle3ShaderMaterial ;
		
		var b4values_size;
		var b4positions;
		var b4values_color;
		var b4values_compartment;
		var particle4ShaderMaterial ;
		
		var b5values_size;
		var b5positions;
		var b5values_color;
		var b5values_compartment;
		var particle5ShaderMaterial ;
		
		var b6values_size;
		var b6positions;
		var b6values_color;
		var b6values_compartment;
		var particle6ShaderMaterial ;
		
		var b7values_size;
		var b7positions;
		var b7values_color;
		var b7values_compartment;
		var particle7ShaderMaterial ;
		var linesShaderMaterial;
		var tokenShaderMaterial;
		var marker=0;
		var sprite;
		
		var b2lpositions;
		var b2lcolors ;
		var b2lcompartments;
		var b2lopacity;
		// 
		var cssScene;
		var rendererCSS;
		var cssObjects=[];
		
		var cssScene2;
		var rendererCSS2;
		var cssObjects2=[];
		
		var cssScene3;
		var rendererCSS3;
		var cssObjects3=[];
		// 
		var flagPick=0;
		
			
		var outlineMaterial1;
		var outlineMesh1;
		var lineGeometry;
		var mesh;
		var tokenPS;
		// clock to animate particles
		var clock = new THREE.Clock();
		
		var parameters;
		var gui;
		
		var isOnParticle=0;
		var isOnLine=0;
		var keyboard = new KeyboardState();
		var goUp=false;
		var goDown=false;
		var goLeft=false;
		var goRight=false;
		var zoomIn=false;
		var zoomOut=false;
		var closest;
		var closestLine;
		var closestid;
		var closestType=-1;
		var hoveredType=-1;
		var sizeParticleGuiElem;
		var colorParticleGuiElem;
		var colorParticleGui = new THREE.Color( 0xffffff );
		
		var stopThreeJsMouseEvent=false;
		var spreadsheet1Visible=false
		
		var updatedListModels=false;
		var updatedModel=false;
		var resetSpreadsheet=false;
		var modelData;
		var simData;
		var simDataBounds=[];
		
		var stackTokenModel=[];
		startPositionTokenMap={};
		endPositionTokenMap={};
		
		function cameraGoTo(position, target) {
						TWEEN.removeAll();
						new TWEEN.Tween( camera.position ).delay(300)
						.to( { x: position.x, y: position.y, z: position.z }, 300 )
						.start();
						new TWEEN.Tween( controls.target )
						.to( { x: target.x, y: target.y, z: target.z }, 300 )
						.start();
						
					}
		var timerElement=document.getElementById("timer");
		var sliderElement=document.getElementById("slider");
		var listModels;
		
		
		var modelVisible=false;
		var selectedModel;
		var selectedMetabolicData;
		//var 
		//default metabolic network file is: recon2.v02.xml_metabolic_net
		//xhttp.open("GET","recon2.v02.xml_metabolic_net2.json",false);
		//xhttp.send();
		selectedMetabolicData = <%-JSON.stringify(data)%>
		console.log("getting metabolic data from default file recon2");
		// set list of edges and nodes from default metabolic data
		var metabolicEdges;
		var metabolicNodes;
		var metabolicCompartments;
		
		metabolicCompartments = selectedMetabolicData[0];
		nbCompartments=metabolicCompartments.length
					
		nbOrganelles=nbCompartments-3;
		var nameModel=<%- JSON.stringify(mtb.name) %>;
		var mapComp = {'-1':-1, g:0 ,r:1 ,l:2 ,m:3 ,x:4 ,n:5 ,c:6 ,e:7 }
		var nameComp = ["golgi","ER","lysosome","mytochodria","peroxisome", "nucleus", "cytoplasm" ,"extra-cellular" ];
		if (nameModel=="Ec_iAF1260_flux2"){
			mapComp = {'-1':-1, Extra_organism:0 ,Periplasm:1 ,Cytosol:2}
			nameComp = ["Extra_organism","Periplasm","Cytosol" ];	
			//element1.src	= "slickgrid132E.html"	
		}
		
		else if (nameModel=="hepatonet1-msb201062-s5"){
			mapComp = {'-1':-1, GolErMi:0 ,bile:1 ,lyso:2 ,mito:3 ,peroxy:4 ,nuc:5 ,cyto:6 ,ext:7 }
			nameComp = ["GolErMi","bile","lysosome","mytochodria","peroxisome", "nucleus", "cytoplasm" ,"extra-cellular" ];	
			//element1.src	= "slickgrid13HP.html"	
		}
		else{
			mapComp = {'-1':-1, g:0 ,r:1 ,l:2 ,m:3 ,x:4 ,n:5 ,c:6 ,e:7 }
			nameComp = ["golgi","ER","lysosome","mytochodria","peroxisome", "nucleus", "cytoplasm" ,"extra-cellular" ];		
			//element1.src	= "slickgrid131.html"						
		}
		
		
		
		
		//for (var i=0;i<nbCompartments;i++){
		//	mapComp[metabolicCompartments[i][0]]=i;
		//}
		metabolicNodes = selectedMetabolicData[1];
		metabolicEdges = selectedMetabolicData[2];
		
		//console.log(listModels);
		//console.log(simpleListModels);
		//console.log(listMetabolicFiles);
		//console.log(metabolicCompartments);
		//console.log(metabolicNodes);
		//console.log(metabolicEdges);
		
		// open json files with lists of nodes and edges
		//var xhttp=new XMLHttpRequest();
		//xhttp.open("GET","listNodes12.json",false);
		//xhttp.send();
		//var jsonObj4=JSON.parse(xhttp.responseText);
		//console.log(jsonObj4);
		
		//xhttp.open("GET","listEdges.json",false);
		//xhttp.send();
		//var jsonObj3=JSON.parse(xhttp.responseText);
		//console.log(jsonObj3);
		
		var jsonObj1=metabolicNodes
		var jsonObj2=metabolicEdges
		//console.log(jsonObj1);
		//console.log(jsonObj2);
		
		// extract number of qsspn typed icons from lists of nodes...
		var mnbDNA=0;
		var mnbRNA=0;
		var mnbProt=0;
		var mnbDegProd=0;
		var mnbPN=0;
		var mnbLog=0;
		var mnbCoarse=0;
		
		var nbPlacesModel=0;
		var nbReactionsModel=0;
		var nbEdgesModel=0;
		/*for (var i = 0, ii= jsonObj1.length;i<ii;i++){
			if (jsonObj1[i]['typeQSSPN']==0){
				mnbDNA++;
			}
			if (jsonObj1[i]['typeQSSPN']==1){
				mnbRNA++;
			}
			if (jsonObj1[i]['typeQSSPN']==2){
				mnbProt++;
			}
			if (jsonObj1[i]['typeQSSPN']==3){
				mnbDegProd++;
			}
			if (jsonObj1[i]['typeQSSPN']==4){
				mnbPN++;
			}
			if (jsonObj1[i]['typeQSSPN']==5){
				mnbLog++;
			}
			if (jsonObj1[i]['typeQSSPN']==6){
				mnbCoarse++;
			}
			
			
		}*/
		for (var i = 0, ii= jsonObj1.length;i<ii;i++){
			if (jsonObj1[i][6]==0){
				mnbDNA++;
			}
			if (jsonObj1[i][6]==1){
				mnbRNA++;
			}
			if (jsonObj1[i][6]==2){
				mnbProt++;
			}
			if (jsonObj1[i][6]==3){
				mnbDegProd++;
			}
			if (jsonObj1[i][6]==4){
				mnbPN++;
			}
			if (jsonObj1[i][6]==5){
				mnbLog++;
			}
			if (jsonObj1[i][6]==6){
				mnbCoarse++;
			}
		}
		var selectedModelEdges;
		var selectedModelNodes;
		
		
		//console.log(mnbDNA);
		//console.log(mnbRNA);
		//console.log(mnbProt);
		//console.log(mnbDegProd);
		//console.log(mnbPN);
		//console.log(mnbLog);
		//console.log(mnbCoarse);
		var nbDNAParticles=mnbDNA; // nb of DNA elements
		var nbRNAParticles=mnbRNA; // nb of RNA elements
		var nbProtParticles=mnbProt+10000; // nb of proteins
		var nbDegradParticles=mnbDegProd; // nb of degradation products
		var nbPNParticles=mnbPN+10000; // nb of PN standard places
		var nbLogParticles=mnbLog; // nb of logical PN places
		var nbCoarseParticles=mnbCoarse; // nb of PN coarse transitions
		var maxNbTokenModel=20000;
		var idMap=[];
		var typesMap=[];
		for (var i=0;i<7;i++){
			typesMap[i]=[];
		};
		var reactionMap=[];
		
		var segments =jsonObj2.length;
		//var segments =0;
		var segmentPts =segments*2;
		
		
		var geometryLineChart;
		var chartSegment = 6000;
		var chartSegmentPts = chartSegment*2;
		var chartPositions ;
		var chartColors ;
		var meshLineChart ;
		
		
		//$.get( "slickgrid7.html", function( data ) {
  //alert( "Data Loaded: " + data );
//});
		
		var mselectedList=[];
		// element for spreadsheet selection
		spritesSelected=[];
		nbSpritesSelected=50;
		var modelspritesSelected=[];
		var modelnbSpritesSelected=50;
		
		var modelReactionLocators=[];
		var modelProductLocators=[];
		var modelReactantLocators=[];
		var modelModifierLocators=[];
		
		var nbModelReactionLocators=50;
		var nbModelPlanesFlow=500;
		var planeMesh=[];
		var stackModel2PlaneMesh=[];
		var flowsStack=[];
		var selectedNodesPaths=[];
		var selectedModelNodesPaths=[];
		var selectedLinesPaths=[];
		var selectedModelLinesPaths=[];
		var toggledLines=0
		var toggledToken=0
		var linesMap=[]
		var selectedLinesPathsIds=[];
		var extraLinesCnt=0;
		var startModelPlaces=0;
		var startModelReactions=0;
		var endModelPlaces=0;
		var endModelReactions=0;
		var myLink =[]
		var myLinkName=[]
		for (var ln =0;ln<10;ln++){
			myLink[ln]=""
			myLinkName[ln]=""
		}
		
		var tokenFlux=[];
		var tokenBounds=[];
		var indexDisabledToken=[];
		
		var tokenStackCount=0;
		var clearedTokenIndex=[]
		
		//var anim = document.getElementById("animload");
		//anim.style.visibility="hidden";
		
		
		
		//var announcementText= document.createElement('div');
		var announcementText= document.getElementById("advert");
		announcementText.style.position = 'absolute';
		
		announcementText.style.width = 100;
		announcementText.style.height = 100;
		//announcementText.setAttribute('animation', 'fadeOut');
		
		announcementText.style.color = "white";
		announcementText.style.textAlign="left";
		announcementText.style.border="3px solid";
		announcementText.style.font="italic bold 20px arial";
		announcementText.style.padding="5px";
		announcementText.style.background="#33AA33";
		//announcementText.style.cssText = 'border: 3px solid #FFF;border-radius: 5px;color: #FFF;font-family: arial;';
		//text0.style.backgroundColor = "#FFFFCC";
		//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
		announcementText.innerHTML = '<p>hello </p>';
		
		announcementText.style.top = 2000 + 'px';
		announcementText.style.left = 2000 + 'px';
		document.body.appendChild(announcementText);
		
		
		var text0 = document.createElement('div');
		text0.style.position = 'absolute';
		text0.style.width = 100;
		text0.style.height = 100;
		text0.style.color = "white";
		text0.style.textAlign="left";
		//text0.style.backgroundColor = "#FFFFCC";
		//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
		text0.innerHTML = 'hello ';
		text0.style.top = 2000 + 'px';
		text0.style.left = 2000 + 'px';
		document.body.appendChild(text0);
		
		var text1 = document.createElement('div');
		text1.style.position = 'absolute';
		text1.style.width = 100;
		text1.style.height = 100;
		text1.style.color = "black";
		text1.style.backgroundColor = "#FFFFCC";
		//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
		text1.innerHTML = 'hello ';
		text1.style.top = 2000 + 'px';
		text1.style.left = 2000 + 'px';
		//text1.style.zIndex = -1;
		document.body.appendChild(text1);
		
		var textk = document.createElement('div');
		textk.style.position = 'absolute';
		textk.style.width = 100;
		textk.style.height = 100;
		textk.style.color = "black";
		textk.style.backgroundColor = "#FFFFCC";
		//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
		textk.innerHTML = 'hello ';
		textk.style.top = 2000 + 'px';
		textk.style.left = 2000 + 'px';
		document.body.appendChild(textk);
		var textkPreviousPos= new THREE.Vector3( 2000, 2000, 1 );
		
		var text1PreviousPos= new THREE.Vector3( 2000, 2000, 1 );
		var text1PreviousString="";
		
		var listGenes = document.createElement('div');
		listGenes.id="listGenes";
		var listGenesTitle = document.createElement('div');
		listGenesTitle.innerHTML="Expressed by gene(s):";
		listGenesTitle.style.textAlign="left";
		var listGenesContent = document.createElement('div');
		listGenesContent.className="scroll-box";
		listGenes.style.color = "white";
		listGenesContent.style.color = "white";
		listGenesContent.innerHTML = '<ul style="margin-left:0em;padding-left:1.3em;height:50px;"><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li></ul>';
		listGenes.style.position = 'absolute';
		listGenes.style.top = 2000 + 'px';
		listGenes.style.left = 2000 + 'px';
		listGenes.appendChild(listGenesTitle);
		listGenes.appendChild(listGenesContent);
		document.body.appendChild(listGenes);
		
		var listLinks = document.createElement('div');
		listLinks.id="listLinks";
		var listLinksTitle = document.createElement('div');
		listLinksTitle.innerHTML="Connectivity:";
		listLinksTitle.style.color = "white";
		listLinksTitle.style.textAlign="left";
		var listLinksContent = document.createElement('div');
		listLinksContent.className="scroll-box";
		
		listLinksContent.style.color = "white";
		listLinksContent.innerHTML = '<ul style="margin-left:0em;padding-left:1.3em;height:150px;"><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li></ul>';
		listLinks.style.position = 'absolute';
		listLinks.style.top = 2000 + 'px';
		listLinks.style.left = 2000 + 'px';
		listLinks.appendChild(listLinksTitle);
		listLinks.appendChild(listLinksContent);
		document.body.appendChild(listLinks);
		
		var txtComp=[]
		for (var i=0;i<10;i++){
			txtComp[i] = document.createElement('div');
			txtComp[i].style.position = 'absolute';
			txtComp[i].style.width = 100;
			txtComp[i].style.height = 100;
			txtComp[i].style.color = "black";
			//txtComp[i].style.fontWeight="1900";
			txtComp[i].style.backgroundColor = "#99FFCC";
			//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
			txtComp[i].innerHTML = 'hello ';
			txtComp[i].style.top = 2000 + 'px';
			txtComp[i].style.left = 2000 + 'px';
			//text1.style.zIndex = -1;
			document.body.appendChild(txtComp[i]);
			
		}
		var exploded=false;
		var focus_label=-1;
		var allDragged=[];
		for (var i=0;i<nbCompartments;i++){
			allDragged[i]=[]
		}
		
		
		var txtReactionActivation=[]
		var nbActivation=1000;
		var tokenIDStackCount={};
		for (var i=0;i<nbActivation;i++){
			txtReactionActivation[i] = document.createElement('div');
			txtReactionActivation[i].style.position = 'absolute';
			txtReactionActivation[i].style.width = 100;
			txtReactionActivation[i].style.height = 100;
			txtReactionActivation[i].style.color = "white";
			//txtComp[i].style.fontWeight="1900";
			//txtReactionActivation[i].style.backgroundColor = "#99FFCC";
			//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
			txtReactionActivation[i].innerHTML = 'hello ';
			txtReactionActivation[i].style.top = 2000 + 'px';
			txtReactionActivation[i].style.left = 2000 + 'px';
			//text1.style.zIndex = -1;
			document.body.appendChild(txtReactionActivation[i]);
			
		}
		var positionContainer;
		var yStartDisplacement=400;
		
		
		function updateSlider(slideAmount){
			console.log(slideAmount/100);
			for (var i=0;i<segmentPts;i++){
				for (var i=0;i<b2lopacity.length;i++){
					
					b2lopacity[i]=(parseFloat(slideAmount)/100);
				}	
			}
			scene.children[7].geometry.attributes.op.needsUpdate = true;
		}
		
		selectedModel = <%- JSON.stringify(qm.file.extra)%>;
		selectedModelNodes=selectedModel[2];
		selectedModelEdges=selectedModel[3];
		//console.log(selectedModelNodes);
		//console.log(selectedModelEdges);
		// in model edges, position index 2: product = 1 , preplace =2, consumed = 0
	
		nbPlacesModel=0;
		nbReactionsModel=0;
		nbEdgesModel=selectedModelEdges.length;
		
		for (var i = 0, ii= selectedModelNodes.length;i<ii;i++){
			if (selectedModelNodes[i][5]==2 ){
				nbPlacesModel++;					
			}
			if (selectedModelNodes[i][5]==4 ){
				nbReactionsModel++;
			}
		}
		
		var layouts = <%- JSON.stringify(qm.layouts)%>;
		for (elem in layouts){
			if (layouts.hasOwnProperty(elem)){
				$('#selectLayout').append("<option>"+elem+"</option>")
			}
		}
		//console.log(selectedModel)
		init();
		animate();
		
		
		function init() {
		
		
			//localStorage.selection=[];
			//localStorage.;

			camera = new THREE.PerspectiveCamera( 45, WIDTH / HEIGHT, 1, 100000 );
			//camera.position.z = 800;
			
			camera.position.y = 500+1.0*yStartDisplacement;
			camera.position.x = 3500;
			//camera2 = new THREE.PerspectiveCamera( 45, WIDTH / HEIGHT, 1, 10000 );
			//camera2.position.z = 250;
			
			

			scene = new THREE.Scene();
			scene2 = new THREE.Scene();
			//////////////////////////////////////////////////
			// define shader attributes for group of particles dna
			particleP1Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP1Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/dna8-green.png" ) }
				

			};

			particleP1Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles rna
			particleP2Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP2Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/rna8.png" ) }
				

			};

			particleP2Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles proteins
			particleP3Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP3Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/disc.png" ) }
				

			};

			particleP3Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles degradation product
			particleP4Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP4Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/disc.png" ) }
				

			};

			particleP4Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles standard pn
			particleP5Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP5Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/PN1.png" ) }
				

			};

			particleP5Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles pn logical
			particleP6Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP6Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/PNLogical1.png" ) }
				

			};

			particleP6Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles pn coarse
			particleP7Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP7Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/PNCoarse1.png" ) }
				

			};

			particleP7Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			// define shader material for group of particles dna
			particle1ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP1Uniforms,
				attributes:     particleP1Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP1' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP1' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle2ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP2Uniforms,
				attributes:     particleP2Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP2' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP2' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle3ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP3Uniforms,
				attributes:     particleP3Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP3' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP3' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle4ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP4Uniforms,
				attributes:     particleP4Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP4' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP4' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle5ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP5Uniforms,
				attributes:     particleP5Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP5' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP5' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle6ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP6Uniforms,
				attributes:     particleP6Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP6' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP6' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle7ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP7Uniforms,
				attributes:     particleP7Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP7' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP7' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			//////////////////////////////////////////////
			// define shader attributes for group of lines
			linesAttributes = {

				displacement: {	type: 'v3', value: [] },
				ca: {	type: 'c', value: [] },
				op:{ type: "f", value: [] }

			};

			linesUniforms = {

				amplitude: { type: "f", value: 1.0 },
				opacity:   { type: "f", value: 0.7 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) }

			};
			// define shader material for group of lines
			linesShaderMaterial = new THREE.ShaderMaterial( {

				uniforms:       linesUniforms,
				attributes:     linesAttributes,
				vertexShader:   document.getElementById( 'vertexshader2' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshader2' ).textContent,
				blending:       THREE.AdditiveBlending,
				depthTest:      false,
				transparent:    true

			});

			linesShaderMaterial.linewidth = 1;
			//linesShaderMaterial.attributes.op.value=0.7;
			
			
			
			
			
			/////////////////////////////////////////////////////////////////
			// define shader attributes for group of animated token particles
			tokenAttributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] },
				endPosition: { type: "v3", value: [] }
				//mixAmount: 	 { type: 'f', value: [] }
			};

			tokenUniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/small-spark.png" ) },
				mixAmount: 	 { type: "f", value: 0.0 }

			};

			//uniforms.texture.value.wrapS = uniforms.texture.value.wrapT = THREE.RepeatWrapping;

			tokenShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		tokenUniforms,
				attributes:     tokenAttributes,
				vertexShader:   document.getElementById( 'vertexshader3' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshader3' ).textContent,
				depthTest: 		false,
				transparent:	true,
				opacity: 0.8,
				blending:	true

			});
			
			
			//particles = nbDNAParticles // nb of DNA elements
			//+ nbRNAParticles // nb of RNA elements
			//+ nbProtParticles // nb of proteins
			//+ nbDegradParticles // nb of degradation products
			//+ nbPNParticles // nb of PN standard places
			//+ nbLogParticles // nb of logical PN places
			//+ nbCoarseParticles; // nb of PN coarse transitions
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for dna particles
			bgeometryP1 = new THREE.BufferGeometry();
			
			bgeometryP1.dynamic = true;
			bgeometryP1.attributes = {

				position: {
					itemSize: 3,
					array: new Float32Array( nbDNAParticles * 3 )
				},
				ca: {
					itemSize: 3,
					array: new Float32Array( nbDNAParticles * 3 )
				},
				size: {
					itemSize: 1,
					array: new Float32Array( nbDNAParticles ),
					dynamic: true
				},
				compartment: {
					itemSize: 1,
					array: new Float32Array( nbDNAParticles ),
					dynamic: true
				}

			}
			bgeometryP1.attributes.size.needsUpdate = true;
			bgeometryP1.attributes.position.needsUpdate = true;
			bgeometryP1.attributes.ca.needsUpdate = true;
			bgeometryP1.attributes.compartment.needsUpdate = true;

			b1values_size = bgeometryP1.attributes.size.array;
			b1positions = bgeometryP1.attributes.position.array;
			b1values_color = bgeometryP1.attributes.ca.array;
			b1values_compartment = bgeometryP1.attributes.compartment.array;
			
			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xffffff );
			var radius =400;
			for( var bv = 0; bv < nbDNAParticles; bv++ ) {
			

				b1values_size[ bv ] = 10;
				b1values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;

				b1positions[ (bv * 3) + 0 ] = (Math.random() * 2 - 1) * radius;
				//b1positions[ (bv * 3) + 1 ] = (Math.random() * 2 - 1) * radius;
				b1positions[ (bv * 3) + 1 ] = yStartDisplacement;
				b1positions[ (bv * 3) + 2 ] = (Math.random() * 2 - 1) * radius;
				
				
				//if ( positions[ bv * 3 + 0 ] < 0 )
				//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
				//else
				//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
				b1values_color[ (bv * 3) + 0 ] = color.r;
				b1values_color[ (bv * 3) + 1 ] = color.g;
				b1values_color[ (bv * 3) + 2 ] = color.b;

			}
			//console.log(bgeometryP1);
			
			// associate first particle system with bufferGeometry
			PointCloud1 = new THREE.PointCloud( bgeometryP1, particle1ShaderMaterial );

			PointCloud1.dynamic = true;
			PointCloud1.sortParticles = true;
			PointCloud1.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud1 );
			
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for rna particles
			bgeometryP2 = new THREE.BufferGeometry();
			
			bgeometryP2.dynamic = true;
			bgeometryP2.attributes = {

				position: {
					itemSize: 3,
					array: new Float32Array( nbRNAParticles * 3 )
				},
				ca: {
					itemSize: 3,
					array: new Float32Array( nbRNAParticles * 3 )
				},
				size: {
					itemSize: 1,
					array: new Float32Array( nbRNAParticles ),
					dynamic: true
				},
				compartment: {
					itemSize: 1,
					array: new Float32Array( nbRNAParticles ),
					dynamic: true
				}
				

			}
			bgeometryP2.attributes.size.needsUpdate = true;
			bgeometryP2.attributes.position.needsUpdate = true;
			bgeometryP2.attributes.ca.needsUpdate = true;
			bgeometryP2.attributes.compartment.needsUpdate = true;

			b2values_size = bgeometryP2.attributes.size.array;
			b2positions = bgeometryP2.attributes.position.array;
			b2values_color = bgeometryP2.attributes.ca.array;
			b2values_compartment = bgeometryP2.attributes.compartment.array;
			
			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xffffff );;
			var radius =400;
			for( var bv = 0; bv < nbRNAParticles; bv++ ) {
			

				b2values_size[ bv ] = 10;
				b2values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
				
				b2positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius;
				//b2positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
				b2positions[ bv * 3 + 1 ] = yStartDisplacement;
				
				b2positions[ bv * 3 + 2 ] = (Math.random() * 2 - 1) * radius;
				
				
				//if ( positions[ bv * 3 + 0 ] < 0 )
				//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
				//else
				//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
				b2values_color[ bv * 3 + 0 ] = color.r;
				b2values_color[ bv * 3 + 1 ] = color.g;
				b2values_color[ bv * 3 + 2 ] = color.b;

			}
			
			
			// associate first particle system with bufferGeometry
			PointCloud2 = new THREE.PointCloud( bgeometryP2, particle2ShaderMaterial );

			PointCloud2.dynamic = true;
			PointCloud2.sortParticles = true;
			PointCloud2.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud2 );
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for protein particles
			bgeometryP3 = new THREE.BufferGeometry();
			
			bgeometryP3.dynamic = true;
			bgeometryP3.attributes = {

				position: {
					itemSize: 3,
					array: new Float32Array( nbProtParticles * 3 )
				},
				ca: {
					itemSize: 3,
					array: new Float32Array( nbProtParticles * 3 )
				},
				size: {
					itemSize: 1,
					array: new Float32Array( nbProtParticles ),
					dynamic: true
				},
				compartment: {
					itemSize: 1,
					array: new Float32Array( nbProtParticles ),
					dynamic: true
				}

			}
			bgeometryP3.attributes.size.needsUpdate = true;
			bgeometryP3.attributes.position.needsUpdate = true;
			bgeometryP3.attributes.ca.needsUpdate = true;
			bgeometryP3.attributes.compartment.needsUpdate = true;

			b3values_size = bgeometryP3.attributes.size.array;
			b3positions = bgeometryP3.attributes.position.array;
			b3values_color = bgeometryP3.attributes.ca.array;
			b3values_compartment = bgeometryP3.attributes.compartment.array;
			
			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xff9900 );;
			var color2 = new THREE.Color( 0x55ff55 );
			var radius =400;
			var bv=0;
			//for( var bv = 0; bv < nbProtParticles; bv++ ) {
				for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
					if (jsonObj1[bw][6]==2){
						b3values_size[ bv ] = 10;
						//b3values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
						b3values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
						idMap[bw]=[2,bv];
						typesMap[2][bv]=bw;
						
						var rm;
						var rr;
						
						if (nameModel=="hepatonet1-msb201062-s5"){
							rm=bv*0.078*2*Math.PI;
							rr = ((bv*0.02)+0.35*radius)
							b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							b3positions[ bv * 3 + 1 ] = yStartDisplacement+0+(bv*0.05);
						}
						else if (nameModel=="Ec_iAF1260_flux2"){
							rm=bv*0.004*2*Math.PI;
							rr = ((radius*1.08)-(bv*0.03)+1)
							b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							b3positions[ bv * 3 + 1 ] = yStartDisplacement+0-(bv*0.03);

						}
						else{
							rm=bv*0.008*2*Math.PI;
							rr = ((bv*0.02)+0.05*radius);
							b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							b3positions[ bv * 3 + 1 ] = yStartDisplacement+0+(bv*0.02);
						}
						
						b3positions[ bv * 3 + 2 ] = Math.sin(rm) *rr;
						
						b3values_color[ bv * 3 + 0 ] = color.r;
						b3values_color[ bv * 3 + 1 ] = color.g;
						b3values_color[ bv * 3 + 2 ] = color.b;
						bv++;
					}
				}
				startModelPlaces=bv;
				for( var bw = jsonObj1.length , bww= jsonObj1.length+5000; bw < bww; bw++ ) {
						
		
					//if (jsonObj1[bw][6]==2){
						b3values_size[ bv ] = 30;
						//b3values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
						b3values_compartment[ bv ] = -1;
						//idMap[bw]=[2,bv];
						//typesMap[2][bv]=bw;
						idMap[bw]=[2,bv];
						typesMap[2][bv]=bw;
						//var rm=(bw-jsonObj1.length)*0.078*2*Math.PI;
						//var	rr = (((bw-jsonObj1.length)*0.02)+0.95*radius)
						//radius=900;
						var rm=(bw-jsonObj1.length)*0.008*2*Math.PI;
						var rr = ((radius)-((bw-jsonObj1.length)*0.3)+1)
						b3positions[ bv * 3 + 0 ] = (Math.cos(rm) *rr)+900;
						//b3positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius+900;
						//b3positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
						b3positions[ bv * 3 + 1 ] = yStartDisplacement/2;
						b3positions[ bv * 3 + 2 ] = ((Math.random() * 2 - 1) * radius)+150000;
						//b3positions[ bv * 3 + 2 ] = (Math.sin(rm) *rr)+50000;
						
						//if ( positions[ bv * 3 + 0 ] < 0 )
						//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
						//else
						//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
						b3values_color[ bv * 3 + 0 ] = color2.r;
						b3values_color[ bv * 3 + 1 ] = color2.g;
						b3values_color[ bv * 3 + 2 ] = color2.b;
						bv++;
					//}
				}
				endModelPlaces=bv;
			//}
			
			
			// associate first particle system with bufferGeometry
			PointCloud3 = new THREE.PointCloud( bgeometryP3, particle3ShaderMaterial );

			PointCloud3.dynamic = true;
			PointCloud3.sortParticles = true;
			PointCloud3.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud3 );
			
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for degradable product particles
			bgeometryP4 = new THREE.BufferGeometry();
			
			bgeometryP4.dynamic = true;
			bgeometryP4.attributes = {

				position: {
					itemSize: 3,
					array: new Float32Array( nbDegradParticles * 3 )
				},
				ca: {
					itemSize: 3,
					array: new Float32Array( nbDegradParticles * 3 )
				},
				size: {
					itemSize: 1,
					array: new Float32Array( nbDegradParticles ),
					dynamic: true
				},
				compartment: {
					itemSize: 1,
					array: new Float32Array( nbDegradParticles ),
					dynamic: true
				}

			}
			bgeometryP4.attributes.size.needsUpdate = true;
			bgeometryP4.attributes.position.needsUpdate = true;
			bgeometryP4.attributes.ca.needsUpdate = true;
			bgeometryP4.attributes.compartment.needsUpdate = true;

			b4values_size = bgeometryP4.attributes.size.array;
			b4positions = bgeometryP4.attributes.position.array;
			b4values_color = bgeometryP4.attributes.ca.array;
			b4values_compartment = bgeometryP4.attributes.compartment.array;
			
			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xff66ff );;
			var radius =400;
			for( var bv = 0; bv < nbDegradParticles; bv++ ) {
			

				b4values_size[ bv ] = 10;
				b4values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;

				b4positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius;
				
				//b4positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
				b4positions[ bv * 3 + 1 ] = yStartDisplacement+0;
				b4positions[ bv * 3 + 2 ] = (Math.random() * 2 - 1) * radius;
				
				
				//if ( positions[ bv * 3 + 0 ] < 0 )
				//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
				//else
				//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
				b4values_color[ bv * 3 + 0 ] = color.r;
				b4values_color[ bv * 3 + 1 ] = color.g;
				b4values_color[ bv * 3 + 2 ] = color.b;

			}
			
			
			// associate first particle system with bufferGeometry
			PointCloud4 = new THREE.PointCloud( bgeometryP4, particle4ShaderMaterial );

			PointCloud4.dynamic = true;
			PointCloud4.sortParticles = true;
			PointCloud4.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud4 );
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for PN particles
			bgeometryP5 = new THREE.BufferGeometry();
			
			bgeometryP5.dynamic = true;
			bgeometryP5.attributes = {

				position: {
					itemSize: 3,
					array: new Float32Array( nbPNParticles * 3 )
				},
				ca: {
					itemSize: 3,
					array: new Float32Array( nbPNParticles * 3 )
				},
				size: {
					itemSize: 1,
					array: new Float32Array( nbPNParticles ),
					dynamic: true
				},
				compartment: {
					itemSize: 1,
					array: new Float32Array( nbPNParticles ),
					dynamic: true
				}

			}
			bgeometryP5.attributes.size.needsUpdate = true;
			bgeometryP5.attributes.position.needsUpdate = true;
			bgeometryP5.attributes.ca.needsUpdate = true;
			bgeometryP5.attributes.compartment.needsUpdate = true;

			b5values_size = bgeometryP5.attributes.size.array;
			b5positions = bgeometryP5.attributes.position.array;
			b5values_color = bgeometryP5.attributes.ca.array;
			b5values_compartment = bgeometryP5.attributes.compartment.array;
			
			var color = new THREE.Color( 0xffffff );
					
					var color2 = new THREE.Color( 0x55ffff );
					var radius =400;
					var bv=0;
					//for( var bv = 0; bv < nbPNParticles; bv++ ) {
					/*subSystems=[];
					for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
						if (jsonObj1[bw][6]==4){
							if (jsonObj1[bw][4][1] && jsonObj1[bw][4][1][0]){
								if (subSystems.indexOf(jsonObj1[bw][4][1][0])== -1){
									subSystems.push(jsonObj1[bw][4][1][0]);
								}
							}
						}
					}*/
					//console.log(subSystems);
					// now allocate a nb of nodes by sub systems
					subSystems={};
					totalSubSystems=0;
					
					totalNbreactions=0;
					for( var bs = 0 , bww= jsonObj1.length; bs < bww; bs++ ) {
						if (jsonObj1[bs][6]==4){
							if (jsonObj1[bs][4][1] && jsonObj1[bs][4][1][0]){
								if (subSystems[jsonObj1[bs][4][1][0]]=== undefined){
									subSystems[jsonObj1[bs][4][1][0]]=1;
									totalSubSystems++;
								}
								else{
									subSystems[jsonObj1[bs][4][1][0]]++;
									totalSubSystems++;
								}
								
							}
							totalNbreactions++;
						}
					}
					totalOutsideSubSystems=totalNbreactions-totalSubSystems;
					nbSubSystems=Object.keys(subSystems).length
					if (totalOutsideSubSystems>0){
						nbAreas=nbSubSystems+1;
						subSystems["Not present"]=totalOutsideSubSystems;
					}
					else{
						nbAreas=nbSubSystems;
					}
					//console.log(subSystems);
					
					//console.log(totalSubSystems);
					//console.log(totalNbreactions);
					//console.log(totalOutsideSubSystems);
					//console.log(nbSubSystems);
					
					// if there is no subsystem identified just use standard spiral layout
					
					// if there are n subsystems then display circular region of width proportional to the nb of nodes in each subsystem
					// first make a list of widths
					// total nb of reactions will dictate the overall nb of points that must be displayed on the ring.
					// depth of the ring is 30 points. there are for 0.004 *2Pi=1.44 degrees = 250 graduations on a circle 
					var listWidthSubSystems={};
					var nbCircleGraduations=250;
					var minCircleFraction=1/nbCircleGraduations;
					var nbNodesDepth=40;
					var totalWidth=0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							var width= Math.ceil(subSystems[key]/nbNodesDepth);
							listWidthSubSystems[key]=[subSystems[key]/*nb of nodes*/,width,/*counter value*/0];
							totalWidth+=width;
						}
					}
					nbNodesDepth=Math.ceil((40*totalWidth)/244);
					listWidthSubSystems={};
					var totalWidth=0;
					var cumulativeWidth=0;
					var colorswap=1.0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							var width= Math.ceil(subSystems[key]/nbNodesDepth);
							listWidthSubSystems[key]=[subSystems[key]/*nb of nodes*/,width,cumulativeWidth,/*counter value*/0,colorswap];
							totalWidth+=width;
							cumulativeWidth+=width;
							if (colorswap==1.0){
							colorswap=0.7;
							}
							else{colorswap=1.0}
						}
					}
					
					//console.log(totalWidth);
					//console.log(listWidthSubSystems);
					/*for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							var percentage= subSystems[key]/totalNbreactions;
							if (percentage < minCircleFraction){
								percentage= minCircleFraction;
								
							}
							subSystems[key]=percentage;
							totalPercentage+=percentage;
							
							//console.log(percentage);
						}
					}
					console.log(totalPercentage);
					var toDistribute=0;
					if (totalPercentage>1){
						toDistribute= totalPercentage-1;
					}
					var nbReducable=0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							if((subSystems[key]*(1-toDistribute))>minCircleFraction){
								nbReducable++;
							}
						}
					}
					console.log(nbReducable);
					var sums=0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							if((subSystems[key]*(1-toDistribute))>minCircleFraction){
								var res=subSystems[key]*(1-(toDistribute));
								subSystems[key]=res;
								
							}
							sums+=subSystems[key];
							
							//toDistribute/nbReducable
						}
					}
					console.log(subSystems+" total: "+sums);*/
					//var cnt1=0
					//var cnt2=0;
					var localRSeparator=0;
					for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
						
						if (jsonObj1[bw][6]==4){

							b5values_size[ bv ] = 10;
							//b5values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
							
							// try to assign the compartment of the majority of the products the reaction is linked to 
							// if there is no product, assign the compartment of the majority of modifiers
							// if there is no modifier, assign the compartment of the majority of reactants
							var listProducts= jsonObj1[bw][11][0];
							var listModifiers= jsonObj1[bw][11][1];
							var listReactants= jsonObj1[bw][11][2];
							
							if (listProducts.length>0){
								var votes=[];
								for (var ncc=0;ncc<nbCompartments;ncc++){
									votes[ncc]=0;
								}
								for(var lp=0;lp<listProducts.length;lp++){
									if (mapComp[jsonObj1[listProducts[lp]][3]]>=0)
										votes[mapComp[jsonObj1[listProducts[lp]][3]]]++;
								}
								var winner= votes.indexOf(Math.max.apply( Math, votes ));
								b5values_compartment[ bv ] = winner;
								if (winner==-1){
									b5values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
								}
							} 
							else if (listModifiers.length>0){
								var votes=[];
								for (var ncc=0;ncc<nbCompartments;ncc++){
									votes[ncc]=0;
								}
								for(var lp=0;lp<listModifiers.length;lp++){
									if (mapComp[jsonObj1[listModifiers[lp]][3]]>=0)
										votes[mapComp[jsonObj1[listModifiers[lp]][3]]]++;
								}
								var winner= votes.indexOf(Math.max.apply( Math, votes ));
								b5values_compartment[ bv ] = winner;
								if (winner==-1){
									b5values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
								}
							}
							else if (listReactants.length>0){
								var votes=[];
								for (var ncc=0;ncc<nbCompartments;ncc++){
									votes[ncc]=0;
								}
								for(var lp=0;lp<listReactants.length;lp++){
									if (mapComp[jsonObj1[listReactants[lp]][3]]>=0)
										votes[mapComp[jsonObj1[listReactants[lp]][3]]]++;
								}
								var winner= votes.indexOf(Math.max.apply( Math, votes ));
								b5values_compartment[ bv ] = winner;
								if (winner==-1){
									b5values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
								}
							}
							else {
								// if no species linked, put reaction in the center
								b5values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
							}
							
							idMap[bw]=[4,bv];
							typesMap[4][bv]=bw;
							
							var rm;
							var rr; 
							
							
							
							
							if (nameModel=="Ec_iAF1260_flux2"){
								rm=bv*0.078*2*Math.PI;
								rr = ((bv*0.02)+0.35*radius)
								//b5positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
								b5positions[ bv * 3 + 1 ] = (yStartDisplacement/2)+(bv*0.04);
							}
							else{
								var yModifier=0;
								var mDepth=0;
								//rr= ((radius*1.08)-(0*0.03)+1);
								if (jsonObj1[bw][4][1] && jsonObj1[bw][4][1][0]){
									
									//console.log("increment node")
									//console.log(jsonObj1[bw][4][1][0]);
									if (listWidthSubSystems.hasOwnProperty(jsonObj1[bw][4][1][0])) {
									
										var startingW=listWidthSubSystems[jsonObj1[bw][4][1][0]][2];
										var maxWidth=listWidthSubSystems[jsonObj1[bw][4][1][0]][1];
										var maxDepth=nbNodesDepth;
										var maxNbNodes=listWidthSubSystems[jsonObj1[bw][4][1][0]][0];
										var presentIndex= listWidthSubSystems[jsonObj1[bw][4][1][0]][3];
										if (presentIndex<maxNbNodes){
										//cnt1++;
											var localWPos=0;
											
											var localRR=0;
											localWPos=Math.floor(presentIndex/maxDepth);
											//if (presentIndex>=maxDepth){
											
												localRR=presentIndex%maxDepth;
											yModifier=	localRR;
											mDepth=maxDepth;
											//}
											//else{
											//	localRR=presentIndex;
											//}
											//if(presentIndex==0){
											//	localRSeparator+=(nbCircleGraduations-totalWidth)/(2*nbAreas);//	rm=((startingW+localWPos+localRSeparator)*0.004*(2*Math.PI));
											//console.log(jsonObj1[bw][4][1][0])
											//listWidthSubSystems[jsonObj1[bw][4][1][0]][2]+=((nbCircleGraduations-totalWidth)/(nbAreas));
											//startingW=listWidthSubSystems[jsonObj1[bw][4][1][0]][2];
											//color.r-=0.01
											//}
											rm=((startingW+localRSeparator+localWPos)*0.004*(2*Math.PI));
											
											rr= ((radius-maxDepth*5)+(localRR*5));
											listWidthSubSystems[jsonObj1[bw][4][1][0]][3]++;
											color.r=listWidthSubSystems[jsonObj1[bw][4][1][0]][4];
											if (color.r==1.0){
											color.g=1.0;
											color.b=1.0;
											}
											else{
											color.g=0.4;
											color.b=1.0;
											}
										}
									}
								}
								else{
									
									//subSystems["Not present"]=totalOutsideSubSystems;
									if (listWidthSubSystems.hasOwnProperty("Not present")) {
									
									//console.log("increment not present")
										var startingW=listWidthSubSystems["Not present"][2];
										var maxWidth=listWidthSubSystems["Not present"][1];
										var maxDepth=nbNodesDepth;
										var maxNbNodes=listWidthSubSystems["Not present"][0];
										var presentIndex= listWidthSubSystems["Not present"][3];
										if (presentIndex<maxNbNodes){
										//cnt2++;
											var localWPos=0;
											var localRR=0;
											localWPos=Math.floor(presentIndex/maxDepth);
											//if (presentIndex>=maxDepth){
											
												localRR=presentIndex%maxDepth;
												yModifier=	localRR;	
												mDepth=maxDepth;
											//}
											//else{
											//	localRR=presentIndex;
											//}
											//if(presentIndex==0){
											//console.log(jsonObj1[bw][4][1][0])
											//listWidthSubSystems["Not present"][2]+=((nbCircleGraduations-totalWidth)/(nbAreas));
											//startingW=listWidthSubSystems["Not present"][2];
											//	localRSeparator+=(nbCircleGraduations-totalWidth)/(2*nbAreas);//	rm=((startingW+localWPos+localRSeparator)*0.004*(2*Math.PI));
											//}
											rm=((startingW+localRSeparator+localWPos)*0.004*(2*Math.PI));
											rr= ((radius-maxDepth*5)+(localRR*5));
											listWidthSubSystems["Not present"][3]++;
											color = new THREE.Color( 0xff0000 );
										}
									}
								}
								//console.log(listWidthSubSystems);
							
								//rm=bv*0.004*2*Math.PI;
								//rr= ((radius*1.08)-(bv*0.03)+1);
								
								//b5positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
								//b5positions[ bv * 3 + 1 ] = 0-(bv*0.03);
								b5positions[ bv * 3 + 1 ] = yStartDisplacement-(mDepth*4)+(yModifier*4);
								//console.log(jsonObj1[bw][4][1][0])
							}
							b5positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							b5positions[ bv * 3 + 2 ] = Math.sin(rm) *rr;
							
							
							b5values_color[ bv * 3 + 0 ] = color.r;
							b5values_color[ bv * 3 + 1 ] = color.g;
							b5values_color[ bv * 3 + 2 ] = color.b;
							bv++;
						}
					}
					//console.log("increment"+cnt1 + "  " +cnt2)
					startModelReactions=bv;
					for( var bw = jsonObj1.length , bww= jsonObj1.length+5000; bw < bww; bw++ ) {
						
						b5values_size[ bv ] = 30;
						
						b5values_compartment[ bv ] = -1;
						idMap[bw]=[4,bv];
						typesMap[4][bv]=bw;
						
						
						
						//radius=900;
						var rm=(bw-jsonObj1.length)*0.008*2*Math.PI;
						var rr = ((radius)-((bw-jsonObj1.length)*0.3)+1)
						//b5positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius+900;
						b5positions[ bv * 3 + 0 ] = (Math.cos(rm) *rr)+1800;
						//b5positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
						b5positions[ bv * 3 + 1 ] = yStartDisplacement/2-180;
						
						b5positions[ bv * 3 + 2 ] = ((Math.random() * 2 - 1) * radius)+150000;
						
						
						//if ( positions[ bv * 3 + 0 ] < 0 )
						//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
						//else
						//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
						b5values_color[ bv * 3 + 0 ] = color2.r;
						b5values_color[ bv * 3 + 1 ] = color2.g;
						b5values_color[ bv * 3 + 2 ] = color2.b;
						bv++;
					}
					endModelReactions=bv;
			
			// associate first particle system with bufferGeometry
			PointCloud5 = new THREE.PointCloud( bgeometryP5, particle5ShaderMaterial );

			PointCloud5.dynamic = true;
			PointCloud5.sortParticles = true;
			PointCloud5.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud5 );
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for PN particles
			bgeometryP6 = new THREE.BufferGeometry();
			
			bgeometryP6.dynamic = true;
			bgeometryP6.attributes = {

				position: {
					itemSize: 3,
					array: new Float32Array( nbLogParticles * 3 )
				},
				ca: {
					itemSize: 3,
					array: new Float32Array( nbLogParticles * 3 )
				},
				size: {
					itemSize: 1,
					array: new Float32Array( nbLogParticles ),
					dynamic: true
				},
				compartment: {
					itemSize: 1,
					array: new Float32Array( nbLogParticles ),
					dynamic: true
				}

			}
			bgeometryP6.attributes.size.needsUpdate = true;
			bgeometryP6.attributes.position.needsUpdate = true;
			bgeometryP6.attributes.ca.needsUpdate = true;
			bgeometryP6.attributes.compartment.needsUpdate = true;

			b6values_size = bgeometryP6.attributes.size.array;
			b6positions = bgeometryP6.attributes.position.array;
			b6values_color = bgeometryP6.attributes.ca.array;
			b6values_compartment = bgeometryP6.attributes.compartment.array;
			
			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xffffff );;
			var radius =400;
			for( var bv = 0; bv < nbLogParticles; bv++ ) {
			

				b6values_size[ bv ] = 10;
				b6values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;

				b6positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius;
				//b6positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
				b6positions[ bv * 3 + 1 ] = yStartDisplacement;
				
				b6positions[ bv * 3 + 2 ] = (Math.random() * 2 - 1) * radius;
				
				
				//if ( positions[ bv * 3 + 0 ] < 0 )
				//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
				//else
				//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
				b6values_color[ bv * 3 + 0 ] = color.r;
				b6values_color[ bv * 3 + 1 ] = color.g;
				b6values_color[ bv * 3 + 2 ] = color.b;

			}
			
			
			// associate first particle system with bufferGeometry
			PointCloud6 = new THREE.PointCloud( bgeometryP6, particle6ShaderMaterial );

			PointCloud6.dynamic = true;
			PointCloud6.sortParticles = true;
			PointCloud6.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud6 );
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for PN particles
			bgeometryP7 = new THREE.BufferGeometry();
			
			bgeometryP7.dynamic = true;
			bgeometryP7.attributes = {

				position: {
					itemSize: 3,
					array: new Float32Array( nbCoarseParticles * 3 )
				},
				ca: {
					itemSize: 3,
					array: new Float32Array( nbCoarseParticles * 3 )
				},
				size: {
					itemSize: 1,
					array: new Float32Array( nbCoarseParticles ),
					dynamic: true
				},
				compartment: {
					itemSize: 1,
					array: new Float32Array( nbCoarseParticles ),
					dynamic: true
				}

			}
			bgeometryP7.attributes.size.needsUpdate = true;
			bgeometryP7.attributes.position.needsUpdate = true;
			bgeometryP7.attributes.ca.needsUpdate = true;
			bgeometryP7.attributes.compartment.needsUpdate = true;

			b7values_size = bgeometryP7.attributes.size.array;
			b7positions = bgeometryP7.attributes.position.array;
			b7values_color = bgeometryP7.attributes.ca.array;
			b7values_compartment = bgeometryP7.attributes.compartment.array;
			
			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xffffff );;
			var radius =400;
			for( var bv = 0; bv < nbCoarseParticles; bv++ ) {
			

				b7values_size[ bv ] = 10;
				b7values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;

				b7positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius;
				//b7positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
				b7positions[ bv * 3 + 1 ] = yStartDisplacement;
				
				b7positions[ bv * 3 + 2 ] = (Math.random() * 2 - 1) * radius;
				
				
				//if ( positions[ bv * 3 + 0 ] < 0 )
				//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
				//else
				//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
				b7values_color[ bv * 3 + 0 ] = color.r;
				b7values_color[ bv * 3 + 1 ] = color.g;
				b7values_color[ bv * 3 + 2 ] = color.b;

			}
			
			
			// associate first particle system with bufferGeometry
			PointCloud7 = new THREE.PointCloud( bgeometryP7, particle7ShaderMaterial );

			PointCloud7.dynamic = true;
			PointCloud7.sortParticles = true;
			PointCloud7.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud7 );
			
			// populates second buffer geometry for lines  with coordinates, colors, and size
			//segmentPts = 20000;
			bgeometry2 = new THREE.BufferGeometry();
			bgeometry2.attributes = {
				position: {
					itemSize: 3,
					array: new Float32Array((segmentPts+10000) * 3)
				},
				ca: {
					itemSize: 3,
					array: new Float32Array((segmentPts+10000) * 3)
				},
				op: {
					itemSize: 1,
					array: new Float32Array( segmentPts+10000  ),
					dynamic: true
				},
				compartment: {
					itemSize: 2,
					array: new Float32Array( (segments+5000) * 2 ),
					dynamic: true
				}
				,flux: {
					itemSize: 1,
					array: new Float32Array( segments+5000 ),
					dynamic: true
				}
				,bounds: {
					itemSize: 2,
					array: new Float32Array( (segments+5000) * 2 ),
					dynamic: true
				}
			};
				
				
			bgeometry2.attributes.position.needsUpdate = true;
			bgeometry2.attributes.ca.needsUpdate = true;
			bgeometry2.attributes.compartment.needsUpdate = true;
			bgeometry2.attributes.op.needsUpdate = true;

			b2lpositions = bgeometry2.attributes.position.array;
				//var colors = bgeometry.attributes.color.array;
			b2lcolors = bgeometry2.attributes.ca.array;
			b2lcompartments=bgeometry2.attributes.compartment.array;
			b2lopacity = bgeometry2.attributes.op.array;
			var r = 800;
			var col = new THREE.Color( 0x00ffff );
			var col2 = new THREE.Color( 0x55ff55 );
			
			var iv=0;
			for ( var i = 0; i < segments; i ++ ) {
			
				var t1 = jsonObj1[jsonObj2[i][0]][6]
				var t2 = jsonObj1[jsonObj2[i][1]][6]
				var ivList=[]
				
				if (t1==2){
					b2lpositions[ (iv * 3)+0 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
					b2lpositions[ (iv * 3) + 1 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
					b2lpositions[ (iv * 3) + 2 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
					b2lcompartments[ (i*2)+0 ] = b3values_compartment[ (idMap[jsonObj2[i][0]][1]) ];
					b2lopacity[iv]=0.25;
					b2lcolors[ iv * 3 ] = col.r;
					b2lcolors[ iv * 3 + 1 ] = col.g;
					b2lcolors[ iv * 3 + 2 ] = col.b;
					ivList.push(iv)
					//linesMap[i]=iv
					
					iv++;
				}
				else if (t1==4){
					b2lpositions[ (iv * 3)+0 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
					b2lpositions[ (iv * 3) + 1 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
					b2lpositions[ (iv * 3) + 2 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
					b2lcompartments[ (i*2)+0 ] = b5values_compartment[ (idMap[jsonObj2[i][0]][1]) ];
					b2lopacity[iv]=0.25;
					b2lcolors[ iv * 3 ] = col.r;
					b2lcolors[ iv * 3 + 1 ] = col.g;
					b2lcolors[ iv * 3 + 2 ] = col.b;
					//linesMap[i]=iv
					ivList.push(iv)
					iv++;
				}
				if (t2 ==2){
					b2lpositions[ (iv * 3)+0 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
					b2lpositions[ (iv * 3) + 1 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
					b2lpositions[ (iv * 3) + 2 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;
					b2lcompartments[ (i*2)+1 ] = b3values_compartment[ (idMap[jsonObj2[i][1]][1]) ];
					b2lopacity[iv]=0.25;
					b2lcolors[ iv * 3 ] = col.r;
					b2lcolors[ iv * 3 + 1 ] = col.g;
					b2lcolors[ iv * 3 + 2 ] = col.b;
					//linesMap[i]=iv
					ivList.push(iv)
					iv++;
				}
				else if (t2 ==4){
					b2lpositions[ (iv * 3)+0 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
					b2lpositions[ (iv * 3) + 1 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
					b2lpositions[ (iv * 3) + 2 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;
					b2lcompartments[ (i*2)+1 ] = b5values_compartment[ (idMap[jsonObj2[i][1]][1]) ];
					b2lopacity[iv]=0.25;
					b2lcolors[ iv * 3 ] = col.r;
					b2lcolors[ iv * 3 + 1 ] = col.g;
					b2lcolors[ iv * 3 + 2 ] = col.b;
					//linesMap[i]=iv
					ivList.push(iv)
					iv++;
				}
				linesMap[i]=ivList
			}
			var radius=400;
			extraLinesCnt=iv;
			for ( var i = segments; i < segments+maxNbTokenModel; i ++ ) {
				
					b2lpositions[ (iv * 3)+0 ] = (Math.random() * 2 - 1) * radius;
					b2lpositions[ (iv * 3) + 1 ] = 80;
					b2lpositions[ (iv * 3) + 2 ] = ((Math.random() * 2 - 1) * radius)+150000;
					b2lcompartments[ (i*2)+0 ] = -1;
					b2lopacity[iv]=0.25;
					b2lcolors[ iv * 3 ] = col2.r;
					b2lcolors[ iv * 3 + 1 ] = col2.g;
					b2lcolors[ iv * 3 + 2 ] = col2.b;
					ivList.push(iv)
					//linesMap[i]=iv
					
					iv++;
				
				
				
			}
			//for ( var i = 0; i < segmentPts; i ++ ) {
			//if (i<50)
			//	console.log(i+" -- "+b1values_compartment[i]);
			//}
			
			bgeometry2.computeBoundingSphere();
		//console.log(bgeometry2);
			mesh = new THREE.Line( bgeometry2, linesShaderMaterial,THREE.LinePieces );
			scene.add( mesh );
			
			// create and populate geometry with token particles coordinates, colors, and size
			var radius = 300;
			//tokenGeometry = new THREE.CubeGeometry( 0.8 * radius, 0.8 * radius, 0.8 * radius, 150, 100, 1 );
			// populate token geometry with "start" extremities of line segmentPts
			tokenGeometry = new THREE.Geometry();
			for ( var i = 0; i < segmentPts; i +=2 ) {
				tokenGeometry.vertices.push(new THREE.Vector3(b2lpositions[ (i * 3) ]+0,b2lpositions[ (i * 3) + 1 ]+0,b2lpositions[ (i * 3) + 2 ]+0));
			}
			// add models tokens
			for ( var i = segmentPts; i < segmentPts+maxNbTokenModel; i +=2 ) {
				tokenGeometry.vertices.push(new THREE.Vector3(b2lpositions[ (i * 3) ]+0,b2lpositions[ (i * 3) + 1 ]+0,b2lpositions[ (i * 3) + 2 ]+150000));
				
			}
			//var v1 = new THREE.Vector3(0,0,0);
			//var v2 = new THREE.Vector3(0,500,0);
			//var v3 = new THREE.Vector3(0,500,500);

			
			//tokenShaderMaterial.blending = THREE.AdditiveBlending; // "glowing" particles
			tokenPS = new THREE.PointCloud( tokenGeometry, tokenShaderMaterial );
			//tokenPS = new THREE.PointCloud( tokenGeometry, spriteMaterial );
			tokenPS.dynamic = true;
			//sphere.sortParticles = true;

			tvertices = tokenPS.geometry.vertices;
			tvalues_size = tokenAttributes.size.value;
			tvalues_color = tokenAttributes.ca.value;
			tvalues_p = tokenAttributes.endPosition.value;
			for( var v = 0, vv= tvertices.length; v < vv; v++ ) {

				tvalues_size[ v ] = 5;
				tvalues_color[ v ] = new THREE.Color( 0xff7777 );
				//tvalues_p[v]=new THREE.Vector3( 600+(Math.random() * 2 - 1) * radius, (Math.random() * 2 - 1) * radius , (Math.random() * 2 - 1) * radius );	
				//tvalues_p[v]=new THREE.Vector3(b2positions[ (v+1) * 3 ],b2positions[ (v+1) * 3 + 1 ],b2positions[ (v+1) * 3 + 2 ]);
			}
			//for( var v = tvertices.length-2500, vv= tvertices.length; v < vv; v++ ) {

			//	tvalues_size[ v ] = 15;
			//	tvalues_color[ v ] = new THREE.Color( 0xff00ff );
				//tvalues_p[v]=new THREE.Vector3( 600+(Math.random() * 2 - 1) * radius, (Math.random() * 2 - 1) * radius , (Math.random() * 2 - 1) * radius );	
				//tvalues_p[v]=new THREE.Vector3(b2positions[ (v+1) * 3 ],b2positions[ (v+1) * 3 + 1 ],b2positions[ (v+1) * 3 + 2 ]);
			//}
			
			for ( var i = 1; i < segmentPts; i +=2 ) {
				tvalues_p.push(new THREE.Vector3(b2lpositions[ i * 3 ],b2lpositions[ i * 3 + 1 ],b2lpositions[ i * 3 + 2 ]));
			}
			for ( var i = segmentPts+1; i < segmentPts+maxNbTokenModel; i +=2 ) {
				tvalues_p.push(new THREE.Vector3(b2lpositions[ i * 3 ],b2lpositions[ i * 3 + 1 ],b2lpositions[ i * 3 + 2 ]+150000));
			}
			
			//sphere.geometry.__dirtyVertices = true;
			scene.add( tokenPS );
			
			
			
			
			
			// outline mesh for lines
			
			lineGeometry = new THREE.Geometry();
			lineGeometry.vertices.push(new THREE.Vector3(-10000, -10000, -150000));
			lineGeometry.vertices.push(new THREE.Vector3(-10000, -10000, -151000));
			lineGeometry.verticesNeedUpdate = true;
			
			outlineMaterial1 = new THREE.MeshBasicMaterial( { color: 0xff0000} );			
			outlineMesh1 = new THREE.Line( lineGeometry, outlineMaterial1 );	
			//outlineMesh1.scale.multiplyScalar(1.002);
			scene.add( outlineMesh1 );
			
			
			
			var spriteMaterial = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/glow.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false, blending: THREE.AdditiveBlending
			});
			sprite = new THREE.Sprite( spriteMaterial );
			sprite.scale.set(8, 8, 8);
			//crateGlow.add(sprite); // this centers the glow at the mesh
			if (marker==0){
			sprite.position.set(-150000,-10000,10000);
			//sprite.transparent=true;
			}		
			scene.add( sprite );
			
			
			var spriteMaterial2 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/tg2.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false//, blending: THREE.AdditiveBlending
			});
			for (var i=0;i<nbSpritesSelected;i++){
				spritesSelected[i] = new THREE.Sprite( spriteMaterial2 );
				spritesSelected[i].scale.set(100, 100, 100);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				spritesSelected[i].position.set(-150000,-10000,10000);
				
					
				scene.add( spritesSelected[i] );
			}
			
			var spriteMaterial22 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/tg2.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false//, blending: THREE.AdditiveBlending
			});
			for (var i=0;i<modelnbSpritesSelected;i++){
				modelspritesSelected[i] = new THREE.Sprite( spriteMaterial22 );
				modelspritesSelected[i].scale.set(100, 100, 100);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				modelspritesSelected[i].position.set(-150000,-10000,10000);
				
					
				scene.add( modelspritesSelected[i] );
			}
			
			
			
			var spriteMaterial3 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/square_canvas.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false
			});
			for (var i=0;i<nbModelReactionLocators;i++){
				modelReactionLocators[i] = new THREE.Sprite( spriteMaterial3 );
				modelReactionLocators[i].scale.set(40, 40, 40);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				modelReactionLocators[i].position.set(-150000,-10000,10000);
				//modelReactionLocators[i].position.set(400,400,200*i);
					
				scene.add( modelReactionLocators[i] );
			}
			
			var spriteMaterial4 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/product.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false
			});
			for (var i=0;i<nbModelReactionLocators;i++){
				modelProductLocators[i] = new THREE.Sprite( spriteMaterial4 );
				modelProductLocators[i].scale.set(40, 40, 40);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				modelProductLocators[i].position.set(-150000,-10000,10000);
				//modelProductLocators[i].position.set(400,400,200*i);
					
				scene.add( modelProductLocators[i] );
			}
			
			var spriteMaterial5 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/reactant2.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false
			});
			for (var i=0;i<nbModelReactionLocators;i++){
				modelReactantLocators[i] = new THREE.Sprite( spriteMaterial5 );
				modelReactantLocators[i].scale.set(40, 40, 40);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				modelReactantLocators[i].position.set(-150000,-10000,10000);
				//modelProductLocators[i].position.set(400,400,200*i);
					
				scene.add( modelReactantLocators[i] );
			}
			
			var spriteMaterial6 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/modifier2.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false
			});
			for (var i=0;i<nbModelReactionLocators;i++){
				modelModifierLocators[i] = new THREE.Sprite( spriteMaterial6 );
				modelModifierLocators[i].scale.set(40, 40, 40);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				modelModifierLocators[i].position.set(-150000,-10000,10000);
				//modelProductLocators[i].position.set(400,400,200*i);
					
				scene.add( modelModifierLocators[i] );
			}
			
			
			// add dynamic texture on plan 
			// MESHES WITH ANIMATED TEXTURES!
	
			/*var runnerTexture = new THREE.ImageUtils.loadTexture( 'mrdoob-three.js-r67/examples/textures/run3.png' );
			animatorT1 = new TextureAnimator( runnerTexture, 9, 1, 9, 30 ); // texture, #horiz, #vert, #total, duration.
			var runnerMaterial = new THREE.MeshBasicMaterial( { map: runnerTexture, side:THREE.DoubleSide } );
			var runnerGeometry = new THREE.PlaneGeometry(400, 10, 1, 1);
			var runner = new THREE.Mesh(runnerGeometry, runnerMaterial);
			runner.position.set(0,800,1500);
			runner.rotation.x -= (90*(Math.PI / 180));
			scene.add(runner);*/
			
			// add an array of planes that will be superimposed on lines to express flows
			//var planeTexture = new THREE.ImageUtils.loadTexture( '/images/glow3.png' );
			//var planeTexture = new THREE.ImageUtils.loadTexture( 'mrdoob-three.js-r67/examples/textures/sprites/small-spark.png' );
			//var planeMaterial = new THREE.MeshBasicMaterial( { map: planeTexture ,side: THREE.DoubleSide}  );
			//planeMaterial.blending=THREE.AdditiveBlending;
			//planeMaterial.transparent = true;
			//planeMaterial.opacity = 0.6;
			//for(var i=0;i<nbModelPlanesFlow;i++){
			//	var planeGeometry = new THREE.PlaneGeometry(400, 5, 1, 1);
			//	planeMesh[i] = new THREE.Mesh(planeGeometry, planeMaterial);
			//	planeMesh[i].position.set(0,0,50000);
			//	planeMesh[i].geometry.dynamic = true;
			//	planeMesh[i].geometry.verticesNeedUpdate = true;
			//	planeMesh[i].frustumCulled = false;
			//	scene.add(planeMesh[i]);	
			//}
			
			// add planar stuff for demonstration
			//var KeggMapTexture = new THREE.ImageUtils.loadTexture( '/images/keggmap-big.png' );
			//var KeggMapMaterial = new THREE.MeshBasicMaterial( { map: KeggMapTexture /*,side: THREE.DoubleSide*/}  );
			//var KeggMapGeometry = new THREE.PlaneGeometry( 900, 547, 0, 0 ) // size image 2587 1575
			//var KeggMapPlan = new THREE.Mesh( KeggMapGeometry, KeggMapMaterial );
			//KeggMapPlan.position.set(3000, 200, 0 );
			//KeggMapPlan.rotation.x -= (90*(Math.PI / 180));
			//KeggMapPlan.name="mapkegg";
			//scene.add( KeggMapPlan );
			
			
			//geometryLineChart= new THREE.BufferGeometry();
			//geometryLineChart.attributes = {
			//	position: {
			//		itemSize: 3,
			//		array: new Float32Array((chartSegmentPts) * 3)
			//	},
			//	ca: {
			//		itemSize: 3,
			//		array: new Float32Array((chartSegmentPts) * 3)
			//	}
			//};
			//var col = new THREE.Color( 0xff0000 );
			//chartPositions = geometryLineChart.attributes.position.array;
			//chartColors = geometryLineChart.attributes.ca.array;
			//var iv=0;
			//for ( var i = 0; i < chartSegment; i ++ ) {
			//	chartPositions[ (iv * 3)+0 ] = 50400;
			//	chartPositions[ (iv * 3) + 1 ] = 0;
			//	chartPositions[ (iv * 3) + 2 ] = -50400;
				//chartColors[ iv * 3 ] = col.r;
				//chartColors[ iv * 3 + 1 ] = col.g;
				//chartColors[ iv * 3 + 2 ] = col.b;
			//	iv++;
			//	chartPositions[ (iv * 3)+0 ] = 50400;
			//	chartPositions[ (iv * 3) + 1 ] = 0;
			//	chartPositions[ (iv * 3) + 2 ] = -50400;
				//chartColors[ iv * 3 ] = col.r;
				//chartColors[ iv * 3 + 1 ] = col.g;
				//chartColors[ iv * 3 + 2 ] = col.b;
			//	iv++
			//}
			//geometryLineChart.computeBoundingSphere();
			//var lineChartMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000} );
			//meshLineChart = new THREE.Line( geometryLineChart, lineChartMaterial,THREE.LinePieces);
			//scene2.add( meshLineChart );
			
			/*
			// create mesh of lines for kegg 3d bar chart 
			geometryKegg = new THREE.BufferGeometry();
			keggSegment = 1000;
			keggSegmentPts = keggSegment*2;
			geometryKegg.attributes = {
				position: {
					itemSize: 3,
					array: new Float32Array((keggSegmentPts) * 3)
				},
				ca: {
					itemSize: 3,
					array: new Float32Array((keggSegmentPts) * 3)
				}
			};
			var col = new THREE.Color( 0xff0000 );
			keggPositions = geometryKegg.attributes.position.array;
			keggColors = geometryKegg.attributes.ca.array;
			var iv=0;
			for ( var i = 0; i < keggSegment; i ++ ) {
				keggPositions[ (iv * 3)+0 ] = 50000;
				keggPositions[ (iv * 3) + 1 ] = 0;
				keggPositions[ (iv * 3) + 2 ] = -50000;
				keggColors[ iv * 3 ] = col.r;
				keggColors[ iv * 3 + 1 ] = col.g;
				keggColors[ iv * 3 + 2 ] = col.b;
				iv++;
				keggPositions[ (iv * 3)+0 ] = 50000;
				keggPositions[ (iv * 3) + 1 ] = 800;
				keggPositions[ (iv * 3) + 2 ] = -50000;
				keggColors[ iv * 3 ] = col.r;
				keggColors[ iv * 3 + 1 ] = col.g;
				keggColors[ iv * 3 + 2 ] = col.b;
				iv++
			}
			geometryKegg.computeBoundingSphere();
			//var meshKegg = new THREE.Line( geometryKegg, keggLinesShaderMaterial,THREE.LinePieces );
			var keggoutlineMaterial1 = new THREE.MeshBasicMaterial( { color: 0xff0000} );
			var meshKegg = new THREE.Line( geometryKegg, keggoutlineMaterial1,THREE.LinePieces );
				
			scene.add( meshKegg );
			*/
			
			// add keegmap cubes instead
			
			//var geometry = new THREE.CubeGeometry( 1, 1, 1 );
			
			//for ( var i = 0; i < keggSegment; i ++ ) {
			//	var material = new THREE.MeshBasicMaterial( {color: 0xff0000} );
			//	cubesGeometry[i] = new THREE.Mesh( geometry, material );
			//	cubesGeometry[i].position.x=50000;
			//	cubesGeometry[i].position.y=200;
			//	cubesGeometry[i].position.z=-50000;
			//	cubesGeometry[i].name="k"+i;
			//	scene.add( cubesGeometry[i] );
			//}
			
			//nbOrganelles=7;
			var canvasSize=900
			
			for (var i=0;i<nbOrganelles;i++){
				arraymaterial[i] = new THREE.MeshBasicMaterial( { color: 0x1111ff, side: THREE.DoubleSide } );
				var o1 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
				o1.applyMatrix( new THREE.Matrix4().makeTranslation(0, canvasSize/2, 0) );
				var o2 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
				o2.applyMatrix( new THREE.Matrix4().makeTranslation(0, -canvasSize/2, 0) );
				var o3 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
				o3.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
				o3.applyMatrix( new THREE.Matrix4().makeTranslation(canvasSize/2, 0, 0) );
				var o4 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
				o4.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
				o4.applyMatrix( new THREE.Matrix4().makeTranslation(-canvasSize/2, 0, 0) );
				o1.merge(o2);
				o1.merge(o3);
				o1.merge(o4);
				organelles[i] = new THREE.Mesh( o1, arraymaterial[i] );
				//organelles[i].position.set( Math.sin((2*Math.PI)/nbOrganelles*i)*scaleExplosion, -10, Math.cos((2*Math.PI)/nbOrganelles*i)*scaleExplosion );
				organelles[i].name="c"+i;
				organelles[i].position.set(0, yStartDisplacement, 0 );
				organelles[i].rotation.x += (90*(Math.PI / 180));
				scene.add( organelles[i] );
			}
			
			
			
			// add planar stuff for demonstration
			//var material2 = new THREE.MeshBasicMaterial( { color: 0x1111ff, side: THREE.DoubleSide } );
			arraymaterial[nbOrganelles] = new THREE.MeshBasicMaterial( { color: 0x1111ff, side: THREE.DoubleSide } );
			var n1 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			n1.applyMatrix( new THREE.Matrix4().makeTranslation(0, canvasSize/2, 0) );
			var n2 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			n2.applyMatrix( new THREE.Matrix4().makeTranslation(0, -canvasSize/2, 0) );
			var n3 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			n3.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
			n3.applyMatrix( new THREE.Matrix4().makeTranslation(canvasSize/2, 0, 0) );
			var n4 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			n4.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
			n4.applyMatrix( new THREE.Matrix4().makeTranslation(-canvasSize/2, 0, 0) );
			n1.merge(n2);
				n1.merge(n3);
				n1.merge(n4);
			//var n3 = new THREE.PlaneGeometry( 1000, 10, 1, 1 )
			//var n4 = new THREE.PlaneGeometry( 1000, 10, 1, 1 )
			//nucleus = new THREE.Mesh( new THREE.PlaneGeometry( 1000, 1000, 1, 1 ), material1 );
			nucleus = new THREE.Mesh( n1, arraymaterial[nbOrganelles] );
			nucleus.name="c"+nbOrganelles;
			//THREE.GeometryUtils.merge(n2, nucleus);
			nucleus.position.set( 0, yStartDisplacement, 0 );
			nucleus.rotation.x += (90*(Math.PI / 180));
			scene.add( nucleus );
			
			// add planar stuff for demonstration
			//var material2 = new THREE.MeshBasicMaterial( { color: 0x1f51ff, side: THREE.DoubleSide } );
			arraymaterial[nbOrganelles+1] = new THREE.MeshBasicMaterial( { color: 0x1111ff, side: THREE.DoubleSide } );
			var c1 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			c1.applyMatrix( new THREE.Matrix4().makeTranslation(0, canvasSize/2, 0) );
			var c2 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			c2.applyMatrix( new THREE.Matrix4().makeTranslation(0, -canvasSize/2, 0) );
			var c3 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			c3.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
			c3.applyMatrix( new THREE.Matrix4().makeTranslation(canvasSize/2, 0, 0) );
			var c4 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			c4.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
			c4.applyMatrix( new THREE.Matrix4().makeTranslation(-canvasSize/2, 0, 0) );
			c1.merge(c2);
			c1.merge(c3);
			c1.merge(c4);
			cytoplasm = new THREE.Mesh( c1, arraymaterial[nbOrganelles+1] );
			cytoplasm.name="c"+(nbOrganelles+1);
			cytoplasm.position.set( 0, yStartDisplacement, 0 );
			cytoplasm.rotation.x += (90*(Math.PI / 180));
			scene.add( cytoplasm );
			
			// add planar stuff for demonstration
			//var material3 = new THREE.MeshBasicMaterial( { color: 0x1f511f, side: THREE.DoubleSide } );
			arraymaterial[nbOrganelles+2] = new THREE.MeshBasicMaterial( { color: 0x1111ff, side: THREE.DoubleSide } );
			var e1 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			e1.applyMatrix( new THREE.Matrix4().makeTranslation(0, canvasSize/2, 0) );
			var e2 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			e2.applyMatrix( new THREE.Matrix4().makeTranslation(0, -canvasSize/2, 0) );
			var e3 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			e3.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
			e3.applyMatrix( new THREE.Matrix4().makeTranslation(canvasSize/2, 0, 0) );
			var e4 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
			e4.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
			e4.applyMatrix( new THREE.Matrix4().makeTranslation(-canvasSize/2, 0, 0) );
			e1.merge(e2);
			e1.merge(e3);
			e1.merge(e4);
			
			ECM = new THREE.Mesh( e1, arraymaterial[nbOrganelles+2] );
			ECM.name="c"+(nbOrganelles+2);
			ECM.position.set( 0, yStartDisplacement, 0 );
			ECM.rotation.x += (90*(Math.PI / 180));
			scene.add( ECM );
			
			
			
			// create skybox
			var mimagePrefix = "/images/";
			var mdirections  = ["p2", "p2", "p2", "p2", "p2", "p2"];
			var mimageSuffix = ".png";
			var mskyGeometry = new THREE.BoxGeometry( 50000, 50000, 50000 );	
			//var cubePath = "/rsi/static/tex/cube/Grid3/";
            //var cubeFormat = ".jpg";
            //var cubeFaces = [cubePath + 'px' + cubeFormat, cubePath + 'nx' + cubeFormat, cubePath + 'py' + cubeFormat, cubePath + 'ny' + cubeFormat, cubePath + 'pz' + cubeFormat, cubePath + 'nz' + cubeFormat];
            //this.gridCubeTex = THREE.ImageUtils.loadTextureCube(cubeFaces);
			var mmaterialArray = [];
			for (var i = 0; i < 6; i++)
				mmaterialArray.push( new THREE.MeshBasicMaterial({
					map: THREE.ImageUtils.loadTexture( mimagePrefix + mdirections[i] + mimageSuffix ),
					side: THREE.BackSide
				}));
			var mskyMaterial = new THREE.MeshFaceMaterial( mmaterialArray );
			var mskyBox = new THREE.Mesh( mskyGeometry, mskyMaterial );
			mskyBox.name="skybox"
			scene.add( mskyBox );
			
			
			
			// add arrows
			//var material3 = new THREE.MeshBasicMaterial( { color: 0x1f511f, side: THREE.DoubleSide } );
			//var arrow1 = cylinderMesh(new THREE.Vector3(0, 30, 0),new THREE.Vector3(200,200, 0),material3);
			//scene.add( arrow1 );
			
			// function to create a 3d arrow
			
			if (nbPlacesModel!=0 && nbReactionsModel!=0){
			
				var cnt1=0;
				var cnt2=0;
				var cnt=0;
				
				//var ln1 = scene.children[2].geometry.attributes.size.array.length-5000; 
				//var ln2 = scene.children[4].geometry.attributes.size.array.length-5000; 
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				//console.log(ln1)
				//console.log(startModelPlaces)
				for (var i= 0; i<selectedModelNodes.length;i++){
					if (selectedModelNodes[i][5]==2 ){
						//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]=((Math.random() * 2 - 1) * 400);
						var rm=cnt1*0.008*2*Math.PI;
						//radius=900;
						var rr = ((radius*1.48)-(cnt1*0.2)+1)
						scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]= (Math.cos(rm) *rr)+900;
						scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (Math.sin(rm) *rr);
						scene.children[2].geometry.attributes.compartment.array[(ln1+cnt1)]= selectedModelNodes[i][2];
						//scene.children[2].geometry.attributes.compartment.array[(ln1+cnt1)]= Math.floor(Math.random()*nbCompartments);
						idMap[jsonObj1.length+cnt]=[2,cnt1+ln1]
						//typesMap[2][cnt1]=i;
						cnt1++;
						cnt++;
					}
					else if (selectedModelNodes[i][5]==4 ){
						//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=((Math.random() * 2 - 1) * 400);
						var rm=cnt2*0.008*2*Math.PI;
						//radius=600;
						var rr = ((radius*1.480)-(cnt2*0.2)+1)
						scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(Math.cos(rm) *rr)+1800;
						scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(Math.sin(rm) *rr);
						scene.children[4].geometry.attributes.compartment.array[(ln2+cnt2)]= selectedModelNodes[i][2];
						//scene.children[4].geometry.attributes.compartment.array[(ln2+cnt2)]= Math.floor(Math.random()*nbCompartments);
						idMap[jsonObj1.length+cnt]=[4,cnt2+ln2]
						//typesMap[4][cnt2]=i;
						cnt2++;
						cnt++;
					}
				}
				//console.log(cnt1)
				//console.log(cnt2)
				scene.children[2].geometry.attributes.compartment.needsUpdate = true;
				scene.children[4].geometry.attributes.compartment.needsUpdate = true;
				scene.children[2].geometry.attributes.position.needsUpdate = true;
				scene.children[4].geometry.attributes.position.needsUpdate = true;
				
				var col2 = new THREE.Color( 0xffa500 );
				
				
				//console.log(selectedModelNodes)
				//for (var s= 0; s<selectedModelEdges.length;s++){
				//	if (selectedModelEdges[s][0]==108){
				//	console.log(s)
				//	}
				//}
				//console.log(nbEdgesModel)
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					if (sim2==2){
					//console.log("link between model nodes")
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
					}
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					if (sim2==2){
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
					}
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				selectedLinesPathsIds=[]
				for (var i=0; i<selectedLinesPaths.length;i++){
					for (var j=0;j<linesMap[selectedLinesPaths[i]].length;j+=1){
						selectedLinesPathsIds.push(linesMap[selectedLinesPaths[i]][j])
					}
				}
				selectedLinesPathsIds = unique(selectedLinesPathsIds)
				for (var i=0;i<selectedLinesPathsIds.length;i+=1){
					scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] +=150000;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
					
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					if (i>=segmentPts){
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+150000;
					}
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					if (i>=segmentPts){
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+150000;
					}
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				tokenUniforms.mixAmount.value = 0.0;
			}	
			
			
			
			// css 3d elements
			/*cssScene = new THREE.Scene();
			var cssText="Id:"
			var element = document.createElement( 'div' );
			element.className = 'element';
			element.style.backgroundColor = 'rgba(0,127,127,' + ( Math.random() * 0.5 + 0.25 ) + ')';
			var number = document.createElement( 'div' );
			number.className = 'number';
			number.textContent = "Object";
			element.appendChild( number );
			var symbol = document.createElement( 'div' );
			symbol.className = 'symbol';
			symbol.textContent = cssText;
			element.appendChild( symbol );
			var details = document.createElement( 'div' );
			details.className = 'details';
			//details.innerHTML = '<br>Type:';
			details.textContent = "Type:";
			element.appendChild( details );

			cssObject = new THREE.CSS3DObject( element );
			cssObject.position.x = 0;
			cssObject.position.y = 0;
			cssScene.add(cssObject);
			cssObjects.push( cssObject );	
			rendererCSS	= new THREE.CSS3DRenderer();
			rendererCSS.setSize( 200, 200 );
			rendererCSS.domElement.style.position = 'absolute';
			rendererCSS.domElement.style.top	  = 0;
			rendererCSS.domElement.style.margin	  = 0;
			rendererCSS.domElement.style.padding  = 0;
			document.body.appendChild( rendererCSS.domElement );*/
					
			// add css object spreadsheet webpage
			//cssScene2 = new THREE.Scene();
			//var planeWidth = 360;
			//var planeHeight = 380;
			//element1	= document.createElement('iframe')
			//element1.src	= "slickgrid131.html"
			//var element1Width = 624;
			// force iframe to have same relative dimensions as planeGeometry
			//var aspectRatio = planeHeight / planeWidth;
			//var element1Height = element1Width * aspectRatio;
			//element1.style.width  = element1Width + "px";
			//element1.style.height = element1Height + "px";
			//var obj = new THREE.CSS3DObject( element1 );
			//obj.position.x = -window.innerWidth*1.5;
			//obj.position.y = 0;
			//obj.position.z = -550;
			//obj.rotation.y += (-90*(Math.PI / 180));
			//cssScene2.add( obj );	
			/*
			var elementLink = document.createElement( 'div' );
			//elementLink.style.background="#dddddd";
			elementLink.style.padding="3px";
			elementLink.style.color="white";
			elementLink.style.font="italic bold 10px arial,serif";
			elementLink.style.zIndex="1";
			var allL=''
			allL=allL+'<p align="left"><a href="'+null+'" target="_blank" id="myLink">'+myLinkName[0]+'</a>'
			for (var ln=0;ln<10;ln++){
				allL=allL+'<p align="left"><a href="'+myLink[ln]+'" target="_blank" id="myLink'+ln+'">'+myLink[ln]+'</a>'
			}
			
			//elementLink.innerHTML='<a href="'+myLink[0]+'" target="_blank" id="myLink0">'+myLinkName+'</a>'
			elementLink.innerHTML=allL
			var objLink = new THREE.CSS3DObject( elementLink);			
			objLink.position.x = 350;
			objLink.position.y = 140;
			objLink.position.z = -500;
			cssScene2.add(objLink);
			*/
			
			// create a renderer for CSS
			//rendererCSS2	= new THREE.CSS3DRenderer();
			//rendererCSS2.setSize( window.innerWidth, window.innerHeight );
			//rendererCSS2.setSize( 280, 300 );
			//rendererCSS2.domElement.style.position = 'absolute';
			//rendererCSS2.domElement.style.top	  = 0;
			//rendererCSS2.domElement.style.margin	  = 0;
			//rendererCSS2.domElement.style.padding  = 0;
					
					
					
					
					
			/*cssScene3 = new THREE.Scene();
			var element3 = document.createElement( 'div' );
			element3.style.background="#dddddd";
			element3.style.padding="3px";
			element3.style.color="black";
			element3.style.zIndex="1";
			element3.innerHTML='Input: <input type="text" id="txtSearch">';
			//element3.style.width  = 100 + "px";
			//element3.style.height = 30 + "px";
			var obj3 = new THREE.CSS3DObject( element3);			
			obj3.position.x = 100;
			obj3.position.y = 0;
			obj3.position.z = 220;
			cssScene3.add(obj3);
			cssObjects3.push( obj3 );			
			rendererCSS3	= new THREE.CSS3DRenderer();
			rendererCSS3.setSize( 500, 25 );
			rendererCSS3.domElement.style.position = 'absolute';
			rendererCSS3.domElement.style.top	  = 0;
			
			rendererCSS3.domElement.style.margin	  = 0;
			rendererCSS3.domElement.style.padding  = 0;
			*/
			
			
			projector = new THREE.Projector();
			raycaster = new THREE.Raycaster();
			
			//renderer = new THREE.WebGLRenderer( { alpha: false } );
			//renderer.setSize( WIDTH, HEIGHT );
			
			//ray = new THREE.Ray();
			

			renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
			//renderer.sortObjects = false;
			renderer.setSize( window.innerWidth, window.innerHeight );
			//renderer.setSize( parseInt(window.innerWidth*0.99), window.innerHeight );
			
			pip = document.createElement('div');
			pip.style.width = window.innerWidth*0.6;
			pip.style.height = window.innerHeight*0.15;
			pip.style.position = 'absolute';
			pip.style.backgroundColor = 'black';
			pip.style.borderRadius = "5px";
			pip.style.border = '2px solid white';
			pip.style.padding = "0px 20px";
			pip.style.left = "2000px";
			pip.style.top = "2000px";
			document.body.appendChild(pip);
			
			renderer2 = new THREE.WebGLRenderer({ antialias: true, alpha: false });
			//renderer.sortObjects = false;
			renderer2.setSize( window.innerWidth*0.6, window.innerHeight*0.15 );
			pip.appendChild(renderer2.domElement);
			
			//var container2 = document.createElement( 'div' );
			//document.body.appendChild(container2);
			//container2.appendChild( rendererCSS3.domElement );
			
			var container = document.getElementById( 'container' );
			
			container.appendChild( renderer.domElement );
			positionContainer = $("#container").position();
			var menu = document.getElementById( 'menu' )
			menu.style.position="absolute";
			menu.style.right="0px";
			menu.style.bottom=(0-positionContainer.top)+"px";//(positionContainer.top-positionContainer.height-30)+"px";
			//console.log( "left: " + position.left + ", top: " + position.top );
			
			//container.appendChild( rendererCSS2.domElement );
			
			
			controls = new THREE.OrbitControls( camera, container  );
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;
				
			
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			
			container.appendChild( stats.domElement );
			stats.domElement.style.top = ($("#container").height()-60)+'px';
			// add grid for graph...
			/*var gridYZ = new THREE.GridHelper(50, 10);
			gridYZ.position.set( 1000,100,100 );
			gridYZ.rotation.y = Math.PI/2;
			gridYZ.setColors( new THREE.Color(0x660000), new THREE.Color(0x660000) );
			scene.add(gridYZ);*/

			//
			//renderer.domElement.addEventListener( 'mousemove', onMouseMove );
			
			
			
			
			//gui = new dat.GUI();
			
			
			function stopEvents(){
				stopThreeJsMouseEvent=true;
			}
			function resumeEvents(){
				stopThreeJsMouseEvent=false;
			}
			//gui.domElement.onmouseenter = stopEvents;
			//gui.domElement.onmouseleave = resumeEvents;
			
			
			
	
			//parameters = 
			//{
			//	size:8,
			//	x: 0, y: 30, z: 0,
				//x1: 0, y1: 30, z1: 0, 
				//x2: 0, y2: 30, z2: 0,
			//	color: "#ff0000", // color (change "#" to "0x")
				//opacity: 1, 
			//	visible: true,
				//material: "Phong",
				//reset: function() { resetCube() },
			//	name: "something"
				
			//};
			/*
			var FParameters = function() {
				this.size=8;
				this.x=0;
				this.y=0;
				this.z=0;
				this.color= "#ff0000";
				this.visible=true;
				this.name="";
			}
			
			parameters= new FParameters();
			
			var folder1 = gui.addFolder('Position element');
			var guiX = folder1.add( parameters, 'x' ).min(-800).max(800).step(10).listen();
			var guiY = folder1.add( parameters, 'y' ).min(-800).max(800).step(10).listen();
			var guiZ = folder1.add( parameters, 'z' ).min(-800).max(800).step(10).listen();
			guiX.onChange(function(value){   
				if(closestType>=0 && closestType<7){
					scene.children[closestType].geometry.attributes.position.array[closestid*3+0]=value;
					scene.children[closestType].geometry.attributes.position.needsUpdate = true;
				}
			});
			guiY.onChange(function(value){   
				if(closestType>=0 && closestType<7){
					scene.children[closestType].geometry.attributes.position.array[closestid*3+1]=value;
					scene.children[closestType].geometry.attributes.position.needsUpdate = true;
				}
			});
			guiZ.onChange(function(value){ 
				if(closestType>=0 && closestType<7){			
					scene.children[closestType].geometry.attributes.position.array[closestid*3+2]=value;
					scene.children[closestType].geometry.attributes.position.needsUpdate = true;
				}
			});
			
			// add a re-size gui element. When size changed, particle size updated...
			sizeParticleGuiElem = gui.add( parameters, 'size').min(5).max(80).step(1).listen().name("size");
			
			sizeParticleGuiElem.onChange(function(value) {
				if(closestType>=0 && closestType<7){	
					scene.children[closestType].geometry.attributes.size.array[closestid]=value;
					scene.children[closestType].geometry.attributes.size.needsUpdate = true;
				}
			});
			
			
			
			colorParticleGuiElem = gui.addColor( parameters, 'color' ).name('Color').listen();
			colorParticleGuiElem.onChange(function(value){
				if(closestType>=0 && closestType<7){	
				//controls = undefined;
					colorParticleGui.setHex( value.replace("#", "0x") );
					scene.children[closestType].geometry.attributes.ca.array[closestid*3+0]=colorParticleGui.r;	
					scene.children[closestType].geometry.attributes.ca.array[closestid*3+1]=colorParticleGui.g;	
					scene.children[closestType].geometry.attributes.ca.array[closestid*3+2]=colorParticleGui.b;					
					scene.children[closestType].geometry.attributes.ca.needsUpdate = true;	
				}
				if(closestType==7){	
				//controls = undefined;
					colorParticleGui.setHex( value.replace("#", "0x") );
					scene.children[closestType].geometry.attributes.ca.array[closestid*3+0]=colorParticleGui.r;	
					scene.children[closestType].geometry.attributes.ca.array[closestid*3+1]=colorParticleGui.g;	
					scene.children[closestType].geometry.attributes.ca.array[closestid*3+2]=colorParticleGui.b;	
					scene.children[closestType].geometry.attributes.ca.array[(closestid+1)*3+0]=colorParticleGui.r;	
					scene.children[closestType].geometry.attributes.ca.array[(closestid+1)*3+1]=colorParticleGui.g;	
					scene.children[closestType].geometry.attributes.ca.array[(closestid+1)*3+2]=colorParticleGui.b;	
					scene.children[closestType].geometry.attributes.ca.needsUpdate = true;	
				}
			});
			gui.add( parameters, 'name' ).name("type").listen();
			
			gui.open();
			*/
			/*var FParameters = function() {
				this.models="";
			}
			var parameters= new FParameters();
			var chooseModel=gui.add(parameters, 'models', simpleListModels );
			chooseModel.onChange(function(newValue) {
				if (newValue!="none"){
					// ask server to send model file...
					socket.emit('request-model', [ newValue, myusername]);
					//xhttp.open("GET","models/"+newValue+".json",false);
					//xhttp.send();
					//selectedModel=JSON.parse(xhttp.responseText);
					//console.log("getting model data from : "+newValue+"_model.json" );
					
				}
				else{
					selectedModel=[[],[],[],[]];
					updatedModel=true;
					
				}
				
				
			});
			gui.open();
			*/
			//selectedModel=
			
			window.addEventListener( 'resize', onWindowResize, false );
			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			document.addEventListener( 'mousedown', onDocumentMouseDown, false );
			document.addEventListener( 'mouseup', onDocumentMouseUp, false );
			
			
			var button = document.getElementById( 'view4' );
			button.addEventListener( 'click', function ( event ) {
				//console.log("view3");
				
				if (toggledLines==0){
					//console.log(scene.children[7].geometry.attributes.compartment.array.length);
					//for ( var iv = 0; iv < scene.children[7].geometry.attributes.position.array.length; iv +=2) {
					for ( var iv = 0; iv <extraLinesCnt; iv +=2) {
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] -=150000;
						scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] -=150000;
					}
					
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					toggledLines=1
				}
				else{
					//for ( var iv = 0; iv < scene.children[7].geometry.attributes.position.array.length; iv +=2) {
					for ( var iv = 0; iv <extraLinesCnt; iv +=2) {
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] +=150000;
						scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] +=150000;
					}
					
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					
					
					toggledLines=0
				}

			}, false );
			
			var button = document.getElementById( 'view5' );
		button.addEventListener( 'click', function ( event ) {
			//console.log("view3");
			
			if (toggledToken==0){
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					//scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y-=150000;
					//scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					//tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y-=150000;
					//tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				tokenUniforms.mixAmount.value = 0.0;
				//var ii=0;
				//for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				//	tokenAttributes.mixAmount.value[ii] = 0.0;
				//	ii++;
				//}
				//tokenAttributes.mixAmount.needsUpdate = true;
				toggledToken=1
			}
			else{
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					//scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y+=150000;
					//scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					//tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y+=150000;
					//tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				tokenUniforms.mixAmount.value = 0.0;
				//var ii=0;
				//for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				//	tokenAttributes.mixAmount.value[ii] = 0.0;
				//	ii++;
				//}
				//tokenAttributes.mixAmount.needsUpdate = true;
				toggledToken=0
			}

		}, false );
		
		var button = document.getElementById( 'view2' );
				button.addEventListener( 'click', function ( event ) {
				
				if (exploded==false){
				
				focus_label=0;
				
				//console.log(nbOrganelles)
				for (var i=0;i<nbOrganelles;i++){
					organelles[i].position.set( Math.sin((2*Math.PI)/nbOrganelles*i)*scaleExplosion, yStartDisplacement, Math.cos((2*Math.PI)/nbOrganelles*i)*scaleExplosion );
					
				}
				//if (selectedModel[0][0]=="Ecoli2.0"){
									
				//}
				
				nucleus.position.set( 0, yStartDisplacement+1000, 0 );
				cytoplasm.position.set( 0, yStartDisplacement-1000, 0 );
				ECM.position.set( 0, yStartDisplacement-3000, 0 );
				if (nameModel=="Ec_iAF1260_flux2"){
					nucleus.position.set( 0, yStartDisplacement+0, 1000 );
					cytoplasm.position.set( 0, yStartDisplacement+0, 0 );
					ECM.position.set( 0, yStartDisplacement+0, -1000 );
				}
				
				//console.log("view2");
				for (var c=0;c<7;c++){
					
						for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
							for (var g=0;g<nbOrganelles;g++){
								if (scene.children[c].geometry.attributes.compartment.array[h]==g){
								//console.log(g)
									scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*scaleExplosion;
									scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*scaleExplosion;
								}
								
							}
							if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles){
								if (nameModel=="Ec_iAF1260_flux2"){
									scene.children[c].geometry.attributes.position.array[h*3+2]+=1000;
								}
								else{
									scene.children[c].geometry.attributes.position.array[h*3+1]+=(1000);
								}
									
									//scene.children[c].geometry.attributes.position.array[h*3+0]=scene.children[c].geometry.attributes.position.array[h*3+0]*2;
									//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
									//scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*2000;
							}
							if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles+1){
								if (nameModel=="Ec_iAF1260_flux2"){
									//scene.children[c].geometry.attributes.position.array[h*3+2]-=1000;
								}
								else{
									scene.children[c].geometry.attributes.position.array[h*3+1]-=(1000);
								}
								
								//scene.children[c].geometry.attributes.position.array[h*3+0]+=2000;
								//scene.children[c].geometry.attributes.position.array[h*3+2]*=6;
									//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
									//scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*2000;
							}
							if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles+2){
								if (nameModel=="Ec_iAF1260_flux2"){
									scene.children[c].geometry.attributes.position.array[h*3+2]-=1000;
								}
								else{
									scene.children[c].geometry.attributes.position.array[h*3+1]-=(3000);
								}
								
								//scene.children[c].geometry.attributes.position.array[h*3+0]-=2000;
								//scene.children[c].geometry.attributes.position.array[h*3+2]*=9;
									//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
									//scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*2000;
							}
							
							//b2compartments[ (i * 2)+0 ] = b1values_compartment[ i  ];
							//b2compartments[ (i * 2)+1 ] = b1values_compartment[ i+1  ];
							
						}
					
					
					scene.children[c].geometry.attributes.position.needsUpdate = true;
				}
				
				var iv=0;
				for ( var i = 0; i < segments; i ++ ) {
					var t1 = jsonObj1[jsonObj2[i][0]][6]
					var t2 = jsonObj1[jsonObj2[i][1]][6]
					//console.log(t1)
					//console.log(t2)
					//var ivList=[]
					var doIt=0
					if (t1==2){
						//console.log(idMap[jsonObj2[i][0]][1])
						scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;					
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
						
						iv++;
					}
					else if (t1==4){
						//console.log(idMap[jsonObj2[i][0]][1])
						scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
						iv++;
					}
					if (t2 ==2){
						scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;						
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;	
						iv++;
					}
					else if (t2 ==4){
						scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;				
						iv++;
					}
					
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				///////////////////////
				
				if (selectedModelNodes){
					var cnt1=0;
					var cnt2=0;
					var cnt=0;
					var ln1 = scene.children[2].geometry.attributes.size.array.length-10000;
					var ln2 = scene.children[4].geometry.attributes.size.array.length-10000;
					
					for (var mi= 0; mi<selectedModelNodes.length;mi++){
						if (selectedModelNodes[mi][5]==2 ){
							if (selectedModelNodes[mi][2]<nbOrganelles && selectedModelNodes[mi][2]>=0){
								
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*selectedModelNodes[mi][2])*scaleExplosion;
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*selectedModelNodes[mi][2])*scaleExplosion;
								cnt++;
								cnt1++;
							}
							else if (selectedModelNodes[mi][2]==nbOrganelles){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]+=1000;
								cnt++;
								cnt1++;
							}
							else if (selectedModelNodes[mi][2]==nbOrganelles+1){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]-=1000;
								cnt++;
								cnt1++;
							}
							else if (selectedModelNodes[mi][2]==nbOrganelles+2){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]-=3000;
								cnt++;
								cnt1++;
							}
						}
						else if (selectedModelNodes[mi][5]==4 ){
							if (selectedModelNodes[mi][2]<nbOrganelles && selectedModelNodes[mi][2]>=0){
								
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*selectedModelNodes[mi][2])*scaleExplosion;
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*selectedModelNodes[mi][2])*scaleExplosion;
								cnt++;
								cnt2++;
							}
							else if (selectedModelNodes[mi][2]==nbOrganelles){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]+=1000;
								cnt++;
								cnt2++;
							}
							else if (selectedModelNodes[mi][2]==nbOrganelles+1){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]-=1000;
								cnt++;
								cnt2++;
							}
							else if (selectedModelNodes[mi][2]==nbOrganelles+2){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]-=3000;
								cnt++;
								cnt2++;
							}
						}
						
					}
					scene.children[2].geometry.attributes.compartment.needsUpdate = true;
					scene.children[4].geometry.attributes.compartment.needsUpdate = true;
					scene.children[2].geometry.attributes.position.needsUpdate = true;
					scene.children[4].geometry.attributes.position.needsUpdate = true;
					
					var col2 = new THREE.Color( 0xffa500 );
					
					
					
					var count=0;
					for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
						var t1;
						var t2;
						var pt1;
						var pt2;
						var sim1=1;
						var sim2=1;
						pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
						sim1 = idMap[pt1][0]
						t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
						if (selectedModelEdges[iv-extraLinesCnt][3]==2){
							//console.log("link between model and metabolic nodes")
							
							if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
								pt2=selectedModelEdges[iv-extraLinesCnt][1];
							}
							else{
								pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
							}
							t2 = jsonObj1[pt2][6]
							sim2=2;
						}
						else{
							//console.log("link between model nodes")
							if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
								pt2=selectedModelEdges[iv-extraLinesCnt][1];
							}
							else{
								pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
							}
							t2 = selectedModelNodes[pt2][5];
						}
						if (sim2!=2){
							pt2+=jsonObj1.length;
							//console.log(idMap[pt2]);
						}
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
						if (sim2==2){
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
						}
						count+=1;
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
						if (sim2==2){
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
						}
						count+=1;
					}
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					scene.children[7].geometry.attributes.ca.needsUpdate = true;
				}	
				
				if (toggledLines==1){
					for ( var iv = 0; iv < extraLinesCnt; iv +=2) {
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] -=150000;
						scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] -=150000;
					}
					
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					
					
					
				}
				
				
				selectedLinesPathsIds=[]
				for (var i=0; i<selectedLinesPaths.length;i++){
					for (var j=0;j<linesMap[selectedLinesPaths[i]].length;j+=1){
						selectedLinesPathsIds.push(linesMap[selectedLinesPaths[i]][j])
					}
				}
				selectedLinesPathsIds = unique(selectedLinesPathsIds)
				for (var i=0;i<selectedLinesPathsIds.length;i+=1){
					scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] +=150000;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
					
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				tokenUniforms.mixAmount.value = 0.0;
				//var ii=0;
				//for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				//	tokenAttributes.mixAmount.value[ii] = 0.0;
				//	ii++;
				//}
				//tokenAttributes.mixAmount.needsUpdate = true;
				//scene.children[8].geometry.attributes.endPosition.needsUpdate = true;
				
				var createArrow = function ( width, length ) {
					var c1Geometry = new THREE.CylinderGeometry(width, width, length, 5, 5);
					var c2Geometry = new THREE.CylinderGeometry( 0, width*2.0, length/3, 5, 1 );		
					c2Geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, length/2+(length/6), 0 ) );	
					var c3Geometry = new THREE.CylinderGeometry( 0, width*2.0, length/3, 5, 1 );	
					//c3Geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, -length/2, 0 ) );
					c3Geometry.applyMatrix( new THREE.Matrix4().makeRotationZ( -Math.PI ));
					c3Geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, -(length/2+(length/6)), 0 ) );
					c1Geometry.merge(c2Geometry);
					c1Geometry.merge(c3Geometry);
					c1Geometry.applyMatrix( new THREE.Matrix4().makeRotationX( Math.PI/2 ));
					var cylinder = new THREE.Mesh(c1Geometry, new THREE.MeshNormalMaterial());
					return cylinder;
				}
				// create arrows between compartments
				// create arrows between organellels
				var scaleArrowsBase = scaleExplosion/1000;
				var cntArrows=0;
				for (var i=0;i<nbOrganelles;i++){
				
					arrows[cntArrows] = createArrow(20,400);
					scene.add( arrows[cntArrows] );
					// shorten length
					arrows[cntArrows].scale.z=scaleArrowsBase*0.9;
					//cylinder.rotateX(Math.PI/2);
					
					var p2 = new THREE.Vector3(0,1000,0);
					arrows[cntArrows].position.set( ((Math.sin((2*Math.PI)/nbOrganelles*i)*scaleExplosion)+p2.x)/2, (0+p2.y)/2, ((Math.cos((2*Math.PI)/nbOrganelles*i)*scaleExplosion)+p2.z)/2); 
					arrows[cntArrows].lookAt(p2);
					cntArrows++;
					
					for (var ii=0;ii<nbOrganelles;ii++){
						if (i!=ii){
							arrows[cntArrows] = createArrow(20,400);
							scene.add( arrows[cntArrows] );
							// shorten length
							//cylinder.scale.y=0.5;
							//cylinder.rotateX(Math.PI/2);
							arrows[cntArrows].scale.z=scaleArrowsBase;
							if (Math.abs(i-ii)>=2 && Math.abs(i-ii)<(nbOrganelles-1)){
								arrows[cntArrows].scale.z=scaleArrowsBase*1.3;
							}
							var p3 = new THREE.Vector3((Math.sin((2*Math.PI)/nbOrganelles*i)*scaleExplosion),0,(Math.cos((2*Math.PI)/nbOrganelles*i)*scaleExplosion));
							arrows[cntArrows].position.set( ((Math.sin((2*Math.PI)/nbOrganelles*i)*scaleExplosion)+(Math.sin((2*Math.PI)/nbOrganelles*(ii))*scaleExplosion))/2, (0+0)/2, ((Math.cos((2*Math.PI)/nbOrganelles*i)*scaleExplosion)+(Math.cos((2*Math.PI)/nbOrganelles*(ii))*scaleExplosion))/2); 
							arrows[cntArrows].lookAt(p3);
							cntArrows++;
						}
					}
					
					arrows[cntArrows] = createArrow(20,400);
					scene.add( arrows[cntArrows] );
					// shorten length
					arrows[cntArrows].scale.z=scaleArrowsBase*0.9;
					//cylinder.rotateX(Math.PI/2);
					
					var p3 = new THREE.Vector3(0,-1000,0);
					arrows[cntArrows].position.set( ((Math.sin((2*Math.PI)/nbOrganelles*i)*scaleExplosion)+p3.x)/2, (0+p3.y)/2, ((Math.cos((2*Math.PI)/nbOrganelles*i)*scaleExplosion)+p3.z)/2); 
					arrows[cntArrows].lookAt(p3);
					cntArrows++;
					arrows[cntArrows] = createArrow(20,400);
					scene.add( arrows[cntArrows] );
					// shorten length
					arrows[cntArrows].scale.z=scaleArrowsBase;
					//cylinder.rotateX(Math.PI/2);
					
					var p4 = new THREE.Vector3(0,-3000,0);
					arrows[cntArrows].position.set( ((Math.sin((2*Math.PI)/nbOrganelles*i)*scaleExplosion)+p4.x)/2, (0+p4.y)/2, ((Math.cos((2*Math.PI)/nbOrganelles*i)*scaleExplosion)+p4.z)/2); 
					arrows[cntArrows].lookAt(p4);	
					cntArrows++;
				}
				
				arrows[cntArrows] = createArrow(20,400);
				scene.add( arrows[cntArrows] );
				// shorten length
				//c5.scale.z=scaleArrowsBase*0.65;
				//cylinder.rotateX(Math.PI/2);
				var p5 = new THREE.Vector3(0,-1000,0);
				arrows[cntArrows].position.set( (0+p5.x)/2, (2000+p5.y)/2, (0+p5.z)/2); 
				arrows[cntArrows].lookAt(p5);
				cntArrows++;
				arrows[cntArrows] = createArrow(20,400);
				scene.add( arrows[cntArrows] );
				// shorten length
				//c6.scale.z=scaleArrowsBase*0.65;
				//cylinder.rotateX(Math.PI/2);
				var p6 = new THREE.Vector3(0,-3000,0);
				arrows[cntArrows].position.set( (0+p6.x)/2, (-1000+p6.y)/2.5, (0+p6.z)/2); 
				arrows[cntArrows].lookAt(p6);
				
				for (var i=0; i<arrows.length;i++){
					arrows[i].position.z-=150000;
				}
				
				
				/*if(typeof(Storage)!=="undefined") {
					//if(resetSpreadsheet==true){localStorage.selection=="";}
					if(resetSpreadsheet==true){localStorage.selection=[];}
					if (localStorage.selection==""){
						mselectedList=[]
							//console.log("empty")
							for (var i =0;i<spritesSelected.length;i++){		
								spritesSelected[i].position.set(-50000,-10000,10000);
							}
						
					}
					if (localStorage.selection.length>0){
						//console.log(mselectedList); 
						//console.log(localStorage.selection.split(",").map(function(x){return parseInt(x)})); 
						var tmpS= localStorage.selection.split(",").map(function(x){return parseInt(x)});
						
						
						//	console.log(localStorage.selection); 
						mselectedList=[];
						for (var i =0;i<tmpS.length;i++){
						mselectedList[i] =tmpS[i];
						}
						console.log(mselectedList); 
						// highlight selection
						for (var i =0;i<spritesSelected.length;i++){		
							spritesSelected[i].position.set(-50000,-10000,10000);
						}
						for (var i =0;i<mselectedList.length;i++){
							//for (var j =0;j<spritesSelected.length;j++){
							if (i<spritesSelected.length){
								//spritesSelected
								//console.log(idMap[mselectedList[i]])
								var a1 = scene.children[idMap[mselectedList[i]][0]].geometry.attributes.position.array;
								spritesSelected[i].position.set(a1[idMap[mselectedList[i]][1]*3],a1[idMap[mselectedList[i]][1]*3+1],a1[idMap[mselectedList[i]][1]*3+2]);	
							}
							
						}
						
					}			  
				} */
				}
				exploded=true;
				focus_label=0;
				}, false );
			
			var button = document.getElementById( 'view1' );
			button.addEventListener( 'click', function ( event ) {
				if (exploded==true){
					for (var i=0;i<nbOrganelles;i++){
						organelles[i].position.set( 0, yStartDisplacement, 0 );
					}
					nucleus.position.set( 0, yStartDisplacement, 0 );
					cytoplasm.position.set( 0, yStartDisplacement, 0 );
					ECM.position.set( 0, yStartDisplacement, 0 );
					//console.log(allDragged)
					if (nameModel=="Ec_iAF1260_flux2"){
						for (var c=0;c<7;c++){
							
								for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
									for (var g=0;g<nbOrganelles;g++){
										if (scene.children[c].geometry.attributes.compartment.array[h]==g){
											var flg=-1;
											for (var dr=0;dr<allDragged.length;dr++){
												if (allDragged[dr].indexOf(g)>-1){
													flg = dr;
													
												}
											}
											
											if (flg==-1){
												scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*g)*scaleExplosion;
												scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*g)*scaleExplosion;
											}
											else{
												if (flg<nbOrganelles){
													scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*flg)*scaleExplosion;
													scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*flg)*scaleExplosion;
												}
												if (flg>=nbOrganelles){
													scene.children[c].geometry.attributes.position.array[h*3+1]-=yStartDisplacement;
												}
												
											}
											
										}
									}
									if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles){
											//scene.children[c].geometry.attributes.position.array[h*3+1]0;
											//scene.children[c].geometry.attributes.position.array[h*3+0]=scene.children[c].geometry.attributes.position.array[h*3+0]*2;
											//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
											scene.children[c].geometry.attributes.position.array[h*3+2]-=1000;
									}
									//if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles+1){
										//scene.children[c].geometry.attributes.position.array[h*3+1]+=1000;
										//scene.children[c].geometry.attributes.position.array[h*3+0]+=2000;
										//scene.children[c].geometry.attributes.position.array[h*3+2]*=6;
											//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
									//		scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*2000;
									//}
									if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles+2){
										//scene.children[c].geometry.attributes.position.array[h*3+1]+=3000;
										//scene.children[c].geometry.attributes.position.array[h*3+0]-=2000;
										//scene.children[c].geometry.attributes.position.array[h*3+2]*=9;
											//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
											scene.children[c].geometry.attributes.position.array[h*3+2]+=1000;
									}
									
									//b2compartments[ (i * 2)+0 ] = b1values_compartment[ i  ];
									//b2compartments[ (i * 2)+1 ] = b1values_compartment[ i+1  ];
									
								}
								
							
							
							scene.children[c].geometry.attributes.position.needsUpdate = true;
						}
					}
					else{
						for (var c=0;c<7;c++){
							
								for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
									for (var g=0;g<nbOrganelles;g++){
										if (scene.children[c].geometry.attributes.compartment.array[h]==g){
											var flg=-1;
											for (var dr=0;dr<allDragged.length;dr++){
												if (allDragged[dr].indexOf(g)>-1){
													flg = dr;
													
												}
											}
											
											if (flg==-1){
												scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*g)*scaleExplosion;
												scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*g)*scaleExplosion;
											}
											else{
												if (flg<nbOrganelles){
													scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*flg)*scaleExplosion;
													scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*flg)*scaleExplosion;
												}
												if (flg>=nbOrganelles){
													scene.children[c].geometry.attributes.position.array[h*3+1]-=yStartDisplacement;
												}
												
											}
											
										}
									}
									if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles){
											scene.children[c].geometry.attributes.position.array[h*3+1]-=1000;
											//scene.children[c].geometry.attributes.position.array[h*3+0]=scene.children[c].geometry.attributes.position.array[h*3+0]*2;
											//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
											//scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*2000;
									}
									if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles+1){
										scene.children[c].geometry.attributes.position.array[h*3+1]+=1000;
										//scene.children[c].geometry.attributes.position.array[h*3+0]+=2000;
										//scene.children[c].geometry.attributes.position.array[h*3+2]*=6;
											//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
											//scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*2000;
									}
									if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles+2){
										scene.children[c].geometry.attributes.position.array[h*3+1]+=3000;
										//scene.children[c].geometry.attributes.position.array[h*3+0]-=2000;
										//scene.children[c].geometry.attributes.position.array[h*3+2]*=9;
											//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
											//scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*2000;
									}
									
									//b2compartments[ (i * 2)+0 ] = b1values_compartment[ i  ];
									//b2compartments[ (i * 2)+1 ] = b1values_compartment[ i+1  ];
									
								}
								
							
							
							scene.children[c].geometry.attributes.position.needsUpdate = true;
						}
					}
					
					for (var dr=0;dr<allDragged.length;dr++){
								allDragged[dr]=[];
					}
					//else if (allDragged[ni].indexOf(scene.children[c].geometry.attributes.compartment.array[h])>-1 && tmp1.indexOf(scene.children[c].geometry.attributes.compartment.array[h])>-1){
					
					
					
					var iv=0;
					for ( var i = 0; i < segments; i ++ ) {
						var t1 = jsonObj1[jsonObj2[i][0]][6]
						var t2 = jsonObj1[jsonObj2[i][1]][6]
						//var ivList=[]
						if (t1==2){
							scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;						
							iv++;
						}
						else if (t1==4){
							scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
							iv++;
						}
						if (t2 ==2){
							scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;
							iv++;
						}
						else if (t2 ==4){
							scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;
							iv++;
						}
						
						

					}
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					var cnt1=0;
					var cnt2=0;
					var cnt=0;
					var ln1 = scene.children[2].geometry.attributes.size.array.length-10000;
					var ln2 = scene.children[4].geometry.attributes.size.array.length-10000;
					if(selectedModelNodes){
					for (var i= 0; i<selectedModelNodes.length;i++){
						if (selectedModelNodes[i][5]==2 ){
							if (selectedModelNodes[i][2]<nbOrganelles && selectedModelNodes[i][2]>=0){
								
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*selectedModelNodes[i][2])*scaleExplosion;
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*selectedModelNodes[i][2])*scaleExplosion;
								cnt++;
								cnt1++;
							}
							else if (selectedModelNodes[i][2]==nbOrganelles){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]-=1000;
								cnt++;
								cnt1++;
							}
							else if (selectedModelNodes[i][2]==nbOrganelles+1){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]+=1000;
								cnt++;
								cnt1++;
							}
							else if (selectedModelNodes[i][2]==nbOrganelles+2){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]+=3000;
								cnt++;
								cnt1++;
							}
						}
						else if (selectedModelNodes[i][5]==4 ){
							if (selectedModelNodes[i][2]<nbOrganelles && selectedModelNodes[i][2]>=0){
								
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*selectedModelNodes[i][2])*scaleExplosion;
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*selectedModelNodes[i][2])*scaleExplosion;
								cnt++;
								cnt2++;
							}
							else if (selectedModelNodes[i][2]==nbOrganelles){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]-=1000;
								cnt++;
								cnt2++;
							}
							else if (selectedModelNodes[i][2]==nbOrganelles+1){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]+=1000;
								cnt++;
								cnt2++;
							}
							else if (selectedModelNodes[i][2]==nbOrganelles+2){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]+=3000;
								cnt++;
								cnt2++;
							}
						}
						
					}
					}
					scene.children[2].geometry.attributes.compartment.needsUpdate = true;
					scene.children[4].geometry.attributes.compartment.needsUpdate = true;
					scene.children[2].geometry.attributes.position.needsUpdate = true;
					scene.children[4].geometry.attributes.position.needsUpdate = true;
					
					var col2 = new THREE.Color( 0xffa500 );
					
					
					
					//console.log(nbEdgesModel)
					var count=0;
					for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
						var t1;
						var t2;
						var pt1;
						var pt2;
						var sim1=1;
						var sim2=1;
						pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
						sim1 = idMap[pt1][0]
						t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
						if (selectedModelEdges[iv-extraLinesCnt][3]==2){
							//console.log("link between model and metabolic nodes")
							
							if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
								pt2=selectedModelEdges[iv-extraLinesCnt][1];
							}
							else{
								pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
							}
							t2 = jsonObj1[pt2][6]
							sim2=2;
						}
						else{
							//console.log("link between model nodes")
							if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
								pt2=selectedModelEdges[iv-extraLinesCnt][1];
							}
							else{
								pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
							}
							t2 = selectedModelNodes[pt2][5];
						}
						if (sim2!=2){
							pt2+=jsonObj1.length;
							//console.log(idMap[pt2]);
						}
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
						if (sim2==2){
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
						}
						count+=1;
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
						scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
						if (sim2==2){
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
						scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
						}
						count+=1;
					}
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					scene.children[7].geometry.attributes.ca.needsUpdate = true;
					
					if (toggledLines==1){
						for ( var iv = 0; iv < extraLinesCnt; iv +=2) {
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] -=150000;
							scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] -=150000;
						}
						
						scene.children[7].geometry.attributes.position.needsUpdate = true;
						
						
						
					}
					
					
					selectedLinesPathsIds=[]
					for (var i=0; i<selectedLinesPaths.length;i++){
						for (var j=0;j<linesMap[selectedLinesPaths[i]].length;j+=1){
							selectedLinesPathsIds.push(linesMap[selectedLinesPaths[i]][j])
						}
					}
					selectedLinesPathsIds = unique(selectedLinesPathsIds)
					for (var i=0;i<selectedLinesPathsIds.length;i+=1){
						scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] +=150000;
					}
					scene.children[7].geometry.attributes.position.needsUpdate = true;
						
					var ii=0;
					for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					
						scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
						scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
						scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
						ii++;
					}
					//console.log(tokenAttributes.endPosition.value[0]);
					var ii=0;
					for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
						tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
						tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
						tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
						
						ii++;
					}
					tokenUniforms.mixAmount.value = 0.0;
					//var ii=0;
					//for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					//	tokenAttributes.mixAmount.value[ii] = 0.0;
					//	ii++;
					//}
					//tokenAttributes.mixAmount.needsUpdate = true;
					//console.log(tokenAttributes.endPosition.value[0]);
					scene.children[8].geometry.verticesNeedUpdate = true;
					tokenAttributes.endPosition.needsUpdate = true;
					
						//var lookPosition  = new THREE.Vector3(Math.sin((2*Math.PI)/nbOrganelles*0)*scaleExplosion, 1100, Math.cos((2*Math.PI)/nbOrganelles*0)*scaleExplosion);
						//var lookTarget = new THREE.Vector3(Math.sin((2*Math.PI)/nbOrganelles*0)*scaleExplosion, -10, Math.cos((2*Math.PI)/nbOrganelles*0)*scaleExplosion);
						//cameraGoTo(lookPosition, lookTarget);
					for (var i=0; i<arrows.length;i++){
						arrows[i].position.z-=150000;
					}
					/*if(typeof(Storage)!=="undefined") {
						//if(resetSpreadsheet==true){localStorage.selection=="";}
						if(resetSpreadsheet==true){localStorage.selection=[];}
						if (localStorage.selection==""){
							mselectedList=[]
								//console.log("empty")
								for (var i =0;i<spritesSelected.length;i++){		
									spritesSelected[i].position.set(-50000,-10000,10000);
								}
							
						}
						if (localStorage.selection.length>0){
							//console.log(mselectedList); 
							//console.log(localStorage.selection.split(",").map(function(x){return parseInt(x)})); 
							var tmpS= localStorage.selection.split(",").map(function(x){return parseInt(x)});
							
							
							//	console.log(localStorage.selection); 
							mselectedList=[];
							for (var i =0;i<tmpS.length;i++){
							mselectedList[i] =tmpS[i];
							}
							console.log(mselectedList); 
							// highlight selection
							for (var i =0;i<spritesSelected.length;i++){		
								spritesSelected[i].position.set(-50000,-10000,10000);
							}
							for (var i =0;i<mselectedList.length;i++){
								//for (var j =0;j<spritesSelected.length;j++){
								if (i<spritesSelected.length){
									//spritesSelected
									//console.log(idMap[mselectedList[i]])
									var a1 = scene.children[idMap[mselectedList[i]][0]].geometry.attributes.position.array;
									spritesSelected[i].position.set(a1[idMap[mselectedList[i]][1]*3],a1[idMap[mselectedList[i]][1]*3+1],a1[idMap[mselectedList[i]][1]*3+2]);	
								}
								
							}
							
						}			  
					}*/
					exploded=false;
				}
			}, false );
			
			
		}
		
		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		}
		
		function onDocumentMouseMove( event ) {
		
			//event.preventDefault();
			//position = window.pageYOffset+$("#container").position();//+;
			
			mouse.x = ( (event.clientX+window.pageXOffset) / window.innerWidth ) * 2 - 1;
			mouse.y = - ( (event.clientY-$("#container").position().top+window.pageYOffset) / window.innerHeight ) * 2 + 1;

		}
		
		function unique(a){
			var arr = [];
			for (var i=0;i<a.length;i++){
				if ( arr.indexOf(a[i]) == -1){
					arr.push(a[i]);
				}
			}
			return arr
		}
		
		function onDocumentMouseDown( event ) {

				//event.preventDefault();
				
				switch ( event.button ) {
					case 0: // left 
					
						if	((isOnParticle==1) && (hoveredType>=0) && (stopThreeJsMouseEvent==false) ){
							closestid =closest;
							closestType=hoveredType;
							//parameters.size=scene.children[closestType].geometry.attributes.size.array[closestid];
							//colorParticleGui.r=scene.children[closestType].geometry.attributes.ca.array[closestid*3+0];
							//colorParticleGui.g=scene.children[closestType].geometry.attributes.ca.array[closestid*3+1];
							//colorParticleGui.b=scene.children[closestType].geometry.attributes.ca.array[closestid*3+2];
							//parameters.color='#' +('000000'+colorParticleGui.getHex().toString(16)).slice(-6);
							
							//myLinkName=""+jsonObj1[typesMap[closestType][closestid]][2]
							//var mlTile= document.getElementById( 'myLink' )
							//mlTile.innerHTML=myLinkName
							//mlTile.href=null
							//var ml=[]
							//for (var ln =0; ln<10;ln++){
								//ml[ln] = document.getElementById( 'myLink'+ln )
								
							//}
							
							//ml.innerHTML=myLinkName
							
							//for (var ln =0; ln<10;ln++){
							//	myLink[ln]=null
								//myLink[ln]=jsonObj1[typesMap[closestType][closestid]].encodedBy[ln]
								//ml[ln].innerHTML=""
								//ml[ln].href=myLink[ln]
							//}
							//console.log(closestid)
							//console.log(typesMap[closestType][closestid])
							
							
							//var dat =typesMap[listretPointsTypes[myr]][closest];
							//if(jsonObj1[dat]){
							//	stringTxt = jsonObj1[dat][0]+" "+jsonObj1[dat][2];
							//	if (jsonObj1[dat][4][1] && jsonObj1[dat][4][1][0]){
							//		stringTxt = jsonObj1[dat][0]+" "+jsonObj1[dat][2]+" ("+jsonObj1[dat][4][1][0]+")";
							//	}
								
							//}
							//else{
							//	if (listretPointsTypes[myr]==2){																
							//		stringTxt = " "+selectedModelNodes[dat-jsonObj1.length][1];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
							//	}
							//	else if (listretPointsTypes[myr]==4){											
							//			stringTxt = " "+selectedModelNodes[nbPlacesModel+dat-jsonObj1.length][1];
							//	}
								//else{stringTxt = " ";}
							//}
							
							//console.log(jsonObj1[typesMap[closestType][closestid]])
							var nbS2=0
							try{
								text0.innerHTML = ""+jsonObj1[typesMap[closestType][closestid]][2];
								text0.style.top = positionContainer.top +10+ 'px';
								text0.style.left = 20 + 'px';
								
								
								var txtListGenes = '<ul style="margin-left:0em;padding-left:1.3em;height:50px;">';
								for (var ln =0; ln<jsonObj1[typesMap[closestType][closestid]][4][0].length;ln++){
									myLink[ln]=jsonObj1[typesMap[closestType][closestid]][4][0][ln]
									//ml[ln].innerHTML=myLink[ln].substring(myLink[ln].lastIndexOf("/")+1);;
									txtListGenes += '<li ><a href="'+myLink[ln]+'" target="_blank">'+myLink[ln].substring(myLink[ln].lastIndexOf("/")+1);+'</a></li>';
									//ml[ln].href=myLink[ln]
								}
								txtListGenes += '</ul>';
								listGenesContent.innerHTML = txtListGenes;
								if (jsonObj1[typesMap[closestType][closestid]][4][0].length<=0){
									listGenes.style.top = 2000 + 'px';
									listGenes.style.left = 2000 + 'px';
								}else{
									listGenes.style.top = (text0.clientHeight+positionContainer.top) +40+ 'px';
									listGenes.style.left = 20 + 'px';
									//text0.style.top = (listGenes.clientHeight+positionContainer.top) + 'px';
								}
							}
							catch(e){
								var stringTxt;
								var tpId;
								if (closestType==2){	
									tpId=typesMap[closestType][closestid]-jsonObj1.length;					
									stringTxt = " "+selectedModelNodes[tpId][1];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
								}
								else if (closestType==4){	
									tpId=nbPlacesModel+typesMap[closestType][closestid]-jsonObj1.length;
									stringTxt = " "+selectedModelNodes[tpId][1];
								}
								text0.innerHTML = ""+stringTxt;//selectedModelNodes[typesMap[closestType][closestid]-jsonObj1.length];
								text0.style.top = positionContainer.top +10+ 'px';
								text0.style.left = 20 + 'px';
								var identifier=typesMap[closestType][closestid]
								var txtListLinks = '<ul style="margin-left:0em;padding-left:1.3em;height:150px;">';
								if (selectedModelNodesPaths.indexOf(tpId)!=-1){
									selectedModelNodesPaths.splice(selectedModelNodesPaths.indexOf(tpId),1)
								}
								else{
									selectedModelNodesPaths.push(tpId)
									for (var i=0; i<selectedModelEdges.length;i++){
										if (selectedModelEdges[i][0]==tpId){
												
												// if selectedModelEdges[i][2]=0 then reactant , if 2 then modifier, if 1 then product
												if(selectedModelEdges[i][2]==0){
													txtListLinks += '<li >'+"transition with consumed pre-place: "+selectedModelNodes[selectedModelEdges[i][1]][1]+'</li>';
													nbS2+=1;
												}
												else if (selectedModelEdges[i][2]==1){
													txtListLinks += '<li >'+"transition with non-consumed pre-place: "+selectedModelNodes[selectedModelEdges[i][1]][1]+'</li>';
													nbS2+=1;
												}
												else if (selectedModelEdges[i][2]==2){
													txtListLinks += '<li >'+"transition with product post-place: "+selectedModelNodes[selectedModelEdges[i][1]][1]+'</li>';
													nbS2+=1;
												}
												else{
													txtListLinks += '<li >'+"place linked to metabolic network reaction: "+jsonObj1[selectedModelEdges[i][1]][2]+'</li>';
													nbS2+=1;
												}
										}
										if (selectedModelEdges[i][1]==tpId){
												// if selectedModelEdges[i][2]=0 then reactant , if 2 then modifier, if 1 then product
												if(selectedModelEdges[i][2]==0){
													txtListLinks += '<li >'+"as consumed pre-place in transition: "+selectedModelNodes[selectedModelEdges[i][0]][1]+'</li>';
													nbS2+=1;
												}
												else if (selectedModelEdges[i][2]==1){
													txtListLinks += '<li >'+"as non-consumed pre-place in transition: "+selectedModelNodes[selectedModelEdges[i][0]][1]+'</li>';
													nbS2+=1;
												}
												else if (selectedModelEdges[i][2]==2){
													txtListLinks += '<li >'+"as post-place in transition: "+selectedModelNodes[selectedModelEdges[i][0]][1]+'</li>';
													nbS2+=1;
												}
												else{
													txtListLinks += '<li >'+"as anomaly: "+selectedModelEdges[i]+'</li>';
													nbS2+=1;
												}
										}
									}
									txtListLinks += '</ul>';
									//console.log(txtListLinks);
									listLinksContent.innerHTML =txtListLinks;
								}
								
							}
							
							var nbS=0
							var txtListLinks2 = '<ul style="margin-left:0em;padding-left:1.3em;height:150px;">';
							var identifier=typesMap[closestType][closestid]
							
							//console.log(selectedModelEdges[iv-extraLinesCnt][1]);
							
							
							/*if (selectedModelNodesPaths.indexOf(identifier-jsonObj1.length)!=-1){
								selectedModelNodesPaths.splice(selectedModelNodesPaths.indexOf(identifier-jsonObj1.length),1)
								for (var i=0; i<selectedModelEdges.length;i++){
									if (selectedModelEdges[i][0]==identifier-jsonObj1.length){
										selectedModelLinesPaths.splice(selectedModelLinesPaths.indexOf(i),1)
									}
									if (selectedModelEdges[i][1]==identifier-jsonObj1.length){
										selectedModelLinesPaths.splice(selectedModelLinesPaths.indexOf(i),1)
									}
								}
							} else{
								selectedModelNodesPaths.push(identifier-jsonObj1.length)
								for (var i=0; i<selectedModelEdges.length;i++){
									if (selectedModelEdges[i][0]==identifier-jsonObj1.length){
										selectedModelLinesPaths.push(i)
										txtListLinks += '<li >'+selectedModelNodes[selectedModelEdges[i][1]][1]+'</li>';
										nbS+=1;
									}
									if (selectedModelEdges[i][1]==identifier){
										selectedModelLinesPaths.push(i)
										txtListLinks += '<li >'+selectedModelNodes[selectedModelEdges[i][1]][1]+'</li>';
										nbS+=1;
									}
								}
					
							}*/
							
							if (selectedNodesPaths.indexOf(identifier)!=-1){
								selectedNodesPaths.splice(selectedNodesPaths.indexOf(identifier),1)
								for (var i=0; i<jsonObj2.length;i++){
									if (jsonObj2[i][0]==identifier){
										selectedLinesPaths.splice(selectedLinesPaths.indexOf(i),1)
									}
									if (jsonObj2[i][1]==identifier){
										selectedLinesPaths.splice(selectedLinesPaths.indexOf(i),1)
									}
								}
							} else{
								selectedNodesPaths.push(identifier)
								for (var i=0; i<jsonObj2.length;i++){
									if (jsonObj2[i][0]==identifier){
										selectedLinesPaths.push(i)
										txtListLinks2 += '<li >'+jsonObj1[jsonObj2[i][1]][2]+'</li>';
										nbS+=1;
									}
									if (jsonObj2[i][1]==identifier){
										selectedLinesPaths.push(i)
										txtListLinks2 += '<li >'+jsonObj1[jsonObj2[i][0]][2]+'</li>';
										nbS+=1;
									}
								}
					
							}
							for (var i=0; i<selectedLinesPathsIds.length;i++){
								scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] -=150000;
							}
							selectedLinesPathsIds=[]
							for (var i=0; i<selectedLinesPaths.length;i++){
								for (var j=0;j<linesMap[selectedLinesPaths[i]].length;j+=1){
									selectedLinesPathsIds.push(linesMap[selectedLinesPaths[i]][j])
								}
							}
							selectedLinesPathsIds = unique(selectedLinesPathsIds)
							for (var i=0;i<selectedLinesPathsIds.length;i+=1){
								scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] +=150000;
							}
							scene.children[7].geometry.attributes.position.needsUpdate = true;
							txtListLinks2 += '</ul>';
							//
							if (nbS==0 && nbS2==0){
								listLinks.style.top = 2000 + 'px';
								listLinks.style.left = 2000 + 'px';
							}else{
								if (nbS!=0){
									listLinksContent.innerHTML =txtListLinks2;
								}
								
								//listLinksContent.width=$("#container").width;
								//listLinksContent.height=$("#container").height+positionContainer.top;
								//listLinks.width=$("#container").width;
								//listLinks.height=$("#container").height+positionContainer.top;
								//listLinks.style.width=$("#container").width;
								//listLinks.style.height=$("#container").style.height;
								listLinks.style.overflow="auto";
								listLinks.style.top = (listGenes.clientHeight+positionContainer.top)+40 + 'px';
								listLinks.style.left = 20 + 'px';
							}
							//console.log(selectedLinesPathsIds)
						}
						else if (isOnLine==1 && isOnParticle==0 && stopThreeJsMouseEvent==false){
							parameters.name="line";
							closestType=hoveredType;
							closestid =closestLine;
							parameters.size=0;
							
							colorParticleGui.r=scene.children[closestType].geometry.attributes.ca.array[closestid*3+0];
							colorParticleGui.g=scene.children[closestType].geometry.attributes.ca.array[closestid*3+1];
							colorParticleGui.b=scene.children[closestType].geometry.attributes.ca.array[closestid*3+2];
							parameters.color='#' +('000000'+colorParticleGui.getHex().toString(16)).slice(-6);
							
						}
						else{
							var onDraggableNb = 0;
							for (var ni=0;ni<nbCompartments;ni++){
								if (onCompartments[ni]==true){
									draggingCompartments[ni]=true;
									onDraggableNb+=1;
									controls.noRotate=true;
									// change mouse cursor shape 
									
									
								}
								
							}
							//if(onDraggableNb>1){
							//	container.style.cursor = 'pointer';
							//}
							//else{
							//	container.style.cursor = 'auto';
							//}
							//if(onDraggableNb>1){
							//			container.style.cursor = 'pointer';
							//		}
							//if(onDraggableNb>0){
							//container.style.cursor = 'pointer';
								//container.style.cursor = 'auto';
							//	controls.noRotate=true;
							//	if(onDraggableNb>1){
							//		container.style.cursor = 'pointer';
							//	}
							//	else{container.style.cursor = 'auto';}
							//}
							//else{
							//container.style.cursor = 'auto';
							//}
						}
							//parameters.name="";
						break;
					case 1: // middle
						break;
					case 2: // right
						break;
				}
				
					
				

				
			}
		function onDocumentMouseUp( event ) {
			switch ( event.button ) {
			
				case 0:
						//mpressed=false;
					//if	((isOnParticle==1) && (hoveredType>=0) && (stopThreeJsMouseEvent==false) ){
						//stopThreeJsMouseEvent=false;
						var dragged=-1;
						
						for (var ni=0;ni<nbCompartments;ni++){
							if (draggingCompartments[ni]==true){
								dragged=ni;
								
							}
						}
						if (dragged!=-1){
							
							for (var ni=0;ni<nbCompartments;ni++){
								if (onCompartments[ni]==true){
									tmp1=[]
									for (var d=0;d<allDragged.length;d++){
										if (d==dragged && allDragged[d].length>0){
											for (var di=0;di<allDragged[d].length;di++){allDragged[ni].push(allDragged[d][di]);tmp1.push(allDragged[d][di])}
											
											allDragged[d]=[];
											
										}
									}
									allDragged[ni].push(dragged);
									console.log("dragging "+ dragged+" to "+ni);										
									// code to merge compartments...
									var answer = confirm ("Proceed with merging compartments?")
									if (answer){
										//alert ("Merged")
										//console.log(nbOrganelles)
										//for (var i=0;i<nbOrganelles;i++){
										//txtComp[dragged].style.top = 2000 + 'px';
										//txtComp[dragged].style.left = 2000 + 'px';
										
										//console.log(allDragged)
										//console.log("view2");
										var error=false;
										for (var c=0;c<7;c++){
												
												for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
													if (dragged<nbOrganelles && ni<nbOrganelles){
															if (scene.children[c].geometry.attributes.compartment.array[h]==dragged){
																scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*ni)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*ni)*scaleExplosion;
															}
															else if (allDragged[ni].indexOf(scene.children[c].geometry.attributes.compartment.array[h])>-1 && tmp1.indexOf(scene.children[c].geometry.attributes.compartment.array[h])>-1){
																//var mflag=false;
																//for (var d=0;d<allDragged.length;d++){
																//	if allDragged[ni].indexOf(d)
																//}
															//console.log(g) &&(allDragged[ni][allDragged[ni].length-1]==g)
																scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*ni)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*ni)*scaleExplosion;
															}
															
														
													}
													else if (dragged<nbOrganelles && ni==nbOrganelles){
														//for (var g=0;g<nbOrganelles;g++){
															if (scene.children[c].geometry.attributes.compartment.array[h]==dragged){
															//console.log(g)
																scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+1]=1000;
															}
															else if (allDragged[ni].indexOf(scene.children[c].geometry.attributes.compartment.array[h])>-1 && tmp1.indexOf(scene.children[c].geometry.attributes.compartment.array[h])>-1){							
																scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+1]=1000;
															}
														//}
													}
													else if (dragged<nbOrganelles && ni==nbOrganelles+1){
														//for (var g=0;g<nbOrganelles;g++){
															if (scene.children[c].geometry.attributes.compartment.array[h]==dragged){
															//console.log(g)
																scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+1]=-1000;
															}
															else if (allDragged[ni].indexOf(scene.children[c].geometry.attributes.compartment.array[h])>-1 && tmp1.indexOf(scene.children[c].geometry.attributes.compartment.array[h])>-1){							
																scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+1]=-1000;
															}
														//}
													}
													else if (dragged<nbOrganelles && ni==nbOrganelles+2){
														//for (var g=0;g<nbOrganelles;g++){
															if (scene.children[c].geometry.attributes.compartment.array[h]==dragged){
															//console.log(g)
																scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+1]=-3000;
															}
															else if (allDragged[ni].indexOf(scene.children[c].geometry.attributes.compartment.array[h])>-1 && tmp1.indexOf(scene.children[c].geometry.attributes.compartment.array[h])>-1){							
																scene.children[c].geometry.attributes.position.array[h*3+0]-=Math.sin((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+2]-=Math.cos((2*Math.PI)/nbOrganelles*dragged)*scaleExplosion;
																scene.children[c].geometry.attributes.position.array[h*3+1]=-3000;
															}
														//}
													}
													else{
														error=true;
													}
													/*if (dragged==nbOrganelles){
														if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles){
																scene.children[c].geometry.attributes.position.array[h*3+1]=1000;
																//scene.children[c].geometry.attributes.position.array[h*3+0]=scene.children[c].geometry.attributes.position.array[h*3+0]*2;
																//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
																//scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*2000;
														}
													}
													if (dragged==nbOrganelles+1){
														if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles+1){
															scene.children[c].geometry.attributes.position.array[h*3+1]=-1000;
															//scene.children[c].geometry.attributes.position.array[h*3+0]+=2000;
															//scene.children[c].geometry.attributes.position.array[h*3+2]*=6;
																//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
																//scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*2000;
														}
													}
													if (dragged==nbOrganelles+2){
														if (scene.children[c].geometry.attributes.compartment.array[h]==nbOrganelles+2){
															scene.children[c].geometry.attributes.position.array[h*3+1]=-3000;
															//scene.children[c].geometry.attributes.position.array[h*3+0]-=2000;
															//scene.children[c].geometry.attributes.position.array[h*3+2]*=9;
																//scene.children[c].geometry.attributes.position.array[h*3+0]+=Math.sin((2*Math.PI)/nbOrganelles*g)*2000;
																//scene.children[c].geometry.attributes.position.array[h*3+2]+=Math.cos((2*Math.PI)/nbOrganelles*g)*2000;
														}
													}*/
													
													//b2compartments[ (i * 2)+0 ] = b1values_compartment[ i  ];
													//b2compartments[ (i * 2)+1 ] = b1values_compartment[ i+1  ];
													
												}
											
											
											scene.children[c].geometry.attributes.position.needsUpdate = true;
										}
										if (error){
											alert("You can only merge an organelle with the nucleus,\n the cytoplasm, the extracelluar matrix or another organelle.")
										}
										else{
										if (dragged<nbOrganelles){
											organelles[dragged].position.set( -500000, 500000, -500000 );
										}
										if(dragged==nbOrganelles){
											nucleus.position.set( -500000, 500000, -500000 );
										}
										if(dragged==nbOrganelles+1){
											cytoplasm.position.set( -500000, 500000, -500000 );
										}
										if(dragged==nbOrganelles+2){
											ECM.position.set( -500000, 500000, -500000 );
										}
										var iv=0;
										if (dragged<nbOrganelles){
										for ( var i = 0; i < segments; i ++ ) {
											var t1 = jsonObj1[jsonObj2[i][0]][6]
											var t2 = jsonObj1[jsonObj2[i][1]][6]
											//console.log(t1)
											//console.log(t2)
											//var ivList=[]
											var doIt=0
											if (t1==2){
												//console.log(idMap[jsonObj2[i][0]][1])
												//console.log(idMap[jsonObj2[i][0]])
												scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
												scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;					
												scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
												
												iv++;
												
											}
											else if (t1==4){
											//console.log(idMap[jsonObj2[i][0]])
												//console.log(idMap[jsonObj2[i][0]][1])
												scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
												scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
												scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
												iv++;
											}
											if (t2 ==2){
											//console.log(idMap[jsonObj2[i][1]])
												scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
												scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;						
												scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[2].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;	
												iv++;
											}
											else if (t2 ==4){
											//console.log(idMap[jsonObj2[i][1]])
												scene.children[7].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
												scene.children[7].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
												scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[4].geometry.attributes.position.array[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;				
												iv++;
											}
											
										}
										
										scene.children[7].geometry.attributes.position.needsUpdate = true;
										
										selectedLinesPathsIds=[]
										for (var i=0; i<selectedLinesPaths.length;i++){
											for (var j=0;j<linesMap[selectedLinesPaths[i]].length;j+=1){
												selectedLinesPathsIds.push(linesMap[selectedLinesPaths[i]][j])
											}
										}
										selectedLinesPathsIds = unique(selectedLinesPathsIds)
										for (var i=0;i<selectedLinesPathsIds.length;i+=1){
											scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] +=150000;
										}
										scene.children[7].geometry.attributes.position.needsUpdate = true;
											
										var ii=0;
										for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
										
											scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
											scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
											scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
											ii++;
										}
										//console.log(tokenAttributes.endPosition.value[0]);
										var ii=0;
										for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
											tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
											tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
											tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
											ii++;
										}
										//console.log(tokenAttributes.endPosition.value[0]);
										scene.children[8].geometry.verticesNeedUpdate = true;
										tokenAttributes.endPosition.needsUpdate = true;
										tokenUniforms.mixAmount.value = 0.0;
										//var ii=0;
										//for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
										//	tokenAttributes.mixAmount.value[ii] = 0.0;
										//	ii++;
										//}
										//tokenAttributes.mixAmount.needsUpdate = true;
										}
										}
										}
									//else
									//	alert ("Merge cancelled")
									for (var ni1=0;ni1<nbCompartments;ni1++){
										draggingCompartments[ni1]=false;
									}
						
								}
							}
						}
						//controls.enabled=true;
						controls.noRotate=false;
						
						
						
						//console.log(controls)
					//}
					break;
				case 1: // middle
					break;
				case 2: // right
					break;
			}
		}
		//function onMouseMove( e ) {

		//		mouse.x = e.clientX;
		//		mouse.y = e.clientY;

		//	}
		function animate() {

			requestAnimationFrame( animate );

			render();
			
			
			
			stats.update();

		}
		
		function toXYCoords (pos) {
			var vector = projector.projectVector(pos.clone(), camera);
			vector.x = (vector.x + 1)/2 * window.innerWidth;
			vector.y = -(vector.y - 1)/2 * window.innerHeight;
			return vector;
		}

		function render() {
			//var delta = clock.getDelta(); 
			//animatorT1.update(1500 * delta);
			
			//cssScene2.children[0].direction=camera.direction;
			//element1.position.x = camera.position.x;
			//element1.position.y = camera.position.y;
			//element1.position.z = camera.position.z;
			controls.update();
			keyboard.update();
			
			
			if ( keyboard.pressed("A") ) {
			
				controls.panLeft(5* controls.zoomScale());
			}
			if ( keyboard.pressed("D") ) {
				controls.panLeft(-5* controls.zoomScale());
			}
				
			if ( keyboard.pressed("W") ) {
				controls.panUp(5* controls.zoomScale());
			}
				
			if ( keyboard.pressed("S") ){
				controls.panUp(-5* controls.zoomScale());
			} 
			
			if ( keyboard.pressed("X") ) {
				controls.dollyIn();
			}
				
			if ( keyboard.pressed("Z") ){
				//controls.pan(-5* controls.zoomScale(),0);
				controls.dollyOut();
			} 
			if ( keyboard.down("1") ){
				if (linesShaderMaterial.depthTest){
					linesShaderMaterial.depthTest = false;
				}
				else{
					linesShaderMaterial.depthTest = true;
				}
			} 
			if ( keyboard.down("2") ){
				if (linesShaderMaterial.blending){
					linesShaderMaterial.blending = false;
				}
				else{
					linesShaderMaterial.blending = THREE.AdditiveBlending;
				}
			} 
			if ( keyboard.down("3") ){
				if (linesShaderMaterial.transparent){
					linesShaderMaterial.transparent = false;
				}
				else{
					linesShaderMaterial.transparent = true;
				}
			} 
			if ( keyboard.down("]") ){
				for (var i=0;i<segmentPts;i++){
				//for (var i=0;i<b2lopacity.length;i++){
					if (b2lopacity[i]<1.0){
					b2lopacity[i]+=0.05;
					}
				}
				scene.children[7].geometry.attributes.op.needsUpdate = true;
				//if (linesUniforms.opacity.value<1.0){
				//	linesUniforms.opacity.value+=0.05;
				//}
				//console.log("opacity: "+linesUniforms.opacity.value);
				//consol.log("+")
					//linesShaderMaterial.transparent = false;
					//linesShaderMaterial.linesUniforms.attributes.opacity+=0.1;
				//linesUniforms.opacity.value=1.0;
				//linesUniforms.opacity.value+=0.05;
				//linesUniforms.color.value.offsetHSL( 0.0005, 0, 0 );
				//linesUniforms.amplitude.value+=0.1;
			} 
			if ( keyboard.down("[")){//linesShaderMaterial.opacity-=0.1;
				//if (linesUniforms.opacity.value>0.0){
				//	linesUniforms.opacity.value-=0.05;
				//}
				for (var i=0;i<segmentPts;i++){
				//for (var i=0;i<b2lopacity.length;i++){
					if (b2lopacity[i]>0.0){
					b2lopacity[i]-=0.05;
					}
				}
				scene.children[7].geometry.attributes.op.needsUpdate = true;
				//console.log("opacity: "+linesUniforms.opacity.value);
					//linesUniforms.opacity.value-=0.05;
					//linesUniforms.color.value.offsetHSL( -0.0005, 0, 0 );
					//linesUniforms.amplitude.value-=0.1;
			} 
				
			
				
			if (updatedListModels==true){
				console.log("changing models from updated listmodels");
				// update list of all models
				simpleListModels=["none"];
				for (var i =0;i< listModels.length;i++){
					simpleListModels.push(listModels[i][0]);
				}
				
				var listBoxModels=document.getElementById("listModels");
				var stringlist="";
				for (var i =0;i< simpleListModels.length;i++){
					stringlist+='<option value="'+simpleListModels[i]+'">'+simpleListModels[i]+'</option>';	
				}
				listBoxModels.innerHTML = stringlist;	
				// file list of metabolic files
				listMetabolicFiles = [];
				for (var i =0;i< listModels.length;i++){
					if (listMetabolicFiles.indexOf(listModels[i][4])<0){
						listMetabolicFiles.push(listModels[i][4]);
					}
				}
				
				//var listBoxMetabolic=document.getElementById("listMetabolic");
				//var stringlist="";
				//for (var i =0;i< listMetabolicFiles.length;i++){
				//	stringlist+='<option value="'+listMetabolicFiles[i]+'">'+listMetabolicFiles[i]+'</option>';	
				//}
				//listBoxMetabolic.innerHTML = stringlist;
				
				
				updatedListModels=false;
			}
			//
			if (updatedModel==true){
				resetSpreadsheet=true;
				//for (var i =0;i<spritesSelected.length;i++){		
				//		spritesSelected[i].position.set(-50000,-10000,50000);
				//	}
				//localStorage.selection=="";
				//mselectedList=[];
					//console.log("empty")
					
				
			
				//localStorage.selection=="";
				//mselectedList=[];
				//for (var i =0;i<spritesSelected.length;i++){		
				//	spritesSelected[i].position.set(-50000,-10000,10000);
				//	spritesSelected[i].scale.set(100, 100, 100);
				//}
				var fValue = document.getElementById("listModels").value;
			    var iv=0;
				if (fValue!="none"){
					
					
					// erase stuff first
					var lll=bgeometryP3.attributes.position.array.length;
					for (var ml =0;ml<lll;ml+=3){
						bgeometryP3.attributes.position.array[ml]+=150000;
					}
					var lll=bgeometryP5.attributes.position.array.length;
					for (var ml =0;ml<lll;ml+=3){
						bgeometryP5.attributes.position.array[ml]+=150000;
					}
					// erase lines 
					var iv=0;
					for ( var i = 0; i < segments; i ++ ) {
						var t1 = jsonObj1[jsonObj2[i][0]][6]
						var t2 = jsonObj1[jsonObj2[i][1]][6]
						//console.log(t1)
						//console.log(t2)
						//var ivList=[]
						var doIt=0
						if (t1==2){
							//console.log(idMap[jsonObj2[i][0]][1])
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] +=150000.0;
							
							iv++;
						}
						else if (t1==4){
							//console.log(idMap[jsonObj2[i][0]][1])
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] =150000.0;
							iv++;
						}
						if (t2 ==2){
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ]=150000.0;
							iv++;
						}
						else if (t2 ==4){
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] =150000.0;			
							iv++;
						}
						
					}
					for ( var i = segments; i < segments+5000; i ++ ) {
							//b2lpositions[ (iv * 3)+0 ] = 0;
							//b2lpositions[ (iv * 3) + 1 ] = 80;
							b2lpositions[ (iv * 3) + 2 ] = 150000;
							iv++;
					}
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					bgeometry2.attributes.position.needsUpdate = true;
					
					var ii=0;
					for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					
						//scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
						//scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
						scene.children[8].geometry.vertices[ii].z=150000;
						ii++;
					}
					//console.log(tokenAttributes.endPosition.value[0]);
					var ii=0;
					for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
						//tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
						//tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
						tokenAttributes.endPosition.value[ii].z=150000;
						ii++;
					}
					//console.log(tokenAttributes.endPosition.value[0]);
					scene.children[8].geometry.verticesNeedUpdate = true;
					tokenAttributes.endPosition.needsUpdate = true;
					tokenUniforms.mixAmount.value = 0.0;
					//var ii=0;
					//for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					//	tokenAttributes.mixAmount.value[ii] = 0.0;
					//	ii++;
					//}
					//tokenAttributes.mixAmount.needsUpdate = true;
					// erase tokens
					
					
					//var lll=bgeometry2.attributes.position.array.length;
					//for (var ml =0;ml<lll;ml+=3){
					//	bgeometry2.attributes.position.array[ml]+=50000;
					//}
					
					//var lll=bgeometry2.attributes.position.array.length;
					//for (var ml =0;ml<lll;ml+=3){
					//	bgeometry2.attributes.position.array[ml]+=50000;
					//}
					
					//for ( var iv = extraLinesCnt; iv <extraLinesCnt+2000; iv +=2) {
					//		scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+50000;	
					//		scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+50000;	
					//}
					
				
					xhttp.open("GET","sbml/"+selectedModel[0][4]+"_metabolic_net.json",false);
					xhttp.send();
					selectedMetabolicData = JSON.parse(xhttp.responseText);
					console.log("getting metabolic data from new metabolic file");
					//console.log(selectedMetabolicData);
					//console.log(selectedModel[0]);
					metabolicCompartments = selectedMetabolicData[0];
					
					oldNbOrganelles=nbOrganelles;
					oldNbCompartments=nbCompartments;
					
					nbCompartments=metabolicCompartments.length
					
					nbOrganelles=nbCompartments-3;
					if (selectedModel[0][0]=="Ecoli2.0"){
						mapComp = {'-1':-1, Extra_organism:0 ,Periplasm:1 ,Cytosol:2}
						nameComp = ["Extra_organism","Periplasm","Cytosol" ];	
						element1.src	= "slickgrid132E.html"	
					}
					
					else if (selectedModel[0][0]=="HepatocyteQSSPN"){
						mapComp = {'-1':-1, GolErMi:0 ,bile:1 ,lyso:2 ,mito:3 ,peroxy:4 ,nuc:5 ,cyto:6 ,ext:7 }
						nameComp = ["GolErMi","bile","lysosome","mytochodria","peroxisome", "nucleus", "cytoplasm" ,"extra-cellular" ];	
						element1.src	= "slickgrid13HP.html"	
					}
					else{
						mapComp = {'-1':-1, g:0 ,r:1 ,l:2 ,m:3 ,x:4 ,n:5 ,c:6 ,e:7 }
						nameComp = ["golgi","ER","lysosome","mytochodria","peroxisome", "nucleus", "cytoplasm" ,"extra-cellular" ];		
						element1.src	= "slickgrid131.html"						
					}
					clearedTokenIndex=[];
					stackTokenModel=[];
					tokenStackCount=0;
					simTimer=0;
					simulationIsOn=false;
					simulationIsPaused==false;
					sliderElement.value=simTimer;
					timerElement.innerHTML="0";
					
					metabolicNodes = selectedMetabolicData[1];
					metabolicEdges = selectedMetabolicData[2];
					jsonObj1=metabolicNodes
					jsonObj2=metabolicEdges
					mnbDNA=0;
					mnbRNA=0;
					mnbProt=0;
					mnbDegProd=0;
					mnbPN=0;
					mnbLog=0;
					mnbCoarse=0;
					for (var i = 0, ii= jsonObj1.length;i<ii;i++){
						if (jsonObj1[i][6]==0){
							mnbDNA++;
						}
						if (jsonObj1[i][6]==1){
							mnbRNA++;
						}
						if (jsonObj1[i][6]==2){
							mnbProt++;
						}
						if (jsonObj1[i][6]==3){
							mnbDegProd++;
						}
						if (jsonObj1[i][6]==4){
							mnbPN++;
						}
						if (jsonObj1[i][6]==5){
							mnbLog++;
						}
						if (jsonObj1[i][6]==6){
							mnbCoarse++;
						}
					}
					nbDNAParticles=mnbDNA; // nb of DNA elements
					nbRNAParticles=mnbRNA; // nb of RNA elements
					nbProtParticles=mnbProt+10000; // nb of proteins
					nbDegradParticles=mnbDegProd; // nb of degradation products
					nbPNParticles=mnbPN+10000; // nb of PN standard places
					nbLogParticles=mnbLog; // nb of logical PN places
					nbCoarseParticles=mnbCoarse; // nb of PN coarse transitions
			
					idMap=[];
					typesMap=[];
					for (var im=0;im<7;im++){
						typesMap[im]=[];
					};
					reactionMap=[];
			
					segments =jsonObj2.length;
					//var segments =0;
					segmentPts =segments*2;
					
					
					
					/////////////////////////////////////////////
					// defines first buffergeometry for protein particles
					
					
					
					
					
					bgeometryP3.attributes.size.needsUpdate = true;
					bgeometryP3.attributes.position.needsUpdate = true;
					bgeometryP3.attributes.ca.needsUpdate = true;
					bgeometryP3.attributes.compartment.needsUpdate = true;

					//b3values_size = bgeometryP3.attributes.size.array;
					//b3positions = bgeometryP3.attributes.position.array;
					//b3values_color = bgeometryP3.attributes.ca.array;
					//b3values_compartment = bgeometryP3.attributes.compartment.array;
					
					
					
					// populates first buffer geometry for particles with coordinates, colors, and size
					var color = new THREE.Color( 0xff9900 );;
					var color2 = new THREE.Color( 0x55ff55 );
					var radius =400;
					var bv=0;
					//for( var bv = 0; bv < nbProtParticles; bv++ ) {
						for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
							if (jsonObj1[bw][6]==2){
								b3values_size[ bv ] = 10;
								//b3values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
								b3values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
								idMap[bw]=[2,bv];
								typesMap[2][bv]=bw;
								
								var rm;
								var rr;
								
								if (selectedModel[0][0]=="HepatocyteQSSPN"){
									rm=bv*0.078*2*Math.PI;
									rr = ((bv*0.02)+0.35*radius)
									b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
									b3positions[ bv * 3 + 1 ] = 0+(bv*0.05);
								}
								else if (selectedModel[0][0]=="Ecoli2.0"){
									rm=bv*0.004*2*Math.PI;
									rr = ((radius*1.08)-(bv*0.03)+1)
									b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
									b3positions[ bv * 3 + 1 ] = 0-(bv*0.03);

								}
								else{
									rm=bv*0.008*2*Math.PI;
									rr = ((bv*0.02)+0.05*radius);
									b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
									b3positions[ bv * 3 + 1 ] = 0+(bv*0.02);
								}
								
								b3positions[ bv * 3 + 2 ] = Math.sin(rm) *rr;
								
								b3values_color[ bv * 3 + 0 ] = color.r;
								b3values_color[ bv * 3 + 1 ] = color.g;
								b3values_color[ bv * 3 + 2 ] = color.b;
								bv++;
							}
						}
						startModelPlaces=bv;
						for( var bw = jsonObj1.length , bww= jsonObj1.length+10000; bw < bww; bw++ ) {
								
				
							//if (jsonObj1[bw][6]==2){
								b3values_size[ bv ] = 30;
								//b3values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
								b3values_compartment[ bv ] = -1;
								//idMap[bw]=[2,bv];
								//typesMap[2][bv]=bw;
								idMap[bw]=[2,bv];
								typesMap[2][bv]=bw;
								//var rm=(bw-jsonObj1.length)*0.078*2*Math.PI;
								//var	rr = (((bw-jsonObj1.length)*0.02)+0.95*radius)
								//radius=900;
								var rm=(bw-jsonObj1.length)*0.008*2*Math.PI;
								var rr = ((radius*1.08)-((bw-jsonObj1.length)*0.3)+1)
								b3positions[ bv * 3 + 0 ] = (Math.cos(rm) *rr)+900;
								//b3positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius+900;
								//b3positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
								b3positions[ bv * 3 + 1 ] = 80;
								b3positions[ bv * 3 + 2 ] = ((Math.random() * 2 - 1) * radius)+150000;
								//b3positions[ bv * 3 + 2 ] = (Math.sin(rm) *rr)+50000;
								
								//if ( positions[ bv * 3 + 0 ] < 0 )
								//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
								//else
								//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
								b3values_color[ bv * 3 + 0 ] = color2.r;
								b3values_color[ bv * 3 + 1 ] = color2.g;
								b3values_color[ bv * 3 + 2 ] = color2.b;
								bv++;
							//}
						}
						endModelPlaces=bv;
					//}
				
				
					// associate first particle system with bufferGeometry
					//PointCloud3 = new THREE.PointCloud( bgeometryP3, particle3ShaderMaterial );

					PointCloud3.dynamic = true;
					PointCloud3.sortParticles = true;
					PointCloud3.geometry.__dirtyVertices = true;
					
					
					
					
					bgeometryP5.attributes.size.needsUpdate = true;
					bgeometryP5.attributes.position.needsUpdate = true;
					bgeometryP5.attributes.ca.needsUpdate = true;
					bgeometryP5.attributes.compartment.needsUpdate = true;

					//b5values_size = bgeometryP5.attributes.size.array;
					//b5positions = bgeometryP5.attributes.position.array;
					//b5values_color = bgeometryP5.attributes.ca.array;
					//b5values_compartment = bgeometryP5.attributes.compartment.array;
					
					// populates first buffer geometry for particles with coordinates, colors, and size
					var color = new THREE.Color( 0xffffff );
					
					var color2 = new THREE.Color( 0x55ffff );
					var radius =400;
					var bv=0;
					//for( var bv = 0; bv < nbPNParticles; bv++ ) {
					/*subSystems=[];
					for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
						if (jsonObj1[bw][6]==4){
							if (jsonObj1[bw][4][1] && jsonObj1[bw][4][1][0]){
								if (subSystems.indexOf(jsonObj1[bw][4][1][0])== -1){
									subSystems.push(jsonObj1[bw][4][1][0]);
								}
							}
						}
					}*/
					//console.log(subSystems);
					// now allocate a nb of nodes by sub systems
					subSystems={};
					totalSubSystems=0;
					
					totalNbreactions=0;
					for( var bs = 0 , bww= jsonObj1.length; bs < bww; bs++ ) {
						if (jsonObj1[bs][6]==4){
							if (jsonObj1[bs][4][1] && jsonObj1[bs][4][1][0]){
								if (subSystems[jsonObj1[bs][4][1][0]]=== undefined){
									subSystems[jsonObj1[bs][4][1][0]]=1;
									totalSubSystems++;
								}
								else{
									subSystems[jsonObj1[bs][4][1][0]]++;
									totalSubSystems++;
								}
								
							}
							totalNbreactions++;
						}
					}
					totalOutsideSubSystems=totalNbreactions-totalSubSystems;
					nbSubSystems=Object.keys(subSystems).length
					if (totalOutsideSubSystems>0){
						nbAreas=nbSubSystems+1;
						subSystems["Not present"]=totalOutsideSubSystems;
					}
					else{
						nbAreas=nbSubSystems;
					}
					console.log(subSystems);
					
					//console.log(totalSubSystems);
					//console.log(totalNbreactions);
					//console.log(totalOutsideSubSystems);
					//console.log(nbSubSystems);
					
					// if there is no subsystem identified just use standard spiral layout
					
					// if there are n subsystems then display circular region of width proportional to the nb of nodes in each subsystem
					// first make a list of widths
					// total nb of reactions will dictate the overall nb of points that must be displayed on the ring.
					// depth of the ring is 30 points. there are for 0.004 *2Pi=1.44 degrees = 250 graduations on a circle 
					var listWidthSubSystems={};
					var nbCircleGraduations=250;
					var minCircleFraction=1/nbCircleGraduations;
					var nbNodesDepth=40;
					var totalWidth=0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							var width= Math.ceil(subSystems[key]/nbNodesDepth);
							listWidthSubSystems[key]=[subSystems[key]/*nb of nodes*/,width,/*counter value*/0];
							totalWidth+=width;
						}
					}
					nbNodesDepth=Math.ceil((40*totalWidth)/244);
					listWidthSubSystems={};
					var totalWidth=0;
					var cumulativeWidth=0;
					var colorswap=1.0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							var width= Math.ceil(subSystems[key]/nbNodesDepth);
							listWidthSubSystems[key]=[subSystems[key]/*nb of nodes*/,width,cumulativeWidth,/*counter value*/0,colorswap];
							totalWidth+=width;
							cumulativeWidth+=width;
							if (colorswap==1.0){
							colorswap=0.7;
							}
							else{colorswap=1.0}
						}
					}
					
					//console.log(totalWidth);
					//console.log(listWidthSubSystems);
					/*for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							var percentage= subSystems[key]/totalNbreactions;
							if (percentage < minCircleFraction){
								percentage= minCircleFraction;
								
							}
							subSystems[key]=percentage;
							totalPercentage+=percentage;
							
							//console.log(percentage);
						}
					}
					console.log(totalPercentage);
					var toDistribute=0;
					if (totalPercentage>1){
						toDistribute= totalPercentage-1;
					}
					var nbReducable=0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							if((subSystems[key]*(1-toDistribute))>minCircleFraction){
								nbReducable++;
							}
						}
					}
					console.log(nbReducable);
					var sums=0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							if((subSystems[key]*(1-toDistribute))>minCircleFraction){
								var res=subSystems[key]*(1-(toDistribute));
								subSystems[key]=res;
								
							}
							sums+=subSystems[key];
							
							//toDistribute/nbReducable
						}
					}
					console.log(subSystems+" total: "+sums);*/
					//var cnt1=0
					//var cnt2=0;
					var localRSeparator=0;
					for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
						
						if (jsonObj1[bw][6]==4){

							b5values_size[ bv ] = 10;
							//b5values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
							
							// try to assign the compartment of the majority of the products the reaction is linked to 
							// if there is no product, assign the compartment of the majority of modifiers
							// if there is no modifier, assign the compartment of the majority of reactants
							var listProducts= jsonObj1[bw][11][0];
							var listModifiers= jsonObj1[bw][11][1];
							var listReactants= jsonObj1[bw][11][2];
							
							if (listProducts.length>0){
								var votes=[];
								for (var ncc=0;ncc<nbCompartments;ncc++){
									votes[ncc]=0;
								}
								for(var lp=0;lp<listProducts.length;lp++){
									if (mapComp[jsonObj1[listProducts[lp]][3]]>=0)
										votes[mapComp[jsonObj1[listProducts[lp]][3]]]++;
								}
								var winner= votes.indexOf(Math.max.apply( Math, votes ));
								b5values_compartment[ bv ] = winner;
								if (winner==-1){
									b5values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
								}
							} 
							else if (listModifiers.length>0){
								var votes=[];
								for (var ncc=0;ncc<nbCompartments;ncc++){
									votes[ncc]=0;
								}
								for(var lp=0;lp<listModifiers.length;lp++){
									if (mapComp[jsonObj1[listModifiers[lp]][3]]>=0)
										votes[mapComp[jsonObj1[listModifiers[lp]][3]]]++;
								}
								var winner= votes.indexOf(Math.max.apply( Math, votes ));
								b5values_compartment[ bv ] = winner;
								if (winner==-1){
									b5values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
								}
							}
							else if (listReactants.length>0){
								var votes=[];
								for (var ncc=0;ncc<nbCompartments;ncc++){
									votes[ncc]=0;
								}
								for(var lp=0;lp<listReactants.length;lp++){
									if (mapComp[jsonObj1[listReactants[lp]][3]]>=0)
										votes[mapComp[jsonObj1[listReactants[lp]][3]]]++;
								}
								var winner= votes.indexOf(Math.max.apply( Math, votes ));
								b5values_compartment[ bv ] = winner;
								if (winner==-1){
									b5values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
								}
							}
							else {
								// if no species linked, put reaction in the center
								b5values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
							}
							
							idMap[bw]=[4,bv];
							typesMap[4][bv]=bw;
							
							var rm;
							var rr; 
							
							
							
							
							if (selectedModel[0][0]=="Ecoli2.0"){
								rm=bv*0.078*2*Math.PI;
								rr = ((bv*0.02)+0.35*radius)
								//b5positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
								b5positions[ bv * 3 + 1 ] = 0+(bv*0.04);
							}
							else{
								//rr= ((radius*1.08)-(0*0.03)+1);
								if (jsonObj1[bw][4][1] && jsonObj1[bw][4][1][0]){
									
									//console.log("increment node")
									//console.log(jsonObj1[bw][4][1][0]);
									if (listWidthSubSystems.hasOwnProperty(jsonObj1[bw][4][1][0])) {
									
										var startingW=listWidthSubSystems[jsonObj1[bw][4][1][0]][2];
										var maxWidth=listWidthSubSystems[jsonObj1[bw][4][1][0]][1];
										var maxDepth=nbNodesDepth;
										var maxNbNodes=listWidthSubSystems[jsonObj1[bw][4][1][0]][0];
										var presentIndex= listWidthSubSystems[jsonObj1[bw][4][1][0]][3];
										if (presentIndex<maxNbNodes){
										//cnt1++;
											var localWPos=0;
											var localRR=0;
											localWPos=Math.floor(presentIndex/maxDepth);
											//if (presentIndex>=maxDepth){
												
												localRR=presentIndex%maxDepth;
											//}
											//else{
											//	localRR=presentIndex;
											//}
											//if(presentIndex==0){
											//	localRSeparator+=(nbCircleGraduations-totalWidth)/(2*nbAreas);//	rm=((startingW+localWPos+localRSeparator)*0.004*(2*Math.PI));
											//console.log(jsonObj1[bw][4][1][0])
											//listWidthSubSystems[jsonObj1[bw][4][1][0]][2]+=((nbCircleGraduations-totalWidth)/(nbAreas));
											//startingW=listWidthSubSystems[jsonObj1[bw][4][1][0]][2];
											//color.r-=0.01
											//}
											rm=((startingW+localRSeparator+localWPos)*0.004*(2*Math.PI));
											
											rr= ((radius-maxDepth*5)+(localRR*5));
											listWidthSubSystems[jsonObj1[bw][4][1][0]][3]++;
											color.r=listWidthSubSystems[jsonObj1[bw][4][1][0]][4];
											if (color.r==1.0){
											color.g=1.0;
											color.b=1.0;
											}
											else{
											color.g=0.4;
											color.b=1.0;
											}
										}
									}
								}
								else{
									
									//subSystems["Not present"]=totalOutsideSubSystems;
									if (listWidthSubSystems.hasOwnProperty("Not present")) {
									
									//console.log("increment not present")
										var startingW=listWidthSubSystems["Not present"][2];
										var maxWidth=listWidthSubSystems["Not present"][1];
										var maxDepth=nbNodesDepth;
										var maxNbNodes=listWidthSubSystems["Not present"][0];
										var presentIndex= listWidthSubSystems["Not present"][3];
										if (presentIndex<maxNbNodes){
										//cnt2++;
											var localWPos=0;
											var localRR=0;
											localWPos=Math.floor(presentIndex/maxDepth);
											//if (presentIndex>=maxDepth){
												
												localRR=presentIndex%maxDepth;
											//}
											//else{
											//	localRR=presentIndex;
											//}
											//if(presentIndex==0){
											//console.log(jsonObj1[bw][4][1][0])
											//listWidthSubSystems["Not present"][2]+=((nbCircleGraduations-totalWidth)/(nbAreas));
											//startingW=listWidthSubSystems["Not present"][2];
											//	localRSeparator+=(nbCircleGraduations-totalWidth)/(2*nbAreas);//	rm=((startingW+localWPos+localRSeparator)*0.004*(2*Math.PI));
											//}
											rm=((startingW+localRSeparator+localWPos)*0.004*(2*Math.PI));
											rr= ((radius-maxDepth*5)+(localRR*5));
											listWidthSubSystems["Not present"][3]++;
											color = new THREE.Color( 0xff0000 );
										}
									}
								}
								//console.log(listWidthSubSystems);
							
								//rm=bv*0.004*2*Math.PI;
								//rr= ((radius*1.08)-(bv*0.03)+1);
								
								//b5positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
								//b5positions[ bv * 3 + 1 ] = 0-(bv*0.03);
								b5positions[ bv * 3 + 1 ] = 0-(0*0.03);
								//console.log(jsonObj1[bw][4][1][0])
							}
							b5positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							b5positions[ bv * 3 + 2 ] = Math.sin(rm) *rr;
							
							
							b5values_color[ bv * 3 + 0 ] = color.r;
							b5values_color[ bv * 3 + 1 ] = color.g;
							b5values_color[ bv * 3 + 2 ] = color.b;
							bv++;
						}
					}
					//console.log("increment"+cnt1 + "  " +cnt2)
					startModelReactions=bv;
					for( var bw = jsonObj1.length , bww= jsonObj1.length+10000; bw < bww; bw++ ) {
						
						b5values_size[ bv ] = 30;
						
						b5values_compartment[ bv ] = -1;
						idMap[bw]=[4,bv];
						typesMap[4][bv]=bw;
						
						
						
						//radius=900;
						var rm=(bw-jsonObj1.length)*0.008*2*Math.PI;
						var rr = ((radius*0.78)-((bw-jsonObj1.length)*0.2)+1)
						//b5positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius+900;
						b5positions[ bv * 3 + 0 ] = (Math.cos(rm) *rr)+1800;
						//b5positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
						b5positions[ bv * 3 + 1 ] = 180;
						
						b5positions[ bv * 3 + 2 ] = ((Math.random() * 2 - 1) * radius)+150000;
						
						
						//if ( positions[ bv * 3 + 0 ] < 0 )
						//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
						//else
						//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
						b5values_color[ bv * 3 + 0 ] = color2.r;
						b5values_color[ bv * 3 + 1 ] = color2.g;
						b5values_color[ bv * 3 + 2 ] = color2.b;
						bv++;
					}
					endModelReactions=bv;
					
					// associate first particle system with bufferGeometry
					PointCloud5 = new THREE.PointCloud( bgeometryP5, particle5ShaderMaterial );

					PointCloud5.dynamic = true;
					PointCloud5.sortParticles = true;
					PointCloud5.geometry.__dirtyVertices = true;
				
					//console.log("changing model file representation");
					
					
					
					bgeometry2.attributes.position.needsUpdate = true;
					bgeometry2.attributes.ca.needsUpdate = true;
					bgeometry2.attributes.compartment.needsUpdate = true;

					//b2lpositions = bgeometry2.attributes.position.array;
						//var colors = bgeometry.attributes.color.array;
					//b2lcolors = bgeometry2.attributes.ca.array;
					//b2lcompartments=bgeometry2.attributes.compartment.array;
					
					var r = 800;
					var col = new THREE.Color( 0x00ffff );
					var col2 = new THREE.Color( 0x55ff55 );
					
					var iv=0;
					for ( var i = 0; i < segments; i ++ ) {
						
						var t1 = jsonObj1[jsonObj2[i][0]][6]
						var t2 = jsonObj1[jsonObj2[i][1]][6]
						var ivList=[]
						if (t1==2){
							b2lpositions[ (iv * 3)+0 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
							b2lpositions[ (iv * 3) + 1 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
							b2lpositions[ (iv * 3) + 2 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
							b2lcompartments[ (i*2)+0 ] = b3values_compartment[ (idMap[jsonObj2[i][0]][1]) ];
							b2lcolors[ iv * 3 ] = col.r;
							b2lcolors[ iv * 3 + 1 ] = col.g;
							b2lcolors[ iv * 3 + 2 ] = col.b;
							ivList.push(iv)
							//linesMap[i]=iv
							
							iv++;
						}
						else if (t1==4){
							b2lpositions[ (iv * 3)+0 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
							b2lpositions[ (iv * 3) + 1 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
							b2lpositions[ (iv * 3) + 2 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
							b2lcompartments[ (i*2)+0 ] = b5values_compartment[ (idMap[jsonObj2[i][0]][1]) ];
							b2lcolors[ iv * 3 ] = col.r;
							b2lcolors[ iv * 3 + 1 ] = col.g;
							b2lcolors[ iv * 3 + 2 ] = col.b;
							//linesMap[i]=iv
							ivList.push(iv)
							iv++;
						}
						if (t2 ==2){
							b2lpositions[ (iv * 3)+0 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
							b2lpositions[ (iv * 3) + 1 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
							b2lpositions[ (iv * 3) + 2 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;
							b2lcompartments[ (i*2)+1 ] = b3values_compartment[ (idMap[jsonObj2[i][1]][1]) ];
							b2lcolors[ iv * 3 ] = col.r;
							b2lcolors[ iv * 3 + 1 ] = col.g;
							b2lcolors[ iv * 3 + 2 ] = col.b;
							//linesMap[i]=iv
							ivList.push(iv)
							iv++;
						}
						else if (t2 ==4){
							b2lpositions[ (iv * 3)+0 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
							b2lpositions[ (iv * 3) + 1 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
							b2lpositions[ (iv * 3) + 2 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;
							b2lcompartments[ (i*2)+1 ] = b5values_compartment[ (idMap[jsonObj2[i][1]][1]) ];
							b2lcolors[ iv * 3 ] = col.r;
							b2lcolors[ iv * 3 + 1 ] = col.g;
							b2lcolors[ iv * 3 + 2 ] = col.b;
							//linesMap[i]=iv
							ivList.push(iv)
							iv++;
						}
						linesMap[i]=ivList
					}
					
					var radius=400;
					extraLinesCnt=iv;
					for ( var i = segments; i < segments+5000; i ++ ) {
						
							b2lpositions[ (iv * 3)+0 ] = (Math.random() * 2 - 1) * radius;
							b2lpositions[ (iv * 3) + 1 ] = 80;
							b2lpositions[ (iv * 3) + 2 ] = ((Math.random() * 2 - 1) * radius)+150000;
							b2lcompartments[ (i*2)+0 ] = -1;
							b2lcolors[ iv * 3 ] = col2.r;
							b2lcolors[ iv * 3 + 1 ] = col2.g;
							b2lcolors[ iv * 3 + 2 ] = col2.b;
							ivList.push(iv)
							//linesMap[i]=iv
							
							iv++;
						
						
						
					}
					
					
					
					// do the token thing
					/*var ii=0;
					for ( var i = segmentPts; i <segmentPts+5000 ; i +=2 ) {
					
						scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
						scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
						scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
						ii++;
					}
					//console.log(tokenAttributes.endPosition.value[0]);
					var ii=0;
					for ( var i = segmentPts+1; i <segmentPts+5000 ; i +=2 ) {
						tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
						tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
						tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
						ii++;
					}
					//console.log(tokenAttributes.endPosition.value[0]);
					scene.children[8].geometry.verticesNeedUpdate = true;
					tokenAttributes.endPosition.needsUpdate = true;
					//tokenUniforms.mixAmount.value = 0.0;
					var ii=0;
					for ( var i = 1; i <segmentPts+5000 ; i +=2 ) {
						tokenAttributes.mixAmount.value[ii] = 0.0;
						ii++;
					}
					tokenAttributes.mixAmount.needsUpdate = true;
					*/
					
					//for ( var i = 0; i < segmentPts; i ++ ) {
					//if (i<50)
					//	console.log(i+" -- "+b1values_compartment[i]);
					//}
					
					//bgeometry2.computeBoundingSphere();
				//console.log(bgeometry2);
					//mesh = new THREE.Line( bgeometry2, linesShaderMaterial,THREE.LinePieces );
					
					//var radius = 300;
					//tokenGeometry = new THREE.CubeGeometry( 0.8 * radius, 0.8 * radius, 0.8 * radius, 150, 100, 1 );
					// populate token geometry with "start" extremities of line segmentPts
					//tokenGeometry = new THREE.Geometry();
					
					//for ( var i = 0; i < segmentPts; i +=2 ) {
					//	tokenGeometry.vertices.push(new THREE.Vector3(b2lpositions[ (i * 3) ]+0,b2lpositions[ (i * 3) + 1 ]+0,b2lpositions[ (i * 3) + 2 ]+0));
					//}
					//var v1 = new THREE.Vector3(0,0,0);
					//var v2 = new THREE.Vector3(0,500,0);
					//var v3 = new THREE.Vector3(0,500,500);

					//geom.vertices.push(v1);
					//geom.vertices.push(v2);
					//geom.vertices.push(v3);
					
					//tokenPS = new THREE.PointCloud( tokenGeometry, tokenShaderMaterial );
					//tokenPS.dynamic = true;
					//sphere.sortParticles = true;

					//var tvertices = tokenPS.geometry.vertices;
					//var tvalues_size = tokenAttributes.size.value;
					//var tvalues_color = tokenAttributes.ca.value;
					//var tvalues_p = tokenAttributes.endPosition.value;
					//for( var v = 0, vv= tvertices.length; v < vv; v++ ) {

					//	tvalues_size[ v ] = 5;
					//	tvalues_color[ v ] = new THREE.Color( 0xff0000 );
						//tvalues_p[v]=new THREE.Vector3( 600+(Math.random() * 2 - 1) * radius, (Math.random() * 2 - 1) * radius , (Math.random() * 2 - 1) * radius );	
						//tvalues_p[v]=new THREE.Vector3(b2positions[ (v+1) * 3 ],b2positions[ (v+1) * 3 + 1 ],b2positions[ (v+1) * 3 + 2 ]);
					//}
					//for ( var i = 1; i < segmentPts; i +=2 ) {
					//	tvalues_p.push(new THREE.Vector3(b2lpositions[ i * 3 ],b2lpositions[ i * 3 + 1 ],b2lpositions[ i * 3 + 2 ]));
					//}
					
					
					
					
					// remake organelles containers
					//oldNbOrganelles=nbOrganelles;
					//var	oldNbCompartments=nbCompartments;
					for (var i=0;i<oldNbOrganelles;i++){
					//organelles[i].position.set(-50000, 50000, 0 );
					//if (selectedModel[0][0]=="Ecoli2.0"){
					//				organelles[i].position.set(-50000, 50000, 50000 );
					//}
					
						scene.remove( organelles[i] );
					}
					
					//organelles[nbOrganelles].position.set(-50000, 50000, 50000 );
					//organelles[nbOrganelles+1].position.set(-50000, 50000, 50000 );
					//organelles[nbOrganelles+2].position.set(-50000, 50000, 50000 );
					
					
					
					var canvasSize=900
					
					organelles=[];
					
									
					
					for (var i=0;i<nbOrganelles;i++){
						arraymaterial[i] = new THREE.MeshBasicMaterial( { color: 0x1111ff, side: THREE.DoubleSide } );
						var o1 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
						o1.applyMatrix( new THREE.Matrix4().makeTranslation(0, canvasSize/2, 0) );
						var o2 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
						o2.applyMatrix( new THREE.Matrix4().makeTranslation(0, -canvasSize/2, 0) );
						var o3 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
						o3.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
						o3.applyMatrix( new THREE.Matrix4().makeTranslation(canvasSize/2, 0, 0) );
						var o4 = new THREE.PlaneGeometry( canvasSize, 20, 1, 1 )
						o4.applyMatrix(new THREE.Matrix4().makeRotationZ( - Math.PI / 2 ));
						o4.applyMatrix( new THREE.Matrix4().makeTranslation(-canvasSize/2, 0, 0) );
						o1.merge(o2);
						o1.merge(o3);
						o1.merge(o4);
						organelles[i] = new THREE.Mesh( o1, arraymaterial[i] );
						//organelles[i].position.set( Math.sin((2*Math.PI)/nbOrganelles*i)*scaleExplosion, -10, Math.cos((2*Math.PI)/nbOrganelles*i)*scaleExplosion );
						
						organelles[i].name="c"+i;
						organelles[i].position.set(0, 0, 0 );
						
						organelles[i].rotation.x += (90*(Math.PI / 180));
						scene.add( organelles[i] );
						
					}
					
					
					
					
					// erase stuff
					var c = 2;
						for (var h=scene.children[c].geometry.attributes.size.array.length-10000, hh=scene.children[c].geometry.attributes.size.array.length+5000;h<hh;h++){
								scene.children[c].geometry.attributes.position.array[h*3+2]=((Math.random() * 2 - 1) * 400)+150000;
								scene.children[c].geometry.attributes.compartment.array[h]= -1;
						}
						scene.children[c].geometry.attributes.position.needsUpdate = true;
						modelVisible=false;
						var c = 4;
						for (var h=scene.children[c].geometry.attributes.size.array.length-10000, hh=scene.children[c].geometry.attributes.size.array.length+5000;h<hh;h++){
								scene.children[c].geometry.attributes.position.array[h*3+2]=((Math.random() * 2 - 1) * 400)+150000;	
								scene.children[c].geometry.attributes.compartment.array[h]= -1;
						}
						scene.children[c].geometry.attributes.position.needsUpdate = true;
						//console.log(extraLinesCnt)
						//console.log(extraLinesCnt+nbReactionsModel)
						for ( var iv = extraLinesCnt; iv <extraLinesCnt+5000; iv +=2) {
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+150000;	
							scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+150000;	
						}
					
					
					
					//console.log(modelData);
					//selectedModel=modelData;
					// update model visualisation 
					// add data 
					//console.log("selectedModel "+selectedModel[4]);
					selectedModelNodes=selectedModel[2];
					selectedModelEdges=selectedModel[3];
					//console.log(selectedModelNodes);
					//console.log(selectedModelEdges);
					// in model edges, position index 2: product = 1 , preplace =2, consumed = 0
				
					nbPlacesModel=0;
					nbReactionsModel=0;
					nbEdgesModel=selectedModelEdges.length;
					
					for (var i = 0, ii= selectedModelNodes.length;i<ii;i++){
						if (selectedModelNodes[i][5]==2 ){
							nbPlacesModel++;					
						}
						if (selectedModelNodes[i][5]==4 ){
							nbReactionsModel++;
						}
					}
					//console.log("nbPlacesModel "+nbPlacesModel);
					//console.log("nbReactionsModel "+nbReactionsModel); startModelReactions startModelPlaces
					if (modelVisible==false && nbPlacesModel!=0 && nbReactionsModel!=0){
					
						var cnt1=0;
						var cnt2=0;
						var cnt=0;
						
						//var ln1 = scene.children[2].geometry.attributes.size.array.length-5000; 
						//var ln2 = scene.children[4].geometry.attributes.size.array.length-5000; 
						var ln1 = startModelPlaces;
						var ln2 = startModelReactions;
						//console.log(ln1)
						//console.log(startModelPlaces)
						for (var i= 0; i<selectedModelNodes.length;i++){
							if (selectedModelNodes[i][5]==2 ){
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]=((Math.random() * 2 - 1) * 400);
								var rm=cnt1*0.008*2*Math.PI;
								//radius=900;
								var rr = ((radius*1.08)-(cnt1*0.2)+1)
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]= (Math.cos(rm) *rr)+900;
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (Math.sin(rm) *rr);
								scene.children[2].geometry.attributes.compartment.array[(ln1+cnt1)]= selectedModelNodes[i][2];
								//scene.children[2].geometry.attributes.compartment.array[(ln1+cnt1)]= Math.floor(Math.random()*nbCompartments);
								idMap[jsonObj1.length+cnt]=[2,cnt1+ln1]
								//typesMap[2][cnt1]=i;
								cnt1++;
								cnt++;
							}
							else if (selectedModelNodes[i][5]==4 ){
								//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=((Math.random() * 2 - 1) * 400);
								var rm=cnt2*0.008*2*Math.PI;
								//radius=600;
								var rr = ((radius*0.78)-(cnt2*0.2)+1)
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(Math.cos(rm) *rr)+1800;
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(Math.sin(rm) *rr);
								scene.children[4].geometry.attributes.compartment.array[(ln2+cnt2)]= selectedModelNodes[i][2];
								//scene.children[4].geometry.attributes.compartment.array[(ln2+cnt2)]= Math.floor(Math.random()*nbCompartments);
								idMap[jsonObj1.length+cnt]=[4,cnt2+ln2]
								//typesMap[4][cnt2]=i;
								cnt2++;
								cnt++;
							}
						}
						//console.log(cnt1)
						//console.log(cnt2)
						scene.children[2].geometry.attributes.compartment.needsUpdate = true;
						scene.children[4].geometry.attributes.compartment.needsUpdate = true;
						scene.children[2].geometry.attributes.position.needsUpdate = true;
						scene.children[4].geometry.attributes.position.needsUpdate = true;
						
						var col2 = new THREE.Color( 0xffa500 );
						
						
						//console.log(selectedModelNodes)
						//for (var s= 0; s<selectedModelEdges.length;s++){
						//	if (selectedModelEdges[s][0]==108){
						//	console.log(s)
						//	}
						//}
						
						var count=0;
						for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
							var t1;
							var t2;
							var pt1;
							var pt2;
							var sim1=1;
							var sim2=1;
							pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
							sim1 = idMap[pt1][0]
							t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
							if (selectedModelEdges[iv-extraLinesCnt][3]==2){
								//console.log("link between model and metabolic nodes")
								
								if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
									pt2=selectedModelEdges[iv-extraLinesCnt][1];
								}
								else{
									pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
								}
								t2 = jsonObj1[pt2][6]
								sim2=2;
							}
							else{
								//console.log("link between model nodes")
								if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
									pt2=selectedModelEdges[iv-extraLinesCnt][1];
								}
								else{
									pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
								}
								t2 = selectedModelNodes[pt2][5];
							}
							if (sim2!=2){
								pt2+=jsonObj1.length;
								//console.log(idMap[pt2]);
							}
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
							startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
							if (sim2==2){
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
							}
							count+=1;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
							endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
							if (sim2==2){
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
							}
							count+=1;
						}
						scene.children[7].geometry.attributes.position.needsUpdate = true;
						scene.children[7].geometry.attributes.ca.needsUpdate = true;
						
						// do the token thing
						// also create a map that connect indexes
						
						/*var ii=0;
						for ( var i = segmentPts; i <segmentPts+5000 ; i +=2 ) {
							startPositionTokenMap[ii]=i;
							scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+50000;
							scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
							scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ];
							ii++;
						}
						//console.log(tokenAttributes.endPosition.value[0]);
						
						var ii=0;
						for ( var i = segmentPts+1; i <segmentPts+5000 ; i +=2 ) {
							endPositionTokenMap[ii]=i;
							tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+50000;
							tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
							tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ];
							
							ii++;
						}
						*/
						//var ii=0;
						//for ( var i = segmentPts; i <segmentPts+(nbEdgesModel) ; i ++ ) {
							//startPositionTokenMap[ii]=i;
							//scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+50000;
							//scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
							//scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ];
							
							//tokenAttributes.mixAmount.value[ii] = 0.0;
							//tokenAttributes.size.value[ii] = 30.0;
							//tokenAttributes.ca.value[ ii ] = new THREE.Color( 0xffffaa );
							
							//endPositionTokenMap[ii]=i+1;
							//tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ ((i+1) * 3) ]+50000;
							//tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ ((i+1) * 3) + 1 ]+0;
							//tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ ((i+1) * 3) + 2 ];
							
						//	ii++;
						//}
						//console.log("nb of start/end pts for tokens"+ii + "  "+(nbEdgesModel*2));
						
						//console.log(tokenAttributes.endPosition.value[0]);
						//scene.children[8].geometry.verticesNeedUpdate = true;
						//tokenAttributes.endPosition.needsUpdate = true;
						//tokenUniforms.mixAmount.value = 0.0;
						/*var ii=0;
						for ( var i = 1; i <segmentPts+5000 ; i +=2 ) {
							tokenAttributes.mixAmount.value[ii] = 0.0;
							tokenAttributes.size.value[ii] = 30.0;
							tokenAttributes.ca.value[ ii ] = new THREE.Color( 0xffaaaa );
							ii++;
						}*/
						
						//tokenAttributes.mixAmount.needsUpdate = true;
						//tokenAttributes.size.needsUpdate = true;
						//tokenAttributes.ca.needsUpdate = true;
						
						modelVisible=true;
					}
					else if ( nbPlacesModel==0 && nbReactionsModel==0){
						
						var c = 2;
						for (var h=scene.children[c].geometry.attributes.size.array.length-10000, hh=scene.children[c].geometry.attributes.size.array.length+5000;h<hh;h++){
								scene.children[c].geometry.attributes.position.array[h*3+2]=((Math.random() * 2 - 1) * 400)+150000;
								scene.children[c].geometry.attributes.compartment.array[h]= -1;
						}
						scene.children[c].geometry.attributes.position.needsUpdate = true;
						modelVisible=false;
						var c = 4;
						for (var h=scene.children[c].geometry.attributes.size.array.length-10000, hh=scene.children[c].geometry.attributes.size.array.length+5000;h<hh;h++){
								scene.children[c].geometry.attributes.position.array[h*3+2]=((Math.random() * 2 - 1) * 400)+150000;	
								scene.children[c].geometry.attributes.compartment.array[h]= -1;
						}
						scene.children[c].geometry.attributes.position.needsUpdate = true;
						//console.log(extraLinesCnt)
						//console.log(extraLinesCnt+nbReactionsModel)
						for ( var iv = extraLinesCnt; iv <extraLinesCnt+5000; iv +=2) {
							scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+150000;	
							scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+150000;	
						}
						
						scene.children[7].geometry.attributes.position.needsUpdate = true;
						modelVisible=false;
					}
					else{
						
						var cnt1=0;
						var cnt2=0;
						var cnt=0;
						//var ln1 = scene.children[2].geometry.attributes.size.array.length-5000;
						//var ln2 = scene.children[4].geometry.attributes.size.array.length-5000;
						var ln1 = startModelPlaces;
						var ln2 = startModelReactions;
						for (var i= 0; i<selectedModelNodes.length;i++){
							if (selectedModelNodes[i][5]==2 ){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]=((Math.random() * 2 - 1) * 400);
								scene.children[2].geometry.attributes.compartment.array[(ln1+cnt1)]= selectedModelNodes[i][2];
								//scene.children[2].geometry.attributes.compartment.array[(ln1+cnt1)]= Math.floor(Math.random()*nbCompartments);
								idMap[jsonObj1.length+cnt]=[2,cnt1+ln1]
								cnt1++;
								cnt++;
							}
							else if (selectedModelNodes[i][5]==4 ){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=((Math.random() * 2 - 1) * 400);
								scene.children[4].geometry.attributes.compartment.array[(ln2+cnt2)]= selectedModelNodes[i][2];
								//scene.children[4].geometry.attributes.compartment.array[(ln2+cnt2)]= Math.floor(Math.random()*nbCompartments);
								idMap[jsonObj1.length+cnt]=[4,cnt2+ln2]
								cnt2++;
								cnt++;
							}
						}
						scene.children[2].geometry.attributes.compartment.needsUpdate = true;
						scene.children[4].geometry.attributes.compartment.needsUpdate = true;
						scene.children[2].geometry.attributes.position.needsUpdate = true;
						scene.children[4].geometry.attributes.position.needsUpdate = true;
						
						var col2 = new THREE.Color( 0xffa500 );
						
						//var lModelNodes=[];
						
						//console.log(nbEdgesModel)
						var count=0;
						for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
							var t1;
							var t2;
							var pt1;
							var pt2;
							var sim1=1;
							var sim2=1;
							pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
							sim1 = idMap[pt1][0]
							t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
							if (selectedModelEdges[iv-extraLinesCnt][3]==2){
								//console.log("link between model and metabolic nodes")
								
								if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
									pt2=selectedModelEdges[iv-extraLinesCnt][1];
								}
								else{
									pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
								}
								t2 = jsonObj1[pt2][6]
								sim2=2;
							}
							else{
								//console.log("link between model nodes")
								if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
									pt2=selectedModelEdges[iv-extraLinesCnt][1];
								}
								else{
									pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
								}
								t2 = selectedModelNodes[pt2][5];
							}
							if (sim2!=2){
								pt2+=jsonObj1.length;
								//console.log(idMap[pt2]);
							}
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
							
							if (sim2==2){
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
							}
							count+=1;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
							scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
							
							if (sim2==2){
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
							scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
							}
							count+=1;
						}
						
						
						scene.children[7].geometry.attributes.position.needsUpdate = true;
						scene.children[7].geometry.attributes.ca.needsUpdate = true;
						
						
						//var ii=0;
						//for ( var i = segmentPts; i <segmentPts+(nbEdgesModel) ; i ++ ) {
							//startPositionTokenMap[ii]=i;
							//scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+50000;
							//scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
							//scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ];
							
							//tokenAttributes.mixAmount.value[ii] = 0.0;
							//tokenAttributes.size.value[ii] = 30.0;
							//tokenAttributes.ca.value[ ii ] = new THREE.Color( 0xffaaaa );
							
							//endPositionTokenMap[ii]=i+1;
							//tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ ((i+1) * 3) ]+50000;
							//tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ ((i+1) * 3) + 1 ]+0;
							//tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ ((i+1) * 3) + 2 ];
							
							//ii++;
						//}
					
						
						
						
						
						modelVisible=true;
					}
					
					
				}
				else{
				// erase stuff first
					var lll=bgeometryP3.attributes.position.array.length;
					for (var ml =0;ml<lll;ml+=3){
						bgeometryP3.attributes.position.array[ml]+=150000;
					}
					var lll=bgeometryP5.attributes.position.array.length;
					for (var ml =0;ml<lll;ml+=3){
						bgeometryP5.attributes.position.array[ml]+=150000;
					}
					var c = 2;
					//for (var h=scene.children[c].geometry.attributes.size.array.length-5000, hh=scene.children[c].geometry.attributes.size.array.length+5000;h<hh;h++){
					//		scene.children[c].geometry.attributes.position.array[h*3+2]=((Math.random() * 2 - 1) * 400)+50000;
					//		scene.children[c].geometry.attributes.compartment.array[h]= -1;
					//}
					scene.children[c].geometry.attributes.position.needsUpdate = true;
					//modelVisible=false;
					var c = 4;
					//for (var h=scene.children[c].geometry.attributes.size.array.length-5000, hh=scene.children[c].geometry.attributes.size.array.length+5000;h<hh;h++){
					//		scene.children[c].geometry.attributes.position.array[h*3+2]=((Math.random() * 2 - 1) * 400)+50000;	
					//		scene.children[c].geometry.attributes.compartment.array[h]= -1;
					//}
					scene.children[c].geometry.attributes.position.needsUpdate = true;
					//console.log(extraLinesCnt)
					//console.log(extraLinesCnt+nbReactionsModel)
					for ( var iv = extraLinesCnt; iv <extraLinesCnt+5000; iv +=2) {
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+150000;	
						scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] =((Math.random() * 2 - 1) * 400)+150000;	
					}
				
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					modelVisible=false;
				}
				updatedModel=false;
			}
			
			
			//if (mtween)
				//camTween.update();
			TWEEN.update();
			//var time = Date.now() * 0.005;

			//PointCloud1.rotation.z = 0.01 * time;
			if (stopThreeJsMouseEvent==false){
			if (flagPick==1){
				var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
				projector.unprojectVector( vector, camera );
				raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
				var distance=99999999;
				var listretPointsIndexes=[];
				var listretPointsDistances=[];	
				var listretPointsTypes=[];	
				var listretPointsIndexesL=[];
				var listretPointsDistancesL=[];	
				var listretPointsTypesL=[];	
				var point = new THREE.Vector3(0,0,0);		
				var myray=raycaster.ray;
				var point1 = new THREE.Vector3(0,0,0);	
				var point2 = new THREE.Vector3(0,0,0);
				
				
				for(var i=0, ii=scene.children.length;i<ii;i++){
					
					for (var partT=0;partT<7;partT++){
					// mouse hover detect particle
					if (scene.children[i] instanceof THREE.PointCloud && (i==partT)){
						var a1 = scene.children[i].geometry.attributes.position.array;
						var a2 = scene.children[i].geometry.attributes.size.array;
						particles = a2.length;
						var a3 = scene.children[i].geometry.attributes.ca.array;
						
						for(var j=0;j<particles;j++){
							point.x = (a1[j*3]);
							point.y = (a1[j*3+1]);
							point.z = (a1[j*3+2]);
							distance = myray.distanceToPoint(point);
							if ( distance <=2 ) {
								listretPointsIndexes.push(j);
								listretPointsDistances.push(distance);	
								listretPointsTypes.push(i);	
							}
						}
						
					}
					/*if (scene.children[i] instanceof THREE.Mesh ){
						for (var nc=0;nc<nbCompartments;nc++){
							if (scene.children[i] instanceof THREE.Mesh && scene.children[i].name=="c"+nc){
								//console.log(scene.children[i])
								var ptMesh = scene.children[i].position;
								var meshdistance = myray.distanceToPoint(point);
								if (meshdistance)<=2
								console.log(ptMesh)
							}
						}
					}*/
					
					
					}
					var h1 = listretPointsDistances.length;
					var myr;
					var mymin = Math.min.apply(Math, listretPointsDistances);
					var v1=0;
					while(h1--){
						if (listretPointsDistances[h1]==mymin){
							myr=h1;
								}
								if (myr==h1)
									break;
								
					}						
					closest = listretPointsIndexes[myr];
					if (closest>=0){
						//console.log(listretPointsTypes[myr]);
						if (listretPointsTypes[myr]>=0)
							sprite.position.set(scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3],scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3+1],scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3+2]);	
						//console.log(closest);
						//console.log(i);
						isOnParticle=1;
							//cssObject.element.children[1].textContent=""+closest;//.element.symbol.textContent=closest;
							
							if (listretPointsTypes[myr]>=0){
								
								var pp = toXYCoords(sprite.position);
								
								if ((text1PreviousPos.x != pp.x) && (text1PreviousPos.y != pp.y)){
									//console.log(text1PreviousPos)
									//console.log(listretPointsTypes[myr])
									// display 2d text in html in screen 2s coordinate corresponding to near the 3d position... 
									//camera.updateMatrixWorld() ;
									//text1.firstChild.value=""+jsonObj1[typesMap[listretPointsTypes[myr]][closest]][2];
									text1.style.top = (pp.y+positionContainer.top )+ 'px';								
									text1.style.left = (pp.x -(text1.firstChild.length*8))-18+ 'px';
									text1PreviousPos = pp;
									var stringTxt="";
									var dat =typesMap[listretPointsTypes[myr]][closest];
									if(jsonObj1[dat]){
										stringTxt = jsonObj1[dat][0]+" "+jsonObj1[dat][2];
										if (jsonObj1[dat][4][1] && jsonObj1[dat][4][1][0]){
											stringTxt = jsonObj1[dat][0]+" "+jsonObj1[dat][2]+" ("+jsonObj1[dat][4][1][0]+")";
										}
										
									}
									else{
										if (listretPointsTypes[myr]==2 ){	
											if(typeof selectedModelNodes[dat-jsonObj1.length] == "undefined"){
												stringTxt = " ";
											}
											else {
												stringTxt = " "+selectedModelNodes[dat-jsonObj1.length][1];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
											}
										}
										else if (listretPointsTypes[myr]==4){											
											//stringTxt = " "+selectedModelNodes[nbPlacesModel+dat-jsonObj1.length][1];
											if(typeof selectedModelNodes[nbPlacesModel+dat-jsonObj1.length] == "undefined"){
												stringTxt = " ";
											}
											else {
												stringTxt = " "+selectedModelNodes[nbPlacesModel+dat-jsonObj1.length][1];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
											}
										}
										//else{stringTxt = " ";}
									}
									if (text1PreviousString!=stringTxt){
										text1.innerHTML=stringTxt;
										text1PreviousString=stringTxt;
									}
									//text1.innerHTML=stringTxt;
									/*else{
										//text1.innerHTML = " ";
										if (listretPointsTypes[myr]==2){												
											text1.innerHTML = " "+selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
										}
										if (listretPointsTypes[myr]==4){
											text1.innerHTML = " "+selectedModelNodes[nbPlacesModel+typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length];
										}
									}*/
									/*try{
										
									text1.innerHTML = ""+jsonObj1[typesMap[listretPointsTypes[myr]][closest]][2];		
																		
									
									}
									catch(e){
										text1.innerHTML = " ";
										try{
											//var ln1 = startModelPlaces;
											//var ln2 = startModelReactions;
											//selectedModelNodes[i][5]==2
											//var Ptype= idMap[closest][0];
											//var Pindex= idMap[closest][1];
											//text1.innerHTML = " "+idMap[closest];
											if (listretPointsTypes[myr]==2){
												
												text1.innerHTML = " "+selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
												//console.log(selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length]);
												//console.log(selectedModelNodes);
											}
											if (listretPointsTypes[myr]==4){
												text1.innerHTML = " "+selectedModelNodes[nbPlacesModel+typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length];
											//	text1.innerHTML = " "+selectedModelNodes[nbPlacesModel+typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
											}
											
											//typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length;
											//+selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
										}
										catch(e1){
											
										}
									
									}*/
								}
								else{
									text1.style.top =  (text1PreviousPos.y+positionContainer.top )+ 'px';								
									text1.style.left = text1PreviousPos.x -(text1.firstChild.length*8)-18+ 'px';
								}
							}
							
							//try{
							//cssObject.element.children[1].textContent=""+jsonObj1[typesMap[listretPointsTypes[myr]][closest]][2];
							//	cssObject.element.children[2].textContent=particleClass[listretPointsTypes[myr]];
								hoveredType=listretPointsTypes[myr];
								//}
							//catch(err){
							//}
					}
					else{
						sprite.position.set(-10000,-10000,-150000);
						//if (text1.style.top == (2000 + 'px')){
						//else{
						//	text1.style.top = 2000 + 'px';
						//	text1.style.left = 2000 + 'px';
						//}
						//text1.style.top = 2000 + 'px';
						//text1.style.left = 2000 + 'px';
						
						isOnParticle=0;		
						if (isOnLine==0 && noKeggCube){
						
						textk.style.top = 2000 + 'px';
						textk.style.left = 2000 + 'px';
						//cssObject.element.children[1].textContent="";
						//cssObject.element.children[2].textContent="";
						hoveredType=-1
						}
					}
					
					
					// mouse hover detect line
					//if (scene.children[i] instanceof THREE.Line && i==7){
					//		var a1 = scene.children[i].geometry.attributes.position.array;
					//		var a2 = scene.children[i].geometry.attributes.ca.array;
					//		var interSegment = new THREE.Vector3();
					//		var interRay = new THREE.Vector3();
							
					//		for(var j=0, jj= segmentPts;j<jj;j+=2){
					//			point1.x = (a1[j*3]); point1.y = (a1[(j*3)+1]); point1.z = (a1[(j*3)+2]);
					//			point2.x = (a1[(j+1)*3]); point2.y = (a1[((j+1)*3)+1]); point2.z = (a1[((j+1)*3)+2]);
					//			distance = myray.distanceSqToSegment( point1, point2, interRay, interSegment );
					//			if ( distance <=4 ) {
					//				listretPointsIndexesL.push(j);
					//				listretPointsDistancesL.push(distance);	
					//			}
					//		}
					//		var h1 = listretPointsDistancesL.length;
					//		var myr;
					//		var mymin = Math.min.apply(Math, listretPointsDistancesL);
					//		var v1=0;
					//		while(h1--){
					//			if (listretPointsDistancesL[h1]==mymin){
					//				myr=h1;
					//			}
					//			if (myr==h1)
					//				break;
									
					//			}						
					//		closestLine = listretPointsIndexesL[myr];
					//		if (closestLine>=0){
					//			isOnLine=1;
					//			if (isOnParticle==0){
					//				cssObject.element.children[1].textContent=""+closestLine;//.element.symbol.textContent=closest;
					//				cssObject.element.children[2].textContent="Line";
									
								// set position of outline mesh
					//			outlineMesh1.geometry.vertices[0].x=a1[closestLine*3]; outlineMesh1.geometry.vertices[0].y=a1[closestLine*3+1]; outlineMesh1.geometry.vertices[0].z=a1[closestLine*3+2];
					//			outlineMesh1.geometry.vertices[1].x=a1[(closestLine+1)*3]; outlineMesh1.geometry.vertices[1].y=a1[(closestLine+1)*3+1]; outlineMesh1.geometry.vertices[1].z=a1[(closestLine+1)*3+2];
					//			lineGeometry.verticesNeedUpdate = true;
					//			hoveredType=7;
					//			}
								//
					//		}
					//		else{//sprite.position.set(-10000,-10000,10000);	
					//			//cssObject.element.children[1].textContent="e";
					//			outlineMesh1.geometry.vertices[0].x=-10000; outlineMesh1.geometry.vertices[0].y=-10000; outlineMesh1.geometry.vertices[0].z=-50000;
					//			outlineMesh1.geometry.vertices[1].x=-10000; outlineMesh1.geometry.vertices[1].y=-10000; outlineMesh1.geometry.vertices[1].z=-51000;
					//			lineGeometry.verticesNeedUpdate = true;isOnLine=0;
					//		}
							
							
					//}
				}
				if (isOnParticle==0 ){
					text1.style.top = 2000 + 'px';
					text1.style.left = 2000 + 'px';
					//pip.style.top = 2000 + 'px';
					//pip.style.left = 2000 + 'px';
				}
				//else{
				//pip.style.top = 50 + 'px';
				//	pip.style.left = 25 + 'px';
				//}
				var intersects = raycaster.intersectObjects( scene.children );
				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].object ) {

						//if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
						if (INTERSECTED instanceof THREE.Mesh ){
							if (INTERSECTED.name=="c0"){
								INTERSECTED.material.color.setHex( 0xffff33 );
								onCompartments[0]=true;
								for (var ni=0;ni<nbCompartments;ni++){
									if (draggingCompartments[ni]==true){
										container.style.cursor = 'pointer';
									}
								}
								console.log(INTERSECTED.name)
							}
							else if (INTERSECTED.name=="c1"){
								INTERSECTED.material.color.setHex( 0xffff33 );
								onCompartments[1]=true;
								for (var ni=0;ni<nbCompartments;ni++){
									if (draggingCompartments[ni]==true){
										container.style.cursor = 'pointer';
									}
								}
								console.log(INTERSECTED.name)
							}
							else if (INTERSECTED.name=="c2"){
								INTERSECTED.material.color.setHex( 0xffff33 );
								onCompartments[2]=true;
								for (var ni=0;ni<nbCompartments;ni++){
									if (draggingCompartments[ni]==true){
										container.style.cursor = 'pointer';
									}
								}
								console.log(INTERSECTED.name)
							}
							else if (INTERSECTED.name=="c3"){
								INTERSECTED.material.color.setHex( 0xffff33 );
								onCompartments[3]=true;
								for (var ni=0;ni<nbCompartments;ni++){
									if (draggingCompartments[ni]==true){
										container.style.cursor = 'pointer';
									}
								}
								console.log(INTERSECTED.name)
							}
							else if (INTERSECTED.name=="c4"){
								INTERSECTED.material.color.setHex( 0xffff33 );
								onCompartments[4]=true;
								for (var ni=0;ni<nbCompartments;ni++){
									if (draggingCompartments[ni]==true){
										container.style.cursor = 'pointer';
									}
								}
								console.log(INTERSECTED.name)
							}
							else if (INTERSECTED.name=="c5"){
								INTERSECTED.material.color.setHex( 0xffff33 );
								onCompartments[5]=true;
								for (var ni=0;ni<nbCompartments;ni++){
									if (draggingCompartments[ni]==true){
										container.style.cursor = 'pointer';
									}
								}
								console.log(INTERSECTED.name)
							}
							else if (INTERSECTED.name=="c6"){
								INTERSECTED.material.color.setHex( 0xffff33 );
								onCompartments[6]=true;
								for (var ni=0;ni<nbCompartments;ni++){
									if (draggingCompartments[ni]==true){
										container.style.cursor = 'pointer';
									}
								}
								console.log(INTERSECTED.name)
							}
							else if (INTERSECTED.name=="c7"){
								INTERSECTED.material.color.setHex( 0xffff33 );
								onCompartments[7]=true;
								for (var ni=0;ni<nbCompartments;ni++){
									if (draggingCompartments[ni]==true){
										container.style.cursor = 'pointer';
									}
								}
								console.log(INTERSECTED.name)
							}
							else if (INTERSECTED.name=="c8"){
								INTERSECTED.material.color.setHex( 0xffff33 );
								onCompartments[8]=true;
								for (var ni=0;ni<nbCompartments;ni++){
									if (draggingCompartments[ni]==true){
										container.style.cursor = 'pointer';
									}
								}
								console.log(INTERSECTED.name)
							}
							//
							else if (INTERSECTED.name.charAt(0)=="k"){
								noKeggCube=false;
								INTERSECTED.material.color.setHex( 0xffdd33 );
								var pp = toXYCoords(INTERSECTED.position);
								if (textkPreviousPos != pp){
									//console.log(closest)
									//console.log(listretPointsTypes[myr])
									// display 2d text in html in screen 2s coordinate corresponding to near the 3d position... 
									//camera.updateMatrixWorld() ;
									//text1.firstChild.value=""+jsonObj1[typesMap[listretPointsTypes[myr]][closest]][2];
									textk.innerHTML = ""+keggCubesProperties[INTERSECTED.name][0]+"  - value:" + keggCubesProperties[INTERSECTED.name][1];		
									textk.style.top = pp.y + 'px';								
									textk.style.left = (pp.x -(text1.firstChild.length*8))+20+ 'px';
									textkPreviousPos = pp;
									
									
								}
								//console.log(keggCubesProperties[INTERSECTED.name])
							}
							else if(INTERSECTED.name=="skybox"){
								noKeggCube=true;
								INTERSECTED = null;
								container.style.cursor = 'auto';
								for (var im=0;im<nbOrganelles;im++){
									//arraymaterial[nbOrganelles].color.setHex( 0x1111ff );
									organelles[im].material.color.setHex( 0x1111ff );
								}
								nucleus.material.color.setHex( 0x1111ff );
								cytoplasm.material.color.setHex( 0x1111ff );
								ECM.material.color.setHex( 0x1111ff );
								for (var ni=0;ni<nbCompartments;ni++){
									onCompartments[ni]=false;
								}
								
							}
							else{container.style.cursor = 'auto';
							noKeggCube=true;
							for ( var k = 0; k < previousKeggLength; k ++ ) {
								cubesGeometry[k].material.color.setHex( 0xff0000 );
							}
							}
						
						}
						//INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						//

					}

				} else {

					//if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
					noKeggCube=true;
					INTERSECTED = null;
					container.style.cursor = 'auto';
					for (var im=0;im<nbOrganelles;im++){
						//arraymaterial[nbOrganelles].color.setHex( 0x1111ff );
						organelles[im].material.color.setHex( 0x1111ff );
					}
					nucleus.material.color.setHex( 0x1111ff );
					cytoplasm.material.color.setHex( 0x1111ff );
					ECM.material.color.setHex( 0x1111ff );
					for (var ni=0;ni<nbCompartments;ni++){
						onCompartments[ni]=false;
					}
					//for ( var k = 0; k < previousKeggLength; k ++ ) {
					//	cubesGeometry[k].material.color.setHex( 0xff0000 );
					//}
					//console.log(listChangingKeggCoordinates.length);
					//for ( var k = 0; k < keggSegment.length; k ++ ) {
					//	scene.getObjectByName( "k"+k ).material.color.setHex( 0xff0000 );
						//cubesGeometry[k].material.color.setHex( 0xff0000 );
						//cubesGeometry[i].material.color.needUpdate=true;
					//}

				}
				
				flagPick=0;
				
				
			}
			else
				flagPick++;
			}	
			
			
			var t = clock.getElapsedTime();
			
			if( simulationIsOn==true && simulationIsPaused==false){
				
				//console.log(simData[1][simTimer])
				//console.log(simTimer);
				
				// refactor simTimer to Object.keys(simDataTime)
				//var limTimer=0;
				//if (simModeValue==0){
				//	limTimer=simData[1].length
				//}
				//if (simModeValue==1){
				var	limTimer=Object.keys(simDataTime).length
				//}
				
				if (simData && simTimer<limTimer){
					//console.log(simTimer)
					
					
					scene.children[7].geometry.attributes.op.needsUpdate = true;
				
					//if (simTimerPrevious!=simTimer){
					//	console.log("new timer:"+simTimerPrevious +" becomes "+simTimer)
						//for(var v=0;v<nbModelReactionLocators;v++){
						//	modelProductLocators[v].position.set(50000,50000,-50000);
						//	modelReactantLocators[v].position.set(50000,50000,-50000);
						//	modelModifierLocators[v].position.set(50000,50000,-50000);
						//}
					//	simTimerPrevious=simTimer;
					//}
					// change display of timer property
					//console.log(simDataTime[Object.keys(simDataTime)[simTimer]][0]);
					if (simModeValue==0){
						for (var i=segmentPts;i<b2lopacity.length;i++){
							if (b2lopacity[i]>0.0){
							b2lopacity[i]=0.2;
							}
						}
						for (var i=0;i<10;i++){
							planeMesh[i].material.blending=THREE.AdditiveBlending;
						}
						for (var i=0;i<tokenAttributes.size.value.length;i++){
							tokenAttributes.size.value[i]=30;
						}
						timerElement.innerHTML=""+simDataTime[Object.keys(simDataTime)[simTimer]][0][1];
						sliderElement.value=simTimer;
						simRow=[simData[1][simTimer]];
						var ln1 = startModelPlaces;
						var ln2 = startModelReactions;
						var cnt1=0;
						var cnt2 = 0;
						var min;
						var max; 
						for(var j=3;j<simData[1][simTimer].length-1;j++){
							min = simDataBounds[j-3][0];
							max = simDataBounds[j-3][1];
							var size=30;
							if ((max-min)!=0){
								size = 30+(50*(simData[1][simTimer][j]-min)/(max-min))
								if (size>80){
									size = 80;
									//console.log("biiig "+ simData[1][simTimer][j])
									}
								if (isNaN(size)){
									size=30;
									//console.log("NaN "+simData[1][simTimer][j] + " "+min+" "+max );
								}
								//console.log(size);
								for(var j1=0;j1<selectedModelNodes.length;j1++){
									if (selectedModelNodes[j1][1]==simData[0][j]){
									
										
										
										//console.log(simData[0][j]);
										if (selectedModelNodes[j1][5]==2 ){
											scene.children[2].geometry.attributes.size.array[(ln1+cnt1)]= size;
											//console.log("node place index"+(ln1+cnt1))
											//bgeometryP3.attributes.size.array[(ln1+cnt1)]= size;
											//console.log("resize place"+(cnt1))
											cnt1++;
										}
										if (selectedModelNodes[j1][5]==4 ){
											scene.children[4].geometry.attributes.size.array[(ln2+cnt2)]= size;
											//console.log("node reaction index"+(ln2+cnt2))
											//bgeometryP5.attributes.size.array[(ln2+cnt2)]= size;
											//console.log("resize reaction"+size)
											cnt2++;
										}
										
									}
								}
							}
							//console.log(window.innerWidth*0.6)
							//console.log(simFlowChart)
							var indexChart=simFlowChart-1+3;
							//console.log(simData[0][indexChart+3]);
							if (j==indexChart){
								if (simTimer==0){
									var iv=0;
									for ( var i = 0; i < chartSegment; i ++ ) {
										chartPositions[ (iv * 3)+0 ] = 50400;
										chartPositions[ (iv * 3) + 1 ] = 0;
										chartPositions[ (iv * 3) + 2 ] = -50400;
										//chartColors[ iv * 3 ] = col.r;
										//chartColors[ iv * 3 + 1 ] = col.g;
										//chartColors[ iv * 3 + 2 ] = col.b;
										iv++;
										chartPositions[ (iv * 3)+0 ] = 50400;
										chartPositions[ (iv * 3) + 1 ] = 0;
										chartPositions[ (iv * 3) + 2 ] = -50400;
										//chartColors[ iv * 3 ] = col.r;
										//chartColors[ iv * 3 + 1 ] = col.g;
										//chartColors[ iv * 3 + 2 ] = col.b;
										iv++
									}
									if (max==min){
										chartPositions[ ((simTimer*2) * 3)+0 ] = -(window.innerWidth*0.11)+((simTimer)*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(0);
										chartPositions[ ((simTimer*2+1) * 3)+0 ] = -(window.innerWidth*0.11)+(simTimer*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2+1) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2+1) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(0);
									}
									else{
										chartPositions[ ((simTimer*2) * 3)+0 ] = -(window.innerWidth*0.11)+((simTimer)*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(((simData[1][simTimer][indexChart]-min)/(max-min))*(-(window.innerHeight*0.15*0.9)));
										chartPositions[ ((simTimer*2+1) * 3)+0 ] = -(window.innerWidth*0.11)+(simTimer*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2+1) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2+1) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(((simData[1][simTimer][indexChart]-min)/(max-min))*(-(window.innerHeight*0.15*0.9)));
									}
									//console.log("value:" +simData[1][simTimer][j] + " min: " + min + " max: " + max)
									}
								else {
								//if ((((simData[1][simTimer-1][5]-min)/(max-min))*-30) != (((simData[1][simTimer][5]-min)/(max-min))*-30) && (simTimer%2==0)){
									if (max==min){
										chartPositions[ ((simTimer*2) * 3)+0 ] = -(window.innerWidth*0.11)+((simTimer-1)*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(0);
										chartPositions[ ((simTimer*2+1) * 3)+0 ] = -(window.innerWidth*0.11)+(simTimer*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2+1) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2+1) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(0);
									}
									else{
										chartPositions[ ((simTimer*2) * 3)+0 ] = -(window.innerWidth*0.11)+((simTimer-1)*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(((simData[1][simTimer-1][indexChart]-min)/(max-min))*(-(window.innerHeight*0.15*0.9)));
										chartPositions[ ((simTimer*2+1) * 3)+0 ] = -(window.innerWidth*0.11)+(simTimer*((window.innerWidth*0.2)/simData[1].length));
										chartPositions[ ((simTimer*2+1) * 3) + 2 ] = 250 + (((window.innerHeight*0.15)/(window.innerWidth*0.6))*(-210)/0.1);//((window.innerHeight*0.15)/(window.innerWidth*0.6))*800;
										chartPositions[ ((simTimer*2+1) * 3) + 1 ] = (-(window.innerHeight*0.15*0.45))-(((simData[1][simTimer][indexChart]-min)/(max-min))*(-(window.innerHeight*0.15*0.9)));
									}
									//console.log("value:" +simData[1][simTimer][j] + " min: " + min + " max: " + max + " coord2:"+ simData[1][simTimer][indexChart])
									//console.log("value:"+simData[1][simTimer][indexChart]+ " normalised value: "+((simData[1][simTimer][indexChart]-min)/(max-min))+ " scale modifier"+(-(window.innerHeight*0.075)));
								//	}
								}
								geometryLineChart.attributes.position.needsUpdate = true;
							}
							
							
							// display linechart in function of timer
							
							//for ( var i = 0; i < chartSegment; i ++ ) {
							
							
							//chartPositions[ ((simTimer*2+1) * 3)+0 ] = 50000;
							//chartPositions[ ((simTimer*2+1) * 3) + 1 ] = 180;
							//chartPositions[ ((simTimer*2+1) * 3) + 2 ] = -500+(((simData[1][simTimer][5]-min)/(max-min))*-30);
							
							//chartPositions[ ((simTimer+1) * 3)+0 ] = 400+simTimer;
							//chartPositions[ ((simTimer+1) * 3) + 1 ] = 180;
							//chartPositions[ ((simTimer+1) * 3) + 2 ] = -500+(((simData[1][simTimer][5]-min)/(max-min))*-30);
							
							//for ( var i = simTimer+1; i < chartSegment*2; i ++ ) {
							//	chartPositions[ (i * 3)+0 ] = 400+simTimer;
							//	chartPositions[ (i * 3) + 1 ] = 180;
							//	chartPositions[ (i * 3) + 2 ] = -500+(((simData[1][simTimer][5]-min)/(max-min))*-30);
							//}//
								//iv++;
								//chartPositions[ (iv * 3)+0 ] = 400+simTimer+1;
								//chartPositions[ (iv * 3) + 1 ] = 0;
								//chartPositions[ (iv * 3) + 2 ] = (simData[1][simTimer+1][j]-min)/(max-min)*-400;
								
								//iv++
							//}
							//chartPositions.needsUpdate = true;
							
							//buffer_geometry.attributes.position.array;
						}
						scene.children[2].geometry.attributes.size.needsUpdate = true;
						scene.children[4].geometry.attributes.size.needsUpdate = true;
						
						//console.log();
						//var nbTokens=Object.keys(startPositionTokenMap).length;
						var triggerOnceReaction=true;
						for (var tk= 0; tk<selectedModelEdges.length;tk++){
							//console.log("aaa");
							
							// if link between model reaction and model place, create token
							if (selectedModelEdges[tk][3]==1){
								// add different possiblities from the simDataTime[Object.keys(simDataTime)[simTimer]][0][1];
								//if (selectedModelNodes[selectedModelEdges[tk][0]][1]==simData[1][simTimer][2]){
								for (var rw=0;rw<simRow.length;rw++){
									if (selectedModelNodes[selectedModelEdges[tk][0]][1]==simRow[rw][2]){
										
										//if (simRow.length>1){console.log(simRow[rw][2])}
										//if (allFalse){
										var nb;
										if (clearedTokenIndex.length>0){
											nb=clearedTokenIndex.pop();	
											stackTokenModel[nb]=[0,nb,selectedModelEdges[tk][0],selectedModelEdges[tk][1],1,true,selectedModelEdges[tk][2]];	
											
											
										}
										else{
											nb=stackTokenModel.length;		
											stackTokenModel.push([0,nb,selectedModelEdges[tk][0],selectedModelEdges[tk][1],1,true,selectedModelEdges[tk][2]]);	
											
										}
										// stackTokenModel element: mixamount value, id of token, pt1 model node id, pt2 model node id, type of link (1= model/model or 2 =model/sim) 
										//console.log(stackTokenModel.length)
										tokenStackCount+=1;
										//tokenAttributes.mixAmount.value[nb]=0;
										//planeMesh[nb].position.set(0,0,0);
										//if(selectedModelEdges[tk][2]==0 || selectedModelEdges[tk][2]==2){
										if(selectedModelEdges[tk][2]==1 ){
											//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])]=1.0;
											//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])+1]=1.0;
											
											scene.children[8].geometry.vertices[nb].x=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) ]+0;
											scene.children[8].geometry.vertices[nb].y=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 1 ]+0;
											scene.children[8].geometry.vertices[nb].z=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 2 ]+0;
											tokenAttributes.endPosition.value[nb].x=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) ]+0;
											tokenAttributes.endPosition.value[nb].y=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 1 ]+0;
											tokenAttributes.endPosition.value[nb].z=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 2 ]+0;
											// change color
											tokenAttributes.ca.value[nb]= new THREE.Color( 0xff0000 );
											
											/*var x1= (scene.children[8].geometry.vertices[nb].x+tokenAttributes.endPosition.value[nb].x)/2;											
											var y1 = (scene.children[8].geometry.vertices[nb].y+tokenAttributes.endPosition.value[nb].y)/2;
											var z1 = (scene.children[8].geometry.vertices[nb].z+tokenAttributes.endPosition.value[nb].z)/2;
											
											var isInFlowsStack =false;
											for (var fs=0;fs<flowsStack.length;fs++){
												if (flowsStack[fs]){
													if ((flowsStack[fs][0]==x1) && (flowsStack[fs][1]==y1) && (flowsStack[fs][2]==z1) ){
														isInFlowsStack=true;
													}
												}
											}
											//console.log(isInFlowsStack)
											if (!isInFlowsStack){
												flowsStack.push([x1,y1,z1]);
												planeMesh[flowsStack.length-1].position.set(0,0,0);
												planeMesh[flowsStack.length-1].geometry.vertices[0].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[0].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[0].z=scene.children[8].geometry.vertices[nb].z-1;
												planeMesh[flowsStack.length-1].geometry.vertices[2].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[2].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[2].z=scene.children[8].geometry.vertices[nb].z+1;
												planeMesh[flowsStack.length-1].geometry.vertices[1].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[1].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[1].z=tokenAttributes.endPosition.value[nb].z-1;
												planeMesh[flowsStack.length-1].geometry.vertices[3].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[3].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[3].z=tokenAttributes.endPosition.value[nb].z+1;
												
												//planeMesh[flowsStack.length-1].scale.z=size/30;
												planeMesh[flowsStack.length-1].geometry.verticesNeedUpdate=true;
											}
											*/
											
											
											//console.log(planeMesh[0].geometry);
											
											//planeMesh[0].position.x=scene.children[8].geometry.vertices[nb].x;
											//planeMesh[0].position.y=scene.children[8].geometry.vertices[nb].y;
											//planeMesh[0].position.z=scene.children[8].geometry.vertices[nb].z;
											//planeMesh[0].geometry.__dirtyVertices = true; 
											//planeMesh[0].geometry.computeCentroids();
											//planeMesh[nb].geometry.verticesNeedUpdate=true;
										}
										// if preplace to reaction
										if(selectedModelEdges[tk][2]!=1 ){
											//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-2]=1.0;
											//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-1]=1.0;
											//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-4]=1.0;
											//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-3]=1.0;
											scene.children[8].geometry.vertices[nb].x=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) ]+0;
											scene.children[8].geometry.vertices[nb].y=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 1 ]+0;
											scene.children[8].geometry.vertices[nb].z=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 2 ]+0;
											tokenAttributes.endPosition.value[nb].x=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) ]+0;
											tokenAttributes.endPosition.value[nb].y=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 1 ]+0;
											tokenAttributes.endPosition.value[nb].z=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 2 ]+0;
											// change color
											tokenAttributes.ca.value[nb]= new THREE.Color( 0x0000ff );
											/*
											var x1= (scene.children[8].geometry.vertices[nb].x+tokenAttributes.endPosition.value[nb].x)/2;											
											var y1 = (scene.children[8].geometry.vertices[nb].y+tokenAttributes.endPosition.value[nb].y)/2;
											var z1 = (scene.children[8].geometry.vertices[nb].z+tokenAttributes.endPosition.value[nb].z)/2;
											
											var isInFlowsStack =false;
											for (var fs=0;fs<flowsStack.length;fs++){
												if (flowsStack[fs]){
													if ((flowsStack[fs][0]==x1) && (flowsStack[fs][1]==y1) && (flowsStack[fs][2]==z1) ){
														isInFlowsStack=true;
													}
												}
											}
											if (!isInFlowsStack){
												flowsStack.push([x1,y1,z1]);
												planeMesh[flowsStack.length-1].position.set(0,0,0);
												planeMesh[flowsStack.length-1].geometry.vertices[0].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[0].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[0].z=scene.children[8].geometry.vertices[nb].z-1;
												planeMesh[flowsStack.length-1].geometry.vertices[2].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[2].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[2].z=scene.children[8].geometry.vertices[nb].z+1;
												planeMesh[flowsStack.length-1].geometry.vertices[1].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[1].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[1].z=tokenAttributes.endPosition.value[nb].z-1;
												planeMesh[flowsStack.length-1].geometry.vertices[3].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[flowsStack.length-1].geometry.vertices[3].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[flowsStack.length-1].geometry.vertices[3].z=tokenAttributes.endPosition.value[nb].z+1;
												
												//planeMesh[flowsStack.length-1].scale.z=size/30;
												planeMesh[flowsStack.length-1].geometry.verticesNeedUpdate=true;
											}*/
											
											
											
										}
										
										var x1= (scene.children[8].geometry.vertices[nb].x+tokenAttributes.endPosition.value[nb].x)/2;											
										var y1 = (scene.children[8].geometry.vertices[nb].y+tokenAttributes.endPosition.value[nb].y)/2;
										var z1 = (scene.children[8].geometry.vertices[nb].z+tokenAttributes.endPosition.value[nb].z)/2;
										
										var isInFlowsStack =false;
										var indexCnt=-1;
										for (var fs=0;fs<flowsStack.length;fs++){
											if (flowsStack[fs]){
												if ((flowsStack[fs][0]==x1) && (flowsStack[fs][1]==y1) && (flowsStack[fs][2]==z1) ){
													isInFlowsStack=true;
													indexCnt=fs;
												}
											}
										}
										if (!isInFlowsStack){
											flowsStack.push([x1,y1,z1]);
											planeMesh[flowsStack.length-1].position.set(0,0,0);
											planeMesh[flowsStack.length-1].geometry.vertices[0].x=scene.children[8].geometry.vertices[nb].x;
											planeMesh[flowsStack.length-1].geometry.vertices[0].y=scene.children[8].geometry.vertices[nb].y;
											planeMesh[flowsStack.length-1].geometry.vertices[0].z=scene.children[8].geometry.vertices[nb].z-1;
											planeMesh[flowsStack.length-1].geometry.vertices[2].x=scene.children[8].geometry.vertices[nb].x;
											planeMesh[flowsStack.length-1].geometry.vertices[2].y=scene.children[8].geometry.vertices[nb].y;
											planeMesh[flowsStack.length-1].geometry.vertices[2].z=scene.children[8].geometry.vertices[nb].z+1;
											planeMesh[flowsStack.length-1].geometry.vertices[1].x=tokenAttributes.endPosition.value[nb].x;
											planeMesh[flowsStack.length-1].geometry.vertices[1].y=tokenAttributes.endPosition.value[nb].y;
											planeMesh[flowsStack.length-1].geometry.vertices[1].z=tokenAttributes.endPosition.value[nb].z-1;
											planeMesh[flowsStack.length-1].geometry.vertices[3].x=tokenAttributes.endPosition.value[nb].x;
											planeMesh[flowsStack.length-1].geometry.vertices[3].y=tokenAttributes.endPosition.value[nb].y;
											planeMesh[flowsStack.length-1].geometry.vertices[3].z=tokenAttributes.endPosition.value[nb].z+1;
											stackModel2PlaneMesh[nb]=flowsStack.length-1;
											//planeMesh[flowsStack.length-1].scale.z=size/30;
											planeMesh[flowsStack.length-1].geometry.verticesNeedUpdate=true;
										}
										else{
										if (simData[1][simTimer][j]<0){
											if(Math.abs(planeMesh[indexCnt].geometry.vertices[0].z-planeMesh[indexCnt].geometry.vertices[2].z)<20){
												planeMesh[indexCnt].geometry.vertices[0].z+=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
												planeMesh[indexCnt].geometry.vertices[2].z-=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
												planeMesh[indexCnt].geometry.vertices[1].z+=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
												planeMesh[indexCnt].geometry.vertices[3].z-=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
											}
										}
										else{
											if(Math.abs(planeMesh[indexCnt].geometry.vertices[0].z-planeMesh[indexCnt].geometry.vertices[2].z)<20){
												planeMesh[indexCnt].geometry.vertices[0].z-=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
												planeMesh[indexCnt].geometry.vertices[2].z+=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
												planeMesh[indexCnt].geometry.vertices[1].z-=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
												planeMesh[indexCnt].geometry.vertices[3].z+=(((simData[1][simTimer][j]-min)/(max-min))*0.2);
												//console.log(Math.abs(planeMesh[indexCnt].geometry.vertices[0].z-planeMesh[indexCnt].geometry.vertices[2].z))
											}
										}
											planeMesh[indexCnt].geometry.verticesNeedUpdate=true;
										}
										// if preplace to reaction
										//if(selectedModelEdges[tk][2]==1){
										//	scene.children[8].geometry.vertices[nb].x=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) ]+0;
										//	scene.children[8].geometry.vertices[nb].y=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 1 ]+0;
										//	scene.children[8].geometry.vertices[nb].z=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 2 ]+0;
										//	tokenAttributes.endPosition.value[nb].x=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) ]+0;
										//	tokenAttributes.endPosition.value[nb].y=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 1 ]+0;
										//	tokenAttributes.endPosition.value[nb].z=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 2 ]+0;
										//}
										tokenAttributes.size.value[nb] = 30.0;
										//}
										if (tokenIDStackCount.hasOwnProperty(simRow[rw][2]) && triggerOnceReaction==true) {
												tokenIDStackCount[simRow[rw][2]][0]+=1;
												//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
												//modelReactionLocators[rw].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
												triggerOnceReaction=false;
												//console.log(tokenIDStackCount);
										}
										else{
											if( triggerOnceReaction==true){
												if(selectedModelEdges[tk][2]!=1){
													tokenIDStackCount[simRow[rw][2]]=[1,tokenAttributes.endPosition.value[nb].x,tokenAttributes.endPosition.value[nb].y,tokenAttributes.endPosition.value[nb].z];
													
												}
												if(selectedModelEdges[tk][2]==1){
													tokenIDStackCount[simRow[rw][2]]=[1,scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z];
													
												}
											//tokenIDStackCount[simRow[rw][2]]=[1,scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z];
											//modelReactionLocators[rw].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
											triggerOnceReaction=false;
											//console.log(tokenIDStackCount);
											//var vectorp = new THREE.Vector3( scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
											//vectorp.x +=10;
											//var ppv = toXYCoords(vectorp	);
											//txtReactionActivation[cntLabels].style.top = ppv.y + 'px';
											//txtReactionActivation[cntLabels].style.left = ppv.x + 'px';
											//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
											}
											
										}
										//cntLabels++;
									}
									
								}
							}
							
						}
						//console.log(flowsStack.length);
						//for (var f = 0;f<planeMesh.length;f++){
						//planeMesh[f].geometry.verticesNeedUpdate= true;
						//}
						scene.children[7].geometry.attributes.op.needsUpdate = true;
						//tokenAttributes.mixAmount.needsUpdate = true;
						tokenAttributes.ca.needsUpdate = true;
						scene.children[8].geometry.verticesNeedUpdate = true;
						tokenAttributes.endPosition.needsUpdate = true;
						tokenAttributes.size.needsUpdate = true;
						simTimer++;
						//reactionIsDone=false;
					}
					if (simModeValue==1){
						//console.log(simTimer);
						timerElement.innerHTML=""+simDataTime[Object.keys(simDataTime)[simTimer]][0][1];
						sliderElement.value=simTimer;
						simRow=simDataTime[Object.keys(simDataTime)[simTimer]];
						
						for (var i=segmentPts;i<b2lopacity.length;i++){
							if (b2lopacity[i]>0.0){
							b2lopacity[i]=0.2;
							}
						}
						
						for (var i=0;i<tokenAttributes.size.value.length;i++){
							tokenAttributes.size.value[i]=80;
						}
						tokenAttributes.size.needsUpdate = true;
						
						var ln1 = startModelPlaces;
						var ln2 = startModelReactions;
						var cnt1=0;
						var cnt2 = 0;
						for(var j=3;j<simData[1][simTimer].length-1;j++){
							var min = simDataBounds[j-3][0];
							var max = simDataBounds[j-3][1];
							var size=30;
							if ((max-min)!=0){
								size = 30+(50*(simData[1][simTimer][j]-min)/(max-min))
								if (size>80){
									size = 80;
									//console.log("biiig "+ simData[1][simTimer][j])
									}
								if (isNaN(size)){
									size=30;
									//console.log("NaN "+simData[1][simTimer][j] + " "+min+" "+max );
								}
								//console.log(size);
								for(var j1=0;j1<selectedModelNodes.length;j1++){
									if (selectedModelNodes[j1][1]==simData[0][j]){
										//console.log(simData[0][j]);
										if (selectedModelNodes[j1][5]==2 ){
											scene.children[2].geometry.attributes.size.array[(ln1+cnt1)]= size;
											//bgeometryP3.attributes.size.array[(ln1+cnt1)]= size;
											//console.log("resize place"+(cnt1))
											cnt1++;
										}
										if (selectedModelNodes[j1][5]==4 ){
											scene.children[4].geometry.attributes.size.array[(ln2+cnt2)]= size;
											//bgeometryP5.attributes.size.array[(ln2+cnt2)]= size;
											//console.log("resize reaction"+size)
											cnt2++;
										}
									}
								}
							}
							//console.log(simData[0][j])
						}
						scene.children[2].geometry.attributes.size.needsUpdate = true;
						scene.children[4].geometry.attributes.size.needsUpdate = true;
						
						//console.log();
						//var nbTokens=Object.keys(startPositionTokenMap).length;
						var triggerOnceReaction=true;
						var namePresentReaction="";
						var counterReactionLinks=0;
						
							//modelProductLocators[v].position.set(50000,50000,-50000);
							//console.log(modelProductLocators[v])
						//}
						for (var tk= 0; tk<selectedModelEdges.length;tk++){
							//console.log("aaa");
							
							// if link between model reaction and model place, create token
							if (selectedModelEdges[tk][3]==1){
								// add different possiblities from the simDataTime[Object.keys(simDataTime)[simTimer]][0][1];
								//if (selectedModelNodes[selectedModelEdges[tk][0]][1]==simData[1][simTimer][2]){
								for (var rw=0;rw<simRow.length;rw++){
									if (selectedModelNodes[selectedModelEdges[tk][0]][1]==simRow[rw][2]){
										
										//if (simRow.length>1){console.log(simRow[rw-1][2]+"  "+simRow[rw][2])}
										if (allFalse){
										
											if (namePresentReaction!=simRow[rw][2]){
												namePresentReaction=simRow[rw][2];
												counterReactionLinks=1;
											}
											else{
												counterReactionLinks++;
											}
											
											var nb;
											if (clearedTokenIndex.length>0){
												nb=clearedTokenIndex.pop();	
												stackTokenModel[nb]=[0,nb,selectedModelEdges[tk][0],selectedModelEdges[tk][1],1,true,selectedModelEdges[tk][2],counterReactionLinks-1];		
												//tokenStackCount-=1;								
											}
											else{
												nb=stackTokenModel.length;		
												stackTokenModel.push([0,nb,selectedModelEdges[tk][0],selectedModelEdges[tk][1],1,true,selectedModelEdges[tk][2],counterReactionLinks-1]);	
											}
											// stackTokenModel element: mixamount value, id of token, pt1 model node id, pt2 model node id, type of link (1= model/model or 2 =model/sim) 
											//console.log(stackTokenModel.length)
											tokenStackCount+=1;
											//tokenAttributes.mixAmount.value[nb]=0;
											// if reaction to post-place orient token
											if(counterReactionLinks-1==0){
												for (var ct=0;ct<10;ct++){
													planeMesh[ct].position.set(0,0,-5000);
												}
												for(var v=0;v<nbModelReactionLocators;v++){
													modelReactantLocators[v].position.set(150000,150000,-150000);
													modelModifierLocators[v].position.set(150000,150000,-150000);
												}
											}
											
											if(selectedModelEdges[tk][2]==1){
											
												//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])]=1.0;
												//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])+1]=1.0;
												
												
												
						
												scene.children[8].geometry.vertices[nb].x=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) ]+0;
												scene.children[8].geometry.vertices[nb].y=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 1 ]+0;
												scene.children[8].geometry.vertices[nb].z=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 2 ]+0;
												tokenAttributes.endPosition.value[nb].x=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) ]+0;
												tokenAttributes.endPosition.value[nb].y=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 1 ]+0;
												tokenAttributes.endPosition.value[nb].z=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 2 ]+0;
												modelProductLocators[counterReactionLinks-1].position.set(tokenAttributes.endPosition.value[nb].x,tokenAttributes.endPosition.value[nb].y,tokenAttributes.endPosition.value[nb].z);
												// change color
												tokenAttributes.ca.value[nb]= new THREE.Color( 0xff0000 );
												
					
												planeMesh[counterReactionLinks-1].position.set(0,0,0);
												planeMesh[counterReactionLinks-1].geometry.vertices[0].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[0].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[0].z=scene.children[8].geometry.vertices[nb].z-5;
												planeMesh[counterReactionLinks-1].geometry.vertices[2].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[2].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[2].z=scene.children[8].geometry.vertices[nb].z+5;
												planeMesh[counterReactionLinks-1].geometry.vertices[1].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[1].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[1].z=tokenAttributes.endPosition.value[nb].z-5;
												planeMesh[counterReactionLinks-1].geometry.vertices[3].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[3].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[3].z=tokenAttributes.endPosition.value[nb].z+5;
												planeMesh[counterReactionLinks-1].geometry.verticesNeedUpdate=true;
												//planeMesh[counterReactionLinks-1].material.transparent = true;
												//planeMesh[counterReactionLinks-1].material.opacity = 0.6;
												planeMesh[counterReactionLinks-1].material.blending=false;
											
												//console.log(tokenAttributes.ca.value[nb])
												//modelReactantLocators[counterReactionLinks-1].position.set(50000,50000,-50000);
												//modelModifierLocators[counterReactionLinks-1].position.set(50000,50000,-50000);
											}
											// if preplace to reaction
											if(selectedModelEdges[tk][2]!=1){
												//console.log(selectedModelEdges[tk][0]);
												//console.log(selectedModelEdges[tk][1]);
												//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-1]=1.0;
												//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-2]=1.0;
												//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-3]=1.0;
												//b2lopacity[(startPositionTokenMap[selectedModelEdges[tk][0]])-4]=1.0;
												scene.children[8].geometry.vertices[nb].x=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) ]+0;
												scene.children[8].geometry.vertices[nb].y=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 1 ]+0;
												scene.children[8].geometry.vertices[nb].z=scene.children[7].geometry.attributes.position.array[ ((endPositionTokenMap[selectedModelEdges[tk][1]]) * 3) + 2 ]+0;
												tokenAttributes.endPosition.value[nb].x=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) ]+0;
												tokenAttributes.endPosition.value[nb].y=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 1 ]+0;
												tokenAttributes.endPosition.value[nb].z=scene.children[7].geometry.attributes.position.array[ ((startPositionTokenMap[selectedModelEdges[tk][0]]) * 3) + 2 ]+0;
												// change color
												tokenAttributes.ca.value[nb]= new THREE.Color( 0x0000ff );
												
												planeMesh[counterReactionLinks-1].position.set(0,0,0);
												planeMesh[counterReactionLinks-1].geometry.vertices[0].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[0].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[0].z=scene.children[8].geometry.vertices[nb].z-5;
												planeMesh[counterReactionLinks-1].geometry.vertices[2].x=scene.children[8].geometry.vertices[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[2].y=scene.children[8].geometry.vertices[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[2].z=scene.children[8].geometry.vertices[nb].z+5;
												planeMesh[counterReactionLinks-1].geometry.vertices[1].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[1].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[1].z=tokenAttributes.endPosition.value[nb].z-5;
												planeMesh[counterReactionLinks-1].geometry.vertices[3].x=tokenAttributes.endPosition.value[nb].x;
												planeMesh[counterReactionLinks-1].geometry.vertices[3].y=tokenAttributes.endPosition.value[nb].y;
												planeMesh[counterReactionLinks-1].geometry.vertices[3].z=tokenAttributes.endPosition.value[nb].z+5;
												planeMesh[counterReactionLinks-1].geometry.verticesNeedUpdate=true;
												//planeMesh[counterReactionLinks-1].material.transparent = true;
												//planeMesh[counterReactionLinks-1].material.opacity = 0.6;
												planeMesh[counterReactionLinks-1].material.blending=false;
												
												if (selectedModelEdges[tk][2]==0){
													modelReactantLocators[counterReactionLinks-1].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z+10);
													//modelModifierLocators[counterReactionLinks-1].position.set(50000,50000,-50000);
													//modelProductLocators[counterReactionLinks-1].position.set(50000,50000,-50000);
												}
												if (selectedModelEdges[tk][2]==2){
													modelModifierLocators[counterReactionLinks-1].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
													//modelReactantLocators[counterReactionLinks-1].position.set(50000,50000,-50000);
													//modelProductLocators[counterReactionLinks-1].position.set(50000,50000,-50000);
												}
												
												
												
											}
											
											
											tokenAttributes.size.value[nb] = 30.0;
											// if consumed pre-place
											//if (selectedModelEdges[tk][2]==0){
														
											//	}
											// if non-consumed pre-place
											//if (selectedModelEdges[tk][2]==2){
														
											//	}
											// if postplace
											//if (selectedModelEdges[tk][2]==1){
														
											//	}
											//console.log(selectedModelEdges[tk]);
											//console.log(counterReactionLinks)
											//modelProductLocators[rw].position.set(tokenAttributes.endPosition.value[nb].x,tokenAttributes.endPosition.value[nb].y,tokenAttributes.endPosition.value[nb].z);
											
											if (tokenIDStackCount.hasOwnProperty(simRow[rw][2]) && triggerOnceReaction==true ) {
													
													tokenIDStackCount[simRow[rw][2]][0]+=1;
													if(selectedModelEdges[tk][2]!=1){
														modelReactionLocators[rw].position.set(tokenAttributes.endPosition.value[nb].x,tokenAttributes.endPosition.value[nb].y,tokenAttributes.endPosition.value[nb].z);
														//modelProductLocators[rw].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
													}
													if(selectedModelEdges[tk][2]==1){
														modelReactionLocators[rw].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
														//modelProductLocators[counterReactionLinks-1].position.set(tokenAttributes.endPosition.value[nb].x,tokenAttributes.endPosition.value[nb].y,tokenAttributes.endPosition.value[nb].z);
														
													}
													
													
													
													
													//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
													triggerOnceReaction=false;
													
											}
											else{
												
												if( triggerOnceReaction==true){
												
												//modelReactionLocators[rw].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
												if(selectedModelEdges[tk][2]!=1){
														tokenIDStackCount[simRow[rw][2]]=[1,tokenAttributes.endPosition.value[nb].x,tokenAttributes.endPosition.value[nb].y,tokenAttributes.endPosition.value[nb].z];
														modelReactionLocators[rw].position.set(tokenAttributes.endPosition.value[nb].x,tokenAttributes.endPosition.value[nb].y,tokenAttributes.endPosition.value[nb].z);
														
													}
												if(selectedModelEdges[tk][2]==1){
														tokenIDStackCount[simRow[rw][2]]=[1,scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z];
														modelReactionLocators[rw].position.set(scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
														
													}
												triggerOnceReaction=false;
												//console.log(selectedModelEdges[tk]);
												//console.log(selectedModelEdges[tk]);
												//console.log(tokenIDStackCount);
												//var vectorp = new THREE.Vector3( scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
												//vectorp.x +=10;
												//var ppv = toXYCoords(vectorp	);
												//txtReactionActivation[cntLabels].style.top = ppv.y + 'px';
												//txtReactionActivation[cntLabels].style.left = ppv.x + 'px';
												//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
												}
												
												//var vectorp = new THREE.Vector3( scene.children[8].geometry.vertices[nb].x,scene.children[8].geometry.vertices[nb].y,scene.children[8].geometry.vertices[nb].z);
												//vectorp.x +=10;
												//var ppv = toXYCoords(vectorp	);
												//txtReactionActivation[cntLabels].style.top = ppv.y + 'px';
												//txtReactionActivation[cntLabels].style.left = ppv.x + 'px';
												//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
											}
											
											//cntLabels++;
										}
									}
									
								}
							}
							
						}
						//scene.children[7].geometry.attributes.op.needsUpdate = true;
						//tokenAttributes.mixAmount.needsUpdate = true;
						tokenAttributes.ca.needsUpdate = true;
						scene.children[8].geometry.verticesNeedUpdate = true;
						tokenAttributes.endPosition.needsUpdate = true;
						tokenAttributes.size.needsUpdate = true;
						if (allFalse){
							simTimer++;
							reactionIsDone=false;
						}
						
						
						
						
					}
					if (simModeValue==2 ){
						//console.log(selectedModelNodes)
						//timerElement.innerHTML=""+simData[1][simTimer][1];
						timerElement.innerHTML=""+simDataTime[Object.keys(simDataTime)[simTimer]][0][1];
						sliderElement.value=simTimer;
						simRow=[simData[1][simTimer]];
						var ln1 = startModelPlaces;
						var ln2 = startModelReactions;
						var cnt1=0;
						var cnt2 = 0;
						for(var j=3;j<simData[1][simTimer].length-1;j++){
							var min = simDataBounds[j-3][0];
							var max = simDataBounds[j-3][1];
							var val =simData[1][simTimer][j];
							var size=30;
							if ((max-min)!=0){
								size = 30+(50*(simData[1][simTimer][j]-min)/(max-min))
								if (size>80){
									size = 80;
									//console.log("biiig "+ simData[1][simTimer][j])
									}
								if (isNaN(size)){
									size=30;
									//console.log("NaN "+simData[1][simTimer][j] + " "+min+" "+max );
								}
								
								listChangingKeggCoordinates=[];
								//console.log(size);
								for(var j1=0;j1<selectedModelNodes.length;j1++){
									if (selectedModelNodes[j1][1]==simData[0][j]){
										//console.log(simData[0][j]);
										if (selectedModelNodes[j1][5]==2 ){
											scene.children[2].geometry.attributes.size.array[(ln1+cnt1)]= size;
											//console.log(idMap[ln1+cnt1]);
											if (selectedModelNodes[j1][7]==3){
												for (var ed= 0; ed<selectedModelEdges.length;ed++){
													if ((selectedModelEdges[ed][0]==selectedModelNodes[j1][0]) && selectedModelEdges[ed][3]==2){
														//console.log(selectedModelEdges[ed][0]+"to metabolic :"+jsonObj1[selectedModelEdges[ed][1]][1])
														if (jsonObj1[selectedModelEdges[ed][1]][4][1][2] && jsonObj1[selectedModelEdges[ed][1]][4][1][2].length>0){
															//console.log(jsonObj1[selectedModelEdges[ed][1]][4][1][2])
															//listChangingKeggCoordinates.push([jsonObj1[selectedModelEdges[ed][1]][4][1][2][0],size])
															for (var kk = 0; kk<jsonObj1[selectedModelEdges[ed][1]][4][1][2].length;kk++){
																listChangingKeggCoordinates.push([jsonObj1[selectedModelEdges[ed][1]][4][1][2][kk],size-30,jsonObj1[selectedModelEdges[ed][1]][4][1][1],val])
															}
															
														}
													}
												}
												
											}
											//bgeometryP3.attributes.size.array[(ln1+cnt1)]= size;
											//console.log("resize place"+(cnt1))
											cnt1++;
										}
										if (selectedModelNodes[j1][5]==4 ){
											scene.children[4].geometry.attributes.size.array[(ln2+cnt2)]= size;
											//console.log("node reaction index"+(ln2+cnt2))
											//bgeometryP5.attributes.size.array[(ln2+cnt2)]= size;
											//console.log("resize reaction"+size)
											cnt2++;
										}
									}
								}
								if (previousKeggLength<listChangingKeggCoordinates.length){
								previousKeggLength=listChangingKeggCoordinates.length;
								}
								//console.log(listChangingKeggCoordinates)
								//console.log(listChangingKeggCoordinates.length)
								/*
								var iv =0;
								for ( var i = 0; i < keggSegment.length; i ++ ) {
									keggPositions[ (iv * 3)+0 ] = 50000;
									keggPositions[ (iv * 3) + 1 ] = 0;
									keggPositions[ (iv * 3) + 2 ] = -50000;
									//keggColors[ iv * 3 ] = col.r;
									//keggColors[ iv * 3 + 1 ] = col.g;
									//keggColors[ iv * 3 + 2 ] = col.b;
									iv++;
									keggPositions[ (iv * 3)+0 ] = 50000;
									keggPositions[ (iv * 3) + 1 ] = 0;
									keggPositions[ (iv * 3) + 2 ] = -50000;
									//keggColors[ iv * 3 ] = col.r;
									//keggColors[ iv * 3 + 1 ] = col.g;
									//keggColors[ iv * 3 + 2 ] = col.b;
									iv++
								}
								var iv =0;
								for ( var i = 0; i < listChangingKeggCoordinates.length; i ++ ) {
									keggPositions[ (iv * 3)+0 ] = (listChangingKeggCoordinates[i][0][0]*0.69605)+3000-450;
									keggPositions[ (iv * 3) + 1 ] = 200;
									keggPositions[ (iv * 3) + 2 ] = (listChangingKeggCoordinates[i][0][1]*0.69605)-273;
									//keggColors[ iv * 3 ] = col.r;
									//keggColors[ iv * 3 + 1 ] = col.g;
									//keggColors[ iv * 3 + 2 ] = col.b;
									iv++;
									keggPositions[ (iv * 3)+0 ] = (listChangingKeggCoordinates[i][0][0]*0.69605)+3000-450;
									keggPositions[ (iv * 3) + 1 ] = 200+(listChangingKeggCoordinates[i][1]*3);
									keggPositions[ (iv * 3) + 2 ] = (listChangingKeggCoordinates[i][0][1]*0.69605)-273;
									//keggColors[ iv * 3 ] = col.r;
									//keggColors[ iv * 3 + 1 ] = col.g;
									//keggColors[ iv * 3 + 2 ] = col.b;
									iv++
								}
								
								
								keggPositions.needsUpdate = true;
								geometryKegg.attributes.position.needsUpdate = true;
								*/
								//for ( var i = listChangingKeggCoordinates.length; i < 1000; i ++ ) {
								//	cubesGeometry[i].position.x=50000;
								//	cubesGeometry[i].position.y=200;
								//	cubesGeometry[i].position.z=-50000;
								//}
								//console.log(listChangingKeggCoordinates.length)
								for ( var i = 0; i < listChangingKeggCoordinates.length; i ++ ) {
			
									//console.log(cubesGeometry[i])
									cubesGeometry[i].position.x=(listChangingKeggCoordinates[i][0][0]*0.69605)+3000-450;
									cubesGeometry[i].position.y=200+(listChangingKeggCoordinates[i][1]*1.5);
									cubesGeometry[i].position.z=(listChangingKeggCoordinates[i][0][1]*0.69605)-273;
									if (listChangingKeggCoordinates[i][1]!=0){
									cubesGeometry[i].scale.y =(listChangingKeggCoordinates[i][1]*3);
									}
									else{
									cubesGeometry[i].scale.y =1;
									}
									keggCubesProperties["k"+i]=[listChangingKeggCoordinates[i][2],listChangingKeggCoordinates[i][3]]
									
								}
								//bgeometry2.attributes.ca.needsUpdate = true;
								/*var iv=0;
								for ( var i = 0; i < keggSegment; i ++ ) {
									keggPositions[ (iv * 3)+0 ] = iv*100;
									keggPositions[ (iv * 3) + 1 ] = 0;
									keggPositions[ (iv * 3) + 2 ] = iv*100;
									//keggColors[ iv * 3 ] = col.r;
									//keggColors[ iv * 3 + 1 ] = col.g;
									//keggColors[ iv * 3 + 2 ] = col.b;
									iv++;
									keggPositions[ (iv * 3)+0 ] = (iv-1)*100;
									keggPositions[ (iv * 3) + 1 ] = size;
									keggPositions[ (iv * 3) + 2 ] = (iv-1)*100;
									//keggColors[ iv * 3 ] = col.r;
									//keggColors[ iv * 3 + 1 ] = col.g;
									//keggColors[ iv * 3 + 2 ] = col.b;
									iv++
								}*/
								
							}
							//console.log(simData[0][j])
						}
						scene.children[2].geometry.attributes.size.needsUpdate = true;
						scene.children[4].geometry.attributes.size.needsUpdate = true;
						simTimer++;
					}
					//console.log(simRow)
					
					//setAttribute("value", simTimer);
					// change property of model nodes to express flux
					
					// change nodes size according to flux values (take into account boundaries as min/max values)
					
					
					
						
					
					
						
					
					
					//simTimer++;
					
				}
				else{
					if (tokenStackCount<=0){
						simTimer=0;
						simulationIsOn=false;
						for (var ii=0;ii<stackTokenModel.length;ii++) {
							stackTokenModel[ii][5]==false
						}
						
						
						for (var tkNb=0; tkNb< txtReactionActivation.length;tkNb++){	
							txtReactionActivation[tkNb].innerHTML = '';
						}
						for (var i=segmentPts;i<b2lopacity.length;i++){	
							b2lopacity[i]=0.7;	
						}
						scene.children[7].geometry.attributes.op.needsUpdate = true;
						allfalse=true;
						//stackTokenModel=[];
						reactionIsDone=false;
						flowsStack=[];
						for(var i=0;i<nbModelPlanesFlow;i++){
							planeMesh[i].position.set(0,0,150000);
						}
						tokenIDStackCount={};
						
						
		
					}
				}
				
				//if (simData && simTimer<simData.length){
				//	console.log(simData[simTimer])
				//}
				
			

				//tokenIDStackCount;
				//for (var reac in tokenIDStackCount) {
				//	if (tokenIDStackCount.hasOwnProperty(reac)) {
						
				//	}	
				//}
			}
			
			if (simulationIsPaused==false && tokenStackCount>0 && simulationIsOn==true){
				//console.log(tokenStackCount)
				//console.log(stackTokenModel)
				for (var ii=0;ii<stackTokenModel.length;ii++) {
						
						//if (stackTokenModel[ii] && stackTokenModel[ii][0]){
							
							//for (var j =0;j<stackTokenModel[ii].length;j++){
							
								if (stackTokenModel[ii][0]<1 && stackTokenModel[ii][5]==true){
									if (stackTokenModel[ii][6]!=1){
										if (simModeValue==0){
										stackTokenModel[ii][0]+=0.001;					
										}
										if (simModeValue==1){
										stackTokenModel[ii][0]+=0.025;
										}
										//tokenAttributes.mixAmount.value[stackTokenModel[ii][1]]=stackTokenModel[ii][0];
									}
									if (stackTokenModel[ii][6]==1 ){
										if (simModeValue==0){
										stackTokenModel[ii][0]+=0.001;
										}
										if (simModeValue==1 && reactionIsDone){
										stackTokenModel[ii][0]+=0.025;
										}
										//tokenAttributes.mixAmount.value[stackTokenModel[ii][1]]=stackTokenModel[ii][0];
										
									}
									//console.log(stackTokenModel[ii][0]);
									
									//tokenAttributes.mixAmount.value[stackTokenModel[ii][1]]=stackTokenModel[ii][0];
								}
								//else if (stackTokenModel[ii][0]<1 && stackTokenModel[ii][5]==false){
								else if (stackTokenModel[ii][0]<1 && stackTokenModel[ii][5]==false){
									scene.children[8].geometry.vertices[stackTokenModel[ii][1]].z-=150000;
									// erase product/modifier/reactant signs if necessary
									if (stackTokenModel[ii][7]){
										if (stackTokenModel[ii][6]==0){ // reactant
											//modelReactantLocators[stackTokenModel[ii][7]].position.set(50000,50000,-50000);
										}
										else if (stackTokenModel[ii][6]==1){ // product
											modelProductLocators[stackTokenModel[ii][7]].position.set(150000,150000,-150000);
										}	
										else if (stackTokenModel[ii][6]==2){// modifier
											//modelModifierLocators[stackTokenModel[ii][7]].position.set(50000,50000,-50000);
										}
										else{}
									}
									
									//console.log(stackTokenModel[ii][0]);
									
									//tokenAttributes.mixAmount.value[stackTokenModel[ii][1]]=stackTokenModel[ii][0];
								}
								else {
									/*if (simModeValue==0 ){
										planeMesh[stackModel2PlaneMesh[ii]].geometry.vertices[0].z-=(0.03);
										planeMesh[stackModel2PlaneMesh[ii]].geometry.vertices[2].z+=(0.03);
										planeMesh[stackModel2PlaneMesh[ii]].geometry.vertices[1].z-=(0.03);
										planeMesh[stackModel2PlaneMesh[ii]].geometry.vertices[3].z+=(0.03);
										planeMesh[stackModel2PlaneMesh[ii]].geometry.verticesNeedUpdate=true;
									}*/
									if (stackTokenModel[ii][6]!=1 ){
										reactionIsDone=true;
									}
									//tokenAttributes.mixAmount.value[ii]=0;
									//tokenAttributes.mixAmount.value[stackTokenModel[ii][1]]=0;
									clearedTokenIndex.push(stackTokenModel[ii][1]);
									stackTokenModel[ii][0]=0;
									
									if(tokenStackCount>0){
										tokenStackCount-=1;
									}
									stackTokenModel[ii][5]=false;
									if (stackTokenModel[ii][7] ){
										if (stackTokenModel[ii][6]==0){ // reactant
											//modelReactantLocators[stackTokenModel[ii][7]].position.set(50000,50000,-50000);
										}
										else if (stackTokenModel[ii][6]==1){ // product
											modelProductLocators[stackTokenModel[ii][7]].position.set(150000,150000,-150000);
										}	
										else if (stackTokenModel[ii][6]==2){// modifier
											//modelModifierLocators[stackTokenModel[ii][7]].position.set(50000,50000,-50000);
										}
										else{}										
									}
									//erasingArray.push(ii);
									//stackTokenModel.splice(ii,1);
									
									
									//console.log(tokenStackCount)
									//console.log(clearedTokenIndex.length);
								}
								
							
							//}

						
						//}
					
				}
				allFalse=true;
				for (var ii=0;ii<stackTokenModel.length;ii++) {
					if (stackTokenModel[ii][5]==true){
						allFalse=false;
					}
				}
				
				//console.log(stackTokenModel.length)	
				
				
			}
			
			//for (var ii=0;ii<erasingArray.length;ii++){
			//tokenAttributes.mixAmount.value[stackTokenModel[ii][1]]=0;
			//stackTokenModel.splice(erasingArray[ii],1);
			//}
			//var t = clock.getElapsedTime();
			//tokenUniforms.mixAmount.value = 0.5 * (1.0 + Math.sin(t));
			//console.log(stackTokenModel.length)
			tokenUniforms.mixAmount.value = 0.5 * (1.0 + Math.sin(t));
			//var ii=0;
			//for ( var i = 0; i <segmentPts ; i +=2 ) {
			//	tokenAttributes.mixAmount.value[i] = 0.5 * (1.0 + Math.sin(t));
			//}
			/*for (var ii=0;ii<stackTokenModel.length;ii++) {
				
					if (stackTokenModel[ii]){
						//for (var j =0;j<stackTokenModel[ii].length;j++){
						if (stackTokenModel[ii][0]){
							if (stackTokenModel[ii][0]<1){
								stackTokenModel[ii][0]+=0.005;
								tokenAttributes.mixAmount.value[stackTokenModel[ii][2]]=stackTokenModel[ii][j][0];
							}
							if (stackTokenModel[ii][0]>=1){
								
								//tokenAttributes.mixAmount.value[ii]=0;
								tokenAttributes.mixAmount.value[stackTokenModel[ii][2]]=0;
								stackTokenModel.splice(ii,1);
								tokenStackCount-=1;
								//console.log(tokenStackCount);
							}
						}
						//}

					
					}
				
			}*/
			
				//ii++;
			//}
			// trigger start of token from/to reactions
			//if (simData && simTimer<simData.length){
			//console.log("trigger: "+simData[1][simTimer][2])
			//}
			
			//tokenAttributes.mixAmount.needsUpdate = true;
			//var tokenPoses =tokenAttributes.mixAmount.value;
			//for ( var i = 1; i <segmentPts ; i +=2 ) {
			//	
			//}
			//rendererCSS.render( cssScene, camera2 );
			//rendererCSS3.render( cssScene3, camera2 );
			//rendererCSS2.render( cssScene2, camera2 );
			renderer.render( scene, camera );
			//renderer2.render( scene2, camera2 );
			
			if (idsOfSelectedRows.length>0){
				for (var i =0;i<spritesSelected.length;i++){		
					spritesSelected[i].position.set(-150000,-10000,10000);
					spritesSelected[i].scale.set(100, 100, 100);
				}
				
				for (var i =0;i<idsOfSelectedRows.length;i++){
					if (i<spritesSelected.length){
						var a1 = scene.children[idMap[idsOfSelectedRows[i]][0]].geometry.attributes.position.array;
						//console.log(idMap[idsOfSelectedRows[i]])
						spritesSelected[i].position.set(a1[idMap[idsOfSelectedRows[i]][1]*3],a1[idMap[idsOfSelectedRows[i]][1]*3+1],a1[idMap[idsOfSelectedRows[i]][1]*3+2]);			
					}
				}
				for (var i =0;i<idsOfSelectedRows.length;i++){
					//for (var j =0;j<spritesSelected.length;j++){
					if (i<spritesSelected.length){
						var dx= camera.position.x-spritesSelected[i].position.x
						var dy= camera.position.y-spritesSelected[i].position.y
						var dz= camera.position.z-spritesSelected[i].position.z
						var dc = Math.sqrt(((dx*dx) + (dy*dy)))
						var ds = Math.sqrt((dc*dc) + (dz*dz))
						var mult = ((ds/100)*5)+20
						spritesSelected[i].scale.set(mult, mult, mult);
					}
				}
			}
			else{
				for (var i =0;i<spritesSelected.length;i++){		
					spritesSelected[i].position.set(-150000,-10000,10000);
					spritesSelected[i].scale.set(100, 100, 100);
				}
			}
			
			if (idsOfModelSelectedRows.length>0){
				for (var i =0;i<modelspritesSelected.length;i++){		
					modelspritesSelected[i].position.set(-150000,-10000,10000);
					modelspritesSelected[i].scale.set(100, 100, 100);
				}
				var anb=jsonObj1.length;
				for (var i =0;i<idsOfModelSelectedRows.length;i++){
					if (i<modelspritesSelected.length){
						var a1 = scene.children[idMap[parseInt(idsOfModelSelectedRows[i])+anb][0]].geometry.attributes.position.array;
						//console.log(idMap[(jsonObj1.length+1)])
						//console.log(jsonObj1.length)
						//console.log(parseInt(idsOfModelSelectedRows[i]))
						//console.log(idMap[parseInt(idsOfModelSelectedRows[i])+anb]);
						modelspritesSelected[i].position.set(a1[idMap[parseInt(idsOfModelSelectedRows[i])+anb][1]*3],a1[idMap[parseInt(idsOfModelSelectedRows[i])+anb][1]*3+1],a1[idMap[parseInt(idsOfModelSelectedRows[i])+anb][1]*3+2]);			
					}
				}
				for (var i =0;i<idsOfModelSelectedRows.length;i++){
					//for (var j =0;j<spritesSelected.length;j++){
					if (i<modelspritesSelected.length){
						var dx= camera.position.x-modelspritesSelected[i].position.x
						var dy= camera.position.y-modelspritesSelected[i].position.y
						var dz= camera.position.z-modelspritesSelected[i].position.z
						var dc = Math.sqrt(((dx*dx) + (dy*dy)))
						var ds = Math.sqrt((dc*dc) + (dz*dz))
						var mult = ((ds/100)*5)+20
						modelspritesSelected[i].scale.set(mult, mult, mult);
					}
				}
			}
			else{
				for (var i =0;i<modelspritesSelected.length;i++){		
					modelspritesSelected[i].position.set(-150000,-10000,10000);
					modelspritesSelected[i].scale.set(100, 100, 100);
				}
			}
		/*if(typeof(Storage)!=="undefined") {
			
				if(resetSpreadsheet==true){localStorage.selection=[];}
				if (localStorage.selection==""){
					mselectedList=[]
					//console.log("empty")
					for (var i =0;i<spritesSelected.length;i++){		
						spritesSelected[i].position.set(-50000,-10000,10000);
					}
				
				}
				else if (localStorage.selection.length>0 ){
					//console.log(mselectedList); 
					//console.log(localStorage.selection.split(",").map(function(x){return parseInt(x)})); 
					
					var tmpS= localStorage.selection.split(",").map(function(x){return parseInt(x)});
					
					if(!($(tmpS).not(mselectedList).length == 0 && $(mselectedList).not(tmpS).length == 0)) {
					//	console.log(localStorage.selection); 
						mselectedList=[];
						for (var i =0;i<tmpS.length;i++){
						mselectedList[i] =tmpS[i];
						}
						//console.log(mselectedList); 
						//console.log(camera.position)
						// highlight selection
						for (var i =0;i<spritesSelected.length;i++){		
							spritesSelected[i].position.set(-50000,-10000,10000);
							spritesSelected[i].scale.set(100, 100, 100);
						}
						//if(resetSpreadsheet==true){
						//resetSpreadsheet=false;
						//}
						//else{
						for (var i =0;i<mselectedList.length;i++){
							//for (var j =0;j<spritesSelected.length;j++){
							if (i<spritesSelected.length){
								//spritesSelected
								//console.log(idMap[mselectedList[i]])
								var a1 = scene.children[idMap[mselectedList[i]][0]].geometry.attributes.position.array;
								spritesSelected[i].position.set(a1[idMap[mselectedList[i]][1]*3],a1[idMap[mselectedList[i]][1]*3+1],a1[idMap[mselectedList[i]][1]*3+2]);	
								//var dx= camera.position.x-spritesSelected[i].position.x
								//var dy= camera.position.y-spritesSelected[i].position.y
								//var dz= camera.position.z-spritesSelected[i].position.z
								//var dc = Math.sqrt(((dx*dx) + (dy*dy)))
								//var ds = Math.sqrt((dc*dc) + (dz*dz))
								//var mult = ((ds/100)*5)+50
								//spritesSelected[i].scale.set(mult, mult, mult);
								//console.log(ds)
								
							}
							
						}
						
						//}
						
					}
				
					for (var i =0;i<mselectedList.length;i++){
							//for (var j =0;j<spritesSelected.length;j++){
							if (i<spritesSelected.length){
								var dx= camera.position.x-spritesSelected[i].position.x
								var dy= camera.position.y-spritesSelected[i].position.y
								var dz= camera.position.z-spritesSelected[i].position.z
								var dc = Math.sqrt(((dx*dx) + (dy*dy)))
								var ds = Math.sqrt((dc*dc) + (dz*dz))
								var mult = ((ds/100)*5)+20
								spritesSelected[i].scale.set(mult, mult, mult);
							}
					}
					   
				}
			//else if 	(resetSpreadsheet==true){
			//	for (var i =0;i<spritesSelected.length;i++){		
			//				spritesSelected[i].position.set(-50000,-10000,10000);
			//				spritesSelected[i].scale.set(100, 100, 100);
			//			}
			//	resetSpreadsheet=false;
			//}		
        }*/
		
		
		if (exploded==true && spreadsheet1Visible==false){
			
			if (focus_label==0){
				for (var i=0;i<nbOrganelles;i++){
					var vector = new THREE.Vector3( organelles[i].position.x,organelles[i].position.y,organelles[i].position.z);
					vector.x +=500;
					var pp = toXYCoords(vector	);
					txtComp[i].style.top = (pp.y+positionContainer.top) + 'px';
					txtComp[i].style.left = pp.x + 'px';
					txtComp[i].innerHTML = nameComp[i];
				}
				var vector = new THREE.Vector3( nucleus.position.x,nucleus.position.y,nucleus.position.z);
				vector.x +=500;
				var pp = toXYCoords(vector	);
				txtComp[nbOrganelles].style.top = (pp.y+positionContainer.top) + 'px';
				txtComp[nbOrganelles].style.left = pp.x + 'px';
				txtComp[nbOrganelles].innerHTML = nameComp[nbOrganelles];
				var vector = new THREE.Vector3( cytoplasm.position.x,cytoplasm.position.y,cytoplasm.position.z);
				vector.x +=500;
				var pp = toXYCoords(vector	);
				txtComp[nbOrganelles+1].style.top = (pp.y+positionContainer.top) + 'px';
				txtComp[nbOrganelles+1].style.left = pp.x + 'px';
				txtComp[nbOrganelles+1].innerHTML = nameComp[nbOrganelles+1];
				var vector = new THREE.Vector3( ECM.position.x,ECM.position.y,ECM.position.z);
				vector.x +=500;
				var pp = toXYCoords(vector	);
				txtComp[nbOrganelles+2].style.top = (pp.y+positionContainer.top) + 'px';
				txtComp[nbOrganelles+2].style.left = pp.x + 'px';
				txtComp[nbOrganelles+2].innerHTML = nameComp[nbOrganelles+2];
				for (var d=0;d<allDragged.length;d++){
				if (allDragged[d].length>0){
					for (var di=0;di<allDragged[d].length;di++){
						
						
						txtComp[allDragged[d][di]].style.top = parseInt(txtComp[d].style.top)+18*(di+1)+"px"
						txtComp[allDragged[d][di]].style.left =parseInt(txtComp[d].style.left)+"px"
						//console.log(parseInt(txtComp[d].style.left))
					}						
				}
			}
			}
			if (focus_label>=1){
				for (var i=0;i<nbOrganelles;i++){
					
					txtComp[i].style.top = 2000 + 'px';
					txtComp[i].style.left = 2000 + 'px';
					
				}
				
				txtComp[nbOrganelles].style.top = 2000 + 'px';
				txtComp[nbOrganelles].style.left = 2000 + 'px';
				
				txtComp[nbOrganelles+1].style.top = 2000 + 'px';
				txtComp[nbOrganelles+1].style.left = 2000 + 'px';
				
				txtComp[nbOrganelles+2].style.top = 2000 + 'px';
				txtComp[nbOrganelles+2].style.left = 2000 + 'px';
				var vector;
				if ((focus_label-1)<nbOrganelles){
					vector = new THREE.Vector3( organelles[focus_label-1].position.x,organelles[focus_label-1].position.y,organelles[focus_label-1].position.z);
				}
				else{
					if (focus_label-1==nbOrganelles){
						vector = new THREE.Vector3( nucleus.position.x,nucleus.position.y,nucleus.position.z);
					}
					if (focus_label-1==nbOrganelles+1){
						vector = new THREE.Vector3( cytoplasm.position.x,cytoplasm.position.y,cytoplasm.position.z);
					}
					if (focus_label-1==nbOrganelles+2){
						vector = new THREE.Vector3( ECM.position.x,ECM.position.y,ECM.position.z);
					}
					
				}
					vector.x +=500;
					var pp = toXYCoords(vector	);
					txtComp[focus_label-1].style.top = (pp.y+positionContainer.top) + 'px';
					txtComp[focus_label-1].style.left = pp.x + 'px';
					txtComp[focus_label-1].innerHTML = nameComp[focus_label-1];
				
				
				
				
			}
		}
		else{
		
			for (var i=0;i<nbOrganelles;i++){
				
				txtComp[i].style.top = 2000 + 'px';
				txtComp[i].style.left = 2000 + 'px';
				
			}
			
			txtComp[nbOrganelles].style.top = 2000 + 'px';
			txtComp[nbOrganelles].style.left = 2000 + 'px';
			
			txtComp[nbOrganelles+1].style.top = 2000 + 'px';
			txtComp[nbOrganelles+1].style.left = 2000 + 'px';
			
			txtComp[nbOrganelles+2].style.top = 2000 + 'px';
			txtComp[nbOrganelles+2].style.left = 2000 + 'px';
			
			
			
			
		}
	
		
		if 	(resetSpreadsheet==true){
		resetSpreadsheet=false;
		}
		
		var tokenIDStackCountSize=Object.keys(tokenIDStackCount).length
		if( reactionIsDone && (simModeValue==1)){
			for (var tkNb=0; tkNb< tokenIDStackCountSize;tkNb++){
				
				var tmp=tokenIDStackCount[Object.keys(tokenIDStackCount)[tkNb]];
				
				//console.log(tokenIDStackCount[tkNb])
				txtReactionActivation[tkNb].innerHTML = ''+tmp[0];
				var vectorp = new THREE.Vector3( tmp[1],tmp[2],tmp[3]);
				vectorp.x +=10;
				var ppv = toXYCoords(vectorp	);
				txtReactionActivation[tkNb].style.top = (ppv.y+positionContainer.top) + 'px';
				txtReactionActivation[tkNb].style.left = ppv.x + 'px';
									//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
				
				
				
			}
		}
		else if( simModeValue==0){
			for (var tkNb=0; tkNb< tokenIDStackCountSize;tkNb++){
				
				var tmp=tokenIDStackCount[Object.keys(tokenIDStackCount)[tkNb]];
				
				//console.log(tokenIDStackCount[tkNb])
				txtReactionActivation[tkNb].innerHTML = ''+tmp[0];
				var vectorp = new THREE.Vector3( tmp[1],tmp[2],tmp[3]);
				vectorp.x +=10;
				var ppv = toXYCoords(vectorp	);
				txtReactionActivation[tkNb].style.top = (ppv.y+positionContainer.top) + 'px';
				txtReactionActivation[tkNb].style.left = ppv.x + 'px';
									//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
				//planeMesh[tkNb].position.set(0,0,50000);
				
				
			}
		}
		else{
			for (var tkNb=0; tkNb< tokenIDStackCountSize;tkNb++){
				
				
				txtReactionActivation[tkNb].innerHTML = '';
				//var vectorp = new THREE.Vector3( tmp[1],tmp[2],tmp[3]);
				//vectorp.x +=10;
				//var ppv = toXYCoords(vectorp	);
				//txtReactionActivation[tkNb].style.top = ppv.y + 'px';
				//txtReactionActivation[tkNb].style.left = ppv.x + 'px';
									//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
				
				
				
			}
		}
		
		//meshLineChart.direction=controls.direction;
		//meshLineChart.position.x=controls.target.x;
		//meshLineChart.position.y=controls.target.y;
		//meshLineChart.position.z=controls.target.z;
		//console.log(controls.target);
		//meshLineChart.lookAt(camera.position);
			//meshLineChart.position.set(camera.position);
			//meshLineChart.position.z+=400;
			//meshLineChart.direction=camera.direction;
		//mselectedList=[]
					//console.log("empty")
		//			for (var i =0;i<spritesSelected.length;i++){		
		//				spritesSelected[i].position.set(-50000,-10000,10000);
		//			}
		//}	
		

		}
		
		
var mydata0=[];
var sz=selectedModelNodes.length;
//console.log(selectedModelNodes)
for (var i=0;i<sz;i++){
	mydata0.push({chkBoxState:false,"id":selectedModelNodes[i][0], "name":selectedModelNodes[i][1],  "type":(selectedModelNodes[i][5]==4) ? "Transition":"Place", "sub-system":"" });
}
		
var mydata = [];
//for(var i=0;i<=20000;i++){
//mydata.push({id: ""+i,invdate:"2007-10-01",name:"test",note:"note",amount:"200.00",tax:"10.00",total:"210.00"});
//}
var sz=selectedMetabolicData[1].length  
for (var i=0;i<sz;i++){
	mydata.push({chkBoxState:false,"id":selectedMetabolicData[1][i][0], "name":selectedMetabolicData[1][i][1], "description":selectedMetabolicData[1][i][2], "comp":selectedMetabolicData[1][i][3],"type":(selectedMetabolicData[1][i][6]==4) ? "Reaction":"Metabolite", "sub-system":(selectedMetabolicData[1][i][6]==4 && selectedMetabolicData[1][i][4][1][0]) ? selectedMetabolicData[1][i][4][1][0]:"" });
}

$("#dataTable0").css({top:  $("#container").height()+$("#container").position().top+40, left:0, width:$("#container").width()});
$("#dataTable").css({top:  $("#container").height()+$("#container").position().top+350+40, left:0, width:$("#container").width()});


jQuery("#list0").jqGrid({
	datatype: "local",
	data: mydata0,
	height: 250,
	width: ($("#container").width()*0.8),
   	colNames:["id", "name","type","sub-system"],
   	colModel:[
		
   		{name:'id',index:'id', width:60, sorttype:"int",searchoptions:{sopt:['eq','bw','bn','cn','nc','ew','en']}},
   		{name:'name',index:'name', width:100,sorttype:'string', searchoptions:{sopt:['eq','bw','bn','cn','nc','ew','en']},editable:true},
   		{name:'type',index:'type', width:100,sorttype:'string', searchoptions:{sopt:['eq','bw','bn','cn','nc','ew','en']},editable:true},
   		{name:'sub-system',index:'sub-system', width:100,sorttype:'string', searchoptions:{sopt:['eq','bw','bn','cn','nc','ew','en']},editable:true},
   	],
   	recordpos: 'left',
	scroll: 1,
  //enable npage request parameter
  //prmNames: { npage: 'npage' },
	scrollrows: true, 
	rowNum: 12,
	rowList:[],
    viewrecords: true,
    sortorder: "desc",
	ignoreCase: true,
	multiselect: true,
                onSelectRow: function (id, isSelected) {
                    var p = this.p, item = p.data[p._index[id]], i = $.inArray(id, idsOfModelSelectedRows);
                    item.cb = isSelected;
                    if (!isSelected && i >= 0) {
                        idsOfModelSelectedRows.splice(i,1); // remove id from the list
                    } else if (i < 0) {
                        idsOfModelSelectedRows.push(id);
                    }
                },
                loadComplete: function () {
                    var p = this.p, data = p.data, item, $this = $(this), index = p._index, rowid, i, selCount;
                    for (i = 0, selCount = idsOfModelSelectedRows.length; i < selCount; i++) {
                        rowid = idsOfModelSelectedRows[i];
                        item = data[index[rowid]];
                        if ('cb' in item && item.cb) {
                            $this.jqGrid('setSelection', rowid, false);
                        }
                    }
                },

	gridview: true,
	//cellEdit: true,
	loadonce: true,
   	caption: "QSSPN Model: list of selectable nodes (places and transitions)"
});
jQuery("#list0").jqGrid('filterToolbar',{searchOperators : true});


jQuery("#list4").jqGrid({
	datatype: "local",
	data: mydata,
	height: 250,
	width: ($("#container").width()*0.8),
   	colNames:["id", "name","description","comp","type","sub-system"],
   	colModel:[
		
   		{name:'id',index:'id', width:60, sorttype:"int",searchoptions:{sopt:['eq','bw','bn','cn','nc','ew','en']}},
   		{name:'name',index:'name', width:100,sorttype:'string', searchoptions:{sopt:['eq','bw','bn','cn','nc','ew','en']},editable:true},
		{name:'description',index:'description', width:100,sorttype:'string', searchoptions:{sopt:['eq','bw','bn','cn','nc','ew','en']},editable:true},
   		{name:'comp',index:'comp', width:100,sorttype:'string', searchoptions:{sopt:['eq','bw','bn','cn','nc','ew','en']},editable:true},
   		{name:'type',index:'type', width:100,sorttype:'string', searchoptions:{sopt:['eq','bw','bn','cn','nc','ew','en']},editable:true},
   		{name:'sub-system',index:'sub-system', width:100,sorttype:'string', searchoptions:{sopt:['eq','bw','bn','cn','nc','ew','en']},editable:true},
   	],
   	recordpos: 'left',
	scroll: 1,
  //enable npage request parameter
  //prmNames: { npage: 'npage' },
	scrollrows: true, 
	rowNum: 12,
	rowList:[],
    viewrecords: true,
    sortorder: "desc",
	
	multiselect: true,
                onSelectRow: function (id, isSelected) {
                    var p = this.p, item = p.data[p._index[id]], i = $.inArray(id, idsOfSelectedRows);
                    item.cb = isSelected;
                    if (!isSelected && i >= 0) {
                        idsOfSelectedRows.splice(i,1); // remove id from the list
                    } else if (i < 0) {
                        idsOfSelectedRows.push(id);
                    }
                },
                loadComplete: function () {
                    var p = this.p, data = p.data, item, $this = $(this), index = p._index, rowid, i, selCount;
                    for (i = 0, selCount = idsOfSelectedRows.length; i < selCount; i++) {
                        rowid = idsOfSelectedRows[i];
                        item = data[index[rowid]];
                        if ('cb' in item && item.cb) {
                            $this.jqGrid('setSelection', rowid, false);
                        }
                    }
                },
	ignoreCase: true,
	gridview: true,
	//cellEdit: true,
	loadonce: true,
   	caption: "Metabolic network: list of selectable nodes (metabolites and reactions)"
});
jQuery("#list4").jqGrid('filterToolbar',{searchOperators : true});




//for(var i=0;i<=mydata.length;i++)
//	jQuery("#list4").jqGrid('addRowData',i+1,mydata);
/*
// get nb of reaction nodes per sub-system
var chartData={};
var tnbReactions=0;
for (var i=0;i<sz;i++){
	if (selectedMetabolicData[1][i][6]==4 && selectedMetabolicData[1][i][4][1][0]){
		tnbReactions++;
		var sn =selectedMetabolicData[1][i][4][1][0];
		//if (chartData[sn] in chartData){
			if (chartData.hasOwnProperty(sn)) {
				chartData[selectedMetabolicData[1][i][4][1][0]]+=1;
			}
		//}
		else{
			chartData[selectedMetabolicData[1][i][4][1][0]]=1;
		}
		
	}
	//mydata.push({chkBoxState:false,"id":selectedMetabolicData[1][i][0], "name":selectedMetabolicData[1][i][1], "description":selectedMetabolicData[1][i][2], "comp":selectedMetabolicData[1][i][3],"type":(selectedMetabolicData[1][i][6]==4) ? "Reaction":"Metabolite", "sub-system":(selectedMetabolicData[1][i][6]==4 && selectedMetabolicData[1][i][4][1][0]) ? selectedMetabolicData[1][i][4][1][0]:"" });
}
var plotchartdata=[];
for (elem in chartData){
	if (chartData.hasOwnProperty(elem)) {
		plotchartdata.push({name: elem, val: chartData[elem]});
	}
}
//console.log(chartData);
//var chartData = [
//    {name: "A", val: 11975},  
//];

var w = 500,
    h = 500,
    r = Math.min(w, h) / 2,
    labelr = r + 10, // radius for label anchor
    color = d3.scale.category20(),
    donut = d3.layout.pie(),
    arc = d3.svg.arc().innerRadius(r * .6).outerRadius(r);
$("#titlechart").css({top:  $("#dataTable").position().top + $("#list4").height()+170});
$("#chart").css({top: 100});

var vis = d3.select("#chart")
  .append("svg:svg")
    .data([plotchartdata])
    .attr("width", w + 150)
    .attr("height", h+150);
	
var ctext;
var arcs = vis.selectAll("g.arc")
    .data(donut.value(function(d) { return d.val }))
  .enter().append("svg:g")
    .attr("class", "arc")
    .attr("transform", "translate(" + (r + 30) + "," + r + ")");

arcs.append("svg:path")
    .attr("fill", function(d, i) { return color(i); })
    .attr("d", arc)
	.on('mouseover', function(d) {
					d3.select(this).transition().duration(300)
					.style({'stroke-opacity':1,'stroke':'#F00', 'stroke-width':2});
                    $("#mytooltip")
                      .html("<b>"+d.data.name+"</b><br>"+d.data.val+" reaction nodes<br>"+((d.data.val/tnbReactions)*100).toFixed(2)+"%")
					  .css('left', window.event.clientX+40)
                      .css('top', window.event.clientY)
                      .show();
    })
	//.on('mousemove', function(d) {
    //                $("#mytooltip")
    //                  .css('left', window.event.clientX+40)
    //                  .css('top', window.event.clientY)//(+$("#container").position().top+window.pageYOffset))
    //            })
	.on("mouseout", function(d) {
               $("#mytooltip").html('').hide();
			   d3.select(this).transition().duration(300)
				.style({'stroke-opacity':0.4,'stroke':'#eee','stroke-width':1});
    });

*/
$("#modelSpreadSheet").css({top:  $("#dataTable").position().top + $("#list4").height()+170, width:$("#container").width()});
//var dataJson={"places" : [], "qssf" : { "constraints" : [], "externality_tag" :null,"objectives" : []}, "transitions" : []};
var dataJson=<%-JSON.stringify(qm.file)%>;
//console.log(JSON.stringify(dataJson).length)
//console.log(dataJson)




var presentTransitionNb=-1;
var presentPrePlaceNb=-1;
var presentConstraintNb=-1;
var presentObjectiveNb=-1;

var $container1 = $("#placesTable");
$container1.handsontable({
  data: [],
  width: 750,
  height:200,
  dataSchema: {name: null, state: null, type: null, max:null, subsystem:null},
  startRows: 5,
  startCols: 5,
  colHeaders: ['Name', 'State', 'Type','Max','Sub-system'],
  columns: [
    {data: "name"},
    {data: "state"},
    {data: "type"},
    {data: "max"},
	{data: "subsystem"}
  ],
  afterChange: function(changes, source) {
    //console.log(this.getData());
	var dt = this.getData();
	for (var i=0, j= dt.length;i<j-1;i++){
		if (dataJson["places"].length <i+1){
			dataJson["places"].push({"place":{	"max" : dt[i].max,"name" : dt[i].name,"state" : dt[i].state,"type" : dt[i].type,"subsystem" : dt[i].subsystem} });
		}
		else dataJson["places"][i]={"place":{	"max" : dt[i].max,"name" : dt[i].name,"state" : dt[i].state,"type" : dt[i].type,"subsystem" : dt[i].subsystem} };
	}
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//console.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
	//console.log(dataJson)
  },
  minSpareRows: 1
});

var tempdata1=new Array(dataJson["places"].length);
for (var i=0, j=dataJson["places"].length; i<j;i++){
	tempdata1[i]=new Array(5);
	tempdata1[i][0]=dataJson["places"][i]["place"]["name"];
	tempdata1[i][1]=dataJson["places"][i]["place"]["state"];
	tempdata1[i][2]=dataJson["places"][i]["place"]["type"];
	tempdata1[i][3]=dataJson["places"][i]["place"]["max"];
	tempdata1[i][4]=dataJson["places"][i]["place"]["subsystem"];
}
//console.log(tempdata1)
var ht = $('#placesTable').handsontable('getInstance');
if ($.isArray(tempdata1) && tempdata1[0] && $.isArray(tempdata1[0])){
	ht.populateFromArray (0, 0, tempdata1,tempdata1.length-1, 3);
}
/*var newColumnSettings = [
    {data: "name", readOnly: true},
    {data: "state"},
    {data: "type"},
    {data: "max"},
	{data: "subsystem"}
  ];
ht.updateSettings({ columns: newColumnSettings });*/
  
var $container2 = $("#transitionsTable");
$container2.handsontable({
  data: [],
  width: 750,
  height:200,
  colWidths: [350, 50, 50, 50,100],
  dataSchema: {name: null, delay: null, type: null, c:null ,prePlaces:null,consumed:null, postPlaces:null , subsystem:null },
  startRows: 5,
  startCols: 5,
  colHeaders: ['Name', 'Delay','Type','c','Sub-system'],
  columns: [
    {data: "name"},
    {data: "delay"},
    {data: "type"},
    {data: "c"},
	{data: "subsystem"}
  ],
  afterSelection : function(rowNb, colNb) {
	presentTransitionNb=rowNb;
	document.getElementById("t1").innerHTML = 'Pre-places List for transition nb:'+rowNb+ ', name:'+this.getDataAtCell(rowNb,0);
	document.getElementById("t2").innerHTML = 'Consumed List for transition nb:'+rowNb+ ', name:'+this.getDataAtCell(rowNb,0);
	document.getElementById("t3").innerHTML = 'Post-places List for transition nb:'+rowNb+ ', name:'+this.getDataAtCell(rowNb,0);
	if(dataJson["transitions"][presentTransitionNb]){
		//dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"]=[{	"preplace" : {	"activity" : [{ "a" : 0.0, "t" : 1.0}],"name" : "dNTPs","stoichiometry" : 1.0}}];
		/*if(dataJson["transitions"][presentTransitionNb]["transition"] && dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"]){
			var dt=dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"];
			var ht = $('#prePlacesTable').handsontable('getInstance');
			ht.clear();
			var tmpT= new Array(dt.length);
			for (var i=0, j= dt.length;i<j;i++){
					tmpT[i]=new Array(2);
					tmpT[i][0]=dt[i]["preplace"]["name"];
					tmpT[i][1]=dt[i]["preplace"]["stoichiometry"];
			}	
			//console.log(tmpT)
			if ($.isArray(tmpT) && tmpT[0] && $.isArray(tmpT[0])){
				ht.populateFromArray (0, 0, tmpT,tmpT.length-1, 1)
			}
		}*/
		if(dataJson["transitions"][presentTransitionNb]["transition"]){ 
			if (dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"]){
				var dt=dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"];
				var ht = $('#prePlacesTable').handsontable('getInstance');
				ht.clear();
				var tmpT= new Array(dt.length);
				for (var i=0, j= dt.length;i<j;i++){
						tmpT[i]=new Array(2);
						tmpT[i][0]=dt[i]["preplace"]["name"];
						tmpT[i][1]=dt[i]["preplace"]["stoichiometry"];
				}	
				//console.log(tmpT)
				if ($.isArray(tmpT) && tmpT[0] && $.isArray(tmpT[0])){
					ht.populateFromArray (0, 0, tmpT,tmpT.length-1, 1)
				}
				
				if(presentPrePlaceNb!=-1 && dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]){
					//console.log(dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb])
					if (dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"]){
						var dt=dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"];
						
						var tmpT= new Array(dt.length);
						for (var i=0, j= dt.length;i<j;i++){
								tmpT[i]=new Array(2);
								tmpT[i][0]=dt[i]["a"];
								tmpT[i][1]=dt[i]["t"];
						}	
						var ht = $('#activityTable').handsontable('getInstance');
						ht.clear();
						if ($.isArray(tmpT) && tmpT[0] && $.isArray(tmpT[0])){
							ht.populateFromArray (0, 0, tmpT,tmpT.length-1, 1);
						}
					}
					else{
						//var ht = $('#activityTable').handsontable('getInstance');
						//ht.clear();
					}
				}
				else{
					//var ht = $('#activityTable').handsontable('getInstance');
					//ht.clear();
				}
				
				
				
			}
			else{
				var ht = $('#prePlacesTable').handsontable('getInstance');
				ht.clear();
				//var ht = $('#activityTable').handsontable('getInstance');
				//ht.clear();
			}
			
			if (dataJson["transitions"][presentTransitionNb]["transition"]["consumed"]){
				var dt=dataJson["transitions"][presentTransitionNb]["transition"]["consumed"];
				var ht = $('#consumedTable').handsontable('getInstance');
				ht.clear();
				var tmpT= new Array(dt.length);
				for (var i=0, j= dt.length;i<j;i++){
						tmpT[i]=new Array(1);
						tmpT[i][0]=dt[i]["consumed_preplace"]["name"];
				}	
				//console.log(tmpT)
				if ($.isArray(tmpT) && tmpT[0] && $.isArray(tmpT[0])){
					ht.populateFromArray (0, 0, tmpT,tmpT.length-1, 1)
				}
				
			}
			else{
				var ht = $('#consumedTable').handsontable('getInstance');
				ht.clear();
			}
			
			if (dataJson["transitions"][presentTransitionNb]["transition"]["postplaces"]){
				var dt=dataJson["transitions"][presentTransitionNb]["transition"]["postplaces"];
				var ht = $('#postPlacesTable').handsontable('getInstance');
				ht.clear();
				var tmpT= new Array(dt.length);
				for (var i=0, j= dt.length;i<j;i++){
						tmpT[i]=new Array(2);
						tmpT[i][0]=dt[i]["postplace"]["name"];
						tmpT[i][1]=dt[i]["postplace"]["stoichiometry"];
				}	
				//console.log(tmpT)
				if ($.isArray(tmpT) && tmpT[0] && $.isArray(tmpT[0])){
					ht.populateFromArray (0, 0, tmpT,tmpT.length-1, 1)
				}
				
			}
			else{
				var ht = $('#postPlacesTable').handsontable('getInstance');
				ht.clear();
			}
			
			
		}
		
		
		else{
			var ht = $('#prePlacesTable').handsontable('getInstance');
			ht.clear();
			var ht = $('#consumedTable').handsontable('getInstance');
			ht.clear();
		}
	}
	else{
		var ht = $('#prePlacesTable').handsontable('getInstance');
		ht.clear();
		var ht = $('#consumedTable').handsontable('getInstance');
		ht.clear();
	}
  },
  afterChange: function(changes, source) {
    //console.log(this.getData());
	var dt = this.getData();
	for (var i=0, j= dt.length;i<j-1;i++){
		if (dataJson["transitions"].length <i+1){
			dataJson["transitions"].push({"transition":{ "name" : dt[i].name,"delay" : dt[i].delay,"type" : dt[i].type,"c" : dt[i].c,"subsystem" : dt[i].subsystem}});
		}
		else {
			dataJson["transitions"][i]["transition"]["name"]=dt[i].name;
			dataJson["transitions"][i]["transition"]["delay"]=dt[i].delay;
			dataJson["transitions"][i]["transition"]["type"]=dt[i].type;
			dataJson["transitions"][i]["transition"]["c"]=dt[i].c;
			dataJson["transitions"][i]["transition"]["subsystem"]=dt[i].subsystem;
		}
	}
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//console.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
	
	//console.log(dataJson)
	//console.log(dataJson);
	//dataJson.places.push()
  },
  minSpareRows: 1
});

var tempdata2=new Array(dataJson["transitions"].length);
for (var i=0, j=dataJson["transitions"].length; i<j;i++){
	tempdata2[i]=new Array(4);
	tempdata2[i][0]=dataJson["transitions"][i]["transition"]["name"];
	tempdata2[i][1]=dataJson["transitions"][i]["transition"]["delay"];
	tempdata2[i][2]=dataJson["transitions"][i]["transition"]["type"];
	tempdata2[i][3]=dataJson["transitions"][i]["transition"]["c"];
}
//console.log(tempdata1)
var ht = $('#transitionsTable').handsontable('getInstance');
if ($.isArray(tempdata2) && tempdata2[0] && $.isArray(tempdata2[0])){
	ht.populateFromArray (0, 0, tempdata2,tempdata2.length-1, 3);
}
/*var newColumnSettings = [
    {data: "name", readOnly: true},
    {data: "delay"},
    {data: "type"},
    {data: "c"},
	{data: "subsystem"}
  ];
ht.updateSettings({ columns: newColumnSettings });
*/

var $container3 = $("#postPlacesTable");
$container3.handsontable({
  data: [],
  width: 400,
  height:200,
  dataSchema: {name: null, stoichiometry: null  },
  startRows: 5,
  startCols: 4,
  colHeaders: ['Name', 'Stoichiometry'],
  columns: [
    {data: "name"},
    {data: "stoichiometry"},
  ],
  afterChange: function(changes, source) {
	if(dataJson["transitions"][presentTransitionNb] && dataJson["transitions"][presentTransitionNb]["transition"]){
		var dt = this.getData();
		
		if (dataJson["transitions"][presentTransitionNb]["transition"]["postplaces"]){
			for (var i=0, j= dt.length;i<j-1;i++){
				if (dataJson["transitions"][presentTransitionNb]["transition"]["postplaces"].length <i+1){
					dataJson["transitions"][presentTransitionNb]["transition"]["postplaces"].push({"postplace":{	"name" : dt[i].name, "stoichiometry" : dt[i].stoichiometry} });
				}
				else{
					dataJson["transitions"][presentTransitionNb]["transition"]["postplaces"][i]["postplace"]["name"]=dt[i].name;
					dataJson["transitions"][presentTransitionNb]["transition"]["postplaces"][i]["postplace"]["stoichiometry"]=dt[i].stoichiometry;
				}
			}
		}
		else{
			dataJson["transitions"][presentTransitionNb]["transition"]["postplaces"]=[];
			for (var i=0, j= dt.length;i<j-1;i++){
				dataJson["transitions"][presentTransitionNb]["transition"]["postplaces"].push({"postplace":{	"name" : dt[i].name, "stoichiometry" : dt[i].stoichiometry} });
			}
		}
		//console.log(dataJson["transitions"][presentTransitionNb]["transition"]["consumed"])
		
	}
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//console.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
	
  },
  minSpareRows: 1
});
var $container4 = $("#prePlacesTable");
$container4.handsontable({
  data: [],
  width: 400,
  height:200,
  dataSchema: {name: null, stoichiometry: null  },
  startRows: 5,
  startCols: 4,
  colHeaders: ['Name','Stoichiometry'],
  columns: [
    {data: "name"},
    {data: "stoichiometry"},
  ],
  afterSelection : function(rowNb, colNb) {
	presentPrePlaceNb=rowNb;
	document.getElementById("t1.1").innerHTML = 'Activity table for pre-place nb:'+rowNb+ ', name:'+this.getDataAtCell(rowNb,0);
	
	if(dataJson["transitions"][presentTransitionNb]){
	//console.log(dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb])
		//dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"]=[{	"preplace" : {	"activity" : [{ "a" : 0.0, "t" : 1.0}],"name" : "dNTPs","stoichiometry" : 1.0}}];
		if(dataJson["transitions"][presentTransitionNb]["transition"] 
		&& dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"]
		&& dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]
		){
			
			if (dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["preplace"]["activity"]){
				
				var dt=dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["preplace"]["activity"];
				//console.log(dt)
				var tmpT= new Array(dt.length);
				for (var i=0, j= dt.length;i<j;i++){
						tmpT[i]=new Array(2);
						tmpT[i][0]=dt[i]["a"];
						tmpT[i][1]=dt[i]["t"];
				}	
				var ht = $('#activityTable').handsontable('getInstance');
				ht.clear();
				if ($.isArray(tmpT) && tmpT[0] && $.isArray(tmpT[0])){
					ht.populateFromArray (0, 0, tmpT,tmpT.length-1, 1);
				}
			}
			else{
				var ht = $('#activityTable').handsontable('getInstance');
				ht.clear();
			}
			//var ht = $('#activityTable').handsontable('getInstance');
			//ht.clear();
			//var tmpT= new Array(dt.length);
			//for (var i=0, j= dt.length;i<j;i++){
			//		tmpT[i]=new Array(2);
			//		tmpT[i][0]=dt[i]["a"];
			//		tmpT[i][1]=dt[i]["t"];
			//}	
			//console.log(tmpT)
			//if ($.isArray(tmpT) && tmpT[0] && $.isArray(tmpT[0])){
			//	ht.populateFromArray (0, 0, tmpT,tmpT.length-1, 1)
			//}
		}
		else{
			var ht = $('#activityTable').handsontable('getInstance');
			ht.clear();
		}
	}
	else{
		var ht = $('#activityTable').handsontable('getInstance');
		ht.clear();
	}
  },
  
  afterChange: function(changes, source) {
	if(dataJson["transitions"][presentTransitionNb]){
		var dt = this.getData();
		if (dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"]){
			
			for (var i=0, j= dt.length;i<j-1;i++){
				if (dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"].length <i+1){
					dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"].push({"preplace":{	"name" : dt[i].name,"stoichiometry" : dt[i].stoichiometry, "activity":[]} });
				}
				else {
					
					dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][i]["preplace"]["name"]=dt[i].name;
					dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][i]["preplace"]["stoichiometry"]=dt[i].stoichiometry;
				}
			}
		}
		else{
			dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"]=[];
			for (var i=0, j= dt.length;i<j-1;i++){
				if (dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"].length <i+1){
					dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"].push({"preplace":{	"name" : dt[i].name,"stoichiometry" : dt[i].stoichiometry, "activity":[]} });
				}
				else {
					
					dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][i]["preplace"]["name"]=dt[i].name;
					dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][i]["preplace"]["stoichiometry"]=dt[i].stoichiometry;
				}
			}
		}
		
	}
	
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//console.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
  },
  
  minSpareRows: 1
});

var $container5 = $("#activityTable");
$container5.handsontable({
  data: [],
  width: 400,
  height:200,
  dataSchema: {a: null, t:null},
  startRows: 5,
  startCols: 4,
  colHeaders: ['a', 't'],
  columns: [
    {data: "a"},
	{data: "t"},
  ],
  afterChange: function(changes, source) {
	if(presentTransitionNb!=-1 && presentPrePlaceNb!=-1 && dataJson["transitions"][presentTransitionNb]){
		
		if (dataJson["transitions"][presentTransitionNb]["transition"]
		&& dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"]
		&& dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]){
			//console.log(dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]);
			
			if(dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"]){
				var dt = this.getData();
				//console.log(dt);
				for (var i=0, j= dt.length;i<j-1;i++){
					
					if (dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"].length<i+1){
						dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"].push({"a":dt[i].a,"t" : dt[i].t});		
					}
					else{
						dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"][i]["a"]=dt[i].a;
						dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"][i]["t"]=dt[i].t;	
					}
				}
				//console.log(dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"]);
			}
			else{
				dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"]=[];
				var dt = this.getData();
				for (var i=0, j= dt.length;i<j-1;i++){
					dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"].push({"a":dt[i].a,"t" : dt[i].t});		
				}
			}
			//console.log(dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"])
		}
		//if (!dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"]){
		//	dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"]=[];
		//}
	//	dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]=[];
		//for (var i=0, j= dt.length;i<j-1;i++){
		//	if (dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"].length <i+1){
		//		dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"].push({"a":dt[i].a,"t" : dt[i].t});
		//	}
		//	else {
		//		dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"][i]["a"]=dt[i].a;
		//		dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"][i]["t"]=dt[i].t;
		//	}
		//}
	}
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//console.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
  },
  minSpareRows: 1
});
var $container6 = $("#consumedTable");
$container6.handsontable({
  data: [],
  width: 400,
  height:200,
  dataSchema: {name: null},
  startRows: 5,
  startCols: 1,
  colHeaders: ['name'],
  columns: [
    {data: "name"}
  ],
  afterChange: function(changes, source) {
	if(dataJson["transitions"][presentTransitionNb] && dataJson["transitions"][presentTransitionNb]["transition"]){
		var dt = this.getData();
		
		if (dataJson["transitions"][presentTransitionNb]["transition"]["consumed"]){
			for (var i=0, j= dt.length;i<j-1;i++){
				if (dataJson["transitions"][presentTransitionNb]["transition"]["consumed"].length <i+1){
					dataJson["transitions"][presentTransitionNb]["transition"]["consumed"].push({"consumed_preplace":{	"name" : dt[i].name} });
				}
				else{
					dataJson["transitions"][presentTransitionNb]["transition"]["consumed"][i]["consumed_preplace"]["name"]=dt[i].name;
				}
			}
		}
		else{
			dataJson["transitions"][presentTransitionNb]["transition"]["consumed"]=[];
			for (var i=0, j= dt.length;i<j-1;i++){
				dataJson["transitions"][presentTransitionNb]["transition"]["consumed"].push({"consumed_preplace":{	"name" : dt[i].name} });
			}
		}
		//console.log(dataJson["transitions"][presentTransitionNb]["transition"]["consumed"])
		
	}
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//console.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
  },
  minSpareRows: 1
});

var $container7 = $("#qssfTable");
$container7.handsontable({
  data: [],
  width: 400,
  height:200,
  dataSchema: {externality_tag: null, sfba_file: null},
  startRows: 1,
  startCols: 2,
  maxRows: 1,
  colHeaders: ['externality_tag', 'sfba_file'],
  columns: [
	{data: "externality_tag"},
	{data: "sfba_file"}
  ],
  afterChange: function(changes, source) {
	var dt = this.getData();
	
		dataJson["qssf"]["externality_tag"]=dt[0].externality_tag;
		//dataJson["qssf"]["sfba_file"]=dt[0].sfba_file;	
		//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
		var mlength=JSON.stringify(dataJson).length;
		var nbArrays=1;
		if (mlength>524288){
			nbArrays=parseInt(Math.ceil(mlength/524288.0));
		}
		if (nbArrays==1){
			document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
		}
		else{
			var stringSfba=JSON.stringify(dataJson);
			var chunksize=524288;
			var stringChunks=[];
			//console.log(mlength)
			for (var i=0;i<nbArrays;i++){
				stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
				document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
				//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
				//console.log(document.getElementById("mySpreadsheet"+i).value.length)
			}
			//console.log(stringChunks)
		}
		
  },
  minSpareRows: 1
});
var tempdata3=[[dataJson["qssf"]["externality_tag"],dataJson["qssf"]["sfba_file"] ]];

var ht = $('#qssfTable').handsontable('getInstance');
if ($.isArray(tempdata3) && tempdata3[0] && $.isArray(tempdata3[0])){
	ht.populateFromArray (0, 0, tempdata3,tempdata3.length-1, 1);
}


var $container8 = $("#constraintsTable");
$container8.handsontable({
  data: [],
  width: 200,
  height:200,
  dataSchema: {name: null},
  startRows: 5,
  startCols: 1,
  colHeaders: ['name'],
  columns: [
    {data: "name"}
  ],
  afterSelection : function(rowNb, colNb) {
	//console.log(rowNb);
	//console.log($("t1").text())
	presentConstraintNb=rowNb;
	document.getElementById("qssf1.1").innerHTML = 'Activity Table for constraint nb:'+rowNb+ ', name:'+this.getDataAtCell(rowNb,0);
	document.getElementById("qssf1.2").innerHTML = 'Flux List for constraint nb:'+rowNb+ ', name:'+this.getDataAtCell(rowNb,0);
	
	if(dataJson["qssf"]["constraints"][presentConstraintNb]){
		if(dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]){ 
			if (dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["activity"]){
				var dt=dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["activity"];
				var ht = $('#constraintsActivityTable').handsontable('getInstance');
				ht.clear();
				var tmpT= new Array(dt.length);
				for (var i=0, j= dt.length;i<j;i++){
						tmpT[i]=new Array(3);
						tmpT[i][0]=dt[i]["lb"];
						tmpT[i][1]=dt[i]["ub"];
						tmpT[i][2]=dt[i]["t"];
				}	
				//console.log(tmpT)
				if ($.isArray(tmpT) && tmpT[0] && $.isArray(tmpT[0])){
					ht.populateFromArray (0, 0, tmpT,tmpT.length-1, 1)
				}
			}
			else{
				var ht = $('#constraintsActivityTable').handsontable('getInstance');
				ht.clear();
				//var ht = $('#activityTable').handsontable('getInstance');
				//ht.clear();
			}
			
			if (dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["flux_list"]){
				var dt=dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["flux_list"];
				var ht = $('#fluxListActivityTable').handsontable('getInstance');
				ht.clear();
				var tmpT= new Array(dt.length);
				for (var i=0, j= dt.length;i<j;i++){
						tmpT[i]=new Array(1);
						tmpT[i][0]=dt[i];
				}	
				//console.log(tmpT)
				if ($.isArray(tmpT) && tmpT[0] && $.isArray(tmpT[0])){
					ht.populateFromArray (0, 0, tmpT,tmpT.length-1, 1)
				}
				
			}
			else{
				var ht = $('#fluxListActivityTable').handsontable('getInstance');
				ht.clear();
			}
			
			
			
			
		}
		
		
		else{
			var ht = $('#constraintsActivityTable').handsontable('getInstance');
			ht.clear();
			var ht = $('#fluxListActivityTable').handsontable('getInstance');
			ht.clear();
		}
	}
	else{
		var ht = $('#constraintsActivityTable').handsontable('getInstance');
		ht.clear();
		var ht = $('#fluxListActivityTable').handsontable('getInstance');
		ht.clear();
	}
	
	
  },
  afterChange: function(changes, source) {
    //console.log(this.getData());
	var dt = this.getData();
	for (var i=0, j= dt.length;i<j-1;i++){
		if (dataJson["qssf"]["constraints"].length <i+1){
			dataJson["qssf"]["constraints"].push({"constraint":{	"name" : dt[i].name,"activity" : [],"flux_list" : []} });
		}
		else dataJson["qssf"]["constraints"][i]["constraint"]["name"]=dt[i].name;
	}
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//console.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
	
	//console.log(dataJson["qssf"]["constraints"]);
	//dataJson.places.push()
  },
  minSpareRows: 1
});

var tempdata4=new Array(dataJson["qssf"]["constraints"].length);
for (var i=0, j=dataJson["qssf"]["constraints"].length; i<j;i++){
	tempdata4[i]=new Array(1);
	tempdata4[i][0]=dataJson["qssf"]["constraints"][i]["constraint"]["name"];
}
var ht = $('#constraintsTable').handsontable('getInstance');
if ($.isArray(tempdata4) && tempdata4[0] && $.isArray(tempdata4[0])){
	ht.populateFromArray (0, 0, tempdata4,tempdata4.length-1, 1);
}

var $container9 = $("#constraintsActivityTable");
$container9.handsontable({
  data: [],
  width: 200,
  height:200,
  dataSchema: {lb: null, ub: null, t: null},
  startRows: 5,
  startCols: 4,
  colHeaders: ['lb', 'ub', 't'],
  columns: [
    {data: "lb"},
	{data: "ub"},
	{data: "t"},
  ],
  afterChange: function(changes, source) {
	if(dataJson["qssf"]["constraints"][presentConstraintNb]){
		var dt = this.getData();
		if (dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["activity"]){
			
			for (var i=0, j= dt.length;i<j-1;i++){
				if (dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["activity"].length <i+1){
					dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["activity"].push({	"ub" : dt[i].ub,"lb" : dt[i].lb, "t":dt[i].t} );
				}
				else {
					
					dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["activity"][i]["ub"]=dt[i].ub;
					dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["activity"][i]["lb"]=dt[i].lb;
					dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["activity"][i]["t"]=dt[i].t;
				}
			}
			//console.log(dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["activity"]);
		}
		
	}
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//console.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
	
  },
  minSpareRows: 1
});

var $container10 = $("#fluxListActivityTable");
$container10.handsontable({
  data: [],
  width: 200,
  height:200,
  dataSchema: {name: null},
  startRows: 5,
  startCols: 1,
  colHeaders: ['name'],
  columns: [
    {data: "name"}
  ],
  afterChange: function(changes, source) {
	if(dataJson["qssf"]["constraints"][presentConstraintNb]){
		var dt = this.getData();
		if (dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["flux_list"]){
			
			for (var i=0, j= dt.length;i<j-1;i++){
				if (dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["flux_list"].length <i+1){
					dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["flux_list"].push(dt[i].name);
				}
				else {
					
					dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["flux_list"][i]=dt[i].name;
					
				}
			}
			//console.log(dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["flux_list"]);
		}
		
	}
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//console.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
	
  },
  minSpareRows: 1
});

var $container11 = $("#objectiveTable");
$container11.handsontable({
  data: [],
  width: 400,
  height:200,
  dataSchema: {name: null, objective: null},
  startRows: 5,
  startCols: 4,
  colHeaders: ['name', 'objective'],
  columns: [
    {data: "name"},
	{data: "objective"}
	
  ],
  afterSelection : function(rowNb, colNb) {
	//console.log(rowNb);
	//console.log($("t1").text())
	presentObjectiveNb=rowNb;
	document.getElementById("qssf2.1").innerHTML = 'Activity Table for objective nb:'+rowNb+ ', name:'+this.getDataAtCell(rowNb,0);
	
	if(dataJson["qssf"]["objectives"][presentObjectiveNb]){
		if(dataJson["qssf"]["objectives"][presentObjectiveNb]["objective"]){ 
			if (dataJson["qssf"]["objectives"][presentObjectiveNb]["objective"]["activity"]){
				var dt=dataJson["qssf"]["objectives"][presentObjectiveNb]["objective"]["activity"];
				var ht = $('#objectiveActivityTable').handsontable('getInstance');
				ht.clear();
				var tmpT= new Array(dt.length);
				for (var i=0, j= dt.length;i<j;i++){
						tmpT[i]=new Array(2);
						tmpT[i][0]=dt[i]["a"];
						tmpT[i][1]=dt[i]["t"];
						
				}	
				//console.log(tmpT)
				if ($.isArray(tmpT) && tmpT[0] && $.isArray(tmpT[0])){
					ht.populateFromArray (0, 0, tmpT,tmpT.length-1, 1)
				}
			}
			else{
				var ht = $('#objectiveActivityTable').handsontable('getInstance');
				ht.clear();
				//var ht = $('#activityTable').handsontable('getInstance');
				//ht.clear();
			}
			
		}
		
		
		else{
			var ht = $('#objectiveActivityTable').handsontable('getInstance');
			ht.clear();
			
		}
	}
	else{
		var ht = $('#objectiveActivityTable').handsontable('getInstance');
		ht.clear();
		
	}
	
  },
  afterChange: function(changes, source) {
    //console.log(this.getData());
	var dt = this.getData();
	
	for (var i=0, j= dt.length;i<j-1;i++){
		if (dataJson["qssf"]["objectives"].length <i+1){
			dataJson["qssf"]["objectives"].push({"objective":{	"name" : dt[i].name,"objective" : dt[i].objective,"activity" : []} });
		}
		else {
			dataJson["qssf"]["objectives"][i]["objective"]["name"]=dt[i].name;
			dataJson["qssf"]["objectives"][i]["objective"]["objective"]=dt[i].objective;
		}
	}
	//dataJson["qssf"]["objectives"].splice(dt.length,dataJson["qssf"]["objectives"].length-dt.length)
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
	
	//console.log(dataJson["qssf"]["objectives"]);
	//dataJson.places.push()
  },
  minSpareRows: 1
});

var tempdata5=new Array(dataJson["qssf"]["objectives"].length);
for (var i=0, j=dataJson["qssf"]["objectives"].length; i<j;i++){
	tempdata5[i]=new Array(2);
	tempdata5[i][0]=dataJson["qssf"]["objectives"][i]["objective"]["name"];
	tempdata5[i][1]=dataJson["qssf"]["objectives"][i]["objective"]["objective"];
}
var ht = $('#objectiveTable').handsontable('getInstance');
if ($.isArray(tempdata5) && tempdata5[0] && $.isArray(tempdata5[0])){
	ht.populateFromArray (0, 0, tempdata5,tempdata5.length-1, 2);
}


var $container12 = $("#objectiveActivityTable");
$container12.handsontable({
  data: [],
  width: 400,
  height:150,
  dataSchema: {a: null, t: null},
  startRows: 5,
  startCols: 4,
  colHeaders: ['a', 't', ],
  columns: [
    {data: "a"},
	{data: "t"},
  ],
  afterChange: function(changes, source) {
	if(dataJson["qssf"]["objectives"][presentObjectiveNb]){
		var dt = this.getData();
		if (dataJson["qssf"]["objectives"][presentObjectiveNb]["objective"]["activity"]){
			
			for (var i=0, j= dt.length;i<j-1;i++){
				if (dataJson["qssf"]["objectives"][presentObjectiveNb]["objective"]["activity"].length <i+1){
					dataJson["qssf"]["objectives"][presentObjectiveNb]["objective"]["activity"].push({	"a" : dt[i].a,"t" : dt[i].t} );
				}
				else {
					
					dataJson["qssf"]["objectives"][presentObjectiveNb]["objective"]["activity"][i]["a"]=dt[i].a;
					dataJson["qssf"]["objectives"][presentObjectiveNb]["objective"]["activity"][i]["t"]=dt[i].t;
				}
			}
			//console.log(dataJson["qssf"]["objectives"][presentObjectiveNb]["objective"]["activity"]);
		}
		
	}
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//console.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
	
  },
  minSpareRows: 1
});






jsPlumb.ready(function() {
	jsPlumb.connect({
		source:"qssf",
		target:"qssf1",
		anchor:"Left",
		
		connector:[ "Flowchart", { stub:[40, 60], gap:50, cornerRadius:5, alwaysRespectStubs:true } ],
		endpoint:"Blank"
		
	});
	jsPlumb.connect({
		source:"qssf1",
		target:"qssf1.1",
		
		anchor:"Left",
		connector:[ "Flowchart", { stub:[40, 60], gap:15, cornerRadius:5, alwaysRespectStubs:true } ],
		endpoint:"Blank"
	});
	jsPlumb.connect({
		source:"qssf1",
		target:"qssf1.2",
		anchor:"Left",
		connector:[ "Flowchart", { stub:[40, 60], gap:15, cornerRadius:5, alwaysRespectStubs:true } ],
		endpoint:"Blank"
	});
	jsPlumb.connect({
		source:"qssf1",
		target:"qssf2",
		anchor:"Left",
		connector:[ "Flowchart", { stub:[40, 60], gap:50, cornerRadius:5, alwaysRespectStubs:true } ],
		endpoint:"Blank"
	});
	jsPlumb.connect({
		source:"qssf2",
		target:"qssf2.1",
		anchor:"Left",
		connector:[ "Flowchart", { stub:[40, 60], gap:5, cornerRadius:5, alwaysRespectStubs:true } ],
		endpoint:"Blank"
	});
	jsPlumb.connect({
		source:"t",
		target:"t1",
		anchor:"Left",
		connector:[ "Flowchart", { stub:[40, 60], gap:50, cornerRadius:5, alwaysRespectStubs:true } ],
		endpoint:"Blank"
	});
	jsPlumb.connect({
		source:"t1",
		target:"t1.1",
		anchor:"Left",
		connector:[ "Flowchart", { stub:[40, 60], gap:15, cornerRadius:5, alwaysRespectStubs:true } ],
		endpoint:"Blank"
	});
	jsPlumb.connect({
		source:"t",
		target:"t2",
		anchor:"Left",
		connector:[ "Flowchart", { stub:[40, 60], gap:50, cornerRadius:5, alwaysRespectStubs:true } ],
		endpoint:"Blank"
	});
	jsPlumb.connect({
		source:"t",
		target:"t3",
		anchor:"Left",
		connector:[ "Flowchart", { stub:[40, 60], gap:50, cornerRadius:5, alwaysRespectStubs:true } ],
		endpoint:"Blank"
	});
	//jsPlumb.hide("t3");
});


	function selectValue(el){
		var sl = document.getElementById("defaultSlider2")
			var amountScale = 0.1+(0.9*(parseFloat(sl.value)/100));
		if (parseInt(el.value)==0){
			console.log("default layout");
			
			var cnt1=0;
			var cnt2=0;
			var cnt=0;
			var radius=400;
			//var ln1 = scene.children[2].geometry.attributes.size.array.length-5000; 
			//var ln2 = scene.children[4].geometry.attributes.size.array.length-5000; 
			var ln1 = startModelPlaces;
			var ln2 = startModelReactions;
			//console.log(ln1)
			//console.log(startModelPlaces)
			for (var i= 0; i<selectedModelNodes.length;i++){
				if (selectedModelNodes[i][5]==2 ){
					//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]=((Math.random() * 2 - 1) * 400);
					var rm=cnt1*0.008*2*Math.PI;
					//radius=900;
					var rr = ((radius*1.08)-(cnt1*0.2)+1)
					scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (Math.sin(rm) *rr);
					//scene.children[2].geometry.attributes.position.array[(ln2+cnt2)*3+0]= (Math.cos(rm) *rr)+1800;
					scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(Math.cos(rm) *rr)+900;
					cnt1++;
					cnt++;
				}
				else if (selectedModelNodes[i][5]==4 ){
					//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=((Math.random() * 2 - 1) * 400);
					var rm=cnt2*0.008*2*Math.PI;
					//radius=600;
					var rr = ((radius*1.08)-(cnt2*0.2)+1)
					scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(Math.sin(rm) *rr);
					scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]= (Math.cos(rm) *rr)+1800;
					
					cnt2++;
					cnt++;
				}
			}
			//console.log(cnt1)
			//console.log(cnt2)
			
			scene.children[2].geometry.attributes.position.needsUpdate = true;
			scene.children[4].geometry.attributes.position.needsUpdate = true;
			
			var count=0;
			for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
				var t1;
				var t2;
				var pt1;
				var pt2;
				var sim1=1;
				var sim2=1;
				pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
				sim1 = idMap[pt1][0]
				t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
				if (selectedModelEdges[iv-extraLinesCnt][3]==2){
					//console.log("link between model and metabolic nodes")
					
					if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
						pt2=selectedModelEdges[iv-extraLinesCnt][1];
					}
					else{
						pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
					}
					t2 = jsonObj1[pt2][6]
					sim2=2;
				}
				else{
					//console.log("link between model nodes")
					if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
						pt2=selectedModelEdges[iv-extraLinesCnt][1];
					}
					else{
						pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
					}
					t2 = selectedModelNodes[pt2][5];
				}
				if (sim2!=2){
					pt2+=jsonObj1.length;
					//console.log(idMap[pt2]);
				}
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
				startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
				
				count+=1;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
				endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
				
				count+=1;
			}
			scene.children[7].geometry.attributes.position.needsUpdate = true;
			scene.children[7].geometry.attributes.ca.needsUpdate = true;
			
			
			var ii=0;
			for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
			
				scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
				scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
				scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
				ii++;
			}
			//console.log(tokenAttributes.endPosition.value[0]);
			var ii=0;
			for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
				tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
				tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
				ii++;
			}
			//console.log(tokenAttributes.endPosition.value[0]);
			scene.children[8].geometry.verticesNeedUpdate = true;
			tokenAttributes.endPosition.needsUpdate = true;
			tokenUniforms.mixAmount.value = 0.0;
			
			
		}
		else {
			console.log("other layout");
			//console.log(layouts[el.value])
			var layout_nodes_coordinates={};
			for (var i=0, j=layouts[el.value].length;i<j;i++){
				if (layouts[el.value][i]['group']=='nodes'){
					layout_nodes_coordinates[layouts[el.value][i]['data']['id']]=[layouts[el.value][i]['position']['x'],layouts[el.value][i]['position']['y'] ]
				}
			}
			//console.log(selectedModelNodes);
			var cnt1=0;
			var cnt2=0;
			var ln1 = startModelPlaces;
			var ln2 = startModelReactions;
			for (var i=0, j=selectedModelNodes.length;i<j;i++){
				if (selectedModelNodes[i][5]==2 ){
						
						if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
							scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
							scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
							//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=50;
							//console.log(scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1])
						}
						cnt1++;
				}
				if (selectedModelNodes[i][5]==4 ){
						
						if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
							scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
							scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
							//console.log(scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1])
						}
						cnt2++;
				}
				
			}
			scene.children[2].geometry.attributes.position.needsUpdate = true;
			scene.children[4].geometry.attributes.position.needsUpdate = true;
			
			var count=0;
			for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
				var t1;
				var t2;
				var pt1;
				var pt2;
				var sim1=1;
				var sim2=1;
				pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
				sim1 = idMap[pt1][0]
				t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
				if (selectedModelEdges[iv-extraLinesCnt][3]==2){
					//console.log("link between model and metabolic nodes")
					
					if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
						pt2=selectedModelEdges[iv-extraLinesCnt][1];
					}
					else{
						pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
					}
					t2 = jsonObj1[pt2][6]
					sim2=2;
				}
				else{
					//console.log("link between model nodes")
					if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
						pt2=selectedModelEdges[iv-extraLinesCnt][1];
					}
					else{
						pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
					}
					t2 = selectedModelNodes[pt2][5];
				}
				if (sim2!=2){
					pt2+=jsonObj1.length;
					//console.log(idMap[pt2]);
				}
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
				startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
				
				count+=1;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
				endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
				
				count+=1;
			}
			scene.children[7].geometry.attributes.position.needsUpdate = true;
			scene.children[7].geometry.attributes.ca.needsUpdate = true;
			
			
			var ii=0;
			for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
			
				scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
				scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
				scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
				ii++;
			}
			//console.log(tokenAttributes.endPosition.value[0]);
			var ii=0;
			for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
				tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
				tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
				ii++;
			}
			//console.log(tokenAttributes.endPosition.value[0]);
			scene.children[8].geometry.verticesNeedUpdate = true;
			tokenAttributes.endPosition.needsUpdate = true;
			tokenUniforms.mixAmount.value = 0.0;
			
			
			//for (elem in layout_nodes_coordinates){
			//	if (layout_nodes_coordinates.hasOwnProperty(elem)){
					//layout_nodes_coordinates[elem]
			//	}
			//}
			
			//console.log(layout_nodes_coordinates);
			
		}
	}
	
	function updateSlider2(slideAmount){
			var el = document.getElementById("selectLayout")
			var amountScale = 0.1+(0.9*(parseFloat(slideAmount)/100));
			if (parseInt(el.value)==0){
				console.log("default layout");
			}
			else {
				console.log("other layout");
				//console.log(layouts[el.value])
				var layout_nodes_coordinates={};
				for (var i=0, j=layouts[el.value].length;i<j;i++){
					if (layouts[el.value][i]['group']=='nodes'){
						layout_nodes_coordinates[layouts[el.value][i]['data']['id']]=[layouts[el.value][i]['position']['x'],layouts[el.value][i]['position']['y'] ]
					}
				}
				//console.log(selectedModelNodes);
				var cnt1=0;
				var cnt2=0;
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				for (var i=0, j=selectedModelNodes.length;i<j;i++){
					if (selectedModelNodes[i][5]==2 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
							}
							cnt1++;
					}
					if (selectedModelNodes[i][5]==4 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
							}
							cnt2++;
					}
					
				}
				scene.children[2].geometry.attributes.position.needsUpdate = true;
				scene.children[4].geometry.attributes.position.needsUpdate = true;
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				tokenUniforms.mixAmount.value = 0.0;
				
				
				//for (elem in layout_nodes_coordinates){
				//	if (layout_nodes_coordinates.hasOwnProperty(elem)){
						//layout_nodes_coordinates[elem]
				//	}
				//}
				
				//console.log(layout_nodes_coordinates);
				
			}	
		}
		
		function updateSlider3(slideAmount){
			var el = document.getElementById("selectLayout");
			var el2= document.getElementById("defaultSlider2");
			var amountScale = 0.1+(0.9*(parseFloat(el2.value)/100));
			var distance = (parseFloat(slideAmount)/100)*200
			
			if (parseInt(el.value)==0){
				console.log("default layout");
			}
			else {
				console.log("other layout");
				//console.log(layouts[el.value])
				var layout_nodes_coordinates={};
				for (var i=0, j=layouts[el.value].length;i<j;i++){
					if (layouts[el.value][i]['group']=='nodes'){
						layout_nodes_coordinates[layouts[el.value][i]['data']['id']]=[layouts[el.value][i]['position']['x'],layouts[el.value][i]['position']['y'] ]
					}
				}
				//console.log(selectedModelNodes);
				var cnt1=0;
				var cnt2=0;
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				for (var i=0, j=selectedModelNodes.length;i<j;i++){
					if (selectedModelNodes[i][5]==2 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
								//console.log(scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1])//=50;
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=200;
							}
							cnt1++;
					}
					if (selectedModelNodes[i][5]==4 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=50;
								//console.log(scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1])//=50;
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1]=200-distance;
							}
							cnt2++;
					}
					
				}
				scene.children[2].geometry.attributes.position.needsUpdate = true;
				scene.children[4].geometry.attributes.position.needsUpdate = true;
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				tokenUniforms.mixAmount.value = 0.0;
				
				
				//for (elem in layout_nodes_coordinates){
				//	if (layout_nodes_coordinates.hasOwnProperty(elem)){
						//layout_nodes_coordinates[elem]
				//	}
				//}
				
				//console.log(layout_nodes_coordinates);
				
			}	
		}

	$("#qsspn-model-edit-form0").css({top:  $("#modelSpreadSheet").position().top -750, width:$("#container").width()/2});	
	
	</script>	
	
	
	
	
