<div class='container'>
<br><br>
	<h1>QSSPN Model </h1>
	<hr>
	<h2>Name: <%= qm.name %> </h2><a href="/qsspn_model/edit/<%= qm.id %>" class="btn btn-sm btn-primary">QSSPN Model Editor</a>
	<a href="/qsspn_model_layout/new" class="btn btn-sm btn-primary">Add new Layout</a>
	<a href="/qsspn_model_layout/index" class="btn btn-sm btn-success">Edit/View Layouts</a>
	<hr>
	<h2>creator: <%= qm.owner %></h2>
	
	<hr>
	<h2>Comment: </h2>
	<%= qm.comment %>
	<h2>Metabolic network: </h2>
	<%= qm.metabolic_net %>
	<% if (session.User.name==qm.owner) {%>
	<hr>
	<a href="/qsspn_model/editusers/<%=qm.id%>" class="btn btn-sm btn-success">Edit/View list of users privileges</a>
	<%}%>
	<%var data=[];
	_.each(mtb.file, function(compartment) {
		data.push(compartment);
	});
	%>
	<hr>
	<h2>users:</h2>
	<table class='table table-bordered table-condensed'>
		<tr>
			<th>Name</th>
			<th>Users</th>
		</tr>
	<%	_.each(qm.users_read, function(err,usr) {%>
		<tr> <td><%=qm.users_read[usr]%></td> <td>read-only</td> </tr>
	<%
		});
		%>
		<%	_.each(qm.users_edit, function(err,usr) {%>
		<tr> <td><%=qm.users_edit[usr]%></td> <td>editor</td> </tr>
	<%
		});
		%>
	</table>
	
	<hr>
	
	
	<nav>
		<a href="" id="menuToggle" title="show menu">
		<span class="navClosed"><i>show menu</i></span>
		</a>
		<a href="#" title="Item 1">Hide/Show</a>
		<button class="btn btn-default btn-xs" title="Make metabolic network lines invisible/visible" id="view4" style="position: relative;left: 20px;">Lines</button>
		<button class="btn btn-default btn-xs" title="Hide/show tokens (if problem, just refresh the page)" id="view5" style="position: relative;left: 20px;">Token</button>
		<br><p style="position: relative;left: 20px;color:white">Line Opacity: <input id="defaultSlider" type="range" min="0" max="100" value="25" onchange="updateSlider(this.value)" style="position: relative;left: 20px"/></p>
		
		
		<a href="#" title="Item 2">Metabolic Layout</a>
			<form action="/qsspn_model/show/<%= qm.id %>" id="layout-select-form" method="POST" style="position: relative;left: 0px;width:250px"><p style="position: relative;left: 20px;color:white">Choose Layout: 
			<input type="text" name="mtnl-id" id ="mtnl-id" style="visibility: hidden;" value=""/>
			<input type="text" name="qml-id" id ="qml-id" style="visibility: hidden;" value=""/>
			<select name="metabolic_net_layouts" id="layout-selector" onchange="selectMTNLayout(this)" style="position: relative;left: 0px;width:120px;color:black">
					<option value="">None</option>
					<% _.each(mtnls, function(mtnl) {%>
					   <option value=<%=mtnl[0]%>><%=mtnl[1]%></option>
					<% }) %>
				</select>
				
			</p>
		<a href="#" title="Item 3">Model Layout</a>
			<p style="position: relative;left: 20px;color:white">Choose Layout: <br><select name="select" id="selectLayout" onchange="selectValue(this)" style="position: relative;left: 0px;color:black;width:120px">
			  <option value="0" selected>Default</option> 
			</select><input type="submit" value="Select Layout:" class="btn btn-sm btn-success" style="position: relative;left: 20px;width:100px"/>
				<input type="hidden" name="_csrf" value="<%= _csrf %>" />
			</form>
			<br> <p style="color:white;position: relative;left: 20px;" />Select sub-graph from layout: <select name="select" id="selectsublayout" onchange="selectsublayout(this)" style="position: relative;left: 0px;color:black;width:120px"> 
			<option value="" selected>None</option>
			</select>
			<br> <p style="color:white"/>Scale: <input id="defaultSlider2" type="range" min="0" max="100" value="25" onchange="updateSlider2(this.value)" style="position: relative;left: 20px"/>
			<br> Separation between transition/places: <input id="defaultSlider3" type="range" min="0" max="100" value="25" onchange="updateSlider3(this.value)" style="position: relative;left: 20px"/>
			
			<br> Slide up/down (horizontal plane): <input id="defaultSlider4" type="range" min="-2000" max="2000" value="0" onchange="updateSlider4(this.value)" style="position: relative;left: 20px"/>
			<br> Slide Left/Right: <input id="defaultSlider5" type="range" min="-2000" max="2000" value="0" onchange="updateSlider5(this.value)" style="position: relative;left: 20px"/>
			<br> Slide up/down: <input id="defaultSlider4" type="range" min="-1000" max="1000" value="0" onchange="updateSlider6(this.value)" style="position: relative;left: 20px"/>
			</p>
	</nav>
	
	<div id="menu" >
	
	
	</div>
	
	
	<div id="container"  style="position: absolute;left: 0px; overflow: inherit">  </div>
	<!--<div id="container"  style="position: absolute;left: 0.5%; overflow: inherit">  </div>-->
	<div id="advert" ></div>
	<div id="dataTable0" style="position: absolute; " align="center">
	<table id="list0"></table>
	</div>
	<div id="dataTable" style="position: absolute; " align="center">
	<table id="list4"></table>
	</div>
	
	<div id="mytooltip"></div>
	
	<div id="modelSpreadSheet" style="position: absolute;left:15%;height:5000px" ><h2>Model data</h2>
	<br><b>Places List:</b><div id="placesTable"></div>
	<br>
	<b id="t">Transitions List:</b><div id="transitionsTable"></div>
	<br><b id="t1">Pre-places List:</b><div id="prePlacesTable"></div>
	<br><b id="t1.1">Activity Table:</b><div id="activityTable"></div>
	<br><b id="t2">Consumed List:</b><div id="consumedTable"></div>
	<br><b id="t3">Post-places List:</b><div id="postPlacesTable"></div>
	<br>	
	<b id="qssf" >QSS-Fluxes:</b><div id="qssfTable"></div>			
	<br><b id="qssf1">Constraints List:</b><div id="constraintsTable"></div>	
	<br><b id="qssf1.1">Activity Table:</b><div id="constraintsActivityTable" ></div>	
	<br><b id="qssf1.2">Flux List:</b><div id="fluxListActivityTable" ></div>
	<br><b id="qssf2">Objective List:</b><div id="objectiveTable"></div>
	<br><b id="qssf2.1">Activity Table:</b><div id="objectiveActivityTable"></div>
	
	<h2>SFBA data</h2>
	<div id="sfbaTable"></div>
	<br>Hive plot data: reactions and associated categories<br><div id="reactionCategoryTable"></div>
	<br>
	<div id="democ0" style="position: absolute;left: 0px; overflow: inherit" class="myborderclass2"></div>
	<div id="mytooltip3"></div>
	<div id="hivePlot" style="position: absolute;left: 0px; overflow: inherit" class="myborderclass2 Scrollable"></div>
	<div id="mytooltip4"></div>
	<button type="button" id="hiveplotColor" style="position: absolute;left: 0px; overflow: inherit" onclick="hiveplotAction()">White/Black Background</button>
	</div>
	<form action="/qsspn_model/update/<%= qm.id %>" id="qsspn-model-edit-form0" method="POST" class="form-inline" style="height: 80px;width: 200px;position: relative;">	
	<%
		//var InputdataJson=JSON.stringify({"places" : [], "qssf" : { "constraints" : [], "externality_tag" :null,"objectives" : []}, "transitions" : []});
		var InputdataSfba=JSON.stringify([]);
	%>
	<input type="text" name="mySpreadsheet0" id ="mySpreadsheet0" style="visibility: hidden;" value="">
	<input type="text"  name="mySpreadsheet1" id ="mySpreadsheet1" style="visibility: hidden;" value="">
	<input type="text"  name="mySpreadsheet2" id ="mySpreadsheet2" style="visibility: hidden;" value="">
	<input type="text"  name="mySpreadsheet3" id ="mySpreadsheet3" style="visibility: hidden;" value="">
	<input type="text"  name="mySpreadsheet4" id ="mySpreadsheet4" style="visibility: hidden;" value="">
	<input type="text"  name="mySpreadsheet5" id ="mySpreadsheet5" style="visibility: hidden;" value="">
	<input type="text"  name="mySpreadsheet6" id ="mySpreadsheet6" style="visibility: hidden;" value="">
	<input type="text"  name="mySpreadsheet7" id ="mySpreadsheet7" style="visibility: hidden;" value="">
	<input type="text"  name="mySpreadsheet8" id ="mySpreadsheet8" style="visibility: hidden;" value="">
	<input type="text"  name="mySpreadsheet9" id ="mySpreadsheet9" style="visibility: hidden;" value="">
	<input type="text"  name="mySfbaSpreadsheet0" id ="mySfbaSpreadsheet0" style="visibility: hidden;" value=<%=InputdataSfba%>>
	<input type="text"  name="mySfbaSpreadsheet1" id ="mySfbaSpreadsheet1" style="visibility: hidden;" value="">
	<input type="text"  name="mySfbaSpreadsheet2" id ="mySfbaSpreadsheet2" style="visibility: hidden;" value="">
	<input type="text"  name="mySfbaSpreadsheet3" id ="mySfbaSpreadsheet3" style="visibility: hidden;" value="">
	<input type="text"  name="mySfbaSpreadsheet4" id ="mySfbaSpreadsheet4" style="visibility: hidden;" value="">
	<input type="text"  name="mySfbaSpreadsheet5" id ="mySfbaSpreadsheet5" style="visibility: hidden;" value="">
	<input type="text"  name="mySfbaSpreadsheet6" id ="mySfbaSpreadsheet6" style="visibility: hidden;" value="">
	<input type="text"  name="mySfbaSpreadsheet7" id ="mySfbaSpreadsheet7" style="visibility: hidden;" value="">
	<input type="text"  name="mySfbaSpreadsheet8" id ="mySfbaSpreadsheet8" style="visibility: hidden;" value="">
	<input type="text"  name="mySfbaSpreadsheet9" id ="mySfbaSpreadsheet9" style="visibility: hidden;" value="">
	<input type="hidden" name="_csrf" value="<%= _csrf %>" />
	<input type="submit" value="Update Edited Data" class="btn btn-primary btn-block" id ="confirm" />
</form>		
</div>	

	<script type="x-shader/x-vertex" id="vertexshaderP1">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP1">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP2">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP2">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP3">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP3">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP4">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP4">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		
		<script type="x-shader/x-vertex" id="vertexshaderP5">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP5">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP6">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP6">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP7">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP7">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshader2">

			//uniform float amplitude;
			//attribute vec3 displacement;
			attribute vec3 ca;
			varying vec3 vColor;
			varying float opacity;
			attribute float op;
			void main() {
				//vec3 newPosition = position + amplitude * displacement;
				vColor = ca;
				opacity =op;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
			//uniform float amplitude;
			//attribute vec3 displacement;
			//attribute vec3 ca;
			//varying vec3 vColor;
			//void main() {
			//	vec3 newPosition = position + amplitude * displacement;
			//	vColor = ca;
			//	gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
			//}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader2">
			uniform vec3 color;
			varying float opacity;
			varying vec3 vColor;
			void main() {

				gl_FragColor = vec4( vColor * color, opacity );

			}
			//uniform vec3 color;
			//uniform float opacity;
			//varying vec3 vColor;
			//void main() {

			//	gl_FragColor = vec4( vColor * color, opacity );

			//}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshader3">

			attribute float size;
			attribute vec3 ca;
			uniform float mixAmount;
			attribute vec3 endPosition;
			varying vec3 vColor;

			void main() {

				vColor = ca;
				vec3 newPosition = mix( position, endPosition, mixAmount );
				vec4 mvPosition = modelViewMatrix * vec4( newPosition, 1.0 );

				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader3">

			uniform vec3 color;
			uniform sampler2D texture;

			varying vec3 vColor;

			void main() {

				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );

			}

		</script>
	
	<script>
		
		$('.Scrollable').on('DOMMouseScroll mousewheel', function(ev) {
			var $this = $(this),
				scrollTop = this.scrollTop,
				scrollHeight = this.scrollHeight,
				height = $this.height(),
				delta = (ev.type == 'DOMMouseScroll' ?
					ev.originalEvent.detail * -40 :
					ev.originalEvent.wheelDelta),
				up = delta > 0;

			var prevent = function() {
				ev.stopPropagation();
				ev.preventDefault();
				ev.returnValue = false;
				return false;
			}

			if (!up && -delta > scrollHeight - height - scrollTop) {
				// Scrolling down, but this will take us past the bottom.
				$this.scrollTop(scrollHeight);
				return prevent();
			} else if (up && delta > scrollTop) {
				// Scrolling up, but this will take us past the top.
				$this.scrollTop(0);
				return prevent();
			}
		});
		
		(function($){
			$(document).ready(function(){
			$('#menuToggle').click(function(e){
			var $parent = $(this).parent('nav');
			$parent.toggleClass("open");
			var navState = $parent.hasClass('open') ? "hide" : "show";
			$(this).attr("title", navState + " navigation");
			// Set the timeout to the animation length in the CSS.
			setTimeout(function(){
			console.log("timeout set");
			$('#menuToggle > span').toggleClass("navClosed").toggleClass("navOpen");
			}, 200);
			e.preventDefault();
			});
			});
			})(jQuery);
		
		var cbColModel, idsOfSelectedRows = [];
		var idsOfModelSelectedRows=[];
		var categoriesReactions={};
		var reactionsCategories={};
		var sfbaReacM={};
		var nodes =[];
		
		var links = [];
		
		var hvBColor=true;
		//var list_compartments=<%-JSON.stringify(data[0])%>;
		//var list_nodes=<%-JSON.stringify(data[1])%>;
		//var list_edges=<%-JSON.stringify(data[2])%>;
		//console.log(list_compartments);
		//console.log(list_nodes);
		//console.log(list_edges);
		
		var layouts = <%-JSON.stringify(mtnls)%>
		var mtnl = <%-JSON.stringify(mtnl)%>
		if (mtnl.hasOwnProperty("id")){
			document.getElementById("layout-selector").value=mtnl.id;
			//console.log(mtnl.id)
		}
		
		var qmlayouts = <%-JSON.stringify(qmls)%>
		var mqml = <%-JSON.stringify(mqml)%>
		if (mqml.hasOwnProperty("id")){
			document.getElementById("selectLayout").value=mqml.id;
			//console.log(mtnl.id)
		}
		//console.log(qmlayouts)
		//console.log(mqml)
		var mtnlLayout=mtnl.layout;
		var generalLayout ={'merged':{},'above':{},'outer':{},'satellite':{},'in':{}};
		var objects = [];
		var spacing=1650;
		var radiusComp=550;
		var yStartDisplacement=100;
		//var yStartDisplacement=400;
		var nodeSize=5;
		var lineOpacity=0.1;
		
		if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
		
		var renderer, renderer2, scene,scene2,  camera, stats, controls, camera2,pip;
		var element1;
		var PointCloud1, uniforms, attributes;
		var mouse = new THREE.Vector2(), INTERSECTED;
		var projector;
		//var vc1;
		var camTween;
		var mtween=false;
		var animatorT1;
		
		var allFalse= true;
		var simModeValue=0;
		var simFlowChart=0;
		var cntLabels=0;
		
		var WIDTH = window.innerWidth;
		var HEIGHT = window.innerHeight;
		var geometry;
		var bgeometryP1;
		var bgeometryP2;
		var bgeometryP3;
		var bgeometryP4;
		var bgeometryP5;
		var bgeometryP6;
		var bgeometryP7;
		
		var bgeometry2;
		var tokenGeometry;
		var tvertices ;
		var tvalues_size ;
		var tvalues_color ;
		var tvalues_p ;
		
		var geometryKegg;
		var keggSegment = 1000;
		var keggSegmentPts = keggSegment*2;
		var keggPositions;
		var keggColors;
		var listChangingKeggCoordinates=[];
		var previousKeggLength=0;
		var cubesGeometry=[];
		var keggCubesProperties={};
		var noKeggCube=true;
		
		var simTimer=0;
		var reactionIsDone=false;
		var listReactionsDone=[]
		//var simTimerPrevious=0;
		var simEnd=0;
		var simulationIsOn=false;
		var simulationIsPaused=false;
		var simRow=[];
		var simDataTime={};
		
		//var scaleExplosion=3000;
		//var nbCompartments=8;
		//var nbOrganelles=nbCompartments-3;
		//var organelles=[];
		//var oldNbOrganelles=nbOrganelles;
		//var	oldNbCompartments=nbCompartments;
		//var nucleus;
		//var cytoplasm;
		//var ECM ;
		var arraymaterial=[];
		//var onCompartments=[];
		//for (var i=0;i<nbCompartments;i++){
		//	onCompartments[i]=false;
		//}
		//var draggingCompartments=[];
		//for (var i=0;i<nbCompartments;i++){
		//	draggingCompartments[i]=false;
		//}
		
		var particleClass = {
					0: "DNA",
					1: "RNA",
					2: "Protein",
					3: "Degradation Product",
					4: "Standard Petri Net",
					5: "Logical Transition",
					6: "Coarse Transition"
					};
		
		var particles;
		
		
		var arrows =[];
		
		
		var b1values_size;
		var b1positions;
		var b1values_color;
		var b1values_compartment;
		var particle1ShaderMaterial ;
		
		var b2values_size;
		var b2positions;
		var b2values_color;
		var b2values_compartment;
		var particle2ShaderMaterial ;
		
		var b3values_size;
		var b3positions;
		var b3values_color;
		var b3values_compartment;
		var particle3ShaderMaterial ;
		
		var b4values_size;
		var b4positions;
		var b4values_color;
		var b4values_compartment;
		var particle4ShaderMaterial ;
		
		var b5values_size;
		var b5positions;
		var b5values_color;
		var b5values_compartment;
		var particle5ShaderMaterial ;
		
		var b6values_size;
		var b6positions;
		var b6values_color;
		var b6values_compartment;
		var particle6ShaderMaterial ;
		
		var b7values_size;
		var b7positions;
		var b7values_color;
		var b7values_compartment;
		var particle7ShaderMaterial ;
		var linesShaderMaterial;
		var tokenShaderMaterial;
		var marker=0;
		var sprite;
		
		var b2lpositions;
		var b2lcolors ;
		var b2lcompartments;
		var b2lopacity;
		// 
		var cssScene;
		var rendererCSS;
		var cssObjects=[];
		
		var cssScene2;
		var rendererCSS2;
		var cssObjects2=[];
		
		var cssScene3;
		var rendererCSS3;
		var cssObjects3=[];
		// 
		var flagPick=0;
		
			
		var outlineMaterial1;
		var outlineMesh1;
		var lineGeometry;
		var mesh;
		var tokenPS;
		// clock to animate particles
		var clock = new THREE.Clock();
		
		var parameters;
		var gui;
		
		var isOnParticle=0;
		var isOnLine=0;
		var keyboard = new KeyboardState();
		var goUp=false;
		var goDown=false;
		var goLeft=false;
		var goRight=false;
		var zoomIn=false;
		var zoomOut=false;
		var closest;
		var closestLine;
		var closestid;
		var closestType=-1;
		var hoveredType=-1;
		var sizeParticleGuiElem;
		var colorParticleGuiElem;
		var colorParticleGui = new THREE.Color( 0xffffff );
		
		var stopThreeJsMouseEvent=false;
		var spreadsheet1Visible=false
		
		var updatedListModels=false;
		var updatedModel=false;
		var resetSpreadsheet=false;
		var modelData;
		var simData;
		var simDataBounds=[];
		
		var stackTokenModel=[];
		startPositionTokenMap={};
		endPositionTokenMap={};
		
		function cameraGoTo(position, target) {
						TWEEN.removeAll();
						new TWEEN.Tween( camera.position ).delay(300)
						.to( { x: position.x, y: position.y, z: position.z }, 300 )
						.start();
						new TWEEN.Tween( controls.target )
						.to( { x: target.x, y: target.y, z: target.z }, 300 )
						.start();
						
					}
		var timerElement=document.getElementById("timer");
		var sliderElement=document.getElementById("slider");
		var listModels;
		
		
		var modelVisible=false;
		var selectedModel;
		var selectedMetabolicData;
		//var 
		//default metabolic network file is: recon2.v02.xml_metabolic_net
		//xhttp.open("GET","recon2.v02.xml_metabolic_net2.json",false);
		//xhttp.send();
		selectedMetabolicData = <%-JSON.stringify(data)%>
		console.log("getting metabolic data from default file recon2");
		// set list of edges and nodes from default metabolic data
		var metabolicEdges;
		var metabolicNodes;
		var metabolicCompartments;
		
		//metabolicCompartments = selectedMetabolicData[0];
		//nbCompartments=metabolicCompartments.length
		
		// part where compartment data come from layout
		var listCompartments=[];
	
		if (!mtnlLayout){
			listCompartments=selectedMetabolicData[0];
			mtnlLayout={"list_compartments":[],"compartments_layout":{}, "nodes_layout":{},"nodes_compartments":{}};
		}
		else {
			if (mtnlLayout["list_compartments"] && mtnlLayout["list_compartments"].length==0){
				listCompartments=selectedMetabolicData[0];
			}
			else if (mtnlLayout["list_compartments"] && mtnlLayout["list_compartments"].length>0){
				listCompartments=mtnlLayout["list_compartments"];
				//console.log("initial existing list of compartments")
			}
		}
		mtnlLayout["list_compartments"]=listCompartments;
		
		//console.log(listCompartments)
		var nbCompartments=listCompartments.length
		var compIds=[];
		for (var i=0; i<listCompartments.length;i++){
			compIds.push(listCompartments[i][0]);
		}
		
		// change compartment nodes attribution from data
		if (mtnlLayout["nodes_compartments"]){
			var listChangedNodes = Object.keys(mtnlLayout["nodes_compartments"]);
			if (listChangedNodes.length>0){
			
				for(var i=0, ii= listChangedNodes.length;i<ii;i++){			
					//console.log(selectedMetabolicData[1][listChangedNodes[i]])
					selectedMetabolicData[1][listChangedNodes[i]][1]=mtnlLayout["nodes_compartments"][listChangedNodes[i]][0];
					selectedMetabolicData[1][listChangedNodes[i]][3]=mtnlLayout["nodes_compartments"][listChangedNodes[i]][1];
					//console.log(selectedMetabolicData[1][listChangedNodes[i]])
				}
			}
			
		}
		
		metabolicCompartments = listCompartments;
		nbCompartments=listCompartments.length
		
		var nameModel=<%- JSON.stringify(mtb.name) %>;
		
		var txtComp=[]
		var maxNbComp=20;
		
		
		var nameComp=[];
		var mapComp = {'-1':-1};
		
		for (var i=0;i<listCompartments.length;i++){
			mapComp[listCompartments[i][0]]=i;
			nameComp.push(listCompartments[i][1]);
		}
		
		metabolicNodes = selectedMetabolicData[1];
		metabolicEdges = selectedMetabolicData[2];
		
		var jsonObj1=metabolicNodes
		var jsonObj2=metabolicEdges
		//console.log(jsonObj1);
		//console.log(jsonObj2);
		
		// extract number of qsspn typed icons from lists of nodes...
		var mnbDNA=0;
		var mnbRNA=0;
		var mnbProt=0;
		var mnbDegProd=0;
		var mnbPN=0;
		var mnbLog=0;
		var mnbCoarse=0;
		
		var nbPlacesModel=0;
		var nbReactionsModel=0;
		var nbEdgesModel=0;
		/*for (var i = 0, ii= jsonObj1.length;i<ii;i++){
			if (jsonObj1[i]['typeQSSPN']==0){
				mnbDNA++;
			}
			if (jsonObj1[i]['typeQSSPN']==1){
				mnbRNA++;
			}
			if (jsonObj1[i]['typeQSSPN']==2){
				mnbProt++;
			}
			if (jsonObj1[i]['typeQSSPN']==3){
				mnbDegProd++;
			}
			if (jsonObj1[i]['typeQSSPN']==4){
				mnbPN++;
			}
			if (jsonObj1[i]['typeQSSPN']==5){
				mnbLog++;
			}
			if (jsonObj1[i]['typeQSSPN']==6){
				mnbCoarse++;
			}
			
			
		}*/
		for (var i = 0, ii= jsonObj1.length;i<ii;i++){
			if (jsonObj1[i][6]==0){
				mnbDNA++;
			}
			if (jsonObj1[i][6]==1){
				mnbRNA++;
			}
			if (jsonObj1[i][6]==2){
				mnbProt++;
			}
			if (jsonObj1[i][6]==3){
				mnbDegProd++;
			}
			if (jsonObj1[i][6]==4){
				mnbPN++;
			}
			if (jsonObj1[i][6]==5){
				mnbLog++;
			}
			if (jsonObj1[i][6]==6){
				mnbCoarse++;
			}
		}
		var selectedModelEdges;
		var selectedModelNodes;
		
		
		//console.log(mnbDNA);
		//console.log(mnbRNA);
		//console.log(mnbProt);
		//console.log(mnbDegProd);
		//console.log(mnbPN);
		//console.log(mnbLog);
		//console.log(mnbCoarse);
		var nbDNAParticles=mnbDNA; // nb of DNA elements
		var nbRNAParticles=mnbRNA; // nb of RNA elements
		var nbProtParticles=mnbProt+10000; // nb of proteins
		var nbDegradParticles=mnbDegProd; // nb of degradation products
		var nbPNParticles=mnbPN+10000; // nb of PN standard places
		var nbLogParticles=mnbLog; // nb of logical PN places
		var nbCoarseParticles=mnbCoarse; // nb of PN coarse transitions
		var maxNbTokenModel=20000;
		var idMap=[];
		var typesMap=[];
		for (var i=0;i<7;i++){
			typesMap[i]=[];
		};
		var reactionMap=[];
		
		var segments =jsonObj2.length;
		//var segments =0;
		var segmentPts =segments*2;
		
		
		var geometryLineChart;
		var chartSegment = 6000;
		var chartSegmentPts = chartSegment*2;
		var chartPositions ;
		var chartColors ;
		var meshLineChart ;
		
		
		//$.get( "slickgrid7.html", function( data ) {
  //alert( "Data Loaded: " + data );
//});
		
		var mselectedList=[];
		// element for spreadsheet selection
		spritesSelected=[];
		nbSpritesSelected=50;
		var modelspritesSelected=[];
		var modelnbSpritesSelected=50;
		
		var modelReactionLocators=[];
		var modelProductLocators=[];
		var modelReactantLocators=[];
		var modelModifierLocators=[];
		
		var nbModelReactionLocators=50;
		var nbModelPlanesFlow=500;
		var planeMesh=[];
		var stackModel2PlaneMesh=[];
		var flowsStack=[];
		var selectedNodesPaths=[];
		var selectedModelNodesPaths=[];
		var selectedLinesPaths=[];
		var selectedModelLinesPaths=[];
		var toggledLines=0
		var toggledToken=0
		var linesMap=[]
		var selectedLinesPathsIds=[];
		var extraLinesCnt=0;
		var startModelPlaces=0;
		var startModelReactions=0;
		var endModelPlaces=0;
		var endModelReactions=0;
		var myLink =[]
		var myLinkName=[]
		for (var ln =0;ln<10;ln++){
			myLink[ln]=""
			myLinkName[ln]=""
		}
		
		var tokenFlux=[];
		var tokenBounds=[];
		var indexDisabledToken=[];
		
		var tokenStackCount=0;
		var clearedTokenIndex=[]
		
		//var anim = document.getElementById("animload");
		//anim.style.visibility="hidden";
		
		
		
		//var announcementText= document.createElement('div');
		var announcementText= document.getElementById("advert");
		announcementText.style.position = 'absolute';
		
		announcementText.style.width = 100;
		announcementText.style.height = 100;
		//announcementText.setAttribute('animation', 'fadeOut');
		
		announcementText.style.color = "white";
		announcementText.style.textAlign="left";
		announcementText.style.border="3px solid";
		announcementText.style.font="italic bold 20px arial";
		announcementText.style.padding="5px";
		announcementText.style.background="#33AA33";
		//announcementText.style.cssText = 'border: 3px solid #FFF;border-radius: 5px;color: #FFF;font-family: arial;';
		//text0.style.backgroundColor = "#FFFFCC";
		//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
		announcementText.innerHTML = '<p>hello </p>';
		
		announcementText.style.top = 2000 + 'px';
		announcementText.style.left = 2000 + 'px';
		document.body.appendChild(announcementText);
		
		
		var text0 = document.createElement('div');
		text0.style.position = 'absolute';
		text0.style.width = 100;
		text0.style.height = 100;
		text0.style.color = "white";
		text0.style.textAlign="left";
		//text0.style.backgroundColor = "#FFFFCC";
		//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
		text0.innerHTML = 'hello ';
		text0.style.top = 2000 + 'px';
		text0.style.left = 2000 + 'px';
		document.body.appendChild(text0);
		
		var text1 = document.createElement('div');
		text1.style.position = 'absolute';
		text1.style.width = 100;
		text1.style.height = 100;
		text1.style.color = "black";
		text1.style.backgroundColor = "#FFFFCC";
		//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
		text1.innerHTML = 'hello ';
		text1.style.top = 2000 + 'px';
		text1.style.left = 2000 + 'px';
		//text1.style.zIndex = -1;
		document.body.appendChild(text1);
		
		var textk = document.createElement('div');
		textk.style.position = 'absolute';
		textk.style.width = 100;
		textk.style.height = 100;
		textk.style.color = "black";
		textk.style.backgroundColor = "#FFFFCC";
		//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
		textk.innerHTML = 'hello ';
		textk.style.top = 2000 + 'px';
		textk.style.left = 2000 + 'px';
		document.body.appendChild(textk);
		var textkPreviousPos= new THREE.Vector3( 2000, 2000, 1 );
		
		var text1PreviousPos= new THREE.Vector3( 2000, 2000, 1 );
		var text1PreviousString="";
		
		var listGenes = document.createElement('div');
		listGenes.id="listGenes";
		var listGenesTitle = document.createElement('div');
		listGenesTitle.innerHTML="Expressed by gene(s):";
		listGenesTitle.style.textAlign="left";
		var listGenesContent = document.createElement('div');
		listGenesContent.className="scroll-box";
		listGenes.style.color = "white";
		listGenesContent.style.color = "white";
		listGenesContent.innerHTML = '<ul style="margin-left:0em;padding-left:1.3em;height:50px;"><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li></ul>';
		listGenes.style.position = 'absolute';
		listGenes.style.top = 2000 + 'px';
		listGenes.style.left = 2000 + 'px';
		listGenes.appendChild(listGenesTitle);
		listGenes.appendChild(listGenesContent);
		document.body.appendChild(listGenes);
		
		var listLinks = document.createElement('div');
		listLinks.id="listLinks";
		var listLinksTitle = document.createElement('div');
		listLinksTitle.innerHTML="Connectivity:";
		listLinksTitle.style.color = "white";
		listLinksTitle.style.textAlign="left";
		var listLinksContent = document.createElement('div');
		listLinksContent.className="scroll-box";
		
		listLinksContent.style.color = "white";
		listLinksContent.innerHTML = '<ul style="margin-left:0em;padding-left:1.3em;height:150px;"><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li><li >A</li></ul>';
		listLinks.style.position = 'absolute';
		listLinks.style.top = 2000 + 'px';
		listLinks.style.left = 2000 + 'px';
		listLinks.appendChild(listLinksTitle);
		listLinks.appendChild(listLinksContent);
		document.body.appendChild(listLinks);
		
		var txtComp=[]
		for (var i=0;i<maxNbComp;i++){
			txtComp[i] = document.createElement('div');
			txtComp[i].style.position = 'absolute';
			txtComp[i].style.width = 100;
			txtComp[i].style.height = 100;
			txtComp[i].style.color = "black";
			txtComp[i].style.fontSize="xx-small";
			txtComp[i].id = "txt"+i;
			//txtComp[i].style.fontWeight="1900";
			txtComp[i].style.backgroundColor = "#99FFCC";
			txtComp[i].style.opacity = 0.5;
			//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
			txtComp[i].innerHTML = '';
			txtComp[i].style.top = 2000 + 'px';
			txtComp[i].style.left = 2000 + 'px';
			//text1.style.zIndex = -1;
			document.body.appendChild(txtComp[i]);
			
		}
		var exploded=false;
		var focus_label=-1;
		var allDragged=[];
		for (var i=0;i<nbCompartments;i++){
			allDragged[i]=[]
		}
		
		
		var txtReactionActivation=[]
		var nbActivation=1000;
		var tokenIDStackCount={};
		for (var i=0;i<nbActivation;i++){
			txtReactionActivation[i] = document.createElement('div');
			txtReactionActivation[i].style.position = 'absolute';
			txtReactionActivation[i].style.width = 100;
			txtReactionActivation[i].style.height = 100;
			txtReactionActivation[i].style.color = "white";
			//txtComp[i].style.fontWeight="1900";
			//txtReactionActivation[i].style.backgroundColor = "#99FFCC";
			//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
			txtReactionActivation[i].innerHTML = 'hello ';
			txtReactionActivation[i].style.top = 2000 + 'px';
			txtReactionActivation[i].style.left = 2000 + 'px';
			//text1.style.zIndex = -1;
			document.body.appendChild(txtReactionActivation[i]);
			
		}
		var positionContainer;
		var yStartDisplacement=400;
		
		
		function updateSlider(slideAmount){
			console.log(slideAmount/100);
			for (var i=0;i<segmentPts;i++){
				for (var i=0;i<b2lopacity.length;i++){
					
					b2lopacity[i]=(parseFloat(slideAmount)/100);
				}	
			}
			scene.children[7].geometry.attributes.op.needsUpdate = true;
		}
		
		selectedModel = <%- JSON.stringify(qm.file.extra)%>;
		selectedModelNodes=selectedModel[2];
		selectedModelEdges=selectedModel[3];
		//console.log(selectedModelNodes);
		//console.log(selectedModelEdges);
		// in model edges, position index 2: product = 1 , preplace =2, consumed = 0
	
		nbPlacesModel=0;
		nbReactionsModel=0;
		nbEdgesModel=selectedModelEdges.length;
		
		for (var i = 0, ii= selectedModelNodes.length;i<ii;i++){
			if (selectedModelNodes[i][5]==2 ){
				nbPlacesModel++;					
			}
			if (selectedModelNodes[i][5]==4 ){
				nbReactionsModel++;
			}
		}
		
		//var layouts = <%- JSON.stringify(qm.layouts)%>;
		for (var i=0;i<qmlayouts.length;i++){
				$('#selectLayout').append("<option value="+qmlayouts[i][0]+">"+qmlayouts[i][1]+"</option>")
			
		}
		if (mqml.hasOwnProperty("id")){
			document.getElementById("selectLayout").value=mqml.id;
			//console.log(mtnl.id)
			for (var sublayout in mqml["layout"]){
				if (mqml["layout"].hasOwnProperty(sublayout)) {
					$('#selectsublayout').append("<option value="+sublayout+">"+sublayout+"</option>")
				}
			}
			document.getElementById("defaultSlider4").value=0;
			document.getElementById("defaultSlider5").value=0;
			
		}
		//console.log(nbPlacesModel)
		//console.log(nbReactionsModel)
		//console.log(nbEdgesModel)
		init();
		animate();
		
		
		function init() {
		
		
			//localStorage.selection=[];
			//localStorage.;

			camera = new THREE.PerspectiveCamera( 45, WIDTH / HEIGHT, 1, 100000 );
			//camera.position.z = 800;
			
			camera.position.y = 500+1.0*yStartDisplacement;
			camera.position.x = 3500;
			//camera2 = new THREE.PerspectiveCamera( 45, WIDTH / HEIGHT, 1, 10000 );
			//camera2.position.z = 250;
			
			

			scene = new THREE.Scene();
			scene2 = new THREE.Scene();
			//////////////////////////////////////////////////
			// define shader attributes for group of particles dna
			particleP1Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP1Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/dna8-green.png" ) }
				

			};

			particleP1Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles rna
			particleP2Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP2Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/rna8.png" ) }
				

			};

			particleP2Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles proteins
			particleP3Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP3Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/disc.png" ) }
				

			};

			particleP3Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles degradation product
			particleP4Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP4Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/disc.png" ) }
				

			};

			particleP4Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles standard pn
			particleP5Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP5Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/PN1.png" ) }
				

			};

			particleP5Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles pn logical
			particleP6Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP6Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/PNLogical1.png" ) }
				

			};

			particleP6Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			//////////////////////////////////////////////////
			// define shader attributes for group of particles pn coarse
			particleP7Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};

			particleP7Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/PNCoarse1.png" ) }
				

			};

			particleP7Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			
			// define shader material for group of particles dna
			particle1ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP1Uniforms,
				attributes:     particleP1Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP1' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP1' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle2ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP2Uniforms,
				attributes:     particleP2Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP2' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP2' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle3ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP3Uniforms,
				attributes:     particleP3Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP3' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP3' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle4ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP4Uniforms,
				attributes:     particleP4Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP4' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP4' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle5ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP5Uniforms,
				attributes:     particleP5Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP5' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP5' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle6ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP6Uniforms,
				attributes:     particleP6Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP6' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP6' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			// define shader material for group of particles rna
			particle7ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP7Uniforms,
				attributes:     particleP7Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP7' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP7' ).textContent,
				depthTest: 		false,
				transparent:	true

			});
			
			//////////////////////////////////////////////
			// define shader attributes for group of lines
			linesAttributes = {

				//displacement: {	type: 'v3', value: [] },
				ca: {	type: 'c', value: [] },
				op:{ type: "f", value: [] }

			};

			linesUniforms = {

				//amplitude: { type: "f", value: 1.0 },
				opacity:   { type: "f", value: 0.7 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) }

			};
			// define shader material for group of lines
			linesShaderMaterial = new THREE.ShaderMaterial( {

				uniforms:       linesUniforms,
				attributes:     linesAttributes,
				vertexShader:   document.getElementById( 'vertexshader2' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshader2' ).textContent,
				blending:       THREE.AdditiveBlending,
				depthTest:      false,
				transparent:    true

			});

			linesShaderMaterial.linewidth = 1;
			//linesShaderMaterial.attributes.op.value=0.7;
			
			
			
			
			
			/////////////////////////////////////////////////////////////////
			// define shader attributes for group of animated token particles
			tokenAttributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] },
				endPosition: { type: "v3", value: [] }
				//mixAmount: 	 { type: 'f', value: [] }
			};

			tokenUniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/small-spark.png" ) },
				mixAmount: 	 { type: "f", value: 0.0 }

			};

			//uniforms.texture.value.wrapS = uniforms.texture.value.wrapT = THREE.RepeatWrapping;

			tokenShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		tokenUniforms,
				attributes:     tokenAttributes,
				vertexShader:   document.getElementById( 'vertexshader3' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshader3' ).textContent,
				depthTest: 		false,
				transparent:	true,
				opacity: 0.8,
				blending:	true

			});
			
			
			//particles = nbDNAParticles // nb of DNA elements
			//+ nbRNAParticles // nb of RNA elements
			//+ nbProtParticles // nb of proteins
			//+ nbDegradParticles // nb of degradation products
			//+ nbPNParticles // nb of PN standard places
			//+ nbLogParticles // nb of logical PN places
			//+ nbCoarseParticles; // nb of PN coarse transitions
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for dna particles
			bgeometryP1 = new THREE.BufferGeometry();
			
			bgeometryP1.dynamic = true;
			var positionsP1 = new Float32Array( nbDNAParticles * 3 );
			var values_colorP1 = new Float32Array( nbDNAParticles * 3 );
			var values_sizeP1 = new Float32Array( nbDNAParticles );
			var compartmentP1 = new Float32Array( nbDNAParticles );
			
			
			var color = new THREE.Color( 0xffffff );
			var radius =400;
			for( var bv = 0; bv < nbDNAParticles; bv++ ) {
			

				values_sizeP1[ bv ] = 10;
				compartmentP1[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;

				positionsP1[ (bv * 3) + 0 ] = (Math.random() * 2 - 1) * radius;
				//b1positions[ (bv * 3) + 1 ] = (Math.random() * 2 - 1) * radius;
				positionsP1[ (bv * 3) + 1 ] = yStartDisplacement;
				positionsP1[ (bv * 3) + 2 ] = (Math.random() * 2 - 1) * radius;
				
				
				//if ( positions[ bv * 3 + 0 ] < 0 )
				//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
				//else
				//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
				values_colorP1[ (bv * 3) + 0 ] = color.r;
				values_colorP1[ (bv * 3) + 1 ] = color.g;
				values_colorP1[ (bv * 3) + 2 ] = color.b;

			}
			bgeometryP1.addAttribute( 'position', new THREE.BufferAttribute( positionsP1, 3 ) );
			bgeometryP1.addAttribute( 'ca', new THREE.BufferAttribute( values_colorP1, 3 ) );
			bgeometryP1.addAttribute( 'size', new THREE.BufferAttribute( values_sizeP1, 1 ) );
			bgeometryP1.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentP1, 1 ) );
			
			b1values_size = bgeometryP1.attributes.size.array;
			b1positions = bgeometryP1.attributes.position.array;
			b1values_color = bgeometryP1.attributes.ca.array;
			b1values_compartment = bgeometryP1.attributes.compartment.array;
			
			
			
			// associate first particle system with bufferGeometry
			PointCloud1 = new THREE.PointCloud( bgeometryP1, particle1ShaderMaterial );

			PointCloud1.dynamic = true;
			PointCloud1.sortParticles = true;
			PointCloud1.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud1 );
			
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for rna particles
			bgeometryP2 = new THREE.BufferGeometry();
			
			bgeometryP2.dynamic = true;
			var positionsP2 = new Float32Array( nbRNAParticles * 3 );
			var values_colorP2 = new Float32Array( nbRNAParticles * 3 );
			var values_sizeP2 = new Float32Array( nbRNAParticles );
			var compartmentP2 = new Float32Array( nbRNAParticles );
									
			//bgeometryP2.attributes.size.needsUpdate = true;
			//bgeometryP2.attributes.position.needsUpdate = true;
			//bgeometryP2.attributes.ca.needsUpdate = true;
			//bgeometryP2.attributes.compartment.needsUpdate = true;
			
			var color = new THREE.Color( 0xffffff );
			var radius =400;
			for( var bv = 0; bv < nbRNAParticles; bv++ ) {
			

				values_sizeP2[ bv ] = 10;
				compartmentP2[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
				
				positionsP2[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius;
				//b2positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
				positionsP2[ bv * 3 + 1 ] = yStartDisplacement;
				
				positionsP2[ bv * 3 + 2 ] = (Math.random() * 2 - 1) * radius;
				
				
				//if ( positions[ bv * 3 + 0 ] < 0 )
				//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
				//else
				//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
				values_colorP2[ bv * 3 + 0 ] = color.r;
				values_colorP2[ bv * 3 + 1 ] = color.g;
				values_colorP2[ bv * 3 + 2 ] = color.b;

			}
			
			
			
			
			
			bgeometryP2.addAttribute( 'position', new THREE.BufferAttribute( positionsP2, 3 ) );
			bgeometryP2.addAttribute( 'ca', new THREE.BufferAttribute( values_colorP2, 3 ) );
			bgeometryP2.addAttribute( 'size', new THREE.BufferAttribute( values_sizeP2, 1 ) );
			bgeometryP2.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentP2, 1 ) );
			
			b2values_size = bgeometryP2.attributes.size.array;
			b2positions = bgeometryP2.attributes.position.array;
			b2values_color = bgeometryP2.attributes.ca.array;
			b2values_compartment = bgeometryP2.attributes.compartment.array;
			// associate first particle system with bufferGeometry
			PointCloud2 = new THREE.PointCloud( bgeometryP2, particle2ShaderMaterial );

			PointCloud2.dynamic = true;
			PointCloud2.sortParticles = true;
			PointCloud2.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud2 );
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for protein particles
			bgeometryP3 = new THREE.BufferGeometry();
			
			bgeometryP3.dynamic = true;
			var positionsP3 = new Float32Array( nbProtParticles * 3 );
			var values_colorP3 = new Float32Array( nbProtParticles * 3 );
			var values_sizeP3 = new Float32Array( nbProtParticles );
			var compartmentP3 = new Float32Array( nbProtParticles );
			
			/*bgeometryP3.attributes = {

				position: {
					itemSize: 3,
					array: new Float32Array( nbProtParticles * 3 )
				},
				ca: {
					itemSize: 3,
					array: new Float32Array( nbProtParticles * 3 )
				},
				size: {
					itemSize: 1,
					array: new Float32Array( nbProtParticles ),
					dynamic: true
				},
				compartment: {
					itemSize: 1,
					array: new Float32Array( nbProtParticles ),
					dynamic: true
				}

			}*/
			//bgeometryP3.attributes.size.needsUpdate = true;
			//bgeometryP3.attributes.position.needsUpdate = true;
			//bgeometryP3.attributes.ca.needsUpdate = true;
			//bgeometryP3.attributes.compartment.needsUpdate = true;
			
			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xff9900 );;
			var color2 = new THREE.Color( 0x55ff55 );
			var radius =400;
			var bv=0;
			//for( var bv = 0; bv < nbProtParticles; bv++ ) {
				for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
					if (jsonObj1[bw][6]==2){
						values_sizeP3[ bv ] = nodeSize;
						//b3values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
						compartmentP3[ bv ] = mapComp[jsonObj1[bw][3]];
						idMap[bw]=[2,bv];
						typesMap[2][bv]=bw;
						
						var rm;
						var rr;
						
						if (nameModel=="hepatonet1-msb201062-s5"){
							rm=bv*0.078*2*Math.PI;
							rr = ((bv*0.02)+0.35*radius)
							positionsP3[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							positionsP3[ bv * 3 + 1 ] = yStartDisplacement+0+(bv*0.05);
						}
						if (nameModel=="msb201062-s5"){
							rm=bv*0.078*2*Math.PI;
							rr = ((bv*0.02)+0.35*radius)
							positionsP3[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							positionsP3[ bv * 3 + 1 ] = yStartDisplacement+0+(bv*0.05);
						}
						else if (nameModel=="Ec_iAF1260_flux2"){
							rm=bv*0.004*2*Math.PI;
							rr = ((radius*1.08)-(bv*0.03)+1)
							positionsP3[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							positionsP3[ bv * 3 + 1 ] = yStartDisplacement+0-(bv*0.03);

						}
						
						else if (nameModel=="iTO977_v1.00_cobra"){
							rm=bv*0.004*2*Math.PI;
							rr = ((radius*1.08)-(bv*0.03)+1)
							positionsP3[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							positionsP3[ bv * 3 + 1 ] = yStartDisplacement+0-(bv*0.03);

						}
						else{
							rm=bv*0.008*2*Math.PI;
							rr = ((bv*0.02)+0.05*radius);
							positionsP3[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							positionsP3[ bv * 3 + 1 ] = yStartDisplacement+0+(bv*0.02);
						}
						
						positionsP3[ bv * 3 + 2 ] = Math.sin(rm) *rr;
						
						values_colorP3[ bv * 3 + 0 ] = color.r;
						values_colorP3[ bv * 3 + 1 ] = color.g;
						values_colorP3[ bv * 3 + 2 ] = color.b;
						bv++;
					}
				}
				startModelPlaces=bv;
				for( var bw = jsonObj1.length , bww= jsonObj1.length+5000; bw < bww; bw++ ) {
						
		
					//if (jsonObj1[bw][6]==2){
						values_sizeP3[ bv ] = 10;
						//b3values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
						compartmentP3[ bv ] = -1;
						//idMap[bw]=[2,bv];
						//typesMap[2][bv]=bw;
						idMap[bw]=[2,bv];
						typesMap[2][bv]=bw;
						//var rm=(bw-jsonObj1.length)*0.078*2*Math.PI;
						//var	rr = (((bw-jsonObj1.length)*0.02)+0.95*radius)
						//radius=900;
						
						var rm;
						
						var rr ;
						
						if (nbPlacesModel<2000){
							rm=(bw-jsonObj1.length)*0.008*2*Math.PI;
							rr == ((radius)-((bw-jsonObj1.length)*0.3)+1)
						}
						else{
							rm=(bw-jsonObj1.length)*0.003*2*Math.PI;
							rr == ((radius*1.8)-((bw-jsonObj1.length)*0.3)+1)
						}
						
						positionsP3[ bv * 3 + 0 ] = (Math.cos(rm) *rr)+900;
						//b3positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius+900;
						//b3positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
						positionsP3[ bv * 3 + 1 ] = yStartDisplacement/2;
						positionsP3[ bv * 3 + 2 ] = ((Math.random() * 2 - 1) * radius)+150000;
						//b3positions[ bv * 3 + 2 ] = (Math.sin(rm) *rr)+50000;
						
						//if ( positions[ bv * 3 + 0 ] < 0 )
						//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
						//else
						//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
						values_colorP3[ bv * 3 + 0 ] = color2.r;
						values_colorP3[ bv * 3 + 1 ] = color2.g;
						values_colorP3[ bv * 3 + 2 ] = color2.b;
						bv++;
					//}
				}
				endModelPlaces=bv;
			
			

			
			/*
			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xff9900 );;
			var color2 = new THREE.Color( 0x55ff55 );
			var radius =400;
			var bv=0;
			//for( var bv = 0; bv < nbProtParticles; bv++ ) {
				for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
					if (jsonObj1[bw][6]==2){
						b3values_size[ bv ] = 10;
						//b3values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
						b3values_compartment[ bv ] = mapComp[jsonObj1[bw][3]];
						idMap[bw]=[2,bv];
						typesMap[2][bv]=bw;
						
						var rm;
						var rr;
						
						if (nameModel=="hepatonet1-msb201062-s5"){
							rm=bv*0.078*2*Math.PI;
							rr = ((bv*0.02)+0.35*radius)
							b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							b3positions[ bv * 3 + 1 ] = yStartDisplacement+0+(bv*0.05);
						}
						else if (nameModel=="Ec_iAF1260_flux2"){
							rm=bv*0.004*2*Math.PI;
							rr = ((radius*1.08)-(bv*0.03)+1)
							b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							b3positions[ bv * 3 + 1 ] = yStartDisplacement+0-(bv*0.03);

						}
						
						else if (nameModel=="iTO977_v1.00_cobra"){
							rm=bv*0.004*2*Math.PI;
							rr = ((radius*1.08)-(bv*0.03)+1)
							b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							b3positions[ bv * 3 + 1 ] = yStartDisplacement+0-(bv*0.03);

						}
						else{
							rm=bv*0.008*2*Math.PI;
							rr = ((bv*0.02)+0.05*radius);
							b3positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							b3positions[ bv * 3 + 1 ] = yStartDisplacement+0+(bv*0.02);
						}
						
						b3positions[ bv * 3 + 2 ] = Math.sin(rm) *rr;
						
						b3values_color[ bv * 3 + 0 ] = color.r;
						b3values_color[ bv * 3 + 1 ] = color.g;
						b3values_color[ bv * 3 + 2 ] = color.b;
						bv++;
					}
				}
				startModelPlaces=bv;
				for( var bw = jsonObj1.length , bww= jsonObj1.length+5000; bw < bww; bw++ ) {
						
		
					//if (jsonObj1[bw][6]==2){
						b3values_size[ bv ] = 30;
						//b3values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
						b3values_compartment[ bv ] = -1;
						//idMap[bw]=[2,bv];
						//typesMap[2][bv]=bw;
						idMap[bw]=[2,bv];
						typesMap[2][bv]=bw;
						//var rm=(bw-jsonObj1.length)*0.078*2*Math.PI;
						//var	rr = (((bw-jsonObj1.length)*0.02)+0.95*radius)
						//radius=900;
						var rm=(bw-jsonObj1.length)*0.008*2*Math.PI;
						var rr = ((radius*1.08)-((bw-jsonObj1.length)*0.3)+1)
						b3positions[ bv * 3 + 0 ] = (Math.cos(rm) *rr)+900;
						//b3positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius+900;
						//b3positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
						b3positions[ bv * 3 + 1 ] = yStartDisplacement+80;
						b3positions[ bv * 3 + 2 ] = ((Math.random() * 2 - 1) * radius)+50000;
						//b3positions[ bv * 3 + 2 ] = (Math.sin(rm) *rr)+50000;
						
						//if ( positions[ bv * 3 + 0 ] < 0 )
						//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
						//else
						//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
						b3values_color[ bv * 3 + 0 ] = color2.r;
						b3values_color[ bv * 3 + 1 ] = color2.g;
						b3values_color[ bv * 3 + 2 ] = color2.b;
						bv++;
					//}
				}
				endModelPlaces=bv;
			//}
			*/
			bgeometryP3.addAttribute( 'position', new THREE.BufferAttribute( positionsP3, 3 ) );
			bgeometryP3.addAttribute( 'ca', new THREE.BufferAttribute( values_colorP3, 3 ) );
			bgeometryP3.addAttribute( 'size', new THREE.BufferAttribute( values_sizeP3, 1 ) );
			bgeometryP3.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentP3, 1 ) );
			
			b3values_size = bgeometryP3.attributes.size.array;
			b3positions = bgeometryP3.attributes.position.array;
			b3values_color = bgeometryP3.attributes.ca.array;
			b3values_compartment = bgeometryP3.attributes.compartment.array;
			
			bgeometryP3.computeBoundingSphere();
			// associate first particle system with bufferGeometry
			PointCloud3 = new THREE.PointCloud( bgeometryP3, particle3ShaderMaterial );

			PointCloud3.dynamic = true;
			PointCloud3.sortParticles = true;
			PointCloud3.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud3 );
			
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for degradable product particles
			bgeometryP4 = new THREE.BufferGeometry();
			
			bgeometryP4.dynamic = true;
			var positionsP4 = new Float32Array( nbDegradParticles * 3 );
			var values_colorP4 = new Float32Array( nbDegradParticles * 3 );
			var values_sizeP4 = new Float32Array( nbDegradParticles );
			var compartmentP4 = new Float32Array( nbDegradParticles );
			
			

			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xff66ff );;
			var radius =400;
			for( var bv = 0; bv < nbDegradParticles; bv++ ) {
			

				values_sizeP4[ bv ] = 10;
				compartmentP4[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;

				positionsP4[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius;
				
				//b4positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
				positionsP4[ bv * 3 + 1 ] = yStartDisplacement+0;
				positionsP4[ bv * 3 + 2 ] = (Math.random() * 2 - 1) * radius;
				
				
				//if ( positions[ bv * 3 + 0 ] < 0 )
				//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
				//else
				//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
				values_colorP4[ bv * 3 + 0 ] = color.r;
				values_colorP4[ bv * 3 + 1 ] = color.g;
				values_colorP4[ bv * 3 + 2 ] = color.b;

			}
			bgeometryP4.addAttribute( 'position', new THREE.BufferAttribute( positionsP4, 3 ) );
			bgeometryP4.addAttribute( 'ca', new THREE.BufferAttribute( values_colorP4, 3 ) );
			bgeometryP4.addAttribute( 'size', new THREE.BufferAttribute( values_sizeP4, 1 ) );
			bgeometryP4.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentP4, 1 ) );
			
			b4values_size = bgeometryP4.attributes.size.array;
			b4positions = bgeometryP4.attributes.position.array;
			b4values_color = bgeometryP4.attributes.ca.array;
			b4values_compartment = bgeometryP4.attributes.compartment.array;
			
			
			
			
			// associate first particle system with bufferGeometry
			PointCloud4 = new THREE.PointCloud( bgeometryP4, particle4ShaderMaterial );

			PointCloud4.dynamic = true;
			PointCloud4.sortParticles = true;
			PointCloud4.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud4 );
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for PN particles
			bgeometryP5 = new THREE.BufferGeometry();
			
			var positionsP5 = new Float32Array( nbPNParticles * 3 );
			var values_colorP5 = new Float32Array( nbPNParticles * 3 );
			var values_sizeP5 = new Float32Array( nbPNParticles );
			var compartmentP5 = new Float32Array( nbPNParticles );
			
			bgeometryP5.dynamic = true;
			/*bgeometryP5.attributes = {

				position: {
					itemSize: 3,
					array: new Float32Array( nbPNParticles * 3 )
				},
				ca: {
					itemSize: 3,
					array: new Float32Array( nbPNParticles * 3 )
				},
				size: {
					itemSize: 1,
					array: new Float32Array( nbPNParticles ),
					dynamic: true
				},
				compartment: {
					itemSize: 1,
					array: new Float32Array( nbPNParticles ),
					dynamic: true
				}

			}*/
			
			
			var color = new THREE.Color( 0xffffff );
					
					var color2 = new THREE.Color( 0x55ffff );
					var radius =400;
					var bv=0;
					//for( var bv = 0; bv < nbPNParticles; bv++ ) {
					/*subSystems=[];
					for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
						if (jsonObj1[bw][6]==4){
							if (jsonObj1[bw][4][1] && jsonObj1[bw][4][1][0]){
								if (subSystems.indexOf(jsonObj1[bw][4][1][0])== -1){
									subSystems.push(jsonObj1[bw][4][1][0]);
								}
							}
						}
					}*/
					//console.log(subSystems);
					// now allocate a nb of nodes by sub systems
					subSystems={};
					totalSubSystems=0;
					
					totalNbreactions=0;
					for( var bs = 0 , bww= jsonObj1.length; bs < bww; bs++ ) {
						if (jsonObj1[bs][6]==4){
							if (jsonObj1[bs][4][1] && jsonObj1[bs][4][1][0]){
								if (subSystems[jsonObj1[bs][4][1][0]]=== undefined){
									subSystems[jsonObj1[bs][4][1][0]]=1;
									totalSubSystems++;
								}
								else{
									subSystems[jsonObj1[bs][4][1][0]]++;
									totalSubSystems++;
								}
								
							}
							totalNbreactions++;
						}
					}
					totalOutsideSubSystems=totalNbreactions-totalSubSystems;
					nbSubSystems=Object.keys(subSystems).length
					if (totalOutsideSubSystems>0){
						nbAreas=nbSubSystems+1;
						subSystems["Not present"]=totalOutsideSubSystems;
					}
					else{
						nbAreas=nbSubSystems;
					}
					//console.log(subSystems);
					
					//console.log(totalSubSystems);
					//console.log(totalNbreactions);
					//console.log(totalOutsideSubSystems);
					//console.log(nbSubSystems);
					
					// if there is no subsystem identified just use standard spiral layout
					
					// if there are n subsystems then display circular region of width proportional to the nb of nodes in each subsystem
					// first make a list of widths
					// total nb of reactions will dictate the overall nb of points that must be displayed on the ring.
					// depth of the ring is 30 points. there are for 0.004 *2Pi=1.44 degrees = 250 graduations on a circle 
					var listWidthSubSystems={};
					var nbCircleGraduations=250;
					var minCircleFraction=1/nbCircleGraduations;
					var nbNodesDepth=40;
					var totalWidth=0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							var width= Math.ceil(subSystems[key]/nbNodesDepth);
							listWidthSubSystems[key]=[subSystems[key]/*nb of nodes*/,width,/*counter value*/0];
							totalWidth+=width;
						}
					}
					nbNodesDepth=Math.ceil((40*totalWidth)/244);
					listWidthSubSystems={};
					var totalWidth=0;
					var cumulativeWidth=0;
					var colorswap=1.0;
					for (var key in subSystems) {
						if (subSystems.hasOwnProperty(key)) {
							var width= Math.ceil(subSystems[key]/nbNodesDepth);
							listWidthSubSystems[key]=[subSystems[key]/*nb of nodes*/,width,cumulativeWidth,/*counter value*/0,colorswap];
							totalWidth+=width;
							cumulativeWidth+=width;
							if (colorswap==1.0){
							colorswap=0.7;
							}
							else{colorswap=1.0}
						}
					}
					
					
					var localRSeparator=0;
					for( var bw = 0 , bww= jsonObj1.length; bw < bww; bw++ ) {
						
						if (jsonObj1[bw][6]==4){

							values_sizeP5[ bv ] = nodeSize;
							//b5values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;
							
							// try to assign the compartment of the majority of the products the reaction is linked to 
							// if there is no product, assign the compartment of the majority of modifiers
							// if there is no modifier, assign the compartment of the majority of reactants
							var listProducts= jsonObj1[bw][11][0];
							var listModifiers= jsonObj1[bw][11][1];
							var listReactants= jsonObj1[bw][11][2];
							
							if (listProducts.length>0){
								var votes=[];
								for (var ncc=0;ncc<nbCompartments;ncc++){
									votes[ncc]=0;
								}
								for(var lp=0;lp<listProducts.length;lp++){
									if (mapComp[jsonObj1[listProducts[lp]][3]]>=0)
										votes[mapComp[jsonObj1[listProducts[lp]][3]]]++;
								}
								var winner= votes.indexOf(Math.max.apply( Math, votes ));
								compartmentP5[ bv ] = winner;
								if (winner==-1){
									compartmentP5[ bv ] = mapComp[jsonObj1[bw][3]];
								}
							} 
							else if (listModifiers.length>0){
								var votes=[];
								for (var ncc=0;ncc<nbCompartments;ncc++){
									votes[ncc]=0;
								}
								for(var lp=0;lp<listModifiers.length;lp++){
									if (mapComp[jsonObj1[listModifiers[lp]][3]]>=0)
										votes[mapComp[jsonObj1[listModifiers[lp]][3]]]++;
								}
								var winner= votes.indexOf(Math.max.apply( Math, votes ));
								compartmentP5[ bv ] = winner;
								if (winner==-1){
									compartmentP5[ bv ] = mapComp[jsonObj1[bw][3]];
								}
							}
							else if (listReactants.length>0){
								var votes=[];
								for (var ncc=0;ncc<nbCompartments;ncc++){
									votes[ncc]=0;
								}
								for(var lp=0;lp<listReactants.length;lp++){
									if (mapComp[jsonObj1[listReactants[lp]][3]]>=0)
										votes[mapComp[jsonObj1[listReactants[lp]][3]]]++;
								}
								var winner= votes.indexOf(Math.max.apply( Math, votes ));
								compartmentP5[ bv ] = winner;
								if (winner==-1){
									compartmentP5[ bv ] = mapComp[jsonObj1[bw][3]];
								}
							}
							else {
								// if no species linked, put reaction in the center
								compartmentP5[ bv ] = mapComp[jsonObj1[bw][3]];
							}
							
							idMap[bw]=[4,bv];
							typesMap[4][bv]=bw;
							
							var rm;
							var rr; 
							
							
							
							
							if (nameModel=="Ec_iAF1260_flux2" || nameModel=="iTO977_v1.00_cobra"){
								rm=bv*0.078*2*Math.PI;
								rr = ((bv*0.02)+0.35*radius)
								//b5positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
								positionsP5[ bv * 3 + 1 ] = (yStartDisplacement/2)+(bv*0.04);
							}
							else{
								var yModifier=0;
								var mDepth=0;
								//rr= ((radius*1.08)-(0*0.03)+1);
								if (jsonObj1[bw][4][1] && jsonObj1[bw][4][1][0]){
									
									//console.log("increment node")
									//console.log(jsonObj1[bw][4][1][0]);
									if (listWidthSubSystems.hasOwnProperty(jsonObj1[bw][4][1][0])) {
									
										var startingW=listWidthSubSystems[jsonObj1[bw][4][1][0]][2];
										var maxWidth=listWidthSubSystems[jsonObj1[bw][4][1][0]][1];
										var maxDepth=nbNodesDepth;
										var maxNbNodes=listWidthSubSystems[jsonObj1[bw][4][1][0]][0];
										var presentIndex= listWidthSubSystems[jsonObj1[bw][4][1][0]][3];
										if (presentIndex<maxNbNodes){
										//cnt1++;
											var localWPos=0;
											
											var localRR=0;
											localWPos=Math.floor(presentIndex/maxDepth);
											//if (presentIndex>=maxDepth){
											
												localRR=presentIndex%maxDepth;
											yModifier=	localRR;
											mDepth=maxDepth;
											//}
											//else{
											//	localRR=presentIndex;
											//}
											//if(presentIndex==0){
											//	localRSeparator+=(nbCircleGraduations-totalWidth)/(2*nbAreas);//	rm=((startingW+localWPos+localRSeparator)*0.004*(2*Math.PI));
											//console.log(jsonObj1[bw][4][1][0])
											//listWidthSubSystems[jsonObj1[bw][4][1][0]][2]+=((nbCircleGraduations-totalWidth)/(nbAreas));
											//startingW=listWidthSubSystems[jsonObj1[bw][4][1][0]][2];
											//color.r-=0.01
											//}
											rm=((startingW+localRSeparator+localWPos)*0.004*(2*Math.PI));
											
											rr= ((radius-maxDepth*5)+(localRR*5));
											listWidthSubSystems[jsonObj1[bw][4][1][0]][3]++;
											color.r=listWidthSubSystems[jsonObj1[bw][4][1][0]][4];
											if (color.r==1.0){
											color.g=1.0;
											color.b=1.0;
											}
											else{
											color.g=0.4;
											color.b=1.0;
											}
										}
									}
								}
								else{
									
									//subSystems["Not present"]=totalOutsideSubSystems;
									if (listWidthSubSystems.hasOwnProperty("Not present")) {
									
									//console.log("increment not present")
										var startingW=listWidthSubSystems["Not present"][2];
										var maxWidth=listWidthSubSystems["Not present"][1];
										var maxDepth=nbNodesDepth;
										var maxNbNodes=listWidthSubSystems["Not present"][0];
										var presentIndex= listWidthSubSystems["Not present"][3];
										if (presentIndex<maxNbNodes){
										//cnt2++;
											var localWPos=0;
											var localRR=0;
											localWPos=Math.floor(presentIndex/maxDepth);
											//if (presentIndex>=maxDepth){
											
												localRR=presentIndex%maxDepth;
												yModifier=	localRR;	
												mDepth=maxDepth;
											//}
											//else{
											//	localRR=presentIndex;
											//}
											//if(presentIndex==0){
											//console.log(jsonObj1[bw][4][1][0])
											//listWidthSubSystems["Not present"][2]+=((nbCircleGraduations-totalWidth)/(nbAreas));
											//startingW=listWidthSubSystems["Not present"][2];
											//	localRSeparator+=(nbCircleGraduations-totalWidth)/(2*nbAreas);//	rm=((startingW+localWPos+localRSeparator)*0.004*(2*Math.PI));
											//}
											rm=((startingW+localRSeparator+localWPos)*0.004*(2*Math.PI));
											rr= ((radius-maxDepth*5)+(localRR*5));
											listWidthSubSystems["Not present"][3]++;
											color = new THREE.Color( 0xff0000 );
										}
									}
								}
								//console.log(listWidthSubSystems);
							
								//rm=bv*0.004*2*Math.PI;
								//rr= ((radius*1.08)-(bv*0.03)+1);
								
								//b5positions[ bv * 3 + 0 ] = Math.cos(rm) *rr;
								//b5positions[ bv * 3 + 1 ] = 0-(bv*0.03);
								positionsP5[ bv * 3 + 1 ] = yStartDisplacement-(mDepth*4)+(yModifier*4);
								//console.log(jsonObj1[bw][4][1][0])
							}
							positionsP5[ bv * 3 + 0 ] = Math.cos(rm) *rr;
							positionsP5[ bv * 3 + 2 ] = Math.sin(rm) *rr;
							
							
							values_colorP5[ bv * 3 + 0 ] = color.r;
							values_colorP5[ bv * 3 + 1 ] = color.g;
							values_colorP5[ bv * 3 + 2 ] = color.b;
							bv++;
						}
					}
					//console.log("increment"+cnt1 + "  " +cnt2)
					startModelReactions=bv;
					for( var bw = jsonObj1.length , bww= jsonObj1.length+5000; bw < bww; bw++ ) {
						
						values_sizeP5[ bv ] = 10;
						
						compartmentP5[ bv ] = -1;
						idMap[bw]=[4,bv];
						typesMap[4][bv]=bw;
						
						
						
						//radius=900;
						if (nbReactionsModel<2000){
							rm=(bw-jsonObj1.length)*0.008*2*Math.PI;
							rr == ((radius)-((bw-jsonObj1.length)*0.3)+1)
						}
						else{
							rm=(bw-jsonObj1.length)*0.003*2*Math.PI;
							rr == ((radius*1.8)-((bw-jsonObj1.length)*0.3)+1)
						}
						
						//var rm=(bw-jsonObj1.length)*0.008*2*Math.PI;
						//var rr = ((radius)-((bw-jsonObj1.length)*0.3)+1)
						//b5positions[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius+900;
						positionsP5[ bv * 3 + 0 ] = (Math.cos(rm) *rr)+1800;
						//b5positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
						positionsP5[ bv * 3 + 1 ] = yStartDisplacement/2-180;
						
						positionsP5[ bv * 3 + 2 ] = ((Math.random() * 2 - 1) * radius)+150000;
						
						
						//if ( positions[ bv * 3 + 0 ] < 0 )
						//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
						//else
						//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
						values_colorP5[ bv * 3 + 0 ] = color2.r;
						values_colorP5[ bv * 3 + 1 ] = color2.g;
						values_colorP5[ bv * 3 + 2 ] = color2.b;
						bv++;
					}
					endModelReactions=bv;
			
			
			
			
			
			bgeometryP5.addAttribute( 'position', new THREE.BufferAttribute( positionsP5, 3 ) );
			bgeometryP5.addAttribute( 'ca', new THREE.BufferAttribute( values_colorP5, 3 ) );
			bgeometryP5.addAttribute( 'size', new THREE.BufferAttribute( values_sizeP5, 1 ) );
			bgeometryP5.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentP5, 1 ) );
			
			//bgeometryP5.attributes.size.needsUpdate = true;
			//bgeometryP5.attributes.position.needsUpdate = true;
			//bgeometryP5.attributes.ca.needsUpdate = true;
			//bgeometryP5.attributes.compartment.needsUpdate = true;

			b5values_size = bgeometryP5.attributes.size.array;
			b5positions = bgeometryP5.attributes.position.array;
			b5values_color = bgeometryP5.attributes.ca.array;
			b5values_compartment = bgeometryP5.attributes.compartment.array;
									
			// associate first particle system with bufferGeometry
			PointCloud5 = new THREE.PointCloud( bgeometryP5, particle5ShaderMaterial );

			PointCloud5.dynamic = true;
			PointCloud5.sortParticles = true;
			PointCloud5.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud5 );
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for PN particles
			bgeometryP6 = new THREE.BufferGeometry();
			
			bgeometryP6.dynamic = true;
			
			var positionsP6 = new Float32Array( nbLogParticles * 3 );
			var values_colorP6 = new Float32Array( nbLogParticles * 3 );
			var values_sizeP6 = new Float32Array( nbLogParticles );
			var compartmentP6 = new Float32Array( nbLogParticles );
			
			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xffffff );;
			var radius =400;
			for( var bv = 0; bv < nbLogParticles; bv++ ) {
			

				values_sizeP6[ bv ] = 10;
				compartmentP6[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;

				positionsP6[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius;
				//b6positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
				positionsP6[ bv * 3 + 1 ] = yStartDisplacement;
				
				positionsP6[ bv * 3 + 2 ] = (Math.random() * 2 - 1) * radius;
				
				
				//if ( positions[ bv * 3 + 0 ] < 0 )
				//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
				//else
				//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
				values_colorP6[ bv * 3 + 0 ] = color.r;
				values_colorP6[ bv * 3 + 1 ] = color.g;
				values_colorP6[ bv * 3 + 2 ] = color.b;

			}

			bgeometryP6.addAttribute( 'position', new THREE.BufferAttribute( positionsP6, 3 ) );
			bgeometryP6.addAttribute( 'ca', new THREE.BufferAttribute( values_colorP6, 3 ) );
			bgeometryP6.addAttribute( 'size', new THREE.BufferAttribute( values_sizeP6, 1 ) );
			bgeometryP6.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentP6, 1 ) );
			
			b6values_size = bgeometryP6.attributes.size.array;
			b6positions = bgeometryP6.attributes.position.array;
			b6values_color = bgeometryP6.attributes.ca.array;
			b6values_compartment = bgeometryP6.attributes.compartment.array;
			
			
			
			
			// associate first particle system with bufferGeometry
			PointCloud6 = new THREE.PointCloud( bgeometryP6, particle6ShaderMaterial );

			PointCloud6.dynamic = true;
			PointCloud6.sortParticles = true;
			PointCloud6.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud6 );
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for PN particles
			bgeometryP7 = new THREE.BufferGeometry();
			
			bgeometryP7.dynamic = true;
			
			var positionsP7 = new Float32Array( nbCoarseParticles * 3 );
			var values_colorP7 = new Float32Array( nbCoarseParticles * 3 );
			var values_sizeP7 = new Float32Array( nbCoarseParticles );
			var compartmentP7 = new Float32Array( nbCoarseParticles );
			
			// populates first buffer geometry for particles with coordinates, colors, and size
			var color = new THREE.Color( 0xffffff );;
			var radius =400;
			for( var bv = 0; bv < nbCoarseParticles; bv++ ) {
			

				values_sizeP7[ bv ] = 10;
				compartmentP7[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;

				positionsP7[ bv * 3 + 0 ] = (Math.random() * 2 - 1) * radius;
				//b7positions[ bv * 3 + 1 ] = (Math.random() * 2 - 1) * radius;
				positionsP7[ bv * 3 + 1 ] = yStartDisplacement;
				
				positionsP7[ bv * 3 + 2 ] = (Math.random() * 2 - 1) * radius;
				
				
				//if ( positions[ bv * 3 + 0 ] < 0 )
				//	color.setHSL( 0.5 + 0.1 * ( bv / particles ), 0.7, 0.1 );
				//else
				//	color.setHSL( 0.0 + 0.1 * ( bv / particles ), 0.9, 0.1 );
				values_colorP7[ bv * 3 + 0 ] = color.r;
				values_colorP7[ bv * 3 + 1 ] = color.g;
				values_colorP7[ bv * 3 + 2 ] = color.b;

			}

			bgeometryP7.addAttribute( 'position', new THREE.BufferAttribute( positionsP7, 3 ) );
			bgeometryP7.addAttribute( 'ca', new THREE.BufferAttribute( values_colorP7, 3 ) );
			bgeometryP7.addAttribute( 'size', new THREE.BufferAttribute( values_sizeP7, 1 ) );
			bgeometryP7.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentP7, 1 ) );
			
			b7values_size = bgeometryP7.attributes.size.array;
			b7positions = bgeometryP7.attributes.position.array;
			b7values_color = bgeometryP7.attributes.ca.array;
			b7values_compartment = bgeometryP7.attributes.compartment.array;
			
			
			
			
			// associate first particle system with bufferGeometry
			PointCloud7 = new THREE.PointCloud( bgeometryP7, particle7ShaderMaterial );

			PointCloud7.dynamic = true;
			PointCloud7.sortParticles = true;
			PointCloud7.geometry.__dirtyVertices = true;
			
			scene.add( PointCloud7 );
			
			// populates second buffer geometry for lines  with coordinates, colors, and size
			//segmentPts = 20000;
			bgeometry2 = new THREE.BufferGeometry();
			
			var positionsL1 = new Float32Array( (segmentPts+18000) * 3 );
			var colorsL1 = new Float32Array( (segmentPts+18000) * 3 );
			var opL1 = new Float32Array((segmentPts+18000));
			var compartmentL1 = new Float32Array( (segments+9000)*2 );
			var fluxL1 = new Float32Array( (segments+9000) );
			var boundsL1= new Float32Array( (segments+9000) * 2 );
			
			/*bgeometry2.attributes = {
				position: {
					itemSize: 3,
					array: new Float32Array((segmentPts+5000) * 3)
				},
				ca: {
					itemSize: 3,
					array: new Float32Array((segmentPts+5000) * 3)
				},
				op: {
					itemSize: 1,
					array: new Float32Array( segmentPts+5000  ),
					dynamic: true
				},
				compartment: {
					itemSize: 2,
					array: new Float32Array( (segments+2500) * 2 ),
					dynamic: true
				}
				,flux: {
					itemSize: 1,
					array: new Float32Array( segments+2500 ),
					dynamic: true
				}
				,bounds: {
					itemSize: 2,
					array: new Float32Array( (segments+2500) * 2 ),
					dynamic: true
				}
			};*/
			
			var r = 800;
			var col = new THREE.Color( 0x00ffff );
			var col2 = new THREE.Color( 0x55ff55 );
			
			var iv=0;
			for ( var i = 0; i < segments; i ++ ) {
			
				var t1 = jsonObj1[jsonObj2[i][0]][6]
				var t2 = jsonObj1[jsonObj2[i][1]][6]
				var ivList=[]
				
				if (t1==2){
					positionsL1[ (iv * 3)+0 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
					positionsL1[ (iv * 3) + 1 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
					positionsL1[ (iv * 3) + 2 ] = b3positions[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
					compartmentL1[ (i*2)+0 ] = b3values_compartment[ (idMap[jsonObj2[i][0]][1]) ];
					opL1[iv]=0.25;
					colorsL1[ iv * 3 ] = 0.0;
					colorsL1[ iv * 3 + 1 ] = 1.0;
					colorsL1[ iv * 3 + 2 ] = 1.0;
					ivList.push(iv)
					//linesMap[i]=iv
					
					iv++;
				}
				else if (t1==4){
					positionsL1[ (iv * 3)+0 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 0 ]+0.0;
					positionsL1[ (iv * 3) + 1 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 1 ]+0.0;
					positionsL1[ (iv * 3) + 2 ] = b5positions[ (idMap[jsonObj2[i][0]][1] * 3) + 2 ]+0.0;
					compartmentL1[ (i*2)+0 ] = b5values_compartment[ (idMap[jsonObj2[i][0]][1]) ];
					opL1[iv]=0.25;
					colorsL1[ iv * 3 ] = 0.0;
					colorsL1[ iv * 3 + 1 ] = 1.0;
					colorsL1[ iv * 3 + 2 ] = 1.0;
					//linesMap[i]=iv
					ivList.push(iv)
					iv++;
				}
				if (t2 ==2){
					positionsL1[ (iv * 3)+0 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
					positionsL1[ (iv * 3) + 1 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
					positionsL1[ (iv * 3) + 2 ] = b3positions[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;
					compartmentL1[ (i*2)+1 ] = b3values_compartment[ (idMap[jsonObj2[i][1]][1]) ];
					opL1[iv]=0.25;
					colorsL1[ iv * 3 ] = 0.0;
					colorsL1[ iv * 3 + 1 ] = 1.0;
					colorsL1[ iv * 3 + 2 ] = 1.0;
					//linesMap[i]=iv
					ivList.push(iv)
					iv++;
				}
				else if (t2 ==4){
					positionsL1[ (iv * 3)+0 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 0 ]+0.0;
					positionsL1[ (iv * 3) + 1 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 1 ]+0.0;
					positionsL1[ (iv * 3) + 2 ] = b5positions[ (idMap[jsonObj2[i][1]][1] * 3) + 2 ]+0.0;
					compartmentL1[ (i*2)+1 ] = b5values_compartment[ (idMap[jsonObj2[i][1]][1]) ];
					opL1[iv]=0.25;
					colorsL1[ iv * 3 ] = 0.0;
					colorsL1[ iv * 3 + 1 ] = 1.0;
					colorsL1[ iv * 3 + 2 ] = 1.0;
					//linesMap[i]=iv
					ivList.push(iv)
					iv++;
				}
				linesMap[i]=ivList
			}
			var radius=400;
			extraLinesCnt=iv;
			for ( var i = segments; i < segments+maxNbTokenModel; i ++ ) {
				
					positionsL1[ (iv * 3)+0 ] = (Math.random() * 2 - 1) * radius;
					positionsL1[ (iv * 3) + 1 ] = 80;
					positionsL1[ (iv * 3) + 2 ] = ((Math.random() * 2 - 1) * radius)+50000;
					compartmentL1[ (i*2)+0 ] = -1;
					opL1[iv]=0.25;
					colorsL1[ iv * 3 ] = 0.33;
					colorsL1[ iv * 3 + 1 ] = 1.0;
					colorsL1[ iv * 3 + 2 ] = 0.33;
					ivList.push(iv)
					//linesMap[i]=iv
					
					iv++;
				
				
				
			}

			bgeometry2.addAttribute( 'position', new THREE.BufferAttribute( positionsL1, 3 ) );	
			bgeometry2.addAttribute( 'ca', new THREE.BufferAttribute( colorsL1, 3 ) );
			bgeometry2.addAttribute( 'op', new THREE.BufferAttribute( opL1, 1 ) );
			bgeometry2.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentL1, 2 ) );

			
			
			bgeometry2.computeBoundingSphere();
		//console.log(bgeometry2);
			mesh = new THREE.Line( bgeometry2, linesShaderMaterial,THREE.LinePieces );
			scene.add( mesh );
			b2lpositions = bgeometry2.attributes.position.array;
				//var colors = bgeometry.attributes.color.array;
			b2lcolors = bgeometry2.attributes.ca.array;
			b2lcompartments=bgeometry2.attributes.compartment.array;
			b2lopacity = bgeometry2.attributes.op.array;
			
			// create and populate geometry with token particles coordinates, colors, and size
			var radius = 300;
			//tokenGeometry = new THREE.CubeGeometry( 0.8 * radius, 0.8 * radius, 0.8 * radius, 150, 100, 1 );
			// populate token geometry with "start" extremities of line segmentPts
			tokenGeometry = new THREE.Geometry();
			for ( var i = 0; i < segmentPts; i +=2 ) {
				tokenGeometry.vertices.push(new THREE.Vector3(b2lpositions[ (i * 3) ]+0,b2lpositions[ (i * 3) + 1 ]+0,b2lpositions[ (i * 3) + 2 ]+0));
			}
			// add models tokens
			for ( var i = segmentPts; i < segmentPts+maxNbTokenModel; i +=2 ) {
				tokenGeometry.vertices.push(new THREE.Vector3(b2lpositions[ (i * 3) ]+0,b2lpositions[ (i * 3) + 1 ]+0,b2lpositions[ (i * 3) + 2 ]+150000));
				
			}
			//var v1 = new THREE.Vector3(0,0,0);
			//var v2 = new THREE.Vector3(0,500,0);
			//var v3 = new THREE.Vector3(0,500,500);

			
			//tokenShaderMaterial.blending = THREE.AdditiveBlending; // "glowing" particles
			tokenPS = new THREE.PointCloud( tokenGeometry, tokenShaderMaterial );
			//tokenPS = new THREE.PointCloud( tokenGeometry, spriteMaterial );
			tokenPS.dynamic = true;
			//sphere.sortParticles = true;

			tvertices = tokenPS.geometry.vertices;
			tvalues_size = tokenAttributes.size.value;
			tvalues_color = tokenAttributes.ca.value;
			tvalues_p = tokenAttributes.endPosition.value;
			for( var v = 0, vv= tvertices.length; v < vv; v++ ) {

				tvalues_size[ v ] = 5;
				tvalues_color[ v ] = new THREE.Color( 0xff7777 );
				//tvalues_p[v]=new THREE.Vector3( 600+(Math.random() * 2 - 1) * radius, (Math.random() * 2 - 1) * radius , (Math.random() * 2 - 1) * radius );	
				//tvalues_p[v]=new THREE.Vector3(b2positions[ (v+1) * 3 ],b2positions[ (v+1) * 3 + 1 ],b2positions[ (v+1) * 3 + 2 ]);
			}
			//for( var v = tvertices.length-2500, vv= tvertices.length; v < vv; v++ ) {

			//	tvalues_size[ v ] = 15;
			//	tvalues_color[ v ] = new THREE.Color( 0xff00ff );
				//tvalues_p[v]=new THREE.Vector3( 600+(Math.random() * 2 - 1) * radius, (Math.random() * 2 - 1) * radius , (Math.random() * 2 - 1) * radius );	
				//tvalues_p[v]=new THREE.Vector3(b2positions[ (v+1) * 3 ],b2positions[ (v+1) * 3 + 1 ],b2positions[ (v+1) * 3 + 2 ]);
			//}
			
			for ( var i = 1; i < segmentPts; i +=2 ) {
				tvalues_p.push(new THREE.Vector3(b2lpositions[ i * 3 ],b2lpositions[ i * 3 + 1 ],b2lpositions[ i * 3 + 2 ]));
			}
			for ( var i = segmentPts+1; i < segmentPts+maxNbTokenModel; i +=2 ) {
				tvalues_p.push(new THREE.Vector3(b2lpositions[ i * 3 ],b2lpositions[ i * 3 + 1 ],b2lpositions[ i * 3 + 2 ]+150000));
			}
			
			//sphere.geometry.__dirtyVertices = true;
			scene.add( tokenPS );
			
			
			
			
			
			// outline mesh for lines
			
			lineGeometry = new THREE.Geometry();
			lineGeometry.vertices.push(new THREE.Vector3(-10000, -10000, -150000));
			lineGeometry.vertices.push(new THREE.Vector3(-10000, -10000, -151000));
			lineGeometry.verticesNeedUpdate = true;
			
			outlineMaterial1 = new THREE.MeshBasicMaterial( { color: 0xff0000} );			
			outlineMesh1 = new THREE.Line( lineGeometry, outlineMaterial1 );	
			//outlineMesh1.scale.multiplyScalar(1.002);
			scene.add( outlineMesh1 );
			
			
			
			var spriteMaterial = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/glow.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false, blending: THREE.AdditiveBlending
			});
			sprite = new THREE.Sprite( spriteMaterial );
			sprite.scale.set(8, 8, 8);
			//crateGlow.add(sprite); // this centers the glow at the mesh
			if (marker==0){
			sprite.position.set(-150000,-10000,10000);
			//sprite.transparent=true;
			}		
			scene.add( sprite );
			
			
			var spriteMaterial2 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/tg2.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false//, blending: THREE.AdditiveBlending
			});
			for (var i=0;i<nbSpritesSelected;i++){
				spritesSelected[i] = new THREE.Sprite( spriteMaterial2 );
				spritesSelected[i].scale.set(100, 100, 100);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				spritesSelected[i].position.set(-150000,-10000,10000);
				
					
				scene.add( spritesSelected[i] );
			}
			
			var spriteMaterial22 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/tg2.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false//, blending: THREE.AdditiveBlending
			});
			for (var i=0;i<modelnbSpritesSelected;i++){
				modelspritesSelected[i] = new THREE.Sprite( spriteMaterial22 );
				modelspritesSelected[i].scale.set(100, 100, 100);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				modelspritesSelected[i].position.set(-150000,-10000,10000);
				
					
				scene.add( modelspritesSelected[i] );
			}
			
			
			
			var spriteMaterial3 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/square_canvas.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false
			});
			for (var i=0;i<nbModelReactionLocators;i++){
				modelReactionLocators[i] = new THREE.Sprite( spriteMaterial3 );
				modelReactionLocators[i].scale.set(40, 40, 40);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				modelReactionLocators[i].position.set(-150000,-10000,10000);
				//modelReactionLocators[i].position.set(400,400,200*i);
					
				scene.add( modelReactionLocators[i] );
			}
			
			var spriteMaterial4 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/product.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false
			});
			for (var i=0;i<nbModelReactionLocators;i++){
				modelProductLocators[i] = new THREE.Sprite( spriteMaterial4 );
				modelProductLocators[i].scale.set(40, 40, 40);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				modelProductLocators[i].position.set(-150000,-10000,10000);
				//modelProductLocators[i].position.set(400,400,200*i);
					
				scene.add( modelProductLocators[i] );
			}
			
			var spriteMaterial5 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/reactant2.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false
			});
			for (var i=0;i<nbModelReactionLocators;i++){
				modelReactantLocators[i] = new THREE.Sprite( spriteMaterial5 );
				modelReactantLocators[i].scale.set(40, 40, 40);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				modelReactantLocators[i].position.set(-150000,-10000,10000);
				//modelProductLocators[i].position.set(400,400,200*i);
					
				scene.add( modelReactantLocators[i] );
			}
			
			var spriteMaterial6 = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/modifier2.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false
			});
			for (var i=0;i<nbModelReactionLocators;i++){
				modelModifierLocators[i] = new THREE.Sprite( spriteMaterial6 );
				modelModifierLocators[i].scale.set(40, 40, 40);
				//crateGlow.add(sprite); // this centers the glow at the mesh
				
				modelModifierLocators[i].position.set(-150000,-10000,10000);
				//modelProductLocators[i].position.set(400,400,200*i);
					
				scene.add( modelModifierLocators[i] );
			}
			
			
			
			
			
			// create skybox
			var mimagePrefix = "/images/";
			var mdirections  = ["p2", "p2", "p2", "p2", "p2", "p2"];
			var mimageSuffix = ".png";
			var mskyGeometry = new THREE.BoxGeometry( 50000, 50000, 50000 );	
			//var cubePath = "/rsi/static/tex/cube/Grid3/";
            //var cubeFormat = ".jpg";
            //var cubeFaces = [cubePath + 'px' + cubeFormat, cubePath + 'nx' + cubeFormat, cubePath + 'py' + cubeFormat, cubePath + 'ny' + cubeFormat, cubePath + 'pz' + cubeFormat, cubePath + 'nz' + cubeFormat];
            //this.gridCubeTex = THREE.ImageUtils.loadTextureCube(cubeFaces);
			var mmaterialArray = [];
			for (var i = 0; i < 6; i++)
				mmaterialArray.push( new THREE.MeshBasicMaterial({
					map: THREE.ImageUtils.loadTexture( mimagePrefix + mdirections[i] + mimageSuffix ),
					side: THREE.BackSide
				}));
			var mskyMaterial = new THREE.MeshFaceMaterial( mmaterialArray );
			var mskyBox = new THREE.Mesh( mskyGeometry, mskyMaterial );
			mskyBox.name="skybox"
			scene.add( mskyBox );
			
			
			
			
			if (nbPlacesModel!=0 && nbReactionsModel!=0){
			
				var cnt1=0;
				var cnt2=0;
				var cnt=0;
				
				//var ln1 = scene.children[2].geometry.attributes.size.array.length-5000; 
				//var ln2 = scene.children[4].geometry.attributes.size.array.length-5000; 
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				//console.log(ln1)
				//console.log(startModelPlaces)
				for (var i= 0; i<selectedModelNodes.length;i++){
					if (selectedModelNodes[i][5]==2 ){
						//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]=((Math.random() * 2 - 1) * 400);
						var rm;
						var rr;
						if (nbReactionsModel<2000){
							rm=cnt1*0.008*2*Math.PI;
							rr=((radius*1.48)-(cnt1*0.2)+1);
						}
						else{
							rm=cnt1*0.004*2*Math.PI;
							rr=((radius*1.88)-(cnt1*0.09)+1);
						}
						//var rm=cnt1*0.008*2*Math.PI;
						//radius=900;
						//var rr = ((radius*1.48)-(cnt1*0.2)+1)
						
						scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]= (Math.cos(rm) *rr)+900;
						scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (Math.sin(rm) *rr);
						scene.children[2].geometry.attributes.compartment.array[(ln1+cnt1)]= selectedModelNodes[i][2];
						//scene.children[2].geometry.attributes.compartment.array[(ln1+cnt1)]= Math.floor(Math.random()*nbCompartments);
						idMap[jsonObj1.length+cnt]=[2,cnt1+ln1]
						//typesMap[2][cnt1]=i;
						cnt1++;
						cnt++;
					}
					else if (selectedModelNodes[i][5]==4 ){
						//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=((Math.random() * 2 - 1) * 400);
						var rm;
						var rr;
						if (nbReactionsModel<2000){
							rm=cnt2*0.008*2*Math.PI;
							rr =((radius*1.480)-(cnt2*0.2)+1);
						}
						else{
							rm=rm=cnt2*0.004*2*Math.PI;
							rr=((radius*1.880)-(cnt2*0.09)+1);
						}
						//var rm=cnt2*0.008*2*Math.PI;
						//radius=600;
						//var rr = ((radius*1.480)-(cnt2*0.2)+1)
						scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(Math.cos(rm) *rr)+1800;
						scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(Math.sin(rm) *rr);
						scene.children[4].geometry.attributes.compartment.array[(ln2+cnt2)]= selectedModelNodes[i][2];
						//scene.children[4].geometry.attributes.compartment.array[(ln2+cnt2)]= Math.floor(Math.random()*nbCompartments);
						idMap[jsonObj1.length+cnt]=[4,cnt2+ln2]
						//typesMap[4][cnt2]=i;
						cnt2++;
						cnt++;
					}
				}
				//console.log(cnt1)
				//console.log(cnt2)
				scene.children[2].geometry.attributes.compartment.needsUpdate = true;
				scene.children[4].geometry.attributes.compartment.needsUpdate = true;
				scene.children[2].geometry.attributes.position.needsUpdate = true;
				scene.children[4].geometry.attributes.position.needsUpdate = true;
				
				var col2 = new THREE.Color( 0xffa500 );
				
				
				//console.log(selectedModelNodes)
				//for (var s= 0; s<selectedModelEdges.length;s++){
				//	if (selectedModelEdges[s][0]==108){
				//	console.log(s)
				//	}
				//}
				//console.log(nbEdgesModel)
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					if (sim2==2){
					//console.log("link between model nodes")
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
					}
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					if (sim2==2){
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
					}
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				selectedLinesPathsIds=[]
				for (var i=0; i<selectedLinesPaths.length;i++){
					for (var j=0;j<linesMap[selectedLinesPaths[i]].length;j+=1){
						selectedLinesPathsIds.push(linesMap[selectedLinesPaths[i]][j])
					}
				}
				selectedLinesPathsIds = unique(selectedLinesPathsIds)
				for (var i=0;i<selectedLinesPathsIds.length;i+=1){
					scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] +=150000;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
					
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					if (i>=segmentPts){
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+150000;
					}
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					if (i>=segmentPts){
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+150000;
					}
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				tokenUniforms.mixAmount.value = 0.0;
			}	
			
			
			
			var geometry = new THREE.SphereGeometry( radiusComp, 50, 15 );

			for ( var i = 0; i < maxNbComp; i ++ ) {
				var object = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: 0x9966ff, ambient: 0x9966ff, // should generally match color
				specular: 0x050505,
				shininess: 200,side: THREE.BackSide}));//THREE.BackSide}));//, transparent: true, opacity: 0.5} ) );
				//var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: (1.0-((i/maxNbComp)*0.5)) * 0xffffff, side: THREE.BackSide}));
				object.material.ambient = object.material.color;
				object.position.x = -99999999;
				object.position.y = -99999999;
				object.position.z = -99999999;
				object.scale.y = 0.5;
				
				scene.add( object );
				objects.push( object );
			}
			
			//mtnlLayout["compartments_layout"]["name-position-scale"]=[];
			//for (var i=0; i<listCompartments.length;i++ ){
			//	mtnlLayout["compartments_layout"]["name-position-scale"][i]=[objects[i].name, objects[i].position , objects[i].scale];
			//}
			for ( var i = 0; i < listCompartments.length; i ++ ) {
				objects[i].position.x = 0;
				objects[i].position.y = 0;
				objects[i].position.z = 0;
				objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
				//stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
				//objects[i].castShadow = true;
				//objects[i].receiveShadow = true;	
			}
			if (mtnlLayout["compartments_layout"] && mtnlLayout["compartments_layout"].hasOwnProperty("name-position-scale")){
				if (mtnlLayout["compartments_layout"]["name-position-scale"].length>0){
					for ( var i = 0; i < mtnlLayout["compartments_layout"]["name-position-scale"].length; i ++ ) {
						objects[i].position.x = mtnlLayout["compartments_layout"]["name-position-scale"][i][1].x;
						objects[i].position.y = mtnlLayout["compartments_layout"]["name-position-scale"][i][1].y;
						objects[i].position.z = mtnlLayout["compartments_layout"]["name-position-scale"][i][1].z;
						objects[i].name = mtnlLayout["compartments_layout"]["name-position-scale"][i][0];
						//stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
						objects[i].scale.x = mtnlLayout["compartments_layout"]["name-position-scale"][i][2].x;
						objects[i].scale.y = mtnlLayout["compartments_layout"]["name-position-scale"][i][2].y;
						objects[i].scale.z = mtnlLayout["compartments_layout"]["name-position-scale"][i][2].z;
					}
				}
			}
			
			if (mtnlLayout["compartments_layout"] && mtnlLayout["compartments_layout"].hasOwnProperty("relations")){
				generalLayout=mtnlLayout["compartments_layout"]["relations"];
			}
			
			
			
			
			
			// add subtle blue ambient lighting
			var ambientLight = new THREE.AmbientLight(0x000027);
			  
			scene.add(ambientLight);
			  
			// directional lighting
			directionalLight = new THREE.DirectionalLight(0x55ffff); 
			directionalLight.position.set(13, 1, 1).normalize();
			ambientLight.name="dlight"
			scene.add(directionalLight);
			
			
			
			
			
			projector = new THREE.Projector();
			raycaster = new THREE.Raycaster();
			
			//renderer = new THREE.WebGLRenderer( { alpha: false } );
			//renderer.setSize( WIDTH, HEIGHT );
			
			//ray = new THREE.Ray();
			

			renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
			//renderer.sortObjects = false;
			renderer.setSize( window.innerWidth, window.innerHeight );
			//renderer.setSize( parseInt(window.innerWidth*0.99), window.innerHeight );
			
			pip = document.createElement('div');
			pip.style.width = window.innerWidth*0.6;
			pip.style.height = window.innerHeight*0.15;
			pip.style.position = 'absolute';
			pip.style.backgroundColor = 'black';
			pip.style.borderRadius = "5px";
			pip.style.border = '2px solid white';
			pip.style.padding = "0px 20px";
			pip.style.left = "2000px";
			pip.style.top = "2000px";
			document.body.appendChild(pip);
			
			//renderer2 = new THREE.WebGLRenderer({ antialias: true, alpha: false });
			//renderer.sortObjects = false;
			//renderer2.setSize( window.innerWidth*0.6, window.innerHeight*0.15 );
			//pip.appendChild(renderer2.domElement);
			
			//var container2 = document.createElement( 'div' );
			//document.body.appendChild(container2);
			//container2.appendChild( rendererCSS3.domElement );
			
			var container = document.getElementById( 'container' );
			
			container.appendChild( renderer.domElement );
			positionContainer = $("#container").position();
			var menu = document.getElementById( 'menu' )
			menu.style.position="absolute";
			menu.style.right="0px";
			menu.style.bottom=(0-positionContainer.top)+"px";//(positionContainer.top-positionContainer.height-30)+"px";
			//console.log( "left: " + position.left + ", top: " + position.top );
			
			//container.appendChild( rendererCSS2.domElement );
			
			
			controls = new THREE.OrbitControls( camera, container  );
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;
				
			
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			
			container.appendChild( stats.domElement );
			stats.domElement.style.top = ($("#container").height()-60)+'px';
			
			
			function stopEvents(){
				stopThreeJsMouseEvent=true;
			}
			function resumeEvents(){
				stopThreeJsMouseEvent=false;
			}
			//gui.domElement.onmouseenter = stopEvents;
			//gui.domElement.onmouseleave = resumeEvents;
			
			
			
	
			
			window.addEventListener( 'resize', onWindowResize, false );
			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			document.addEventListener( 'mousedown', onDocumentMouseDown, false );
			document.addEventListener( 'mouseup', onDocumentMouseUp, false );
			
			
			var button = document.getElementById( 'view4' );
			button.addEventListener( 'click', function ( event ) {
				//console.log("view3");
				
				if (toggledLines==0){
					//console.log(scene.children[7].geometry.attributes.compartment.array.length);
					//for ( var iv = 0; iv < scene.children[7].geometry.attributes.position.array.length; iv +=2) {
					for ( var iv = 0; iv <extraLinesCnt; iv +=2) {
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] -=150000;
						scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] -=150000;
					}
					
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					toggledLines=1
				}
				else{
					//for ( var iv = 0; iv < scene.children[7].geometry.attributes.position.array.length; iv +=2) {
					for ( var iv = 0; iv <extraLinesCnt; iv +=2) {
						scene.children[7].geometry.attributes.position.array[ (iv * 3) + 2 ] +=150000;
						scene.children[7].geometry.attributes.position.array[ ((iv+1) * 3) + 2 ] +=150000;
					}
					
					scene.children[7].geometry.attributes.position.needsUpdate = true;
					
					
					toggledLines=0
				}

			}, false );
			
			var button = document.getElementById( 'view5' );
		button.addEventListener( 'click', function ( event ) {
			//console.log("view3");
			
			if (toggledToken==0){
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					//scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y-=150000;
					//scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					//tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y-=150000;
					//tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				tokenUniforms.mixAmount.value = 0.0;
				//var ii=0;
				//for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				//	tokenAttributes.mixAmount.value[ii] = 0.0;
				//	ii++;
				//}
				//tokenAttributes.mixAmount.needsUpdate = true;
				toggledToken=1
			}
			else{
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					//scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y+=150000;
					//scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					//tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y+=150000;
					//tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				tokenUniforms.mixAmount.value = 0.0;
				//var ii=0;
				//for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				//	tokenAttributes.mixAmount.value[ii] = 0.0;
				//	ii++;
				//}
				//tokenAttributes.mixAmount.needsUpdate = true;
				toggledToken=0
			}

		}, false );
		
		
			
			
			
			
		}
		
		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		}
		
		function onDocumentMouseMove( event ) {
		
			//event.preventDefault();
			//position = window.pageYOffset+$("#container").position();//+;
			
			mouse.x = ( (event.clientX+window.pageXOffset) / window.innerWidth ) * 2 - 1;
			mouse.y = - ( (event.clientY-$("#container").position().top+window.pageYOffset) / window.innerHeight ) * 2 + 1;

		}
		
		function unique(a){
			var arr = [];
			for (var i=0;i<a.length;i++){
				if ( arr.indexOf(a[i]) == -1){
					arr.push(a[i]);
				}
			}
			return arr
		}
		
		function onDocumentMouseDown( event ) {

				//event.preventDefault();
				
				switch ( event.button ) {
					case 0: // left 
					
						if	((isOnParticle==1) && (hoveredType>=0) && (stopThreeJsMouseEvent==false) ){
							closestid =closest;
							closestType=hoveredType;
							//parameters.size=scene.children[closestType].geometry.attributes.size.array[closestid];
							//colorParticleGui.r=scene.children[closestType].geometry.attributes.ca.array[closestid*3+0];
							//colorParticleGui.g=scene.children[closestType].geometry.attributes.ca.array[closestid*3+1];
							//colorParticleGui.b=scene.children[closestType].geometry.attributes.ca.array[closestid*3+2];
							//parameters.color='#' +('000000'+colorParticleGui.getHex().toString(16)).slice(-6);
							
							//myLinkName=""+jsonObj1[typesMap[closestType][closestid]][2]
							//var mlTile= document.getElementById( 'myLink' )
							//mlTile.innerHTML=myLinkName
							//mlTile.href=null
							//var ml=[]
							//for (var ln =0; ln<10;ln++){
								//ml[ln] = document.getElementById( 'myLink'+ln )
								
							//}
							
							//ml.innerHTML=myLinkName
							
							//for (var ln =0; ln<10;ln++){
							//	myLink[ln]=null
								//myLink[ln]=jsonObj1[typesMap[closestType][closestid]].encodedBy[ln]
								//ml[ln].innerHTML=""
								//ml[ln].href=myLink[ln]
							//}
							//console.log(closestid)
							//console.log(typesMap[closestType][closestid])
							
							
							//var dat =typesMap[listretPointsTypes[myr]][closest];
							//if(jsonObj1[dat]){
							//	stringTxt = jsonObj1[dat][0]+" "+jsonObj1[dat][2];
							//	if (jsonObj1[dat][4][1] && jsonObj1[dat][4][1][0]){
							//		stringTxt = jsonObj1[dat][0]+" "+jsonObj1[dat][2]+" ("+jsonObj1[dat][4][1][0]+")";
							//	}
								
							//}
							//else{
							//	if (listretPointsTypes[myr]==2){																
							//		stringTxt = " "+selectedModelNodes[dat-jsonObj1.length][1];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
							//	}
							//	else if (listretPointsTypes[myr]==4){											
							//			stringTxt = " "+selectedModelNodes[nbPlacesModel+dat-jsonObj1.length][1];
							//	}
								//else{stringTxt = " ";}
							//}
							
							//console.log(jsonObj1[typesMap[closestType][closestid]])
							var nbS2=0
							try{
								text0.innerHTML = ""+jsonObj1[typesMap[closestType][closestid]][2];
								text0.style.top = positionContainer.top +10+ 'px';
								text0.style.left = 20 + 'px';
								
								
								var txtListGenes = '<ul style="margin-left:0em;padding-left:1.3em;height:50px;">';
								for (var ln =0; ln<jsonObj1[typesMap[closestType][closestid]][4][0].length;ln++){
									myLink[ln]=jsonObj1[typesMap[closestType][closestid]][4][0][ln]
									//ml[ln].innerHTML=myLink[ln].substring(myLink[ln].lastIndexOf("/")+1);;
									txtListGenes += '<li ><a href="'+myLink[ln]+'" target="_blank">'+myLink[ln].substring(myLink[ln].lastIndexOf("/")+1);+'</a></li>';
									//ml[ln].href=myLink[ln]
								}
								txtListGenes += '</ul>';
								listGenesContent.innerHTML = txtListGenes;
								if (jsonObj1[typesMap[closestType][closestid]][4][0].length<=0){
									listGenes.style.top = 2000 + 'px';
									listGenes.style.left = 2000 + 'px';
								}else{
									listGenes.style.top = (text0.clientHeight+positionContainer.top) +40+ 'px';
									listGenes.style.left = 20 + 'px';
									//text0.style.top = (listGenes.clientHeight+positionContainer.top) + 'px';
								}
							}
							catch(e){
								var stringTxt;
								var tpId;
								if (closestType==2){	
									tpId=typesMap[closestType][closestid]-jsonObj1.length;					
									stringTxt = " "+selectedModelNodes[tpId][1];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
								}
								else if (closestType==4){	
									tpId=nbPlacesModel+typesMap[closestType][closestid]-jsonObj1.length;
									stringTxt = " "+selectedModelNodes[tpId][1];
								}
								text0.innerHTML = ""+stringTxt;//selectedModelNodes[typesMap[closestType][closestid]-jsonObj1.length];
								text0.style.top = positionContainer.top +10+ 'px';
								text0.style.left = 20 + 'px';
								var identifier=typesMap[closestType][closestid]
								var txtListLinks = '<ul style="margin-left:0em;padding-left:1.3em;height:150px;">';
								//if (selectedModelNodesPaths.indexOf(tpId)!=-1){
								//	selectedModelNodesPaths.splice(selectedModelNodesPaths.indexOf(tpId),1)
								//}
								//else{
								//	selectedModelNodesPaths.push(tpId)
									for (var i=0; i<selectedModelEdges.length;i++){
										if (selectedModelEdges[i][0]==tpId){
												
												// if selectedModelEdges[i][2]=0 then reactant , if 2 then modifier, if 1 then product
												if(selectedModelEdges[i][2]==0){
													txtListLinks += '<li >'+"transition with consumed pre-place: "+selectedModelNodes[selectedModelEdges[i][1]][1]+'</li>';
													nbS2+=1;
												}
												else if (selectedModelEdges[i][2]==1){
													txtListLinks += '<li >'+"transition with non-consumed pre-place: "+selectedModelNodes[selectedModelEdges[i][1]][1]+'</li>';
													nbS2+=1;
												}
												else if (selectedModelEdges[i][2]==2){
													txtListLinks += '<li >'+"transition with product post-place: "+selectedModelNodes[selectedModelEdges[i][1]][1]+'</li>';
													nbS2+=1;
												}
												else{
													txtListLinks += '<li >'+"place linked to metabolic network reaction: "+jsonObj1[selectedModelEdges[i][1]][2]+'</li>';
													nbS2+=1;
												}
										}
										if (selectedModelEdges[i][1]==tpId){
												// if selectedModelEdges[i][2]=0 then reactant , if 2 then modifier, if 1 then product
												if(selectedModelEdges[i][2]==0){
													txtListLinks += '<li >'+"as consumed pre-place in transition: "+selectedModelNodes[selectedModelEdges[i][0]][1]+'</li>';
													nbS2+=1;
												}
												else if (selectedModelEdges[i][2]==1){
													txtListLinks += '<li >'+"as non-consumed pre-place in transition: "+selectedModelNodes[selectedModelEdges[i][0]][1]+'</li>';
													nbS2+=1;
												}
												else if (selectedModelEdges[i][2]==2){
													txtListLinks += '<li >'+"as post-place in transition: "+selectedModelNodes[selectedModelEdges[i][0]][1]+'</li>';
													nbS2+=1;
												}
												else{
													txtListLinks += '<li >'+"as anomaly: "+selectedModelEdges[i]+'</li>';
													nbS2+=1;
												}
										}
									}
									txtListLinks += '</ul>';
									//console.log(txtListLinks);
									listLinksContent.innerHTML =txtListLinks;
								//}
								
							}
							
							var nbS=0
							var txtListLinks2 = '<ul style="margin-left:0em;padding-left:1.3em;height:150px;">';
							var identifier=typesMap[closestType][closestid]
							
							//console.log(selectedModelEdges[iv-extraLinesCnt][1]);
							
							
							/*if (selectedModelNodesPaths.indexOf(identifier-jsonObj1.length)!=-1){
								selectedModelNodesPaths.splice(selectedModelNodesPaths.indexOf(identifier-jsonObj1.length),1)
								for (var i=0; i<selectedModelEdges.length;i++){
									if (selectedModelEdges[i][0]==identifier-jsonObj1.length){
										selectedModelLinesPaths.splice(selectedModelLinesPaths.indexOf(i),1)
									}
									if (selectedModelEdges[i][1]==identifier-jsonObj1.length){
										selectedModelLinesPaths.splice(selectedModelLinesPaths.indexOf(i),1)
									}
								}
							} else{
								selectedModelNodesPaths.push(identifier-jsonObj1.length)
								for (var i=0; i<selectedModelEdges.length;i++){
									if (selectedModelEdges[i][0]==identifier-jsonObj1.length){
										selectedModelLinesPaths.push(i)
										txtListLinks += '<li >'+selectedModelNodes[selectedModelEdges[i][1]][1]+'</li>';
										nbS+=1;
									}
									if (selectedModelEdges[i][1]==identifier){
										selectedModelLinesPaths.push(i)
										txtListLinks += '<li >'+selectedModelNodes[selectedModelEdges[i][1]][1]+'</li>';
										nbS+=1;
									}
								}
					
							}*/
							
							//if (selectedNodesPaths.indexOf(identifier)!=-1){
							//	selectedNodesPaths.splice(selectedNodesPaths.indexOf(identifier),1)
							//	for (var i=0; i<jsonObj2.length;i++){
							//		if (jsonObj2[i][0]==identifier){
							//			selectedLinesPaths.splice(selectedLinesPaths.indexOf(i),1)
							//		}
							//		if (jsonObj2[i][1]==identifier){
							//			selectedLinesPaths.splice(selectedLinesPaths.indexOf(i),1)
							//		}
							//	}
							//} else{
							//	selectedNodesPaths.push(identifier)
								for (var i=0; i<jsonObj2.length;i++){
									if (jsonObj2[i][0]==identifier){
										//selectedLinesPaths.push(i)
										txtListLinks2 += '<li >'+jsonObj1[jsonObj2[i][1]][2]+'</li>';
										nbS+=1;
									}
									if (jsonObj2[i][1]==identifier){
										//selectedLinesPaths.push(i)
										txtListLinks2 += '<li >'+jsonObj1[jsonObj2[i][0]][2]+'</li>';
										nbS+=1;
									}
								}
					
							//}
							//for (var i=0; i<selectedLinesPathsIds.length;i++){
							//	scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] -=150000;
							//}
							//selectedLinesPathsIds=[]
							//for (var i=0; i<selectedLinesPaths.length;i++){
							//	for (var j=0;j<linesMap[selectedLinesPaths[i]].length;j+=1){
							//		selectedLinesPathsIds.push(linesMap[selectedLinesPaths[i]][j])
							//	}
							//}
							//selectedLinesPathsIds = unique(selectedLinesPathsIds)
							//for (var i=0;i<selectedLinesPathsIds.length;i+=1){
							//	scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] +=150000;
							//}
							//scene.children[7].geometry.attributes.position.needsUpdate = true;
							txtListLinks2 += '</ul>';
							//
							if (nbS==0 && nbS2==0){
								listLinks.style.top = 2000 + 'px';
								listLinks.style.left = 2000 + 'px';
							}else{
								if (nbS!=0){
									listLinksContent.innerHTML =txtListLinks2;
								}
								
								//listLinksContent.width=$("#container").width;
								//listLinksContent.height=$("#container").height+positionContainer.top;
								//listLinks.width=$("#container").width;
								//listLinks.height=$("#container").height+positionContainer.top;
								//listLinks.style.width=$("#container").width;
								//listLinks.style.height=$("#container").style.height;
								listLinks.style.overflow="auto";
								listLinks.style.top = (listGenes.clientHeight+positionContainer.top)+40 + 'px';
								listLinks.style.left = 20 + 'px';
							}
							//console.log(selectedLinesPathsIds)
						}
						else if (isOnLine==1 && isOnParticle==0 && stopThreeJsMouseEvent==false){
							parameters.name="line";
							closestType=hoveredType;
							closestid =closestLine;
							parameters.size=0;
							
							colorParticleGui.r=scene.children[closestType].geometry.attributes.ca.array[closestid*3+0];
							colorParticleGui.g=scene.children[closestType].geometry.attributes.ca.array[closestid*3+1];
							colorParticleGui.b=scene.children[closestType].geometry.attributes.ca.array[closestid*3+2];
							parameters.color='#' +('000000'+colorParticleGui.getHex().toString(16)).slice(-6);
							
						}
						else{
							var onDraggableNb = 0;
							listLinksContent.innerHTML="";
							text0.innerHTML ="";
							listGenesContent.innerHTML="";
							if (nbS==0){
								listLinks.style.top = 6000 + 'px';
								listLinks.style.left = 6000 + 'px';
								listGenes.style.top = 6000 + 'px';
								listGenes.style.left = 6000 + 'px';
							}
						}
							//parameters.name="";
						break;
					case 1: // middle
						break;
					case 2: // right
						break;
				}
				
					
				

				
			}
		function onDocumentMouseUp( event ) {
			switch ( event.button ) {
			
				case 0:
					break;
				case 1: // middle
					break;
				case 2: // right
					break;
			}
		}
		//function onMouseMove( e ) {

		//		mouse.x = e.clientX;
		//		mouse.y = e.clientY;

		//	}
		function animate() {

			requestAnimationFrame( animate );

			render();
			
			
			
			stats.update();

		}
		
		function toXYCoords (pos) {
			//var vector = projector.projectVector(pos.clone(), camera);
			var vector = pos.clone().project(camera);
			vector.x = (vector.x + 1)/2 * window.innerWidth;
			vector.y = -(vector.y - 1)/2 * window.innerHeight;
			return vector;
		}

		function render() {
			//var delta = clock.getDelta(); 
			//animatorT1.update(1500 * delta);
			
			//cssScene2.children[0].direction=camera.direction;
			//element1.position.x = camera.position.x;
			//element1.position.y = camera.position.y;
			//element1.position.z = camera.position.z;
			controls.update();
			keyboard.update();
			
			
			if ( keyboard.pressed("A") ) {
			
				controls.panLeft(5* controls.zoomScale());
			}
			if ( keyboard.pressed("D") ) {
				controls.panLeft(-5* controls.zoomScale());
			}
				
			if ( keyboard.pressed("W") ) {
				controls.panUp(5* controls.zoomScale());
			}
				
			if ( keyboard.pressed("S") ){
				controls.panUp(-5* controls.zoomScale());
			} 
			
			if ( keyboard.pressed("X") ) {
				controls.dollyIn();
			}
				
			if ( keyboard.pressed("Z") ){
				//controls.pan(-5* controls.zoomScale(),0);
				controls.dollyOut();
			} 
			if ( keyboard.down("1") ){
				if (linesShaderMaterial.depthTest){
					linesShaderMaterial.depthTest = false;
				}
				else{
					linesShaderMaterial.depthTest = true;
				}
			} 
			if ( keyboard.down("2") ){
				if (linesShaderMaterial.blending){
					linesShaderMaterial.blending = false;
				}
				else{
					linesShaderMaterial.blending = THREE.AdditiveBlending;
				}
			} 
			if ( keyboard.down("3") ){
				if (linesShaderMaterial.transparent){
					linesShaderMaterial.transparent = false;
				}
				else{
					linesShaderMaterial.transparent = true;
				}
			} 
			if ( keyboard.down("]") ){
				for (var i=0;i<segmentPts;i++){
				//for (var i=0;i<b2lopacity.length;i++){
					if (b2lopacity[i]<1.0){
					b2lopacity[i]+=0.05;
					}
				}
				scene.children[7].geometry.attributes.op.needsUpdate = true;
				//if (linesUniforms.opacity.value<1.0){
				//	linesUniforms.opacity.value+=0.05;
				//}
				//console.log("opacity: "+linesUniforms.opacity.value);
				//consol.log("+")
					//linesShaderMaterial.transparent = false;
					//linesShaderMaterial.linesUniforms.attributes.opacity+=0.1;
				//linesUniforms.opacity.value=1.0;
				//linesUniforms.opacity.value+=0.05;
				//linesUniforms.color.value.offsetHSL( 0.0005, 0, 0 );
				//linesUniforms.amplitude.value+=0.1;
			} 
			if ( keyboard.down("[")){//linesShaderMaterial.opacity-=0.1;
				//if (linesUniforms.opacity.value>0.0){
				//	linesUniforms.opacity.value-=0.05;
				//}
				for (var i=0;i<segmentPts;i++){
				//for (var i=0;i<b2lopacity.length;i++){
					if (b2lopacity[i]>0.0){
					b2lopacity[i]-=0.05;
					}
				}
				scene.children[7].geometry.attributes.op.needsUpdate = true;
				//console.log("opacity: "+linesUniforms.opacity.value);
					//linesUniforms.opacity.value-=0.05;
					//linesUniforms.color.value.offsetHSL( -0.0005, 0, 0 );
					//linesUniforms.amplitude.value-=0.1;
			} 
				
			//if (mtween)
				//camTween.update();
			TWEEN.update();
			//var time = Date.now() * 0.005;

			//PointCloud1.rotation.z = 0.01 * time;
			if (stopThreeJsMouseEvent==false){
			if (flagPick==1){
				var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
				//projector.unprojectVector( vector, camera );
				vector.unproject(camera );
				raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
				var distance=99999999;
				var listretPointsIndexes=[];
				var listretPointsDistances=[];	
				var listretPointsTypes=[];	
				var listretPointsIndexesL=[];
				var listretPointsDistancesL=[];	
				var listretPointsTypesL=[];	
				var point = new THREE.Vector3(0,0,0);		
				var myray=raycaster.ray;
				var point1 = new THREE.Vector3(0,0,0);	
				var point2 = new THREE.Vector3(0,0,0);
				
				
				for(var i=0, ii=scene.children.length;i<ii;i++){
					
					for (var partT=0;partT<7;partT++){
					// mouse hover detect particle
					if (scene.children[i] instanceof THREE.PointCloud && (i==partT)){
						var a1 = scene.children[i].geometry.attributes.position.array;
						var a2 = scene.children[i].geometry.attributes.size.array;
						particles = a2.length;
						var a3 = scene.children[i].geometry.attributes.ca.array;
						
						for(var j=0;j<particles;j++){
							point.x = (a1[j*3]);
							point.y = (a1[j*3+1]);
							point.z = (a1[j*3+2]);
							distance = myray.distanceToPoint(point);
							if ( distance <=2 ) {
								listretPointsIndexes.push(j);
								listretPointsDistances.push(distance);	
								listretPointsTypes.push(i);	
							}
						}
						
					}
					/*if (scene.children[i] instanceof THREE.Mesh ){
						for (var nc=0;nc<nbCompartments;nc++){
							if (scene.children[i] instanceof THREE.Mesh && scene.children[i].name=="c"+nc){
								//console.log(scene.children[i])
								var ptMesh = scene.children[i].position;
								var meshdistance = myray.distanceToPoint(point);
								if (meshdistance)<=2
								console.log(ptMesh)
							}
						}
					}*/
					
					
					}
					var h1 = listretPointsDistances.length;
					var myr;
					var mymin = Math.min.apply(Math, listretPointsDistances);
					var v1=0;
					while(h1--){
						if (listretPointsDistances[h1]==mymin){
							myr=h1;
								}
								if (myr==h1)
									break;
								
					}						
					closest = listretPointsIndexes[myr];
					if (closest>=0){
						//console.log(listretPointsTypes[myr]);
						if (listretPointsTypes[myr]>=0)
							sprite.position.set(scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3],scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3+1],scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3+2]);	
						//console.log(closest);
						//console.log(i);
						isOnParticle=1;
							//cssObject.element.children[1].textContent=""+closest;//.element.symbol.textContent=closest;
							
							if (listretPointsTypes[myr]>=0){
								
								var pp = toXYCoords(sprite.position);
								
								if ((text1PreviousPos.x != pp.x) && (text1PreviousPos.y != pp.y)){
									//console.log(text1PreviousPos)
									//console.log(listretPointsTypes[myr])
									// display 2d text in html in screen 2s coordinate corresponding to near the 3d position... 
									//camera.updateMatrixWorld() ;
									//text1.firstChild.value=""+jsonObj1[typesMap[listretPointsTypes[myr]][closest]][2];
									text1.style.top = (pp.y+positionContainer.top )+ 'px';								
									text1.style.left = (pp.x -(text1.firstChild.length*8))-18+ 'px';
									text1PreviousPos = pp;
									var stringTxt="";
									var dat =typesMap[listretPointsTypes[myr]][closest];
									if(jsonObj1[dat]){
										stringTxt = jsonObj1[dat][0]+" "+jsonObj1[dat][2];
										if (jsonObj1[dat][4][1] && jsonObj1[dat][4][1][0]){
											stringTxt = jsonObj1[dat][0]+" "+jsonObj1[dat][2]+" ("+jsonObj1[dat][4][1][0]+")";
										}
										
									}
									else{
										if (listretPointsTypes[myr]==2 ){	
											if(typeof selectedModelNodes[dat-jsonObj1.length] == "undefined"){
												stringTxt = " ";
											}
											else {
												stringTxt = " "+selectedModelNodes[dat-jsonObj1.length][1];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
											}
										}
										else if (listretPointsTypes[myr]==4){											
											//stringTxt = " "+selectedModelNodes[nbPlacesModel+dat-jsonObj1.length][1];
											if(typeof selectedModelNodes[nbPlacesModel+dat-jsonObj1.length] == "undefined"){
												stringTxt = " ";
											}
											else {
												stringTxt = " "+selectedModelNodes[nbPlacesModel+dat-jsonObj1.length][1];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
											}
										}
										//else{stringTxt = " ";}
									}
									if (text1PreviousString!=stringTxt){
										text1.innerHTML=stringTxt;
										text1PreviousString=stringTxt;
									}
									//text1.innerHTML=stringTxt;
									/*else{
										//text1.innerHTML = " ";
										if (listretPointsTypes[myr]==2){												
											text1.innerHTML = " "+selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
										}
										if (listretPointsTypes[myr]==4){
											text1.innerHTML = " "+selectedModelNodes[nbPlacesModel+typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length];
										}
									}*/
									/*try{
										
									text1.innerHTML = ""+jsonObj1[typesMap[listretPointsTypes[myr]][closest]][2];		
																		
									
									}
									catch(e){
										text1.innerHTML = " ";
										try{
											//var ln1 = startModelPlaces;
											//var ln2 = startModelReactions;
											//selectedModelNodes[i][5]==2
											//var Ptype= idMap[closest][0];
											//var Pindex= idMap[closest][1];
											//text1.innerHTML = " "+idMap[closest];
											if (listretPointsTypes[myr]==2){
												
												text1.innerHTML = " "+selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length];//selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
												//console.log(selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length]);
												//console.log(selectedModelNodes);
											}
											if (listretPointsTypes[myr]==4){
												text1.innerHTML = " "+selectedModelNodes[nbPlacesModel+typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length];
											//	text1.innerHTML = " "+selectedModelNodes[nbPlacesModel+typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
											}
											
											//typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length;
											//+selectedModelNodes[typesMap[listretPointsTypes[myr]][closest]-jsonObj1.length][1];
										}
										catch(e1){
											
										}
									
									}*/
								}
								else{
									text1.style.top =  (text1PreviousPos.y+positionContainer.top )+ 'px';								
									text1.style.left = text1PreviousPos.x -(text1.firstChild.length*8)-18+ 'px';
								}
							}
							
							//try{
							//cssObject.element.children[1].textContent=""+jsonObj1[typesMap[listretPointsTypes[myr]][closest]][2];
							//	cssObject.element.children[2].textContent=particleClass[listretPointsTypes[myr]];
								hoveredType=listretPointsTypes[myr];
								//}
							//catch(err){
							//}
					}
					else{
						sprite.position.set(-10000,-10000,-150000);
						//if (text1.style.top == (2000 + 'px')){
						//else{
						//	text1.style.top = 2000 + 'px';
						//	text1.style.left = 2000 + 'px';
						//}
						//text1.style.top = 2000 + 'px';
						//text1.style.left = 2000 + 'px';
						
						isOnParticle=0;		
						if (isOnLine==0 && noKeggCube){
						
						textk.style.top = 2000 + 'px';
						textk.style.left = 2000 + 'px';
						//cssObject.element.children[1].textContent="";
						//cssObject.element.children[2].textContent="";
						hoveredType=-1
						}
					}
					
					
					// mouse hover detect line
					//if (scene.children[i] instanceof THREE.Line && i==7){
					//		var a1 = scene.children[i].geometry.attributes.position.array;
					//		var a2 = scene.children[i].geometry.attributes.ca.array;
					//		var interSegment = new THREE.Vector3();
					//		var interRay = new THREE.Vector3();
							
					//		for(var j=0, jj= segmentPts;j<jj;j+=2){
					//			point1.x = (a1[j*3]); point1.y = (a1[(j*3)+1]); point1.z = (a1[(j*3)+2]);
					//			point2.x = (a1[(j+1)*3]); point2.y = (a1[((j+1)*3)+1]); point2.z = (a1[((j+1)*3)+2]);
					//			distance = myray.distanceSqToSegment( point1, point2, interRay, interSegment );
					//			if ( distance <=4 ) {
					//				listretPointsIndexesL.push(j);
					//				listretPointsDistancesL.push(distance);	
					//			}
					//		}
					//		var h1 = listretPointsDistancesL.length;
					//		var myr;
					//		var mymin = Math.min.apply(Math, listretPointsDistancesL);
					//		var v1=0;
					//		while(h1--){
					//			if (listretPointsDistancesL[h1]==mymin){
					//				myr=h1;
					//			}
					//			if (myr==h1)
					//				break;
									
					//			}						
					//		closestLine = listretPointsIndexesL[myr];
					//		if (closestLine>=0){
					//			isOnLine=1;
					//			if (isOnParticle==0){
					//				cssObject.element.children[1].textContent=""+closestLine;//.element.symbol.textContent=closest;
					//				cssObject.element.children[2].textContent="Line";
									
								// set position of outline mesh
					//			outlineMesh1.geometry.vertices[0].x=a1[closestLine*3]; outlineMesh1.geometry.vertices[0].y=a1[closestLine*3+1]; outlineMesh1.geometry.vertices[0].z=a1[closestLine*3+2];
					//			outlineMesh1.geometry.vertices[1].x=a1[(closestLine+1)*3]; outlineMesh1.geometry.vertices[1].y=a1[(closestLine+1)*3+1]; outlineMesh1.geometry.vertices[1].z=a1[(closestLine+1)*3+2];
					//			lineGeometry.verticesNeedUpdate = true;
					//			hoveredType=7;
					//			}
								//
					//		}
					//		else{//sprite.position.set(-10000,-10000,10000);	
					//			//cssObject.element.children[1].textContent="e";
					//			outlineMesh1.geometry.vertices[0].x=-10000; outlineMesh1.geometry.vertices[0].y=-10000; outlineMesh1.geometry.vertices[0].z=-50000;
					//			outlineMesh1.geometry.vertices[1].x=-10000; outlineMesh1.geometry.vertices[1].y=-10000; outlineMesh1.geometry.vertices[1].z=-51000;
					//			lineGeometry.verticesNeedUpdate = true;isOnLine=0;
					//		}
							
							
					//}
				}
				if (isOnParticle==0 ){
					text1.style.top = 2000 + 'px';
					text1.style.left = 2000 + 'px';
					//pip.style.top = 2000 + 'px';
					//pip.style.left = 2000 + 'px';
				}
				//else{
				//pip.style.top = 50 + 'px';
				//	pip.style.left = 25 + 'px';
				//}
				var intersects = raycaster.intersectObjects( scene.children );
				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].object ) {

						//if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
						if (INTERSECTED instanceof THREE.Mesh ){
							
							if (INTERSECTED.name.charAt(0)=="k"){
								noKeggCube=false;
								INTERSECTED.material.color.setHex( 0xffdd33 );
								var pp = toXYCoords(INTERSECTED.position);
								if (textkPreviousPos != pp){
									//console.log(closest)
									//console.log(listretPointsTypes[myr])
									// display 2d text in html in screen 2s coordinate corresponding to near the 3d position... 
									//camera.updateMatrixWorld() ;
									//text1.firstChild.value=""+jsonObj1[typesMap[listretPointsTypes[myr]][closest]][2];
									textk.innerHTML = ""+keggCubesProperties[INTERSECTED.name][0]+"  - value:" + keggCubesProperties[INTERSECTED.name][1];		
									textk.style.top = pp.y + 'px';								
									textk.style.left = (pp.x -(text1.firstChild.length*8))+20+ 'px';
									textkPreviousPos = pp;
									
									
								}
								//console.log(keggCubesProperties[INTERSECTED.name])
							}
							else if(INTERSECTED.name=="skybox"){
								noKeggCube=true;
								INTERSECTED = null;
								container.style.cursor = 'auto';
								
								
							}
							else{container.style.cursor = 'auto';
							noKeggCube=true;
							for ( var k = 0; k < previousKeggLength; k ++ ) {
								cubesGeometry[k].material.color.setHex( 0xff0000 );
							}
							}
						
						}
						//INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						//

					}

				} else {

					//if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
					noKeggCube=true;
					INTERSECTED = null;
					container.style.cursor = 'auto';
					

				}
				
				flagPick=0;
				
				
			}
			else
				flagPick++;
			}	
			
			
			var t = clock.getElapsedTime();
			
			
			
			
			
			//for (var ii=0;ii<erasingArray.length;ii++){
			//tokenAttributes.mixAmount.value[stackTokenModel[ii][1]]=0;
			//stackTokenModel.splice(erasingArray[ii],1);
			//}
			//var t = clock.getElapsedTime();
			//tokenUniforms.mixAmount.value = 0.5 * (1.0 + Math.sin(t));
			//console.log(stackTokenModel.length)
			tokenUniforms.mixAmount.value = 0.5 * (1.0 + Math.sin(t));
			//var ii=0;
			//for ( var i = 0; i <segmentPts ; i +=2 ) {
			//	tokenAttributes.mixAmount.value[i] = 0.5 * (1.0 + Math.sin(t));
			//}
			/*for (var ii=0;ii<stackTokenModel.length;ii++) {
				
					if (stackTokenModel[ii]){
						//for (var j =0;j<stackTokenModel[ii].length;j++){
						if (stackTokenModel[ii][0]){
							if (stackTokenModel[ii][0]<1){
								stackTokenModel[ii][0]+=0.005;
								tokenAttributes.mixAmount.value[stackTokenModel[ii][2]]=stackTokenModel[ii][j][0];
							}
							if (stackTokenModel[ii][0]>=1){
								
								//tokenAttributes.mixAmount.value[ii]=0;
								tokenAttributes.mixAmount.value[stackTokenModel[ii][2]]=0;
								stackTokenModel.splice(ii,1);
								tokenStackCount-=1;
								//console.log(tokenStackCount);
							}
						}
						//}

					
					}
				
			}*/
			
				//ii++;
			//}
			// trigger start of token from/to reactions
			//if (simData && simTimer<simData.length){
			//console.log("trigger: "+simData[1][simTimer][2])
			//}
			
			//tokenAttributes.mixAmount.needsUpdate = true;
			//var tokenPoses =tokenAttributes.mixAmount.value;
			//for ( var i = 1; i <segmentPts ; i +=2 ) {
			//	
			//}
			//rendererCSS.render( cssScene, camera2 );
			//rendererCSS3.render( cssScene3, camera2 );
			//rendererCSS2.render( cssScene2, camera2 );
			renderer.render( scene, camera );
			//renderer2.render( scene2, camera2 );
			
			if (idsOfSelectedRows.length>0){
				for (var i =0;i<spritesSelected.length;i++){		
					spritesSelected[i].position.set(-150000,-10000,10000);
					spritesSelected[i].scale.set(100, 100, 100);
				}
				
				for (var i =0;i<idsOfSelectedRows.length;i++){
					if (i<spritesSelected.length){
						var a1 = scene.children[idMap[idsOfSelectedRows[i]][0]].geometry.attributes.position.array;
						//console.log(idMap[idsOfSelectedRows[i]])
						spritesSelected[i].position.set(a1[idMap[idsOfSelectedRows[i]][1]*3],a1[idMap[idsOfSelectedRows[i]][1]*3+1],a1[idMap[idsOfSelectedRows[i]][1]*3+2]);			
					}
				}
				for (var i =0;i<idsOfSelectedRows.length;i++){
					//for (var j =0;j<spritesSelected.length;j++){
					if (i<spritesSelected.length){
						var dx= camera.position.x-spritesSelected[i].position.x
						var dy= camera.position.y-spritesSelected[i].position.y
						var dz= camera.position.z-spritesSelected[i].position.z
						var dc = Math.sqrt(((dx*dx) + (dy*dy)))
						var ds = Math.sqrt((dc*dc) + (dz*dz))
						var mult = ((ds/100)*5)+20
						spritesSelected[i].scale.set(mult, mult, mult);
					}
				}
			}
			else{
				for (var i =0;i<spritesSelected.length;i++){		
					spritesSelected[i].position.set(-150000,-10000,10000);
					spritesSelected[i].scale.set(100, 100, 100);
				}
			}
			
			if (idsOfModelSelectedRows.length>0){
				for (var i =0;i<modelspritesSelected.length;i++){		
					modelspritesSelected[i].position.set(-150000,-10000,10000);
					modelspritesSelected[i].scale.set(100, 100, 100);
				}
				var anb=jsonObj1.length;
				for (var i =0;i<idsOfModelSelectedRows.length;i++){
					if (i<modelspritesSelected.length){
						var a1 = scene.children[idMap[parseInt(idsOfModelSelectedRows[i])+anb][0]].geometry.attributes.position.array;
						//console.log(idMap[(jsonObj1.length+1)])
						//console.log(jsonObj1.length)
						//console.log(parseInt(idsOfModelSelectedRows[i]))
						//console.log(idMap[parseInt(idsOfModelSelectedRows[i])+anb]);
						modelspritesSelected[i].position.set(a1[idMap[parseInt(idsOfModelSelectedRows[i])+anb][1]*3],a1[idMap[parseInt(idsOfModelSelectedRows[i])+anb][1]*3+1],a1[idMap[parseInt(idsOfModelSelectedRows[i])+anb][1]*3+2]);			
					}
				}
				for (var i =0;i<idsOfModelSelectedRows.length;i++){
					//for (var j =0;j<spritesSelected.length;j++){
					if (i<modelspritesSelected.length){
						var dx= camera.position.x-modelspritesSelected[i].position.x
						var dy= camera.position.y-modelspritesSelected[i].position.y
						var dz= camera.position.z-modelspritesSelected[i].position.z
						var dc = Math.sqrt(((dx*dx) + (dy*dy)))
						var ds = Math.sqrt((dc*dc) + (dz*dz))
						var mult = ((ds/100)*5)+20
						modelspritesSelected[i].scale.set(mult, mult, mult);
					}
				}
			}
			else{
				for (var i =0;i<modelspritesSelected.length;i++){		
					modelspritesSelected[i].position.set(-150000,-10000,10000);
					modelspritesSelected[i].scale.set(100, 100, 100);
				}
			}
		/*if(typeof(Storage)!=="undefined") {
			
				if(resetSpreadsheet==true){localStorage.selection=[];}
				if (localStorage.selection==""){
					mselectedList=[]
					//console.log("empty")
					for (var i =0;i<spritesSelected.length;i++){		
						spritesSelected[i].position.set(-50000,-10000,10000);
					}
				
				}
				else if (localStorage.selection.length>0 ){
					//console.log(mselectedList); 
					//console.log(localStorage.selection.split(",").map(function(x){return parseInt(x)})); 
					
					var tmpS= localStorage.selection.split(",").map(function(x){return parseInt(x)});
					
					if(!($(tmpS).not(mselectedList).length == 0 && $(mselectedList).not(tmpS).length == 0)) {
					//	console.log(localStorage.selection); 
						mselectedList=[];
						for (var i =0;i<tmpS.length;i++){
						mselectedList[i] =tmpS[i];
						}
						//console.log(mselectedList); 
						//console.log(camera.position)
						// highlight selection
						for (var i =0;i<spritesSelected.length;i++){		
							spritesSelected[i].position.set(-50000,-10000,10000);
							spritesSelected[i].scale.set(100, 100, 100);
						}
						//if(resetSpreadsheet==true){
						//resetSpreadsheet=false;
						//}
						//else{
						for (var i =0;i<mselectedList.length;i++){
							//for (var j =0;j<spritesSelected.length;j++){
							if (i<spritesSelected.length){
								//spritesSelected
								//console.log(idMap[mselectedList[i]])
								var a1 = scene.children[idMap[mselectedList[i]][0]].geometry.attributes.position.array;
								spritesSelected[i].position.set(a1[idMap[mselectedList[i]][1]*3],a1[idMap[mselectedList[i]][1]*3+1],a1[idMap[mselectedList[i]][1]*3+2]);	
								//var dx= camera.position.x-spritesSelected[i].position.x
								//var dy= camera.position.y-spritesSelected[i].position.y
								//var dz= camera.position.z-spritesSelected[i].position.z
								//var dc = Math.sqrt(((dx*dx) + (dy*dy)))
								//var ds = Math.sqrt((dc*dc) + (dz*dz))
								//var mult = ((ds/100)*5)+50
								//spritesSelected[i].scale.set(mult, mult, mult);
								//console.log(ds)
								
							}
							
						}
						
						//}
						
					}
				
					for (var i =0;i<mselectedList.length;i++){
							//for (var j =0;j<spritesSelected.length;j++){
							if (i<spritesSelected.length){
								var dx= camera.position.x-spritesSelected[i].position.x
								var dy= camera.position.y-spritesSelected[i].position.y
								var dz= camera.position.z-spritesSelected[i].position.z
								var dc = Math.sqrt(((dx*dx) + (dy*dy)))
								var ds = Math.sqrt((dc*dc) + (dz*dz))
								var mult = ((ds/100)*5)+20
								spritesSelected[i].scale.set(mult, mult, mult);
							}
					}
					   
				}
			//else if 	(resetSpreadsheet==true){
			//	for (var i =0;i<spritesSelected.length;i++){		
			//				spritesSelected[i].position.set(-50000,-10000,10000);
			//				spritesSelected[i].scale.set(100, 100, 100);
			//			}
			//	resetSpreadsheet=false;
			//}		
        }*/
		
		
		if 	(resetSpreadsheet==true){
		resetSpreadsheet=false;
		}
		
		var tokenIDStackCountSize=Object.keys(tokenIDStackCount).length
		if( reactionIsDone && (simModeValue==1)){
			for (var tkNb=0; tkNb< tokenIDStackCountSize;tkNb++){
				
				var tmp=tokenIDStackCount[Object.keys(tokenIDStackCount)[tkNb]];
				
				//console.log(tokenIDStackCount[tkNb])
				txtReactionActivation[tkNb].innerHTML = ''+tmp[0];
				var vectorp = new THREE.Vector3( tmp[1],tmp[2],tmp[3]);
				vectorp.x +=10;
				var ppv = toXYCoords(vectorp	);
				txtReactionActivation[tkNb].style.top = (ppv.y+positionContainer.top) + 'px';
				txtReactionActivation[tkNb].style.left = ppv.x + 'px';
									//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
				
				
				
			}
		}
		else if( simModeValue==0){
			for (var tkNb=0; tkNb< tokenIDStackCountSize;tkNb++){
				
				var tmp=tokenIDStackCount[Object.keys(tokenIDStackCount)[tkNb]];
				
				//console.log(tokenIDStackCount[tkNb])
				txtReactionActivation[tkNb].innerHTML = ''+tmp[0];
				var vectorp = new THREE.Vector3( tmp[1],tmp[2],tmp[3]);
				vectorp.x +=10;
				var ppv = toXYCoords(vectorp	);
				txtReactionActivation[tkNb].style.top = (ppv.y+positionContainer.top) + 'px';
				txtReactionActivation[tkNb].style.left = ppv.x + 'px';
									//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
				//planeMesh[tkNb].position.set(0,0,50000);
				
				
			}
		}
		else{
			for (var tkNb=0; tkNb< tokenIDStackCountSize;tkNb++){
				
				
				txtReactionActivation[tkNb].innerHTML = '';
				//var vectorp = new THREE.Vector3( tmp[1],tmp[2],tmp[3]);
				//vectorp.x +=10;
				//var ppv = toXYCoords(vectorp	);
				//txtReactionActivation[tkNb].style.top = ppv.y + 'px';
				//txtReactionActivation[tkNb].style.left = ppv.x + 'px';
									//txtReactionActivation[cntLabels].innerHTML = ''+tokenIDStackCount[simRow[rw][2]];
				
				
				
			}
		}
		
		//meshLineChart.direction=controls.direction;
		//meshLineChart.position.x=controls.target.x;
		//meshLineChart.position.y=controls.target.y;
		//meshLineChart.position.z=controls.target.z;
		//console.log(controls.target);
		//meshLineChart.lookAt(camera.position);
			//meshLineChart.position.set(camera.position);
			//meshLineChart.position.z+=400;
			//meshLineChart.direction=camera.direction;
		//mselectedList=[]
					//console.log("empty")
		//			for (var i =0;i<spritesSelected.length;i++){		
		//				spritesSelected[i].position.set(-50000,-10000,10000);
		//			}
		//}	
		
		// place labels for compartments
			var poscont = $("#container");
			var cnt_merged_comp={};
			for ( var i = 0; i < listCompartments.length; i ++ ) {
				//cnt_merged=0;
				var vector = new THREE.Vector3( objects[i].position.x+(radiusComp*objects[i].scale.x),objects[i].position.y,objects[i].position.z);
				var pp = toXYCoords(vector	);
				
				if (pp.x >=0 && pp.y >=0 && pp.x <=poscont.width()-10 && pp.y <=poscont.height()-10){
					document.getElementById("txt"+i).style.top = (pp.y+poscont.position().top+(0*12)) + 'px';
					document.getElementById("txt"+i).style.left = (pp.x +20)+ 'px';
				}
				else{
					document.getElementById("txt"+i).style.top = 4000 + 'px';
					document.getElementById("txt"+i).style.left = 4000+ 'px';
				}
				for (var ref in generalLayout["merged"]){
					if (generalLayout["merged"].hasOwnProperty(ref)){
						if (objects[i].name==ref){
							document.getElementById("txt"+i).style.top = (pp.y+poscont.position().top+(0*12)) + 'px';
							document.getElementById("txt"+i).style.left = (pp.x +20)+ 'px';
						}
						for (var j=0;j<generalLayout["merged"][ref].length;j++){
							if (objects[i].name==generalLayout["merged"][ref][j]){
								 document.getElementById("txt"+i).style.top = (pp.y+poscont.position().top+((j+1)*12)) + 'px';
								 document.getElementById("txt"+i).style.left = (pp.x +20)+ 'px';
							}
						}
					}
				}
				// for (el in list_merged_chains){
					// if (list_merged_chains.hasOwnProperty(el)){
						// if (objects[i].name==el){
							// document.getElementById("txt"+i).style.top = (pp.y+poscont.position().top+(0*12)) + 'px';
							// document.getElementById("txt"+i).style.left = (pp.x +20)+ 'px';
						// }
						// for (var j=0;j<list_merged_chains[el].length;j++){
							// if (objects[i].name==list_merged_chains[el][j]){
								// document.getElementById("txt"+i).style.top = (pp.y+poscont.position().top+((j+1)*12)) + 'px';
								// document.getElementById("txt"+i).style.left = (pp.x +20)+ 'px';
							// }
							
						// }
					// }
				// }					
				document.getElementById("txt"+i).innerHTML = objects[i].name;			
			}
		

		}
		
		
var mydata0=[];
var sz=selectedModelNodes.length;
//console.log(selectedModelNodes)
for (var i=0;i<sz;i++){
	mydata0.push({chkBoxState:false,"id":selectedModelNodes[i][0], "name":selectedModelNodes[i][1],  "type":(selectedModelNodes[i][5]==4) ? "Transition":"Place", "sub-system":"" });
}
		
var mydata = [];
//for(var i=0;i<=20000;i++){
//mydata.push({id: ""+i,invdate:"2007-10-01",name:"test",note:"note",amount:"200.00",tax:"10.00",total:"210.00"});
//}
var sz=selectedMetabolicData[1].length  
for (var i=0;i<sz;i++){
	mydata.push({chkBoxState:false,"id":selectedMetabolicData[1][i][0], "name":selectedMetabolicData[1][i][1], "description":selectedMetabolicData[1][i][2], "comp":selectedMetabolicData[1][i][3],"type":(selectedMetabolicData[1][i][6]==4) ? "Reaction":"Metabolite", "sub-system":(selectedMetabolicData[1][i][6]==4 && selectedMetabolicData[1][i][4][1][0]) ? selectedMetabolicData[1][i][4][1][0]:"" });
}

$("#dataTable0").css({top:  $("#container").height()+$("#container").position().top+40, left:0, width:$("#container").width()});
$("#dataTable").css({top:  $("#container").height()+$("#container").position().top+350+40, left:0, width:$("#container").width()});


jQuery("#list0").jqGrid({
	datatype: "local",
	data: mydata0,
	height: 250,
	width: ($("#container").width()*0.9),
   	colNames:["id", "name","type","sub-system"],
   	colModel:[
		
   		{name:'id',index:'id', width:30, sorttype:"int",searchoptions:{sopt:['eq','cn']}},
   		{name:'name',index:'name', width:100,sorttype:'string', searchoptions:{sopt:['eq','cn','bw']},editable:true},
   		{name:'type',index:'type', width:25,sorttype:'string', searchoptions:{sopt:['eq','cn']},editable:true},
   		{name:'sub-system',index:'sub-system', width:100,sorttype:'string', searchoptions:{sopt:['cn']},editable:true},
   	],
   	recordpos: 'left',
	scroll: 1,
  //enable npage request parameter
  //prmNames: { npage: 'npage' },
	scrollrows: true, 
	rowNum: 12,
	rowList:[],
    viewrecords: true,
    sortorder: "desc",
	ignoreCase: true,
	multiselect: true,
                onSelectRow: function (id, isSelected) {
                    var p = this.p, item = p.data[p._index[id]], i = $.inArray(id, idsOfModelSelectedRows);
                    item.cb = isSelected;
                    if (!isSelected && i >= 0) {
                        idsOfModelSelectedRows.splice(i,1); // remove id from the list
                    } else if (i < 0) {
                        idsOfModelSelectedRows.push(id);
                    }
                },
                loadComplete: function () {
                    var p = this.p, data = p.data, item, $this = $(this), index = p._index, rowid, i, selCount;
                    for (i = 0, selCount = idsOfModelSelectedRows.length; i < selCount; i++) {
                        rowid = idsOfModelSelectedRows[i];
                        item = data[index[rowid]];
                        if ('cb' in item && item.cb) {
                            $this.jqGrid('setSelection', rowid, false);
                        }
                    }
                },

	gridview: true,
	//cellEdit: true,
	loadonce: true,
   	caption: "QSSPN Model: list of selectable nodes (places and transitions)"
});
jQuery("#list0").jqGrid('filterToolbar',{searchOperators : true});


jQuery("#list4").jqGrid({
	datatype: "local",
	data: mydata,
	height: 250,
	width: ($("#container").width()*0.9),
   	colNames:["id", "name","description","comp","type","sub-system","mute"],
   	colModel:[
		
   		{name:'id',index:'id', width:30, sorttype:"int",searchoptions:{sopt:['eq','cn']}},
   		{name:'name',index:'name', width:100,sorttype:'string', searchoptions:{sopt:['eq','cn','bw']},editable:true},
		{name:'description',index:'description', width:100,sorttype:'string', searchoptions:{sopt:['cn','nc','bw']},editable:true},
   		{name:'comp',index:'comp', width:20,sorttype:'string', searchoptions:{sopt:['eq']},editable:true},
   		{name:'type',index:'type', width:25,sorttype:'string', searchoptions:{sopt:['eq','cn']},editable:true},
   		{name:'sub-system',index:'sub-system', width:100,sorttype:'string', searchoptions:{sopt:['cn']},editable:true},
		{name:'mute',index:'mute', width:15,sorttype:'boolean',editable:true, searchoptions:{sopt:['eq']},edittype:'checkbox', editoptions: { value:"True:False"}, formatter: "checkbox", formatoptions: {disabled : false}},
	],
   	recordpos: 'left',
	scroll: 1,
  //enable npage request parameter
  //prmNames: { npage: 'npage' },
	scrollrows: true, 
	rowNum: 12,
	rowList:[],
    viewrecords: true,
    sortorder: "desc",
	
	multiselect: true,
                onSelectRow: function (id, isSelected) {
                    var p = this.p, item = p.data[p._index[id]], i = $.inArray(id, idsOfSelectedRows);
                    item.cb = isSelected;
                    if (!isSelected && i >= 0) {
                        idsOfSelectedRows.splice(i,1); // remove id from the list
                    } else if (i < 0) {
                        idsOfSelectedRows.push(id);
                    }
                },
                loadComplete: function () {
                    var p = this.p, data = p.data, item, $this = $(this), index = p._index, rowid, i, selCount;
                    for (i = 0, selCount = idsOfSelectedRows.length; i < selCount; i++) {
                        rowid = idsOfSelectedRows[i];
                        item = data[index[rowid]];
                        if ('cb' in item && item.cb) {
                            $this.jqGrid('setSelection', rowid, false);
                        }
                    }
					for (i = 0, selCount = selectedNodesPaths.length; i < selCount; i++) {
						rowid = parseInt(selectedNodesPaths[i]);
						$this.jqGrid('setCell', index[rowid],7, "True");
					}
                },
	ignoreCase: true,
	gridview: true,
	//cellEdit: true,
	loadonce: true,
   	caption: "Metabolic network: list of selectable nodes (metabolites and reactions)"
});
jQuery("#list4").jqGrid('filterToolbar',{searchOperators : true});

var checkboxFix = [];
jQuery(document).delegate('#list4 .jqgrow td input', 'click', function () { 
	//console.log("a")
	var iCol = $(this).parent('td').parent('tr').find('td').index($(this).parent('td'));
	if (iCol==7){
		//console.log(iCol)
		var iRow = $(this).parent('td').parent('tr').attr('id');
		
		
		var identifier=iRow;
		if (selectedNodesPaths.indexOf(identifier)!=-1){
			selectedNodesPaths.splice(selectedNodesPaths.indexOf(identifier),1)
			for (var i=0; i<jsonObj2.length;i++){
				if (jsonObj2[i][0]==identifier){
					selectedLinesPaths.splice(selectedLinesPaths.indexOf(i),1)
				}
				if (jsonObj2[i][1]==identifier){
					selectedLinesPaths.splice(selectedLinesPaths.indexOf(i),1)
				}
			}
		} else{
			selectedNodesPaths.push(identifier)
			for (var i=0; i<jsonObj2.length;i++){
				if (jsonObj2[i][0]==identifier){
					selectedLinesPaths.push(i)
					//txtListLinks += '<li >'+jsonObj1[jsonObj2[i][1]][2]+'</li>';
					//nbS+=1;
				}
				if (jsonObj2[i][1]==identifier){
					selectedLinesPaths.push(i)
					//txtListLinks += '<li >'+jsonObj1[jsonObj2[i][0]][2]+'</li>';
					//nbS+=1;
				}
			}

		}
		for (var i=0; i<selectedLinesPathsIds.length;i++){
			scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] -=5000000;
		}
		selectedLinesPathsIds=[]
		for (var i=0; i<selectedLinesPaths.length;i++){
			for (var j=0;j<linesMap[selectedLinesPaths[i]].length;j+=1){
				selectedLinesPathsIds.push(linesMap[selectedLinesPaths[i]][j])
			}
		}
		selectedLinesPathsIds = unique(selectedLinesPathsIds)
		for (var i=0;i<selectedLinesPathsIds.length;i+=1){
			scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] +=5000000;
		}
		scene.children[7].geometry.attributes.position.needsUpdate = true;
		
		
		//console.log(iRow)
		//console.log($(this)[0].checked)
	}
	//console.log(iCol)
});


//for(var i=0;i<=mydata.length;i++)
//	jQuery("#list4").jqGrid('addRowData',i+1,mydata);
/*
// get nb of reaction nodes per sub-system
var chartData={};
var tnbReactions=0;
for (var i=0;i<sz;i++){
	if (selectedMetabolicData[1][i][6]==4 && selectedMetabolicData[1][i][4][1][0]){
		tnbReactions++;
		var sn =selectedMetabolicData[1][i][4][1][0];
		//if (chartData[sn] in chartData){
			if (chartData.hasOwnProperty(sn)) {
				chartData[selectedMetabolicData[1][i][4][1][0]]+=1;
			}
		//}
		else{
			chartData[selectedMetabolicData[1][i][4][1][0]]=1;
		}
		
	}
	//mydata.push({chkBoxState:false,"id":selectedMetabolicData[1][i][0], "name":selectedMetabolicData[1][i][1], "description":selectedMetabolicData[1][i][2], "comp":selectedMetabolicData[1][i][3],"type":(selectedMetabolicData[1][i][6]==4) ? "Reaction":"Metabolite", "sub-system":(selectedMetabolicData[1][i][6]==4 && selectedMetabolicData[1][i][4][1][0]) ? selectedMetabolicData[1][i][4][1][0]:"" });
}
var plotchartdata=[];
for (elem in chartData){
	if (chartData.hasOwnProperty(elem)) {
		plotchartdata.push({name: elem, val: chartData[elem]});
	}
}
//console.log(chartData);
//var chartData = [
//    {name: "A", val: 11975},  
//];

var w = 500,
    h = 500,
    r = Math.min(w, h) / 2,
    labelr = r + 10, // radius for label anchor
    color = d3.scale.category20(),
    donut = d3.layout.pie(),
    arc = d3.svg.arc().innerRadius(r * .6).outerRadius(r);
$("#titlechart").css({top:  $("#dataTable").position().top + $("#list4").height()+170});
$("#chart").css({top: 100});

var vis = d3.select("#chart")
  .append("svg:svg")
    .data([plotchartdata])
    .attr("width", w + 150)
    .attr("height", h+150);
	
var ctext;
var arcs = vis.selectAll("g.arc")
    .data(donut.value(function(d) { return d.val }))
  .enter().append("svg:g")
    .attr("class", "arc")
    .attr("transform", "translate(" + (r + 30) + "," + r + ")");

arcs.append("svg:path")
    .attr("fill", function(d, i) { return color(i); })
    .attr("d", arc)
	.on('mouseover', function(d) {
					d3.select(this).transition().duration(300)
					.style({'stroke-opacity':1,'stroke':'#F00', 'stroke-width':2});
                    $("#mytooltip")
                      .html("<b>"+d.data.name+"</b><br>"+d.data.val+" reaction nodes<br>"+((d.data.val/tnbReactions)*100).toFixed(2)+"%")
					  .css('left', window.event.clientX+40)
                      .css('top', window.event.clientY)
                      .show();
    })
	//.on('mousemove', function(d) {
    //                $("#mytooltip")
    //                  .css('left', window.event.clientX+40)
    //                  .css('top', window.event.clientY)//(+$("#container").position().top+window.pageYOffset))
    //            })
	.on("mouseout", function(d) {
               $("#mytooltip").html('').hide();
			   d3.select(this).transition().duration(300)
				.style({'stroke-opacity':0.4,'stroke':'#eee','stroke-width':1});
    });

*/
$("#modelSpreadSheet").css({top:  $("#dataTable").position().top + $("#list4").height()+170, width:$("#container").width()});
//var dataJson={"places" : [], "qssf" : { "constraints" : [], "externality_tag" :null,"objectives" : []}, "transitions" : []};
var dataJson=<%-JSON.stringify(qm.file)%>;
var dataJsonSfba=<%-JSON.stringify(qm.sfba)%>;
//console.log(JSON.stringify(dataJson).length)
//console.log(dataJson)




var presentTransitionNb=-1;
var presentPrePlaceNb=-1;
var presentConstraintNb=-1;
var presentObjectiveNb=-1;

var $container1 = $("#placesTable");
$container1.handsontable({
  data: [],
  width: 750,
  height:200,
  dataSchema: {name: null, state: null, type: null, max:null, subsystem:null},
  startRows: 5,
  startCols: 5,
  colHeaders: ['Name', 'State', 'Type','Max','Sub-system'],
  columns: [
    {data: "name"},
    {data: "state"},
    {data: "type"},
    {data: "max"},
	{data: "subsystem"}
  ],
  afterChange: function(changes, source) {
    //console.log(this.getData());
	var dt = this.getData();
	for (var i=0, j= dt.length;i<j-1;i++){
		if (dataJson["places"].length <i+1){
			dataJson["places"].push({"place":{	"max" : dt[i].max,"name" : dt[i].name,"state" : dt[i].state,"type" : dt[i].type,"subsystem" : dt[i].subsystem} });
		}
		else dataJson["places"][i]={"place":{	"max" : dt[i].max,"name" : dt[i].name,"state" : dt[i].state,"type" : dt[i].type,"subsystem" : dt[i].subsystem} };
	}
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//console.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
	//console.log(dataJson)
  },
  minSpareRows: 1
});

var tempdata1=new Array(dataJson["places"].length);
for (var i=0, j=dataJson["places"].length; i<j;i++){
	tempdata1[i]=new Array(5);
	tempdata1[i][0]=dataJson["places"][i]["place"]["name"];
	tempdata1[i][1]=dataJson["places"][i]["place"]["state"];
	tempdata1[i][2]=dataJson["places"][i]["place"]["type"];
	tempdata1[i][3]=dataJson["places"][i]["place"]["max"];
	tempdata1[i][4]=dataJson["places"][i]["place"]["subsystem"];
}
//console.log(tempdata1)
var ht = $('#placesTable').handsontable('getInstance');
if ($.isArray(tempdata1) && tempdata1[0] && $.isArray(tempdata1[0])){
	ht.populateFromArray (0, 0, tempdata1,tempdata1.length-1, 3);
}
/*var newColumnSettings = [
    {data: "name", readOnly: true},
    {data: "state"},
    {data: "type"},
    {data: "max"},
	{data: "subsystem"}
  ];
ht.updateSettings({ columns: newColumnSettings });*/
  
var $container2 = $("#transitionsTable");
$container2.handsontable({
  data: [],
  width: 750,
  height:200,
  colWidths: [350, 50, 50, 50,100],
  dataSchema: {name: null, delay: null, type: null, c:null ,prePlaces:null,consumed:null, postPlaces:null , subsystem:null },
  startRows: 5,
  startCols: 5,
  colHeaders: ['Name', 'Delay','Type','c','Sub-system'],
  columns: [
    {data: "name"},
    {data: "delay"},
    {data: "type"},
    {data: "c"},
	{data: "subsystem"}
  ],
  afterSelection : function(rowNb, colNb) {
	presentTransitionNb=rowNb;
	document.getElementById("t1").innerHTML = 'Pre-places List for transition nb:'+rowNb+ ', name:'+this.getDataAtCell(rowNb,0);
	document.getElementById("t2").innerHTML = 'Consumed List for transition nb:'+rowNb+ ', name:'+this.getDataAtCell(rowNb,0);
	document.getElementById("t3").innerHTML = 'Post-places List for transition nb:'+rowNb+ ', name:'+this.getDataAtCell(rowNb,0);
	if(dataJson["transitions"][presentTransitionNb]){
		//dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"]=[{	"preplace" : {	"activity" : [{ "a" : 0.0, "t" : 1.0}],"name" : "dNTPs","stoichiometry" : 1.0}}];
		/*if(dataJson["transitions"][presentTransitionNb]["transition"] && dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"]){
			var dt=dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"];
			var ht = $('#prePlacesTable').handsontable('getInstance');
			ht.clear();
			var tmpT= new Array(dt.length);
			for (var i=0, j= dt.length;i<j;i++){
					tmpT[i]=new Array(2);
					tmpT[i][0]=dt[i]["preplace"]["name"];
					tmpT[i][1]=dt[i]["preplace"]["stoichiometry"];
			}	
			//console.log(tmpT)
			if ($.isArray(tmpT) && tmpT[0] && $.isArray(tmpT[0])){
				ht.populateFromArray (0, 0, tmpT,tmpT.length-1, 1)
			}
		}*/
		if(dataJson["transitions"][presentTransitionNb]["transition"]){ 
			if (dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"]){
				var dt=dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"];
				var ht = $('#prePlacesTable').handsontable('getInstance');
				ht.clear();
				var tmpT= new Array(dt.length);
				for (var i=0, j= dt.length;i<j;i++){
						tmpT[i]=new Array(2);
						tmpT[i][0]=dt[i]["preplace"]["name"];
						tmpT[i][1]=dt[i]["preplace"]["stoichiometry"];
				}	
				//console.log(tmpT)
				if ($.isArray(tmpT) && tmpT[0] && $.isArray(tmpT[0])){
					ht.populateFromArray (0, 0, tmpT,tmpT.length-1, 1)
				}
				
				if(presentPrePlaceNb!=-1 && dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]){
					//console.log(dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb])
					if (dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"]){
						var dt=dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"];
						
						var tmpT= new Array(dt.length);
						for (var i=0, j= dt.length;i<j;i++){
								tmpT[i]=new Array(2);
								tmpT[i][0]=dt[i]["a"];
								tmpT[i][1]=dt[i]["t"];
						}	
						var ht = $('#activityTable').handsontable('getInstance');
						ht.clear();
						if ($.isArray(tmpT) && tmpT[0] && $.isArray(tmpT[0])){
							ht.populateFromArray (0, 0, tmpT,tmpT.length-1, 1);
						}
					}
					else{
						//var ht = $('#activityTable').handsontable('getInstance');
						//ht.clear();
					}
				}
				else{
					//var ht = $('#activityTable').handsontable('getInstance');
					//ht.clear();
				}
				
				
				
			}
			else{
				var ht = $('#prePlacesTable').handsontable('getInstance');
				ht.clear();
				//var ht = $('#activityTable').handsontable('getInstance');
				//ht.clear();
			}
			
			if (dataJson["transitions"][presentTransitionNb]["transition"]["consumed"]){
				var dt=dataJson["transitions"][presentTransitionNb]["transition"]["consumed"];
				var ht = $('#consumedTable').handsontable('getInstance');
				ht.clear();
				var tmpT= new Array(dt.length);
				for (var i=0, j= dt.length;i<j;i++){
						tmpT[i]=new Array(1);
						tmpT[i][0]=dt[i]["consumed_preplace"]["name"];
				}	
				//console.log(tmpT)
				if ($.isArray(tmpT) && tmpT[0] && $.isArray(tmpT[0])){
					ht.populateFromArray (0, 0, tmpT,tmpT.length-1, 1)
				}
				
			}
			else{
				var ht = $('#consumedTable').handsontable('getInstance');
				ht.clear();
			}
			
			if (dataJson["transitions"][presentTransitionNb]["transition"]["postplaces"]){
				var dt=dataJson["transitions"][presentTransitionNb]["transition"]["postplaces"];
				var ht = $('#postPlacesTable').handsontable('getInstance');
				ht.clear();
				var tmpT= new Array(dt.length);
				for (var i=0, j= dt.length;i<j;i++){
						tmpT[i]=new Array(2);
						tmpT[i][0]=dt[i]["postplace"]["name"];
						tmpT[i][1]=dt[i]["postplace"]["stoichiometry"];
				}	
				//console.log(tmpT)
				if ($.isArray(tmpT) && tmpT[0] && $.isArray(tmpT[0])){
					ht.populateFromArray (0, 0, tmpT,tmpT.length-1, 1)
				}
				
			}
			else{
				var ht = $('#postPlacesTable').handsontable('getInstance');
				ht.clear();
			}
			
			
		}
		
		
		else{
			var ht = $('#prePlacesTable').handsontable('getInstance');
			ht.clear();
			var ht = $('#consumedTable').handsontable('getInstance');
			ht.clear();
		}
	}
	else{
		var ht = $('#prePlacesTable').handsontable('getInstance');
		ht.clear();
		var ht = $('#consumedTable').handsontable('getInstance');
		ht.clear();
	}
  },
  afterChange: function(changes, source) {
    //console.log(this.getData());
	var dt = this.getData();
	for (var i=0, j= dt.length;i<j-1;i++){
		if (dataJson["transitions"].length <i+1){
			dataJson["transitions"].push({"transition":{ "name" : dt[i].name,"delay" : dt[i].delay,"type" : dt[i].type,"c" : dt[i].c,"subsystem" : dt[i].subsystem}});
		}
		else {
			dataJson["transitions"][i]["transition"]["name"]=dt[i].name;
			dataJson["transitions"][i]["transition"]["delay"]=dt[i].delay;
			dataJson["transitions"][i]["transition"]["type"]=dt[i].type;
			dataJson["transitions"][i]["transition"]["c"]=dt[i].c;
			dataJson["transitions"][i]["transition"]["subsystem"]=dt[i].subsystem;
		}
	}
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//console.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
	
	//console.log(dataJson)
	//console.log(dataJson);
	//dataJson.places.push()
  },
  minSpareRows: 1
});

var tempdata2=new Array(dataJson["transitions"].length);
for (var i=0, j=dataJson["transitions"].length; i<j;i++){
	tempdata2[i]=new Array(4);
	tempdata2[i][0]=dataJson["transitions"][i]["transition"]["name"];
	tempdata2[i][1]=dataJson["transitions"][i]["transition"]["delay"];
	tempdata2[i][2]=dataJson["transitions"][i]["transition"]["type"];
	tempdata2[i][3]=dataJson["transitions"][i]["transition"]["c"];
}
//console.log(tempdata1)
var ht = $('#transitionsTable').handsontable('getInstance');
if ($.isArray(tempdata2) && tempdata2[0] && $.isArray(tempdata2[0])){
	ht.populateFromArray (0, 0, tempdata2,tempdata2.length-1, 3);
}
/*var newColumnSettings = [
    {data: "name", readOnly: true},
    {data: "delay"},
    {data: "type"},
    {data: "c"},
	{data: "subsystem"}
  ];
ht.updateSettings({ columns: newColumnSettings });
*/

var $container3 = $("#postPlacesTable");
$container3.handsontable({
  data: [],
  width: 400,
  height:200,
  dataSchema: {name: null, stoichiometry: null  },
  startRows: 5,
  startCols: 4,
  colHeaders: ['Name', 'Stoichiometry'],
  columns: [
    {data: "name"},
    {data: "stoichiometry"},
  ],
  afterChange: function(changes, source) {
	if(dataJson["transitions"][presentTransitionNb] && dataJson["transitions"][presentTransitionNb]["transition"]){
		var dt = this.getData();
		
		if (dataJson["transitions"][presentTransitionNb]["transition"]["postplaces"]){
			for (var i=0, j= dt.length;i<j-1;i++){
				if (dataJson["transitions"][presentTransitionNb]["transition"]["postplaces"].length <i+1){
					dataJson["transitions"][presentTransitionNb]["transition"]["postplaces"].push({"postplace":{	"name" : dt[i].name, "stoichiometry" : dt[i].stoichiometry} });
				}
				else{
					dataJson["transitions"][presentTransitionNb]["transition"]["postplaces"][i]["postplace"]["name"]=dt[i].name;
					dataJson["transitions"][presentTransitionNb]["transition"]["postplaces"][i]["postplace"]["stoichiometry"]=dt[i].stoichiometry;
				}
			}
		}
		else{
			dataJson["transitions"][presentTransitionNb]["transition"]["postplaces"]=[];
			for (var i=0, j= dt.length;i<j-1;i++){
				dataJson["transitions"][presentTransitionNb]["transition"]["postplaces"].push({"postplace":{	"name" : dt[i].name, "stoichiometry" : dt[i].stoichiometry} });
			}
		}
		//console.log(dataJson["transitions"][presentTransitionNb]["transition"]["consumed"])
		
	}
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//console.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
	
  },
  minSpareRows: 1
});
var $container4 = $("#prePlacesTable");
$container4.handsontable({
  data: [],
  width: 400,
  height:200,
  dataSchema: {name: null, stoichiometry: null  },
  startRows: 5,
  startCols: 4,
  colHeaders: ['Name','Stoichiometry'],
  columns: [
    {data: "name"},
    {data: "stoichiometry"},
  ],
  afterSelection : function(rowNb, colNb) {
	presentPrePlaceNb=rowNb;
	document.getElementById("t1.1").innerHTML = 'Activity table for pre-place nb:'+rowNb+ ', name:'+this.getDataAtCell(rowNb,0);
	
	if(dataJson["transitions"][presentTransitionNb]){
	//console.log(dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb])
		//dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"]=[{	"preplace" : {	"activity" : [{ "a" : 0.0, "t" : 1.0}],"name" : "dNTPs","stoichiometry" : 1.0}}];
		if(dataJson["transitions"][presentTransitionNb]["transition"] 
		&& dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"]
		&& dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]
		){
			
			if (dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["preplace"]["activity"]){
				
				var dt=dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["preplace"]["activity"];
				//console.log(dt)
				var tmpT= new Array(dt.length);
				for (var i=0, j= dt.length;i<j;i++){
						tmpT[i]=new Array(2);
						tmpT[i][0]=dt[i]["a"];
						tmpT[i][1]=dt[i]["t"];
				}	
				var ht = $('#activityTable').handsontable('getInstance');
				ht.clear();
				if ($.isArray(tmpT) && tmpT[0] && $.isArray(tmpT[0])){
					ht.populateFromArray (0, 0, tmpT,tmpT.length-1, 1);
				}
			}
			else{
				var ht = $('#activityTable').handsontable('getInstance');
				ht.clear();
			}
			//var ht = $('#activityTable').handsontable('getInstance');
			//ht.clear();
			//var tmpT= new Array(dt.length);
			//for (var i=0, j= dt.length;i<j;i++){
			//		tmpT[i]=new Array(2);
			//		tmpT[i][0]=dt[i]["a"];
			//		tmpT[i][1]=dt[i]["t"];
			//}	
			//console.log(tmpT)
			//if ($.isArray(tmpT) && tmpT[0] && $.isArray(tmpT[0])){
			//	ht.populateFromArray (0, 0, tmpT,tmpT.length-1, 1)
			//}
		}
		else{
			var ht = $('#activityTable').handsontable('getInstance');
			ht.clear();
		}
	}
	else{
		var ht = $('#activityTable').handsontable('getInstance');
		ht.clear();
	}
  },
  
  afterChange: function(changes, source) {
	if(dataJson["transitions"][presentTransitionNb]){
		var dt = this.getData();
		if (dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"]){
			
			for (var i=0, j= dt.length;i<j-1;i++){
				if (dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"].length <i+1){
					dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"].push({"preplace":{	"name" : dt[i].name,"stoichiometry" : dt[i].stoichiometry, "activity":[]} });
				}
				else {
					
					dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][i]["preplace"]["name"]=dt[i].name;
					dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][i]["preplace"]["stoichiometry"]=dt[i].stoichiometry;
				}
			}
		}
		else{
			dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"]=[];
			for (var i=0, j= dt.length;i<j-1;i++){
				if (dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"].length <i+1){
					dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"].push({"preplace":{	"name" : dt[i].name,"stoichiometry" : dt[i].stoichiometry, "activity":[]} });
				}
				else {
					
					dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][i]["preplace"]["name"]=dt[i].name;
					dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][i]["preplace"]["stoichiometry"]=dt[i].stoichiometry;
				}
			}
		}
		
	}
	
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//console.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
  },
  
  minSpareRows: 1
});

var $container5 = $("#activityTable");
$container5.handsontable({
  data: [],
  width: 400,
  height:200,
  dataSchema: {a: null, t:null},
  startRows: 5,
  startCols: 4,
  colHeaders: ['a', 't'],
  columns: [
    {data: "a"},
	{data: "t"},
  ],
  afterChange: function(changes, source) {
	if(presentTransitionNb!=-1 && presentPrePlaceNb!=-1 && dataJson["transitions"][presentTransitionNb]){
		
		if (dataJson["transitions"][presentTransitionNb]["transition"]
		&& dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"]
		&& dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]){
			//console.log(dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]);
			
			if(dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"]){
				var dt = this.getData();
				//console.log(dt);
				for (var i=0, j= dt.length;i<j-1;i++){
					
					if (dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"].length<i+1){
						dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"].push({"a":dt[i].a,"t" : dt[i].t});		
					}
					else{
						dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"][i]["a"]=dt[i].a;
						dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"][i]["t"]=dt[i].t;	
					}
				}
				//console.log(dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"]);
			}
			else{
				dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"]=[];
				var dt = this.getData();
				for (var i=0, j= dt.length;i<j-1;i++){
					dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"].push({"a":dt[i].a,"t" : dt[i].t});		
				}
			}
			//console.log(dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"])
		}
		//if (!dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"]){
		//	dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"]=[];
		//}
	//	dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]=[];
		//for (var i=0, j= dt.length;i<j-1;i++){
		//	if (dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"].length <i+1){
		//		dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"].push({"a":dt[i].a,"t" : dt[i].t});
		//	}
		//	else {
		//		dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"][i]["a"]=dt[i].a;
		//		dataJson["transitions"][presentTransitionNb]["transition"]["preplaces"][presentPrePlaceNb]["activity"][i]["t"]=dt[i].t;
		//	}
		//}
	}
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//console.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
  },
  minSpareRows: 1
});
var $container6 = $("#consumedTable");
$container6.handsontable({
  data: [],
  width: 400,
  height:200,
  dataSchema: {name: null},
  startRows: 5,
  startCols: 1,
  colHeaders: ['name'],
  columns: [
    {data: "name"}
  ],
  afterChange: function(changes, source) {
	if(dataJson["transitions"][presentTransitionNb] && dataJson["transitions"][presentTransitionNb]["transition"]){
		var dt = this.getData();
		
		if (dataJson["transitions"][presentTransitionNb]["transition"]["consumed"]){
			for (var i=0, j= dt.length;i<j-1;i++){
				if (dataJson["transitions"][presentTransitionNb]["transition"]["consumed"].length <i+1){
					dataJson["transitions"][presentTransitionNb]["transition"]["consumed"].push({"consumed_preplace":{	"name" : dt[i].name} });
				}
				else{
					dataJson["transitions"][presentTransitionNb]["transition"]["consumed"][i]["consumed_preplace"]["name"]=dt[i].name;
				}
			}
		}
		else{
			dataJson["transitions"][presentTransitionNb]["transition"]["consumed"]=[];
			for (var i=0, j= dt.length;i<j-1;i++){
				dataJson["transitions"][presentTransitionNb]["transition"]["consumed"].push({"consumed_preplace":{	"name" : dt[i].name} });
			}
		}
		//console.log(dataJson["transitions"][presentTransitionNb]["transition"]["consumed"])
		
	}
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//console.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
  },
  minSpareRows: 1
});

var $container7 = $("#qssfTable");
$container7.handsontable({
  data: [],
  width: 400,
  height:200,
  dataSchema: {externality_tag: null, sfba_file: null},
  startRows: 1,
  startCols: 2,
  maxRows: 1,
  colHeaders: ['externality_tag', 'sfba_file'],
  columns: [
	{data: "externality_tag"},
	{data: "sfba_file"}
  ],
  afterChange: function(changes, source) {
	var dt = this.getData();
	
		dataJson["qssf"]["externality_tag"]=dt[0].externality_tag;
		//dataJson["qssf"]["sfba_file"]=dt[0].sfba_file;	
		//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
		var mlength=JSON.stringify(dataJson).length;
		var nbArrays=1;
		if (mlength>524288){
			nbArrays=parseInt(Math.ceil(mlength/524288.0));
		}
		if (nbArrays==1){
			document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
		}
		else{
			var stringSfba=JSON.stringify(dataJson);
			var chunksize=524288;
			var stringChunks=[];
			//console.log(mlength)
			for (var i=0;i<nbArrays;i++){
				stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
				document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
				//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
				//console.log(document.getElementById("mySpreadsheet"+i).value.length)
			}
			//console.log(stringChunks)
		}
		
  },
  minSpareRows: 1
});
var tempdata3=[[dataJson["qssf"]["externality_tag"],dataJson["qssf"]["sfba_file"] ]];

var ht = $('#qssfTable').handsontable('getInstance');
if ($.isArray(tempdata3) && tempdata3[0] && $.isArray(tempdata3[0])){
	ht.populateFromArray (0, 0, tempdata3,tempdata3.length-1, 1);
}


var $container8 = $("#constraintsTable");
$container8.handsontable({
  data: [],
  width: 200,
  height:200,
  dataSchema: {name: null},
  startRows: 5,
  startCols: 1,
  colHeaders: ['name'],
  columns: [
    {data: "name"}
  ],
  afterSelection : function(rowNb, colNb) {
	//console.log(rowNb);
	//console.log($("t1").text())
	presentConstraintNb=rowNb;
	document.getElementById("qssf1.1").innerHTML = 'Activity Table for constraint nb:'+rowNb+ ', name:'+this.getDataAtCell(rowNb,0);
	document.getElementById("qssf1.2").innerHTML = 'Flux List for constraint nb:'+rowNb+ ', name:'+this.getDataAtCell(rowNb,0);
	
	if(dataJson["qssf"]["constraints"][presentConstraintNb]){
		if(dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]){ 
			if (dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["activity"]){
				var dt=dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["activity"];
				var ht = $('#constraintsActivityTable').handsontable('getInstance');
				ht.clear();
				var tmpT= new Array(dt.length);
				for (var i=0, j= dt.length;i<j;i++){
						tmpT[i]=new Array(3);
						tmpT[i][0]=dt[i]["lb"];
						tmpT[i][1]=dt[i]["ub"];
						tmpT[i][2]=dt[i]["t"];
				}	
				//console.log(tmpT)
				if ($.isArray(tmpT) && tmpT[0] && $.isArray(tmpT[0])){
					ht.populateFromArray (0, 0, tmpT,tmpT.length-1, 1)
				}
			}
			else{
				var ht = $('#constraintsActivityTable').handsontable('getInstance');
				ht.clear();
				//var ht = $('#activityTable').handsontable('getInstance');
				//ht.clear();
			}
			
			if (dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["flux_list"]){
				var dt=dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["flux_list"];
				var ht = $('#fluxListActivityTable').handsontable('getInstance');
				ht.clear();
				var tmpT= new Array(dt.length);
				for (var i=0, j= dt.length;i<j;i++){
						tmpT[i]=new Array(1);
						tmpT[i][0]=dt[i];
				}	
				//console.log(tmpT)
				if ($.isArray(tmpT) && tmpT[0] && $.isArray(tmpT[0])){
					ht.populateFromArray (0, 0, tmpT,tmpT.length-1, 1)
				}
				
			}
			else{
				var ht = $('#fluxListActivityTable').handsontable('getInstance');
				ht.clear();
			}
			
			
			
			
		}
		
		
		else{
			var ht = $('#constraintsActivityTable').handsontable('getInstance');
			ht.clear();
			var ht = $('#fluxListActivityTable').handsontable('getInstance');
			ht.clear();
		}
	}
	else{
		var ht = $('#constraintsActivityTable').handsontable('getInstance');
		ht.clear();
		var ht = $('#fluxListActivityTable').handsontable('getInstance');
		ht.clear();
	}
	
	
  },
  afterChange: function(changes, source) {
    //console.log(this.getData());
	var dt = this.getData();
	for (var i=0, j= dt.length;i<j-1;i++){
		if (dataJson["qssf"]["constraints"].length <i+1){
			dataJson["qssf"]["constraints"].push({"constraint":{	"name" : dt[i].name,"activity" : [],"flux_list" : []} });
		}
		else dataJson["qssf"]["constraints"][i]["constraint"]["name"]=dt[i].name;
	}
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//console.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
	
	//console.log(dataJson["qssf"]["constraints"]);
	//dataJson.places.push()
  },
  minSpareRows: 1
});

var tempdata4=new Array(dataJson["qssf"]["constraints"].length);
for (var i=0, j=dataJson["qssf"]["constraints"].length; i<j;i++){
	tempdata4[i]=new Array(1);
	tempdata4[i][0]=dataJson["qssf"]["constraints"][i]["constraint"]["name"];
}
//for(var i=0, j=tempdata4.length; i<j;i++){
//console.log(tempdata4[i][0])
//}
var ht = $('#constraintsTable').handsontable('getInstance');
if ($.isArray(tempdata4) && tempdata4[0] && $.isArray(tempdata4[0])){
	ht.populateFromArray (0, 0, tempdata4,tempdata4.length-1, 1);
}

var $container9 = $("#constraintsActivityTable");
$container9.handsontable({
  data: [],
  width: 200,
  height:200,
  dataSchema: {lb: null, ub: null, t: null},
  startRows: 5,
  startCols: 4,
  colHeaders: ['lb', 'ub', 't'],
  columns: [
    {data: "lb"},
	{data: "ub"},
	{data: "t"},
  ],
  afterChange: function(changes, source) {
	if(dataJson["qssf"]["constraints"][presentConstraintNb]){
		var dt = this.getData();
		if (dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["activity"]){
			
			for (var i=0, j= dt.length;i<j-1;i++){
				if (dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["activity"].length <i+1){
					dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["activity"].push({	"ub" : dt[i].ub,"lb" : dt[i].lb, "t":dt[i].t} );
				}
				else {
					
					dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["activity"][i]["ub"]=dt[i].ub;
					dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["activity"][i]["lb"]=dt[i].lb;
					dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["activity"][i]["t"]=dt[i].t;
				}
			}
			//console.log(dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["activity"]);
		}
		
	}
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//console.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
	
  },
  minSpareRows: 1
});

var $container10 = $("#fluxListActivityTable");
$container10.handsontable({
  data: [],
  width: 200,
  height:200,
  dataSchema: {name: null},
  startRows: 5,
  startCols: 1,
  colHeaders: ['name'],
  columns: [
    {data: "name"}
  ],
  afterChange: function(changes, source) {
	if(dataJson["qssf"]["constraints"][presentConstraintNb]){
		var dt = this.getData();
		if (dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["flux_list"]){
			
			for (var i=0, j= dt.length;i<j-1;i++){
				if (dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["flux_list"].length <i+1){
					dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["flux_list"].push(dt[i].name);
				}
				else {
					
					dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["flux_list"][i]=dt[i].name;
					
				}
			}
			//console.log(dataJson["qssf"]["constraints"][presentConstraintNb]["constraint"]["flux_list"]);
		}
		
	}
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//console.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
	
  },
  minSpareRows: 1
});

var $container11 = $("#objectiveTable");
$container11.handsontable({
  data: [],
  width: 400,
  height:200,
  dataSchema: {name: null, objective: null},
  startRows: 5,
  startCols: 4,
  colHeaders: ['name', 'objective'],
  columns: [
    {data: "name"},
	{data: "objective"}
	
  ],
  afterSelection : function(rowNb, colNb) {
	//console.log(rowNb);
	//console.log($("t1").text())
	presentObjectiveNb=rowNb;
	document.getElementById("qssf2.1").innerHTML = 'Activity Table for objective nb:'+rowNb+ ', name:'+this.getDataAtCell(rowNb,0);
	
	if(dataJson["qssf"]["objectives"][presentObjectiveNb]){
		if(dataJson["qssf"]["objectives"][presentObjectiveNb]["objective"]){ 
			if (dataJson["qssf"]["objectives"][presentObjectiveNb]["objective"]["activity"]){
				var dt=dataJson["qssf"]["objectives"][presentObjectiveNb]["objective"]["activity"];
				var ht = $('#objectiveActivityTable').handsontable('getInstance');
				ht.clear();
				var tmpT= new Array(dt.length);
				for (var i=0, j= dt.length;i<j;i++){
						tmpT[i]=new Array(2);
						tmpT[i][0]=dt[i]["a"];
						tmpT[i][1]=dt[i]["t"];
						
				}	
				//console.log(tmpT)
				if ($.isArray(tmpT) && tmpT[0] && $.isArray(tmpT[0])){
					ht.populateFromArray (0, 0, tmpT,tmpT.length-1, 1)
				}
			}
			else{
				var ht = $('#objectiveActivityTable').handsontable('getInstance');
				ht.clear();
				//var ht = $('#activityTable').handsontable('getInstance');
				//ht.clear();
			}
			
		}
		
		
		else{
			var ht = $('#objectiveActivityTable').handsontable('getInstance');
			ht.clear();
			
		}
	}
	else{
		var ht = $('#objectiveActivityTable').handsontable('getInstance');
		ht.clear();
		
	}
	
  },
  afterChange: function(changes, source) {
    //console.log(this.getData());
	var dt = this.getData();
	
	for (var i=0, j= dt.length;i<j-1;i++){
		if (dataJson["qssf"]["objectives"].length <i+1){
			dataJson["qssf"]["objectives"].push({"objective":{	"name" : dt[i].name,"objective" : dt[i].objective,"activity" : []} });
		}
		else {
			dataJson["qssf"]["objectives"][i]["objective"]["name"]=dt[i].name;
			dataJson["qssf"]["objectives"][i]["objective"]["objective"]=dt[i].objective;
		}
	}
	//dataJson["qssf"]["objectives"].splice(dt.length,dataJson["qssf"]["objectives"].length-dt.length)
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
	
	//console.log(dataJson["qssf"]["objectives"]);
	//dataJson.places.push()
  },
  minSpareRows: 1
});

var tempdata5=new Array(dataJson["qssf"]["objectives"].length);
for (var i=0, j=dataJson["qssf"]["objectives"].length; i<j;i++){
	tempdata5[i]=new Array(2);
	tempdata5[i][0]=dataJson["qssf"]["objectives"][i]["objective"]["name"];
	tempdata5[i][1]=dataJson["qssf"]["objectives"][i]["objective"]["objective"];
}
var ht = $('#objectiveTable').handsontable('getInstance');
if ($.isArray(tempdata5) && tempdata5[0] && $.isArray(tempdata5[0])){
	ht.populateFromArray (0, 0, tempdata5,tempdata5.length-1, 2);
}


var $container12 = $("#objectiveActivityTable");
$container12.handsontable({
  data: [],
  width: 400,
  height:150,
  dataSchema: {a: null, t: null},
  startRows: 5,
  startCols: 4,
  colHeaders: ['a', 't', ],
  columns: [
    {data: "a"},
	{data: "t"},
  ],
  afterChange: function(changes, source) {
	if(dataJson["qssf"]["objectives"][presentObjectiveNb]){
		var dt = this.getData();
		if (dataJson["qssf"]["objectives"][presentObjectiveNb]["objective"]["activity"]){
			
			for (var i=0, j= dt.length;i<j-1;i++){
				if (dataJson["qssf"]["objectives"][presentObjectiveNb]["objective"]["activity"].length <i+1){
					dataJson["qssf"]["objectives"][presentObjectiveNb]["objective"]["activity"].push({	"a" : dt[i].a,"t" : dt[i].t} );
				}
				else {
					
					dataJson["qssf"]["objectives"][presentObjectiveNb]["objective"]["activity"][i]["a"]=dt[i].a;
					dataJson["qssf"]["objectives"][presentObjectiveNb]["objective"]["activity"][i]["t"]=dt[i].t;
				}
			}
			//console.log(dataJson["qssf"]["objectives"][presentObjectiveNb]["objective"]["activity"]);
		}
		
	}
	//document.getElementById("mySpreadsheet").value=JSON.stringify(dataJson);
	var mlength=JSON.stringify(dataJson).length;
	var nbArrays=1;
	if (mlength>524288){
		nbArrays=parseInt(Math.ceil(mlength/524288.0));
	}
	if (nbArrays==1){
		document.getElementById("mySpreadsheet0").value=JSON.stringify(dataJson);
	}
	else{
		var stringSfba=JSON.stringify(dataJson);
		var chunksize=524288;
		var stringChunks=[];
		//console.log(mlength)
		for (var i=0;i<nbArrays;i++){
			stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
			document.getElementById("mySpreadsheet"+i).value=stringChunks[i];
			//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
			//console.log(document.getElementById("mySpreadsheet"+i).value.length)
		}
		//console.log(stringChunks)
	}
	
  },
  minSpareRows: 1
});

var $container13 = $("#sfbaTable");
$container13.handsontable({
  data: [],
  width: ($("#container").width()*0.8),
  height:200,
  dataSchema: {name: null, formula: null, lb: null, ub:null,command:null, rule:null},
  colWidths: [105, (($("#container").width()*0.6)-235)/2, 40, 40,100, (($("#container").width()*0.6)-235)/2],
  startRows: 5,
  startCols: 6,
  colHeaders: ['Reaction name', 'Reaction Formula', 'Lb','Ub','Command','Gene/Reaction Rule'],
  columns: [
    {data: "name"},
    {data: "formula"},
    {data: "lb"},
    {data: "ub"},
	{data: "command"},
	{data: "rule"}
  ],
  /*afterChange: function(changes, source) {
    //console.log(this.getData());
	var dt = this.getData();
	
	for (var i=0, j= dt.length;i<j-1;i++){
		dataSfba[i]=new Array(5);
		dataSfba[i][0]=dt[i].name;
		dataSfba[i][1]=dt[i].formula;
		dataSfba[i][2]=dt[i].lb;
		dataSfba[i][3]=dt[i].ub;
		dataSfba[i][4]=dt[i].rule;
	}
	
		document.getElementById("mySfbaSpreadsheet").value=JSON.stringify(dataSfba);
	
	//console.log(JSON.stringify(dataSfba));
	//dataJson.places.push()
  },*/
  minSpareRows: 1
});


var tempdata6=dataJsonSfba;
var ht = $('#sfbaTable').handsontable('getInstance');
//console.log(ht)
if ($.isArray(tempdata6) && tempdata6[0] && $.isArray(tempdata6[0])){
	ht.populateFromArray (0, 0, tempdata6,tempdata6.length-1, 5);
}
var tmpN="";
var tmpS="";
for (var i=0,j=dataJsonSfba.length;i<j;i++){
	if(dataJsonSfba[i]){
		tmpN=dataJsonSfba[i][0];
		tmpS=dataJsonSfba[i][1];
		var aString=tmpS.replace(/(\d+\.\d+)|(\+)|(\=)/g, "").split(/\s+/);
		sfbaReacM[tmpN]=aString;
		//console.log(rString)
	}
}

var sfbaGeneralReactionMap={}
var k_sfbaReacM=Object.keys(sfbaReacM);
for (var i=0, j=k_sfbaReacM.length;i<j;i++){
	var components = sfbaReacM[k_sfbaReacM[i]];
	var cl =components.length;
	for (var i1=0, j1=k_sfbaReacM.length;i1<j1;i1++){
		if (i1!=i){
			var components2 = sfbaReacM[k_sfbaReacM[i1]];
			for (var c=0;c<cl;c++){
				var ind = components2.indexOf(components[c]);
				if (ind!=-1){
					if (sfbaGeneralReactionMap.hasOwnProperty(k_sfbaReacM[i])){
						if (sfbaGeneralReactionMap[k_sfbaReacM[i]].indexOf(k_sfbaReacM[i1])==-1){
							sfbaGeneralReactionMap[k_sfbaReacM[i]].push(k_sfbaReacM[i1]);
						}
						
					}
					else{
						sfbaGeneralReactionMap[k_sfbaReacM[i]]=[];
						
						sfbaGeneralReactionMap[k_sfbaReacM[i]].push(k_sfbaReacM[i1]);
						
					}
				}
			}
		}	
	}
	
}

//console.log(sfbaGeneralReactionMap)


var $container14 = $("#reactionCategoryTable");
$container14.handsontable({
	data: [],
	width: 400,
	height:150,
	dataSchema: {reaction: null, category: null},
	startRows: 5,
	startCols: 4,
	colHeaders: ['reaction', 'category', ],
	columns: [
	{data: "reaction"},
	{data: "category"},
	],
	afterChange: function(changes, source) {
		var dt = this.getData();	
		categoriesReactions={};
		reactionsCategories={};
		var countPerCategory={};
		for (var i=0, j= dt.length;i<j-1;i++){
			var tmpReaction = dt[i].reaction;
			var tmpCategory = dt[i].category;
			//if (tmpCategory!="null"){
				if (categoriesReactions.hasOwnProperty(tmpCategory)){
					if (categoriesReactions[tmpCategory].indexOf(tmpReaction)==-1){
						categoriesReactions[tmpCategory].push(tmpReaction);
					}
				}
				else {
					categoriesReactions[tmpCategory]=[];
					categoriesReactions[tmpCategory].push(tmpReaction);
				}
			//}
		}
		//console.log(categoriesReactions)
		for (var i=0, j= dt.length;i<j-1;i++){
			var tmpReaction = dt[i].reaction;
			var tmpCategory = dt[i].category;
			//if (tmpCategory!="null"){
				if (reactionsCategories.hasOwnProperty(tmpReaction)){
					if (reactionsCategories[tmpReaction].indexOf(tmpCategory)==-1){
						reactionsCategories[tmpReaction].push(tmpCategory);
					}
				}
				else {
					reactionsCategories[tmpReaction]=[];
					reactionsCategories[tmpReaction].push(tmpCategory);
				}
			//}
		}
		
		var listCategory = Object.keys(categoriesReactions);
		for (var i=0, j=listCategory.length;i<j;i++){
			countPerCategory[listCategory[i]]=0;
		}
		
		
		var listCloneCategory = [];
		var nbCloneAxis=0;
		var listReactions = Object.keys(reactionsCategories);
		//console.log(listCategory)
		var hwidth = (screen.width*0.5),
		hheight = screen.height*0.9,
		innerRadius = 40,
		outerRadius = (screen.height*0.7)/2;
		var nbAxis = listCategory.length;
		
		var angle = d3.scale.ordinal().domain(d3.range(nbAxis+1)).rangePoints([0, 2 * Math.PI]),
		radius = d3.scale.linear().range([innerRadius, outerRadius]),
		color = d3.scale.category10().domain(d3.range(20));
		//console.log(angle)
		//console.log(reactionsCategories)
		nodes =[];
		var listDisplayedNodes=[];
		links = [];
		for (var i=0,j=listReactions.length;i<j;i++){
			if (sfbaGeneralReactionMap.hasOwnProperty(listReactions[i])) {
				//var laxis=categoriesReactions[reactionsCategories[listReactions[i]][0]].length;
				var indexSource;
				var indexTarget;
				if(listDisplayedNodes.indexOf(listReactions[i])==-1){
					listDisplayedNodes.push(listReactions[i]);
					indexSource=listDisplayedNodes.length-1;
					//nodes.push({x: listCategory.indexOf(reactionsCategories[listReactions[i]][0]), y: (countPerCategory[reactionsCategories[listReactions[i]][0]]/(categoriesReactions[reactionsCategories[listReactions[i]][0]].length))*(categoriesReactions[reactionsCategories[listReactions[i]][0]].length/100)});
					nodes.push({x: listCategory.indexOf(reactionsCategories[listReactions[i]][0]), y: (countPerCategory[reactionsCategories[listReactions[i]][0]]/(categoriesReactions[reactionsCategories[listReactions[i]][0]].length))*(categoriesReactions[reactionsCategories[listReactions[i]][0]].length/100), nname:listReactions[i]});
					
					countPerCategory[reactionsCategories[listReactions[i]][0]]+=1;
				}
				else{
					indexSource=listDisplayedNodes.indexOf(listReactions[i]);
				}
				for(var i1=0,j1=sfbaGeneralReactionMap[listReactions[i]].length;i1<j1;i1++){
					var nextNode= sfbaGeneralReactionMap[listReactions[i]][i1];
					if(listDisplayedNodes.indexOf(nextNode)==-1){
						if (reactionsCategories[nextNode]){
							if (listCategory.indexOf(reactionsCategories[nextNode][0])!=-1){
								if (listCategory.indexOf(reactionsCategories[nextNode][0])!=listCategory.indexOf(reactionsCategories[listReactions[i]][0])){
									listDisplayedNodes.push(nextNode);
									indexTarget=listDisplayedNodes.length-1;
									//nodes.push({x: listCategory.indexOf(reactionsCategories[nextNode][0]), y: (countPerCategory[reactionsCategories[nextNode][0]]/(categoriesReactions[reactionsCategories[nextNode][0]].length))*(categoriesReactions[reactionsCategories[nextNode][0]].length/100)});
									nodes.push({x: listCategory.indexOf(reactionsCategories[nextNode][0]), y: (countPerCategory[reactionsCategories[nextNode][0]]/(categoriesReactions[reactionsCategories[nextNode][0]].length))*(categoriesReactions[reactionsCategories[nextNode][0]].length/100), nname:nextNode});
									
									countPerCategory[reactionsCategories[nextNode][0]]+=1;
									links.push({source: nodes[indexSource], target: nodes[indexTarget]})
								}
								else{
									/*if (listCloneCategory.indexOf(reactionsCategories[nextNode][0])==-1){
										listCloneCategory.push(reactionsCategories[nextNode][0]);
										nbCloneAxis++;
									}*/
									//console.log(nbAxis+listCloneCategory.indexOf(reactionsCategories[nextNode][0]))
									listDisplayedNodes.push(nextNode);
									indexTarget=listDisplayedNodes.length-1;
									//nodes.push({x: listCategory.indexOf(reactionsCategories[nextNode][0]), y: 1.0+(countPerCategory[reactionsCategories[nextNode][0]]/(categoriesReactions[reactionsCategories[nextNode][0]].length))*(categoriesReactions[reactionsCategories[nextNode][0]].length/100)});
									nodes.push({x: listCategory.indexOf(reactionsCategories[nextNode][0]), y: (countPerCategory[reactionsCategories[nextNode][0]]/(categoriesReactions[reactionsCategories[nextNode][0]].length))*(categoriesReactions[reactionsCategories[nextNode][0]].length/100), nname:nextNode});
									countPerCategory[reactionsCategories[nextNode][0]]+=1;
									//nodes.push({x: (nbAxis+listCloneCategory.indexOf(reactionsCategories[nextNode][0])), y: Math.random()});
									//nodes.push({x: nbAxis+listCloneCategory.indexOf(reactionsCategories[nextNode][0]), y: Math.random()});
									
									links.push({source: nodes[indexSource], target: nodes[indexTarget]})
								}
							}
						}
					}
				}
				//nodes.push({x: listCategory.indexOf(reactionsCategories[listReactions[i]]) Math.floor((Math.random() * nbAxis)), y: Math.random() });
				//nodes.push({x: Math.floor((Math.random() * nbAxis)), y: Math.random() });
				//links.push({source: nodes[nodes.length-2], target: nodes[nodes.length-1]})
			}
		}
		//console.log(listCloneCategory)
		//console.log(nbCloneAxis)
		//for (var i=0,j=listReactions.length;i<j;i++){
		//	if (sfbaGeneralReactionMap.hasOwnProperty(listReactions[i])) {
		//		for(){
				
		//		}
		//	}
		//}
		//console.log(nodes)
		//console.log(links)
		//for (elem in sfbaGeneralReactionMap){
		//	if (sfbaGeneralReactionMap.hasOwnProperty(elem)) {
				//sfbaGeneralReactionMap[elem]
				//nodes.push({x: (Math.random() * nbAxis), y: Math.random() });
				//nodes.push({x: (Math.random() * nbAxis), y: Math.random() });
				//links.push({source: nodes[nodes.length-2], target: nodes[nodes.length-1]})
		//	}
		//}
		
		//var nbReactionsPerSub={};
		// create nodes and links data
		
		/*for (elem in chartData){
			//if (chartData.hasOwnProperty(elem)) {
				//console.log(chartData[elem]/tnbReactions);
				//for (var i=0, j=chartData[elem]; i<j;i++){
					
					nodes.push({x: (Math.random() * nbAxis), y: Math.random() });
					nodes.push({x: (Math.random() * nbAxis), y: Math.random() });
					links.push({source: nodes[nodes.length-2], target: nodes[nodes.length-1]})
				//}
			//}
			nbElem++;
		}*/
		
		
		
		
		//$("#hivePlot").style.top = $("#democ0").position().top+$("#democ0").height()+150 + 'px';
		document.getElementById("hivePlot").style.top =$("#democ0").position().top+(window.innerHeight *0.6)+150 + 'px';
		
		$("#hivePlot").html("");
		
		
		var svg2 = d3.select("#hivePlot").append("svg")
			.attr("width", hwidth)
			.attr("height", hheight)	
			
			.append("g")
			.call(d3.behavior.zoom().scaleExtent([0.01, 12]).on("zoom", zoom))
			
			.append("g")
			.attr("transform", "translate(" + hwidth / 2 + "," + hheight / 2 + ")");
		
		svg2.append('rect')
       .classed('background', true)
       .attr('y',-100000)
       .attr('x', -100000)
       .attr('height', 200000)
       .attr('width', 200000)
       .attr('fill', 'white')
		//console.log(d3.range(nbAxis))
		svg2.selectAll(".hvaxis")
			.data(d3.range(nbAxis+nbCloneAxis))
		  .enter().append("line")
			.attr("class", "hvaxis")
			.attr("transform", function(d) {if (d<nbAxis) {return "rotate(" + degrees(angle(d)) + ")"} else{return "rotate(" + (degrees(angle(listCategory.indexOf(listCloneCategory[d-nbAxis])))+((360/nbAxis)/4)) + ")"  }})
			.attr("x1", radius.range()[0])
			.attr("x2", radius.range()[1]);
		svg2.append("text")
					.attr("id", "axislabel0")
					.attr("x", 0)
					.attr("y", 0)
					.text("Reactions by category")
					.attr("text-anchor", "middle")
					.attr("style", "fill: black")
					.attr("dy", -(hheight / 2)*0.90)
					.attr("dx", 0);
		
		var mnbElem=0;
		for (var i=0;i< listCategory.length;i++){		
				svg2.append("text")
					.attr("id", "axislabel"+(mnbElem))
					.attr("x", Math.sin(((mnbElem)*(2.0*Math.PI/(nbAxis))))*(width / 1.0)*1.1)
					.attr("y", -Math.cos(((mnbElem)*(2.0*Math.PI/(nbAxis))))*(width / 1.0)*1.1)
					.text(""+listCategory[i].substring(0, 4))
					.attr("text-anchor", "middle")
					.attr("style", "fill: black;fontSize:5px");
					//.attr("dy", )
					//.attr("dx", );
				//console.log(mnbElem+1)
				//console.log(nbAxis)
				mnbElem++;
		}

		
		svg2.selectAll(".hvnode")
			.data(nodes)
		  .enter().append("circle")
			.attr("class", "hvnode")
			.attr("transform", function(d) { if (d.x<nbAxis) {return "rotate(" + degrees(angle(d.x)) + ")"; } else{return "rotate(" + (degrees(angle(listCategory.indexOf(listCloneCategory[d.x-nbAxis])))+((360/nbAxis)/4)) + ")";} })
			.attr("cx", function(d) { return radius(d.y); })
			.attr("r", 0.5)
			.style("fill", function(d) { return color(d.x); })
			.on("mouseover", nodeMouseover)
			.on("mouseout", mouseout);
			
		svg2.selectAll(".hvlink")
			.data(links)
		  .enter().append("path")
			.attr("class", "hvlink")
			.attr("d", d3.hive.link(nbAxis+nbCloneAxis)
				.angle(function(d) { return angle(d.x); })//return angle((angle(listCategory.indexOf(listCloneCategory[d.x-nbAxis])))+((2*Math.PI/nbAxis)/4));} })
				.radius(function(d) { return radius(d.y); }))
			.attr("stroke", function(d) { return color(d.source.x); })
			.on("mouseover", linkMouseover)
			.on("mouseout", mouseout);
			//
		
		
		function nodeMouseover(d) {
			
			var neiNodeList = [];
			svg2.selectAll(".hvlink").classed("active", function (p) {
				
				if (p.source.x == d.x && p.source.y == d.y) {
					neiNodeList.push(p.target);
				}
				if (p.target.x == d.x && p.target.y == d.y ) {
					neiNodeList.push(p.source);
				}
				return p.source === d || p.target === d;
			});
			//nodename.text(""+d.nname);
			//console.log(d.nname)
			d3.select(this).classed("active", true);
			$("#mytooltip4")
                      .html("Reaction: <b>"+d.nname+"</b>")
					  .css('left', window.event.clientX+40)
                      .css('top', window.event.clientY)
                      .show();
			//if (Object.keys( nbReactionsPerSub )[d.x-1]){
			//	nodename.text("Nodes from "+Object.keys( nbReactionsPerSub )[d.x-1] + ": "+ (d.y*tnbReactions));
			//}
			//else{
			//	nodename.text("Metabolite nodes: "+ Math.floor(d.y*maxNBMetabolitesPerReaction));
			//}
			
		}	
		function linkMouseover(d) {
					svg2.selectAll(".hvlink").classed("active", function (p) {
						
						return p === d;
					});
					//d3.select(this).classed("active", true);
					svg2.selectAll(".hvnode").classed("active", function (p) {
						
						return p === d.source || p === d.target;
					});
					
					
		}
		
		// Clear any highlighted nodes or links.
		function mouseout() {
			svg2.selectAll(".active").classed("active", false);
			$("#mytooltip4").html('').hide();
		}
		function zoom() {
		  svg2.attr("transform", "translate(" + (d3.event.translate[0] + (hwidth / 2)*d3.event.scale )+","+ (d3.event.translate[1]+ (hheight / 2)*d3.event.scale) +")scale(" + d3.event.scale + ")");
		}
		

		function degrees(radians) {
		  return radians / Math.PI * 180 - 90;
		}
		
		//var listCategory = Object.keys(categoriesReactions);
		//for (var i=0; i< listCategory.length;i++){	
		//		nbReactionsPerSub[listCategory[i]]=0;		
		//}
		
		/*for (elem in chartData){
			if (chartData.hasOwnProperty(elem)) {
				nbReactionsPerSub[elem]=0;
			}
		}
		for (elem1 in chartData){
			if (chartData.hasOwnProperty(elem1)) {
				for (elem2 in MapNbMetabolitesPerReaction){
					if (MapNbMetabolitesPerReaction.hasOwnProperty(elem2)) {
						if (selectedMetabolicData[1][elem2][4][1][0] ){
							if (selectedMetabolicData[1][elem2][4][1][0]==elem1){
								nbReactionsPerSub[elem1]+=MapNbMetabolitesPerReaction[elem2]
							}
						}
					}
				}
			}
		}
		var arr = Object.keys( nbReactionsPerSub ).map(function ( key ) { return nbReactionsPerSub[key]; });
		var maxNBMetabolitesPerReaction = Math.max.apply( null, arr );
		//console.log(chartData);
		var nbElem=1;
		for (elem in chartData){
			if (chartData.hasOwnProperty(elem)) {
				//console.log(chartData[elem]/tnbReactions);
				//for (var i=0, j=chartData[elem]; i<j;i++){
					
					nodes.push({x: 0, y: nbReactionsPerSub[elem]/maxNBMetabolitesPerReaction });
					nodes.push({x: nbElem, y: (chartData[elem]/tnbReactions) });
					links.push({source: nodes[nodes.length-2], target: nodes[nodes.length-1]})
				//}
			}
			nbElem++;
		}

		var listR=Object.keys( nbReactionsPerSub );
		*/
		
		//console.log(categoriesReactions)
	},
	minSpareRows: 1
});


jsPlumb.ready(function() {
	jsPlumb.connect({
		source:"qssf",
		target:"qssf1",
		anchor:"Left",
		
		connector:[ "Flowchart", { stub:[40, 60], gap:50, cornerRadius:5, alwaysRespectStubs:true } ],
		endpoint:"Blank"
		
	});
	jsPlumb.connect({
		source:"qssf1",
		target:"qssf1.1",
		
		anchor:"Left",
		connector:[ "Flowchart", { stub:[40, 60], gap:15, cornerRadius:5, alwaysRespectStubs:true } ],
		endpoint:"Blank"
	});
	jsPlumb.connect({
		source:"qssf1",
		target:"qssf1.2",
		anchor:"Left",
		connector:[ "Flowchart", { stub:[40, 60], gap:15, cornerRadius:5, alwaysRespectStubs:true } ],
		endpoint:"Blank"
	});
	jsPlumb.connect({
		source:"qssf1",
		target:"qssf2",
		anchor:"Left",
		connector:[ "Flowchart", { stub:[40, 60], gap:50, cornerRadius:5, alwaysRespectStubs:true } ],
		endpoint:"Blank"
	});
	jsPlumb.connect({
		source:"qssf2",
		target:"qssf2.1",
		anchor:"Left",
		connector:[ "Flowchart", { stub:[40, 60], gap:5, cornerRadius:5, alwaysRespectStubs:true } ],
		endpoint:"Blank"
	});
	jsPlumb.connect({
		source:"t",
		target:"t1",
		anchor:"Left",
		connector:[ "Flowchart", { stub:[40, 60], gap:50, cornerRadius:5, alwaysRespectStubs:true } ],
		endpoint:"Blank"
	});
	jsPlumb.connect({
		source:"t1",
		target:"t1.1",
		anchor:"Left",
		connector:[ "Flowchart", { stub:[40, 60], gap:15, cornerRadius:5, alwaysRespectStubs:true } ],
		endpoint:"Blank"
	});
	jsPlumb.connect({
		source:"t",
		target:"t2",
		anchor:"Left",
		connector:[ "Flowchart", { stub:[40, 60], gap:50, cornerRadius:5, alwaysRespectStubs:true } ],
		endpoint:"Blank"
	});
	jsPlumb.connect({
		source:"t",
		target:"t3",
		anchor:"Left",
		connector:[ "Flowchart", { stub:[40, 60], gap:50, cornerRadius:5, alwaysRespectStubs:true } ],
		endpoint:"Blank"
	});
	//jsPlumb.hide("t3");
});


	function selectValue(el){
		//console.log(el.value)
		if (parseInt(el.value)!=0){
			document.getElementById("qml-id").value=el.value;
			
			//console.log(document.getElementById("mtnl-id").value)
			//console.log(document.getElementById("qml-id").value)
			//document.getElementById("qml-id").value=document.getElementById("selectLayout").value;
		}
		document.getElementById("mtnl-id").value=document.getElementById("layout-selector").value;
		
	}
	
	function selectsublayout(el){
		
		document.getElementById("defaultSlider4").value=0;
		document.getElementById("defaultSlider5").value=0;
		var sl = document.getElementById("defaultSlider2")
		var amountScale = 0.1+(0.9*(parseFloat(sl.value)/100));
		if (el.value==""){
			console.log("default layout");
			
			var cnt1=0;
			var cnt2=0;
			var cnt=0;
			var radius=400;
			//var ln1 = scene.children[2].geometry.attributes.size.array.length-5000; 
			//var ln2 = scene.children[4].geometry.attributes.size.array.length-5000; 
			var ln1 = startModelPlaces;
			var ln2 = startModelReactions;
			//console.log(ln1)
			//console.log(startModelPlaces)
			for (var i= 0; i<selectedModelNodes.length;i++){
				if (selectedModelNodes[i][5]==2 ){
					//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]=((Math.random() * 2 - 1) * 400);
					var rm=cnt1*0.008*2*Math.PI;
					//radius=900;
					var rr = ((radius*1.08)-(cnt1*0.2)+1)
					scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (Math.sin(rm) *rr);
					//scene.children[2].geometry.attributes.position.array[(ln2+cnt2)*3+0]= (Math.cos(rm) *rr)+1800;
					scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(Math.cos(rm) *rr)+900;
					scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=yStartDisplacement/2;
					cnt1++;
					cnt++;
				}
				else if (selectedModelNodes[i][5]==4 ){
					//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=((Math.random() * 2 - 1) * 400);
					var rm=cnt2*0.008*2*Math.PI;
					//radius=600;
					var rr = ((radius*1.08)-(cnt2*0.2)+1)
					scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(Math.sin(rm) *rr);
					scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]= (Math.cos(rm) *rr)+1800;
					scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1]=yStartDisplacement/2-180;
					cnt2++;
					cnt++;
				}
			}
			//console.log(cnt1)
			//console.log(cnt2)
			
			scene.children[2].geometry.attributes.position.needsUpdate = true;
			scene.children[4].geometry.attributes.position.needsUpdate = true;
			
			var count=0;
			for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
				var t1;
				var t2;
				var pt1;
				var pt2;
				var sim1=1;
				var sim2=1;
				pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
				sim1 = idMap[pt1][0]
				t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
				if (selectedModelEdges[iv-extraLinesCnt][3]==2){
					//console.log("link between model and metabolic nodes")
					
					if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
						pt2=selectedModelEdges[iv-extraLinesCnt][1];
					}
					else{
						pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
					}
					t2 = jsonObj1[pt2][6]
					sim2=2;
				}
				else{
					//console.log("link between model nodes")
					if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
						pt2=selectedModelEdges[iv-extraLinesCnt][1];
					}
					else{
						pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
					}
					t2 = selectedModelNodes[pt2][5];
				}
				if (sim2!=2){
					pt2+=jsonObj1.length;
					//console.log(idMap[pt2]);
				}
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
				startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
				
				count+=1;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
				endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
				
				count+=1;
			}
			scene.children[7].geometry.attributes.position.needsUpdate = true;
			scene.children[7].geometry.attributes.ca.needsUpdate = true;
			
			
			var ii=0;
			for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
			
				scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
				scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
				scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
				ii++;
			}
			//console.log(tokenAttributes.endPosition.value[0]);
			var ii=0;
			for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
				tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
				tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
				ii++;
			}
			//console.log(tokenAttributes.endPosition.value[0]);
			scene.children[8].geometry.verticesNeedUpdate = true;
			tokenAttributes.endPosition.needsUpdate = true;
			tokenUniforms.mixAmount.value = 0.0;
			
			
		}
		else {
			//console.log("other layout");
			//console.log($("#selectLayout").find('option:selected').text())
			//console.log(layouts[el.value])
			var layout_nodes_coordinates={};
			var sublayout=el.value;
			//console.log(sublayout)
			if (mqml["layout"].hasOwnProperty(sublayout)) {
				console.log(sublayout)
				for (var i=0, j=mqml["layout"][sublayout].length;i<j;i++){
					layout_nodes_coordinates[mqml["layout"][sublayout][i]['data']['id']]=[mqml["layout"][sublayout][i]['position']['x'],mqml["layout"][sublayout][i]['position']['y'] ]
				}
			}
			
			//console.log(layout_nodes_coordinates)
			// //console.log(selectedModelNodes);
			var cnt1=0;
			var cnt2=0;
			var ln1 = startModelPlaces;
			var ln2 = startModelReactions;
			for (var i=0, j=selectedModelNodes.length;i<j;i++){
				if (selectedModelNodes[i][5]==2 ){
						
						if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
							scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
							scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
							
							//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=50;
							//console.log(scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1])
						}
						cnt1++;
				}
				if (selectedModelNodes[i][5]==4 ){
						
						if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
							scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
							scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
							
							//console.log(scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1])
						}
						cnt2++;
				}
				
			}
			scene.children[2].geometry.attributes.position.needsUpdate = true;
			scene.children[4].geometry.attributes.position.needsUpdate = true;
			
			var count=0;
			for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
				var t1;
				var t2;
				var pt1;
				var pt2;
				var sim1=1;
				var sim2=1;
				pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
				sim1 = idMap[pt1][0]
				t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
				if (selectedModelEdges[iv-extraLinesCnt][3]==2){
					//console.log("link between model and metabolic nodes")
					
					if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
						pt2=selectedModelEdges[iv-extraLinesCnt][1];
					}
					else{
						pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
					}
					t2 = jsonObj1[pt2][6]
					sim2=2;
				}
				else{
					//console.log("link between model nodes")
					if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
						pt2=selectedModelEdges[iv-extraLinesCnt][1];
					}
					else{
						pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
					}
					t2 = selectedModelNodes[pt2][5];
				}
				if (sim2!=2){
					pt2+=jsonObj1.length;
					//console.log(idMap[pt2]);
				}
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
				startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
				
				count+=1;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
				scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
				endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
				
				count+=1;
			}
			scene.children[7].geometry.attributes.position.needsUpdate = true;
			scene.children[7].geometry.attributes.ca.needsUpdate = true;
			
			
			var ii=0;
			for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
			
				scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
				scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
				scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
				ii++;
			}
			//console.log(tokenAttributes.endPosition.value[0]);
			var ii=0;
			for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
				tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
				tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
				ii++;
			}
			//console.log(tokenAttributes.endPosition.value[0]);
			scene.children[8].geometry.verticesNeedUpdate = true;
			tokenAttributes.endPosition.needsUpdate = true;
			tokenUniforms.mixAmount.value = 0.0;
			
		}
	}
	
	function updateSlider2(slideAmount){
			var el = document.getElementById("selectsublayout").value;
			var amountScale = 0.1+(0.9*(parseFloat(slideAmount)/100));
			if (el==""){
				//console.log("default layout");
			}
			else {
				//console.log("other layout");
				var layout_nodes_coordinates={};
				var sublayout=document.getElementById("selectsublayout").value;
				//console.log(sublayout)
				if (mqml["layout"].hasOwnProperty(sublayout)) {
					//console.log(sublayout)
					for (var i=0, j=mqml["layout"][sublayout].length;i<j;i++){
						layout_nodes_coordinates[mqml["layout"][sublayout][i]['data']['id']]=[mqml["layout"][sublayout][i]['position']['x'],mqml["layout"][sublayout][i]['position']['y'] ]
					}
				}
				//console.log(selectedModelNodes);
				var cnt1=0;
				var cnt2=0;
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				for (var i=0, j=selectedModelNodes.length;i<j;i++){
					if (selectedModelNodes[i][5]==2 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
							}
							cnt1++;
					}
					if (selectedModelNodes[i][5]==4 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
							}
							cnt2++;
					}
					
				}
				scene.children[2].geometry.attributes.position.needsUpdate = true;
				scene.children[4].geometry.attributes.position.needsUpdate = true;
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				tokenUniforms.mixAmount.value = 0.0;
				
				
				//for (elem in layout_nodes_coordinates){
				//	if (layout_nodes_coordinates.hasOwnProperty(elem)){
						//layout_nodes_coordinates[elem]
				//	}
				//}
				
				//console.log(layout_nodes_coordinates);
				
			}	
		}
		
		function updateSlider3(slideAmount){
			var el = document.getElementById("selectsublayout").value;
			var el2= document.getElementById("defaultSlider2");
			var amountScale = 0.1+(0.9*(parseFloat(el2.value)/100));
			var distance = (parseFloat(slideAmount)/100)*200
			
			if (el==""){
				//console.log("default layout");
			}
			else {
				//console.log("other layout");
				//console.log(layouts[el.value])
				var layout_nodes_coordinates={};
				var sublayout=document.getElementById("selectsublayout").value;
				//console.log(sublayout)
				if (mqml["layout"].hasOwnProperty(sublayout)) {
					//console.log(sublayout)
					for (var i=0, j=mqml["layout"][sublayout].length;i<j;i++){
						layout_nodes_coordinates[mqml["layout"][sublayout][i]['data']['id']]=[mqml["layout"][sublayout][i]['position']['x'],mqml["layout"][sublayout][i]['position']['y'] ]
					}
				}
				//console.log(selectedModelNodes);
				var cnt1=0;
				var cnt2=0;
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				for (var i=0, j=selectedModelNodes.length;i<j;i++){
					if (selectedModelNodes[i][5]==2 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
								//console.log(scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1])//=50;
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=200;
							}
							cnt1++;
					}
					if (selectedModelNodes[i][5]==4 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=50;
								//console.log(scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1])//=50;
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1]=200-distance;
							}
							cnt2++;
					}
					
				}
				scene.children[2].geometry.attributes.position.needsUpdate = true;
				scene.children[4].geometry.attributes.position.needsUpdate = true;
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				tokenUniforms.mixAmount.value = 0.0;
				
				
				//for (elem in layout_nodes_coordinates){
				//	if (layout_nodes_coordinates.hasOwnProperty(elem)){
						//layout_nodes_coordinates[elem]
				//	}
				//}
				
				//console.log(layout_nodes_coordinates);
				
			}	
		}
		var updownPlaneVal=0;
		function updateSlider4(slideAmount){
			var el = document.getElementById("selectsublayout").value;
			var el2= document.getElementById("defaultSlider2");
			var amountScale = 0.1+(0.9*(parseFloat(el2.value)/100));
			var distance = (parseFloat(document.getElementById("defaultSlider3").value)/100)*200
			
			if (el==""){
				//console.log("default layout");
				var slideValue = parseFloat(slideAmount)-updownPlaneVal;
				
				var listChildrenPoints=[2,4];
				for (var i =0;i< listChildrenPoints.length;i++){
					var c = listChildrenPoints[i];
					var start=0;
					var end=0;
					if (c==2){
						start =startModelPlaces ;
						end = endModelPlaces ;
					}
					if (c==4){
						start =startModelReactions ;
						end =endModelReactions ;
					}
					for (var h=start;h<end;h++){					
						scene.children[c].geometry.attributes.position.array[h*3+0]-=slideValue;//-stackCompInitialPos[cRef].x-stackCompInitialPos[cRef].x;
						//scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y;//-stackCompInitialPos[cRef].y-stackCompInitialPos[cRef].y;
						//scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z;//-stackCompInitialPos[cRef].z-stackCompInitialPos[cRef].z;	
					}
					scene.children[c].geometry.attributes.position.needsUpdate = true;
				}
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				tokenUniforms.mixAmount.value = 0.0;
				
				updownPlaneVal+=slideValue;
			}
			else {
				//console.log("other layout");
				//console.log(layouts[el.value])
				var layout_nodes_coordinates={};
				var sublayout=document.getElementById("selectsublayout").value;
				//console.log(sublayout)
				if (mqml["layout"].hasOwnProperty(sublayout)) {
					//console.log(sublayout)
					for (var i=0, j=mqml["layout"][sublayout].length;i<j;i++){
						layout_nodes_coordinates[mqml["layout"][sublayout][i]['data']['id']]=[mqml["layout"][sublayout][i]['position']['x'],mqml["layout"][sublayout][i]['position']['y'] ]
					}
				}
				//console.log(selectedModelNodes);
				var cnt1=0;
				var cnt2=0;
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				for (var i=0, j=selectedModelNodes.length;i<j;i++){
					if (selectedModelNodes[i][5]==2 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale)+parseFloat(slideAmount);
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200+parseFloat(slideAmount);
								//console.log(scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1])//=50;
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=200;
							}
							cnt1++;
					}
					if (selectedModelNodes[i][5]==4 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale)+parseFloat(slideAmount);
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200+parseFloat(slideAmount);
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=50;
								//console.log(scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1])//=50;
								//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1]=200-distance+parseFloat(slideAmount);
							}
							cnt2++;
					}
					
				}
				scene.children[2].geometry.attributes.position.needsUpdate = true;
				scene.children[4].geometry.attributes.position.needsUpdate = true;
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				tokenUniforms.mixAmount.value = 0.0;
				
				
				//for (elem in layout_nodes_coordinates){
				//	if (layout_nodes_coordinates.hasOwnProperty(elem)){
						//layout_nodes_coordinates[elem]
				//	}
				//}
				
				//console.log(layout_nodes_coordinates);
				
			}	
		}
		var leftRightVal=0;
		function updateSlider5(slideAmount){
			
			var el = document.getElementById("selectsublayout").value;
			var el2= document.getElementById("defaultSlider2");
			var amountScale = 0.1+(0.9*(parseFloat(el2.value)/100));
			var distance = (parseFloat(document.getElementById("defaultSlider3").value)/100)*200
			
			if (el==""){
				//console.log("default layout");
				var slideValue = parseFloat(slideAmount)-leftRightVal;
				
				var listChildrenPoints=[2,4];
				for (var i =0;i< listChildrenPoints.length;i++){
					var c = listChildrenPoints[i];
					var start=0;
					var end=0;
					if (c==2){
						start =startModelPlaces ;
						end = endModelPlaces ;
					}
					if (c==4){
						start =startModelReactions ;
						end =endModelReactions ;
					}
					for (var h=start;h<end;h++){					
						scene.children[c].geometry.attributes.position.array[h*3+2]-=slideValue;//-stackCompInitialPos[cRef].x-stackCompInitialPos[cRef].x;
						//scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y;//-stackCompInitialPos[cRef].y-stackCompInitialPos[cRef].y;
						//scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z;//-stackCompInitialPos[cRef].z-stackCompInitialPos[cRef].z;	
					}
					scene.children[c].geometry.attributes.position.needsUpdate = true;
				}
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				tokenUniforms.mixAmount.value = 0.0;
				
				leftRightVal+=slideValue;
			}
			else {
				//console.log("other layout");
				//console.log(layouts[el.value])
				var layout_nodes_coordinates={};
				var sublayout=document.getElementById("selectsublayout").value;
				//console.log(sublayout)
				if (mqml["layout"].hasOwnProperty(sublayout)) {
					//console.log(sublayout)
					for (var i=0, j=mqml["layout"][sublayout].length;i<j;i++){
						layout_nodes_coordinates[mqml["layout"][sublayout][i]['data']['id']]=[mqml["layout"][sublayout][i]['position']['x'],mqml["layout"][sublayout][i]['position']['y'] ]
					}
				}
				//console.log(selectedModelNodes);
				var cnt1=0;
				var cnt2=0;
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				for (var i=0, j=selectedModelNodes.length;i<j;i++){
					if (selectedModelNodes[i][5]==2 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale)-parseFloat(slideAmount);
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
								//console.log(scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1])//=50;
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=200;
							}
							cnt1++;
					}
					if (selectedModelNodes[i][5]==4 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale)-parseFloat(slideAmount);
								//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=50;
								//console.log(scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1])//=50;
								//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1]=200-distance+parseFloat(slideAmount);
							}
							cnt2++;
					}
					
				}
				scene.children[2].geometry.attributes.position.needsUpdate = true;
				scene.children[4].geometry.attributes.position.needsUpdate = true;
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				tokenUniforms.mixAmount.value = 0.0;
				
				
				//for (elem in layout_nodes_coordinates){
				//	if (layout_nodes_coordinates.hasOwnProperty(elem)){
						//layout_nodes_coordinates[elem]
				//	}
				//}
				
				//console.log(layout_nodes_coordinates);
				
			}	
		}
		var updownVal=0;
		function updateSlider6(slideAmount){
			var el = document.getElementById("selectsublayout").value;
			var el2= document.getElementById("defaultSlider2");
			var amountScale = 0.1+(0.9*(parseFloat(el2.value)/100));
			var distance = (parseFloat(document.getElementById("defaultSlider3").value)/100)*200
			
			if (el==""){
				//console.log("default layout");
				var slideValue = parseFloat(slideAmount)-updownVal;
				
				var listChildrenPoints=[2,4];
				for (var i =0;i< listChildrenPoints.length;i++){
					var c = listChildrenPoints[i];
					var start=0;
					var end=0;
					if (c==2){
						start =startModelPlaces ;
						end = endModelPlaces ;
					}
					if (c==4){
						start =startModelReactions ;
						end =endModelReactions ;
					}
					for (var h=start;h<end;h++){					
						scene.children[c].geometry.attributes.position.array[h*3+1]-=slideValue;//-stackCompInitialPos[cRef].x-stackCompInitialPos[cRef].x;
						//scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y;//-stackCompInitialPos[cRef].y-stackCompInitialPos[cRef].y;
						//scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z;//-stackCompInitialPos[cRef].z-stackCompInitialPos[cRef].z;	
					}
					scene.children[c].geometry.attributes.position.needsUpdate = true;
				}
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				tokenUniforms.mixAmount.value = 0.0;
				
				updownVal+=slideValue;
			}
			else {
				//console.log("other layout");
				//console.log(layouts[el.value])
				var layout_nodes_coordinates={};
				var sublayout=document.getElementById("selectsublayout").value;
				//console.log(sublayout)
				if (mqml["layout"].hasOwnProperty(sublayout)) {
					//console.log(sublayout)
					for (var i=0, j=mqml["layout"][sublayout].length;i<j;i++){
						layout_nodes_coordinates[mqml["layout"][sublayout][i]['data']['id']]=[mqml["layout"][sublayout][i]['position']['x'],mqml["layout"][sublayout][i]['position']['y'] ]
					}
				}
				//console.log(selectedModelNodes);
				var cnt1=0;
				var cnt2=0;
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				for (var i=0, j=selectedModelNodes.length;i<j;i++){
					if (selectedModelNodes[i][5]==2 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
								//console.log(scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1])//=50;
								scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=200+parseFloat(slideAmount);
							}
							cnt1++;
					}
					if (selectedModelNodes[i][5]==4 ){
							
							if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
								//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
								//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
								//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=50;
								//console.log(scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1])//=50;
								scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1]=200-distance+parseFloat(slideAmount);
							}
							cnt2++;
					}
					
				}
				scene.children[2].geometry.attributes.position.needsUpdate = true;
				scene.children[4].geometry.attributes.position.needsUpdate = true;
				
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				tokenUniforms.mixAmount.value = 0.0;
				
				
				//for (elem in layout_nodes_coordinates){
				//	if (layout_nodes_coordinates.hasOwnProperty(elem)){
						//layout_nodes_coordinates[elem]
				//	}
				//}
				
				//console.log(layout_nodes_coordinates);
				
			}	
		}

	$("#qsspn-model-edit-form0").css({top:  $("#modelSpreadSheet").position().top -750, width:$("#container").width()/2});	
	
	var qm = <%- JSON.stringify(qm)%>;
	var detailMTN={};
	var listMTN={};
	var tmpListModelNodes={};
	var mtns={};
	var results ={};
	var mtb=<%- JSON.stringify(mtb) %>;
		mtns[mtb['name']]=mtb['file'][1];
	
	for (var i=0, j= qm.file.extra[3].length; i<j; i++){
		if (qm.file.extra[3][i][3]==2){
			//var name_model_node= 
			if (tmpListModelNodes.hasOwnProperty(qm.file.extra[2][qm.file.extra[3][i][0]][1])){
				tmpListModelNodes[qm.file.extra[2][qm.file.extra[3][i][0]][1]].push(mtns[qm.metabolic_net][qm.file.extra[3][i][1]][1]);
				if (detailMTN.hasOwnProperty(qm.metabolic_net)){
					if (detailMTN[qm.metabolic_net].indexOf(mtns[qm.metabolic_net][qm.file.extra[3][i][1]][1])==-1){
						
						detailMTN[qm.metabolic_net].push(mtns[qm.metabolic_net][qm.file.extra[3][i][1]][1]);
					}
				}
				else{
					detailMTN[qm.metabolic_net]=[];
					detailMTN[qm.metabolic_net].push(mtns[qm.metabolic_net][qm.file.extra[3][i][1]][1]);
					
				}
			}
			else{
				tmpListModelNodes[qm.file.extra[2][qm.file.extra[3][i][0]][1]]=[];
				tmpListModelNodes[qm.file.extra[2][qm.file.extra[3][i][0]][1]].push(mtns[qm.metabolic_net][qm.file.extra[3][i][1]][1]);
				if (detailMTN.hasOwnProperty(qm.metabolic_net)){
					if (detailMTN[qm.metabolic_net].indexOf(mtns[qm.metabolic_net][qm.file.extra[3][i][1]][1])==-1){
						
						detailMTN[qm.metabolic_net].push(mtns[qm.metabolic_net][qm.file.extra[3][i][1]][1]);
					}
				}
				else{
					detailMTN[qm.metabolic_net]=[];
					detailMTN[qm.metabolic_net].push(mtns[qm.metabolic_net][qm.file.extra[3][i][1]][1]);
					
				}
			}
		
		}
	}
	listMTN[qm.name]=[qm.metabolic_net,tmpListModelNodes];
	
	
	var myListModels=Object.keys(listMTN);
	var mylistMTN=Object.keys(detailMTN);
	
	var data;
	for (el0 in listMTN ){
		if (listMTN.hasOwnProperty(el0)) {
			data = [];
			for (var j = 0, jl =detailMTN[listMTN[el0][0]].length; j < jl; j += 1) {
				var tmpdata = [];
				for (var k = 0, kl = Object.keys(listMTN[el0][1]).length; k < kl; k += 1) {
					if (listMTN[el0][1][Object.keys(listMTN[el0][1])[k]].indexOf(detailMTN[listMTN[el0][0]][j])>-1){
					tmpdata.push(1);
					}
					else{
					tmpdata.push(0);
					}
				}
				data.push(tmpdata);
			}
			results[el0]=data;
		}
	}
	
	var nbModel=0;
	var data = [];
	for (var j = 0, jl =detailMTN[listMTN[myListModels[nbModel]][0]].length; j < jl; j += 1) {
		var tmpdata = [];
		for (var k = 0, kl = Object.keys(listMTN[myListModels[nbModel]][1]).length; k < kl; k += 1) {
			if (listMTN[myListModels[nbModel]][1][Object.keys(listMTN[myListModels[nbModel]][1])[k]].indexOf(detailMTN[listMTN[myListModels[nbModel]][0]][j])>-1){
			tmpdata.push(1);
			}
			else{
			tmpdata.push(0);
			}
		}
		data.push(tmpdata);
	}
	//console.log(listMTN);
	//console.log(detailMTN);
    // Make the changes
	//$("#democ0").html("");
	var width = window.innerWidth / 5,
    height = window.innerHeight *0.6,
    mdiv = d3.select('#democ0'),
    msvg = mdiv.append('svg')
        .attr('width', width)
        .attr('height', height),
	rw = width/results[myListModels[nbModel]][0].length,
    rh = height/results[myListModels[nbModel]].length;
	//var msvg = d3.select("#democ0").transition();
	var grp = msvg.selectAll('g')
		.data(data)
		.enter()
		.append('g')
		.attr('transform', function(d, i) {
			return 'translate(0, ' + (rh*1.0) * i + ')';
		});

	// For each group, create a set of rectangles and bind 
	// them to the inner array (the inner array is already
	// binded to the group)
	grp.selectAll('rect')
		.data(function(d) { return d; })
		.enter()
		.append('rect')
        .attr('x', function(d, i) { return (rw*1.0 )* i; })
        .attr('width', rw)
        .attr('height', rh)
		.style("fill", function(d, i) { if (d==1) {return "rgb(0,0,"+(parseInt(255*d))+")"} else return "transparent"})
		.on('mouseover', function(d,i,j) {
					disableSelection=true;
					if (d==1){
					d3.select(this).transition().duration(10)
					.style({'stroke-opacity':1,'stroke':'#F00', 'stroke-width':2});
					$("#mytooltip3")
                      .html("Link between: <br>Model node: <b>"+Object.keys(listMTN[myListModels[nbModel]][1])[i]+"</b><br>and Metabolic node: <b>"+detailMTN[listMTN[myListModels[nbModel]][0]][j]) //listMTN[myListModels[nbModel]][1]
					  .css('left', window.event.clientX+40)
                      .css('top', window.event.clientY)
                      .show();
					}
                    
		})
		.on("mouseout", function(d,i) {
					disableSelection=false;
				   $("#mytooltip3").html('').hide();
				   d3.select(this).transition().duration(100)
					.style({'stroke-opacity':0.0,'stroke':'transparent','stroke-width':0});
		});
	
	
	$("#hiveplotColor").css({top:  $("#hivePlot").position().top +$("#hivePlot").height()+5});	
	
	
	function hiveplotAction(){
		var svg2= d3.select("#hivePlot").select("svg");
		if(hvBColor==true){
			//console.log("black")
			svg2.select("rect").attr('fill', 'black');
			svg2.selectAll("text").attr("style", "fill: white");
			svg2.selectAll("line").attr("style", "stroke: white");
			svg2.selectAll("circle").attr("style", "stroke: white");
			
			
			//svg2.selectAll(".hvnode")
			//.data(nodes)
			//.attr("r", function(d) {console.log(d); return 0.5+(d.y )});
			
			svg2.selectAll(".hvlink")
			.data(links)
			.attr("stroke", function(d) { return '#'+Math.floor( 215+(d.source.y/10)*215).toString(16);});
			//.attr("r", function(d) {console.log(d); return 0.5+(d.y )});
			
			
			hvBColor=false;
		}
		else{
			//console.log("white")
			svg2.select("rect").attr('fill', 'white');
			svg2.selectAll("text").attr("style", "fill: black");
			svg2.selectAll("line").attr("style", "stroke: #000");
			svg2.selectAll("circle").attr("style", "stroke: black");
			hvBColor=true;
		}
	}
	
	
	function selectMTNLayout(el){
		//console.log(el.value)
		document.getElementById("mtnl-id").value=el.value;
		document.getElementById("qml-id").value=document.getElementById("selectLayout").value;
		//console.log("mtnl id: "+document.getElementById("mtnl-id").value)
		//console.log("qml id: "+document.getElementById("qml-id").value)
	}
	
	
	// refresh qsspn model graphics from layout
	var el = document.getElementById("mtnl-id").value;
	var sl = document.getElementById("defaultSlider2")
	var amountScale = 0.1+(0.9*(parseFloat(sl.value)/100));
	if (parseInt(el.value)==0){
		//console.log("default layout");
		
		var cnt1=0;
		var cnt2=0;
		var cnt=0;
		var radius=400;
		//var ln1 = scene.children[2].geometry.attributes.size.array.length-5000; 
		//var ln2 = scene.children[4].geometry.attributes.size.array.length-5000; 
		var ln1 = startModelPlaces;
		var ln2 = startModelReactions;
		//console.log(ln1)
		//console.log(startModelPlaces)
		for (var i= 0; i<selectedModelNodes.length;i++){
			if (selectedModelNodes[i][5]==2 ){
				//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]=((Math.random() * 2 - 1) * 400);
				var rm=cnt1*0.008*2*Math.PI;
				//radius=900;
				var rr = ((radius*1.08)-(cnt1*0.2)+1)
				scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (Math.sin(rm) *rr);
				//scene.children[2].geometry.attributes.position.array[(ln2+cnt2)*3+0]= (Math.cos(rm) *rr)+1800;
				scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(Math.cos(rm) *rr)+900;
				cnt1++;
				cnt++;
			}
			else if (selectedModelNodes[i][5]==4 ){
				//scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=((Math.random() * 2 - 1) * 400);
				var rm=cnt2*0.008*2*Math.PI;
				//radius=600;
				var rr = ((radius*1.08)-(cnt2*0.2)+1)
				scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(Math.sin(rm) *rr);
				scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]= (Math.cos(rm) *rr)+1800;
				
				cnt2++;
				cnt++;
			}
		}
		//console.log(cnt1)
		//console.log(cnt2)
		
		scene.children[2].geometry.attributes.position.needsUpdate = true;
		scene.children[4].geometry.attributes.position.needsUpdate = true;
		
		var count=0;
		for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
			var t1;
			var t2;
			var pt1;
			var pt2;
			var sim1=1;
			var sim2=1;
			pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
			sim1 = idMap[pt1][0]
			t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
			if (selectedModelEdges[iv-extraLinesCnt][3]==2){
				//console.log("link between model and metabolic nodes")
				
				if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
					pt2=selectedModelEdges[iv-extraLinesCnt][1];
				}
				else{
					pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
				}
				t2 = jsonObj1[pt2][6]
				sim2=2;
			}
			else{
				//console.log("link between model nodes")
				if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
					pt2=selectedModelEdges[iv-extraLinesCnt][1];
				}
				else{
					pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
				}
				t2 = selectedModelNodes[pt2][5];
			}
			if (sim2!=2){
				pt2+=jsonObj1.length;
				//console.log(idMap[pt2]);
			}
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
			startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
			
			count+=1;
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
			endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
			
			count+=1;
		}
		scene.children[7].geometry.attributes.position.needsUpdate = true;
		scene.children[7].geometry.attributes.ca.needsUpdate = true;
		
		
		var ii=0;
		for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
		
			scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
			scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
			scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
			ii++;
		}
		//console.log(tokenAttributes.endPosition.value[0]);
		var ii=0;
		for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
			tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
			tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
			tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
			ii++;
		}
		//console.log(tokenAttributes.endPosition.value[0]);
		scene.children[8].geometry.verticesNeedUpdate = true;
		tokenAttributes.endPosition.needsUpdate = true;
		tokenUniforms.mixAmount.value = 0.0;
		
		
	}
	else {
		//console.log("other layout");
		//console.log($("#selectLayout").find('option:selected').text())
		//console.log(layouts[el.value])
		var layout_nodes_coordinates={};
		var sublayout=document.getElementById("selectsublayout").value;
		//console.log(sublayout)
		if (mqml["layout"] && mqml["layout"].hasOwnProperty(sublayout)) {
			//console.log(sublayout)
			for (var i=0, j=mqml["layout"][sublayout].length;i<j;i++){
				layout_nodes_coordinates[mqml["layout"][sublayout][i]['data']['id']]=[mqml["layout"][sublayout][i]['position']['x'],mqml["layout"][sublayout][i]['position']['y'] ]
			}
		}
		
		//console.log(layout_nodes_coordinates)
		// //console.log(selectedModelNodes);
		var cnt1=0;
		var cnt2=0;
		var ln1 = startModelPlaces;
		var ln2 = startModelReactions;
		for (var i=0, j=selectedModelNodes.length;i<j;i++){
			if (selectedModelNodes[i][5]==2 ){
					
					if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
						scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+2]= (-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
						scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
						//scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1]=50;
						//console.log(scene.children[2].geometry.attributes.position.array[(ln1+cnt1)*3+1])
					}
					cnt1++;
			}
			if (selectedModelNodes[i][5]==4 ){
					
					if (layout_nodes_coordinates.hasOwnProperty(selectedModelNodes[i][1])){
						scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+2]=(-layout_nodes_coordinates[selectedModelNodes[i][1]][0]*amountScale);
						scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+0]=(layout_nodes_coordinates[selectedModelNodes[i][1]][1]*amountScale)+1200;
						//console.log(scene.children[4].geometry.attributes.position.array[(ln2+cnt2)*3+1])
					}
					cnt2++;
			}
			
		}
		scene.children[2].geometry.attributes.position.needsUpdate = true;
		scene.children[4].geometry.attributes.position.needsUpdate = true;
		
		var count=0;
		for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
			var t1;
			var t2;
			var pt1;
			var pt2;
			var sim1=1;
			var sim2=1;
			pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
			sim1 = idMap[pt1][0]
			t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
			if (selectedModelEdges[iv-extraLinesCnt][3]==2){
				//console.log("link between model and metabolic nodes")
				
				if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
					pt2=selectedModelEdges[iv-extraLinesCnt][1];
				}
				else{
					pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
				}
				t2 = jsonObj1[pt2][6]
				sim2=2;
			}
			else{
				//console.log("link between model nodes")
				if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
					pt2=selectedModelEdges[iv-extraLinesCnt][1];
				}
				else{
					pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
				}
				t2 = selectedModelNodes[pt2][5];
			}
			if (sim2!=2){
				pt2+=jsonObj1.length;
				//console.log(idMap[pt2]);
			}
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
			startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
			
			count+=1;
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
			scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
			endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
			
			count+=1;
		}
		scene.children[7].geometry.attributes.position.needsUpdate = true;
		scene.children[7].geometry.attributes.ca.needsUpdate = true;
		
		
		var ii=0;
		for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
		
			scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
			scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
			scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
			ii++;
		}
		//console.log(tokenAttributes.endPosition.value[0]);
		var ii=0;
		for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
			tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
			tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
			tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
			ii++;
		}
		//console.log(tokenAttributes.endPosition.value[0]);
		scene.children[8].geometry.verticesNeedUpdate = true;
		tokenAttributes.endPosition.needsUpdate = true;
		tokenUniforms.mixAmount.value = 0.0;
		
	}
	
	
	
	
	var listChildrenPoints=[2,4];
	
	for (var i =0;i< listChildrenPoints.length;i++){
			var c = listChildrenPoints[i];
			for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
				for (var g=0;g<nbCompartments;g++){
					//if (objects[g].scale<1.0){
					//	scene.children[c].geometry
					//}
					if (scene.children[c].geometry.attributes.compartment.array[h]==g){
						//console.log(scene.children[c].geometry)
						
							scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x;//-stackCompInitialPos[cRef].x-stackCompInitialPos[cRef].x;
							scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y;//-stackCompInitialPos[cRef].y-stackCompInitialPos[cRef].y;
							scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z;//-stackCompInitialPos[cRef].z-stackCompInitialPos[cRef].z;
							
							var displacement = new THREE.Vector3(scene.children[c].geometry.attributes.position.array[h*3+0]- objects[g].position.x,
																 scene.children[c].geometry.attributes.position.array[h*3+1]- objects[g].position.y,
																 scene.children[c].geometry.attributes.position.array[h*3+2]- objects[g].position.z)
							if (objects[g].scale.x<1.0){
								scene.children[c].geometry.attributes.position.array[h*3+0]-=(displacement.x*(1-objects[g].scale.x));
								scene.children[c].geometry.attributes.position.array[h*3+1]-=(displacement.y*(1-objects[g].scale.y));
								scene.children[c].geometry.attributes.position.array[h*3+2]-=(displacement.z*(1-objects[g].scale.z));
								scene.children[c].geometry.attributes.size.array[h]*=0.417777;
							}
							if (objects[g].scale.x>1.0){
								var indLayer=-1;
								for (var ref in generalLayout["outer"]){
									if (generalLayout["outer"].hasOwnProperty(ref)){
										indLayer =generalLayout["outer"][ref].indexOf(objects[g].name);
										//if (indLayer!=-1){}
									}
								}
								if (indLayer>-1){
									var lengthV = displacement.length();
									displacement.setLength(lengthV+((indLayer+0.5)*radiusComp));
									scene.children[c].geometry.attributes.position.array[h*3+0]+=(displacement.x);
									scene.children[c].geometry.attributes.position.array[h*3+1]+=(displacement.y+radiusComp/2);
									scene.children[c].geometry.attributes.position.array[h*3+2]+=(displacement.z);
									scene.children[c].geometry.attributes.size.array[h]/=0.417777;
								}
								
								
							}
						
						
					}
				}
			}
			scene.children[c].geometry.attributes.position.needsUpdate = true;
			scene.children[c].geometry.attributes.size.needsUpdate = true;
		}
		
		if (mtnlLayout["nodes_layout"]){
			var listDisplacedNodes = Object.keys(mtnlLayout["nodes_layout"]);
			if (listDisplacedNodes.length>0){
				//console.log(mtnlLayout["nodes_layout"])
				for(var i=0, ii= listDisplacedNodes.length;i<ii;i++){
					var typeNode=idMap[listDisplacedNodes[i]][0];
					var indexNode=idMap[listDisplacedNodes[i]][1];
					if (typeNode==2){
						scene.children[listChildrenPoints[0]].geometry.attributes.position.array[indexNode*3+0]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].x;
						scene.children[listChildrenPoints[0]].geometry.attributes.position.array[indexNode*3+1]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].y;
						scene.children[listChildrenPoints[0]].geometry.attributes.position.array[indexNode*3+2]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].z;
						
					}
					if (typeNode==4){
						scene.children[listChildrenPoints[1]].geometry.attributes.position.array[indexNode*3+0]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].x;
						scene.children[listChildrenPoints[1]].geometry.attributes.position.array[indexNode*3+1]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].y;
						scene.children[listChildrenPoints[1]].geometry.attributes.position.array[indexNode*3+2]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].z;
					}
				}
				scene.children[listChildrenPoints[0]].geometry.attributes.position.needsUpdate = true;
				scene.children[listChildrenPoints[1]].geometry.attributes.position.needsUpdate = true;
				//
				//
				//if (typeNode==2){console.log(""+2)}
				//if (typeNode==4){console.log(""+4)}
				//
				
			}
			//console.log("nodes layout")
			//
		}
		
		//console.log(metabolicNodes[9802])
		
		var indexChildrenLines=7;
		var iv=0;
		for ( var i = 0; i < segments; i ++ ) {
			var t1 = metabolicNodes[metabolicEdges[i][0]][6]
			var t2 = metabolicNodes[metabolicEdges[i][1]][6]
			//console.log(t1)
			//console.log(t2)
			//var ivList=[]
			var doIt=0
			if (t1==2){
				//console.log(idMap[jsonObj2[i][0]][1])
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[listChildrenPoints[0]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[listChildrenPoints[0]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[listChildrenPoints[0]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
				
				iv++;
			}
			else if (t1==4){
				//console.log(idMap[jsonObj2[i][0]][1])
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[listChildrenPoints[1]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[listChildrenPoints[1]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[listChildrenPoints[1]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
				iv++;
			}
			if (t2 ==2){
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[listChildrenPoints[0]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[listChildrenPoints[0]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[listChildrenPoints[0]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
				iv++;
			}
			else if (t2 ==4){
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[listChildrenPoints[1]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[listChildrenPoints[1]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
				scene.children[indexChildrenLines].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[listChildrenPoints[1]].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
				iv++;
			}
			
		}
		scene.children[indexChildrenLines].geometry.attributes.position.needsUpdate = true;
	
		var ii=0;
		for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
		
			scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
			scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
			scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
			ii++;
		}
		//console.log(tokenAttributes.endPosition.value[0]);
		var ii=0;
		for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
			tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
			tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
			tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
			
			ii++;
		}
		tokenUniforms.mixAmount.value = 0.0;
		//var ii=0;
		//for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
		//	tokenAttributes.mixAmount.value[ii] = 0.0;
		//	ii++;
		//}
		//tokenAttributes.mixAmount.needsUpdate = true;
		//console.log(tokenAttributes.endPosition.value[0]);
		scene.children[8].geometry.verticesNeedUpdate = true;
		tokenAttributes.endPosition.needsUpdate = true;
	
	
	
	
		if (nbPlacesModel!=0 && nbReactionsModel!=0){
				console.log(nbPlacesModel)
				console.log(nbReactionsModel)
				var cnt1=0;
				var cnt2=0;
				var cnt=0;
				
				//var ln1 = scene.children[2].geometry.attributes.size.array.length-5000; 
				//var ln2 = scene.children[4].geometry.attributes.size.array.length-5000; 
				var ln1 = startModelPlaces;
				var ln2 = startModelReactions;
				//console.log(ln1)
				//console.log(startModelPlaces)
				
				
				var col2 = new THREE.Color( 0xffa500 );
				
				
				//console.log(selectedModelNodes)
				//for (var s= 0; s<selectedModelEdges.length;s++){
				//	if (selectedModelEdges[s][0]==108){
				//	console.log(s)
				//	}
				//}
				//console.log(nbEdgesModel)
				var count=0;
				for ( var iv = extraLinesCnt; iv <extraLinesCnt+nbEdgesModel; iv +=1) {
					var t1;
					var t2;
					var pt1;
					var pt2;
					var sim1=1;
					var sim2=1;
					pt1 = selectedModelEdges[iv-extraLinesCnt][0]+jsonObj1.length;
					sim1 = idMap[pt1][0]
					t1 = selectedModelNodes[selectedModelEdges[iv-extraLinesCnt][0]][5];
					if (selectedModelEdges[iv-extraLinesCnt][3]==2){
						//console.log("link between model and metabolic nodes")
						
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = jsonObj1[pt2][6]
						sim2=2;
					}
					else{
						//console.log("link between model nodes")
						if (typeof selectedModelEdges[iv-extraLinesCnt][1] == "number"){
							pt2=selectedModelEdges[iv-extraLinesCnt][1];
						}
						else{
							pt2=selectedModelEdges[iv-extraLinesCnt][1][0];
						}
						t2 = selectedModelNodes[pt2][5];
					}
					if (sim2!=2){
						pt2+=jsonObj1.length;
						//console.log(idMap[pt2]);
					}
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt1][0]].geometry.attributes.position.array[ (idMap[pt1][1] * 3) + 2 ]+0.0;
					startPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][0]]=count+extraLinesCnt;
					if (sim2==2){
					//console.log("link between model nodes")
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
					}
					count+=1;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 0 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 0 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 1 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 1 ]+0.0;
					scene.children[7].geometry.attributes.position.array[ ((count+extraLinesCnt) * 3) + 2 ] =scene.children[idMap[pt2][0]].geometry.attributes.position.array[ (idMap[pt2][1] * 3) + 2 ]+0.0;
					endPositionTokenMap[selectedModelEdges[iv-extraLinesCnt][1]]=count+extraLinesCnt;
					if (sim2==2){
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 ] = col2.r;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 1 ] = col2.g;
					scene.children[7].geometry.attributes.ca.array[ (count+extraLinesCnt) * 3 + 2 ] = col2.b;
					}
					count+=1;
				}
				scene.children[7].geometry.attributes.position.needsUpdate = true;
				scene.children[7].geometry.attributes.ca.needsUpdate = true;
				
				// selectedLinesPathsIds=[]
				// for (var i=0; i<selectedLinesPaths.length;i++){
					// for (var j=0;j<linesMap[selectedLinesPaths[i]].length;j+=1){
						// selectedLinesPathsIds.push(linesMap[selectedLinesPaths[i]][j])
					// }
				// }
				// selectedLinesPathsIds = unique(selectedLinesPathsIds)
				// for (var i=0;i<selectedLinesPathsIds.length;i+=1){
					// scene.children[7].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] +=150000;
				// }
				// scene.children[7].geometry.attributes.position.needsUpdate = true;
					
				var ii=0;
				for ( var i = 0; i <segmentPts+maxNbTokenModel ; i +=2 ) {
				
					scene.children[8].geometry.vertices[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					scene.children[8].geometry.vertices[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					if (i>=segmentPts){
					scene.children[8].geometry.vertices[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ];
					}
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				var ii=0;
				for ( var i = 1; i <segmentPts+maxNbTokenModel ; i +=2 ) {
					tokenAttributes.endPosition.value[ii].x=scene.children[7].geometry.attributes.position.array[ (i * 3) ]+0;
					tokenAttributes.endPosition.value[ii].y=scene.children[7].geometry.attributes.position.array[ (i * 3) + 1 ]+0;
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ]+0;
					if (i>=segmentPts){
					tokenAttributes.endPosition.value[ii].z=scene.children[7].geometry.attributes.position.array[ (i * 3) + 2 ];
					}
					ii++;
				}
				//console.log(tokenAttributes.endPosition.value[0]);
				scene.children[8].geometry.verticesNeedUpdate = true;
				tokenAttributes.endPosition.needsUpdate = true;
				tokenUniforms.mixAmount.value = 0.0;
			}
		
	
	
	
	
	
	</script>	
	
	
	
	
