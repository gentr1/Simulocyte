<div class='container'>
<br><br>
	<h1>Metabolic Network Layout </h1>
	<hr>
	<h2>Name: <%= mtnl.name %> </h2>
	<hr>
	<h2>Comment: </h2>
	<%= mtnl.comment %>
	<h2>Metabolic network: </h2>
	<%= mtnl.metabolic_net %>
	<hr>
	<h3 id="titleComp" style="position: absolute;left: 20px;">Edit/Add New Compartments:</h3>
	<div id="compTable" style="position: absolute;left: 20px;"></div>
	<br>	
	<br>
	
	<div id="searchfield" style="position: absolute;left: 20px;"><h3>Edit Nodes Compartments:</h3><br>Search Term: <input id="searchgrid" type="text" /></div>
	<br>
	<div id="mtnTable" style="position: absolute;left: 20px;"></div>	
	<br>
	<h3 id="titleEditor" style="position: absolute;left: 20px;">Layout Editor:  
	<select id="modeSelector" onchange="runModeSelector()">
  <option value="0">between compartments</option>
  <option value="1">inside compartments</option>
	</select></h3>
	<div id="container"  style="position: absolute;left: 0px; overflow: inherit">  </div>
	
	<div id="container2"  style="position: absolute;left: 0px; overflow: inherit">  </div>
	<div id="layout1menu" class="btn-group-vertical" role="group" aria-label="..." style="position: absolute;left: 0px;">
		<button class="btn btn-default btn-xs" title="Merge" id="b_merge" style="position: relative;left: 20px;">Merge</button>
		<button class="btn btn-default btn-xs" title="Stack above" id="b_above" style="position: relative;left: 20px;">Place Above</button>
		<button class="btn btn-default btn-xs" title="Stack below" id="b_below" style="position: relative;left: 20px;">Place Below</button>
		<button class="btn btn-default btn-xs" title="Add as Inner Circle" id="b_inner" style="position: relative;left: 20px;">Add as Inner</button>
		<button class="btn btn-default btn-xs" title="Add as Outer Circle" id="b_outer" style="position: relative;left: 20px;">Add as Outer</button>
		<button class="btn btn-default btn-xs" title="Add as Satellite" id="b_satellite" style="position: relative;left: 20px;">Add as Satellite</button>
		<button class="btn btn-default btn-xs" title="Add as Subset" id="b_subset" style="position: relative;left: 20px;">Add as Subset</button>
		<button class="btn btn-warning btn-xs" title="Cancel" id="b_cancel" style="position: relative;left: 20px;">Cancel</button>
	</div>
	
	
</div>	

	<script id="fragmentShader" type="x-shader/x-fragment">
			
			varying vec2 vUv;

			#define FB_ZOOM 0.075
			#define BEAM_WIDTH 0.0005

			void main(void)
			{
				float t = 0.0;
				float intensity = BEAM_WIDTH;
				vec2 unit = vec2(cos(t), sin(t));
				float aspect = 0.5;
				vec2 position = vUv;
				//position.y *= resolution.y / resolution.x;
				vec2 ms = vec2(0.5, 0.5);
				//ms.y *= resolution.y / resolution.x;
				vec2 uv = ((gl_FragCoord.xy ) - vec2(0.5)) * FB_ZOOM + vec2(0.5);
				float f = 0.0;

				f += intensity / abs(dot(position - ms, unit));
				f += intensity / abs(dot(position - ms, vec2(unit.y, -unit.x)));
				f += intensity / abs(dot(position - ms, vec2(2.0*ms.x, -unit.x)));
				f += intensity / abs(dot(position - ms, vec2(-2.0*ms.x, -unit.x)));
				f += intensity / abs(0.3 - length(position - ms));
				f += intensity / abs(0.2 - length(position - ms));
				f += intensity / abs(0.1 - length(position - ms));
				
				gl_FragColor = vec4(f * 1.0, f * 0.0, f * 0., 0.3);
			}

	</script>
	
	<script id="vertexShader" type="x-shader/x-vertex">

			varying vec2 vUv;

			void main()
			{
				vUv = uv;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
			}

		</script>
	<script>
	
	$('#layout1menu').hide();
		$('#layout1menu').zIndex(2000);
		var stopThreeJsMouseEvent = false;	
		var initialPos=new THREE.Vector3( 0, 0, 0 );
		var initialName="";
		var spacing=120;
		var radiusComp=40;
		
		var selectedMetabolicData = <%-JSON.stringify(mtb.file)%>
		//console.log("getting metabolic data from default file recon2");
		var listCompartments=selectedMetabolicData[0];
		var compIds=[];
		for (var i=0; i<listCompartments.length;i++){
			compIds.push(listCompartments[i][0]);
		}
		var listNodes=selectedMetabolicData[1];
		var txtComp=[]
		var maxNbComp=20;
		var compLayout={"merged":[],"above":[], "outer":[], "satellite":[], "in":[]};
		var stackCompToMove=[];
		var stackCompInitialPos={};
		//console.log(listCompartments.length)
		for (var i=0;i<maxNbComp;i++){
			txtComp[i] = document.createElement('div');
			txtComp[i].style.position = 'absolute';
			txtComp[i].style.width = 100;
			txtComp[i].style.height = 100;
			txtComp[i].style.color = "black";
			txtComp[i].style.fontSize="xx-small";
			txtComp[i].id = "txt"+i;
			//txtComp[i].style.fontWeight="1900";
			txtComp[i].style.backgroundColor = "#99FFCC";
			txtComp[i].style.opacity = 0.5;
			//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
			txtComp[i].innerHTML = 'hello ';
			txtComp[i].style.top = 4000 + 'px';
			txtComp[i].style.left = 4000 + 'px';
			txtComp[i].style.zIndex = 1000;
			txtComp[i].className="disabled";
			//txtComp[i].style="cursor: none"
			//txtComp[i].pointer-events:none;
			document.body.appendChild(txtComp[i]);
			
		}
		
		var container, stats;
		var camera, controls, scene, renderer, uniforms;
		var objects = [], plane;

		var mouse = new THREE.Vector2(),
		offset = new THREE.Vector3(),
		INTERSECTED,INTERSECTED2, SELECTED;
		
		var myLayout = <%-JSON.stringify(mtnl.layout)%>
		
		init();
		animate();
		
		function toXYCoords (pos) {
			//var vector = projector.projectVector(pos.clone(), camera);
			
			var vector = pos.clone().project(camera);//projector.projectVector(pos.clone(), camera);
			vector.x = (vector.x + 1)/2 * window.innerWidth;
			vector.y = -(vector.y - 1)/2 * window.innerHeight;
			return vector;
		}
		function init() {

			container = document.getElementById( 'container' );
			//document.body.appendChild( container );

			camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
			camera.position.z = -800;
			camera.position.y = 500;
			//camera.position.x = -800;
			
			scene = new THREE.Scene();
			scene.add( new THREE.AmbientLight( 0xffffff,2.5 ) );

			var light = new THREE.SpotLight( 0xffffff, 2.5 );
			light.position.set( 0, 500, 2000 );
			light.castShadow = true;

			light.shadowCameraNear = 200;
			light.shadowCameraFar = camera.far;
			light.shadowCameraFov = 50;

			light.shadowBias = -0.00022;
			light.shadowDarkness = 0.5;

			light.shadowMapWidth = 2048;
			light.shadowMapHeight = 2048;

			scene.add( light );

			//var geometry = new THREE.BoxGeometry( 40, 40, 40 );
			var geometry = new THREE.SphereGeometry( radiusComp, 50, 15 );

			for ( var i = 0; i < maxNbComp; i ++ ) {
				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x777777, side: THREE.BackSide}));//, transparent: true, opacity: 0.5} ) );
				//var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: (1.0-((i/maxNbComp)*0.5)) * 0xffffff, side: THREE.BackSide}));
				object.material.ambient = object.material.color;
				object.position.x = -9999999;
				object.position.y = -9999999;
				object.position.z = -9999999;
				object.scale.y = 0.5;
				
				scene.add( object );
				objects.push( object );
			}
			for ( var i = 0; i < listCompartments.length; i ++ ) {
				objects[i].position.x = 0;
				objects[i].position.y = 0;
				objects[i].position.z = 0;
				objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
				//objects[i].castShadow = true;
				//objects[i].receiveShadow = true;	
			}
			
			uniforms = {
				time: { type: "f", value: 1.0 },
				resolution: { type: "v2", value: new THREE.Vector2() }
			};

			var smaterial = new THREE.ShaderMaterial( {

				uniforms: uniforms,
				vertexShader: document.getElementById( 'vertexShader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
				 opacity: 0.15, transparent: true ,
				side: THREE.DoubleSide 
			} );
			
			
			plane = new THREE.Mesh(
				new THREE.PlaneBufferGeometry( 2000, 2000, 8, 8 ),
				smaterial
				//new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.45, transparent: true } )
			);
			plane.rotation.x -= (90*(Math.PI / 180));
			//KeggMapPlan.rotation.z += (90*(Math.PI / 180));
			plane.visible = true;
			scene.add( plane );

			renderer = new THREE.WebGLRenderer( { antialias: true } );
			//renderer.setClearColor( 0xf5f5f5 );
			renderer.setClearColor( 0xe0e0e0 );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.sortObjects = false;

			renderer.shadowMapEnabled = true;
			renderer.shadowMapType = THREE.PCFShadowMap;

			container.appendChild( renderer.domElement );

			controls = new THREE.OrbitControls( camera, renderer.domElement) ;
			
			controls.damping = 0.2;
			

			controls.noZoom = false;
			controls.noPan = false;

			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3;
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			container.appendChild( stats.domElement );

			renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
			renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
			renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );

			//

			window.addEventListener( 'resize', onWindowResize, false );

		}
			
		var list_merged_chains={};	
		var generalLayout ={'merged':{},'above':{},'outer':{},'satellite':{},'in':{}};
		//generalLayout['merged']
		
		function isMerged(comp,cType) {
			var result ="";
			if (generalLayout[cType].hasOwnProperty(comp)){
				result=comp;
			}
			else {
				for (var elem in generalLayout[cType]){
					if (generalLayout[cType].hasOwnProperty(elem)){
						for (var i=0;i<generalLayout[cType][elem].length;i++ ){
							if (generalLayout[cType][elem][i]==comp){
								result=elem;
							}
						}
					} 
				}
			}
			return result;
		}
		
		function isCenterMerged(comp,cType) {
			var result ="";
			if (generalLayout[cType].hasOwnProperty(comp)){
				result=comp;
			}
			
			return result;
		}
		function isPeripheralMerged(comp,cType) {
			var result ="";
			for (var elem in generalLayout[cType]){
				if (generalLayout[cType].hasOwnProperty(elem)){
					for (var i=0;i<generalLayout[cType][elem].length;i++ ){
						if (generalLayout[cType][elem][i]==comp){
							result=elem;
						}
					}
				} 
			}
			
			return result;
		}
			
		var button1 = document.getElementById( 'b_merge' );
			button1.addEventListener( 'click', function ( event ) {
		
			stopThreeJsMouseEvent=false;
			
			
			var targetContainer=isMerged(INTERSECTED.name,'merged');
			var refContainer=isMerged(INTERSECTED2.name,'merged');
			// target and ref items dont exist in the merged list
			if ((targetContainer=="") && (refContainer=="")){
				generalLayout['merged'][INTERSECTED2.name]=[];
				generalLayout['merged'][INTERSECTED2.name].push(INTERSECTED.name)
			}
			// target doesnt exist in the merged list while ref exists
			else if ((targetContainer=="") && (refContainer!="")){
				if (generalLayout['merged'][refContainer].indexOf(INTERSECTED.name)==-1){
					generalLayout['merged'][refContainer].push(INTERSECTED.name)
				}
			}
			// target doesnt exist in the merged list while ref exists
			else if ((targetContainer!="") && (refContainer=="")){
				if (generalLayout['merged'][targetContainer].indexOf(INTERSECTED2.name)==-1){
					generalLayout['merged'][targetContainer].push(INTERSECTED2.name)
				}
			}
			// we want to merge two existing merged groups already
			else{
				var newcontent=$.unique(generalLayout['merged'][targetContainer].concat(generalLayout['merged'][refContainer]));
				if (newcontent.length<listCompartments.length-1){
					newcontent.push(targetContainer);
					generalLayout['merged'][refContainer]=newcontent;
					delete generalLayout['merged'][targetContainer];
				}
				
			}
			
			//compLayout["merged"]=[];
			//for (el in generalLayout['merged']){
			//	if (generalLayout['merged'].hasOwnProperty(el)){
			//		for (var i=0; i<generalLayout['merged'][el].length;i++){
			//			compLayout["merged"].push([generalLayout['merged'][el][i], el])
			//		}
			//	}
			//}
			
			
			//generalLayout['merged']=list_merged_chains;
			placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name, 'merged');
			$('#layout1menu').hide();
			
		});
			
		var button2 = document.getElementById( 'b_above' );
		button2.addEventListener( 'click', function ( event ) {
			//console.log("above");
			stopThreeJsMouseEvent=false;
			
			var targetContainer=isMerged(INTERSECTED.name,'above');
			var refContainer=isMerged(INTERSECTED2.name,'above');
			// target and ref items dont exist in the merged list
			if ((targetContainer=="") && (refContainer=="")){
				generalLayout['above'][INTERSECTED2.name]=[];
				generalLayout['above'][INTERSECTED2.name].push(INTERSECTED.name)
			}
			// target doesnt exist in the merged list while ref exists
			else if ((targetContainer=="") && (refContainer!="")){
				if (generalLayout['above'][refContainer].indexOf(INTERSECTED.name)==-1){
					generalLayout['above'][refContainer].push(INTERSECTED.name)
				}
			}
			// target doesnt exist in the merged list while ref exists
			else if ((targetContainer!="") && (refContainer=="")){
				if (generalLayout['above'][targetContainer].indexOf(INTERSECTED2.name)==-1){
					generalLayout['above'][targetContainer].push(INTERSECTED2.name)
				}
			}
			// we want to merge two existing merged groups already
			else{
				var newcontent=$.unique(generalLayout['above'][targetContainer].concat(generalLayout['above'][refContainer]));
				if (newcontent.length<listCompartments.length-1){
					newcontent.push(targetContainer);
					generalLayout['above'][refContainer]=newcontent;
					delete generalLayout['above'][targetContainer];
				}
				
			}
			
			
			
			//compLayout["above"].push([INTERSECTED.name, INTERSECTED2.name] );
			//console.log(compLayout);
			placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name,'above');
			$('#layout1menu').hide();
		});
		var button3 = document.getElementById( 'b_below' );
		button3.addEventListener( 'click', function ( event ) {
			//console.log("below");
			stopThreeJsMouseEvent=false;
			
			var targetContainer=isMerged(INTERSECTED.name,'above');
			var refContainer=isMerged(INTERSECTED2.name,'above');
			// target and ref items dont exist in the merged list
			if ((targetContainer=="") && (refContainer=="")){
				generalLayout['above'][INTERSECTED.name]=[];
				generalLayout['above'][INTERSECTED.name].push(INTERSECTED2.name)
			}
			// target doesnt exist in the merged list while ref exists
			else if ((targetContainer=="") && (refContainer!="")){
				var newcontent=generalLayout['above'][refContainer].slice();
				
				if (newcontent.length<listCompartments.length-1){
					newcontent.unshift(refContainer);
					generalLayout['above'][INTERSECTED.name]=newcontent
					delete generalLayout['above'][refContainer];
				}
			}
			// target does exist in the merged list while ref doesnt exist
			else if ((targetContainer!="") && (refContainer=="")){
				if (generalLayout['above'][targetContainer].indexOf(INTERSECTED2.name)==-1){
					generalLayout['above'][targetContainer].push(INTERSECTED2.name)
				}
			}
			// we want to merge two existing merged groups already
			else{
				var newcontent=$.unique(generalLayout['above'][targetContainer].concat(generalLayout['above'][refContainer]));
				if (newcontent.length<listCompartments.length-1){
					newcontent.unshift(refContainer);
					generalLayout['above'][targetContainer]=newcontent;
					delete generalLayout['above'][refContainer];
				}
				
			}
			
			
			//compLayout["above"].push([INTERSECTED2.name, INTERSECTED.name] );
			//console.log(compLayout);
			placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name,'below');
			$('#layout1menu').hide();
		});
		var button4 = document.getElementById( 'b_inner' );
		button4.addEventListener( 'click', function ( event ) {
			//console.log("inner");
			stopThreeJsMouseEvent=false;
			
			var targetContainer=isMerged(INTERSECTED.name,'outer');
			var refContainer=isMerged(INTERSECTED2.name,'outer');
			// target and ref items dont exist in the merged list
			if ((targetContainer=="") && (refContainer=="")){
				generalLayout['outer'][INTERSECTED.name]=[];
				generalLayout['outer'][INTERSECTED.name].push(INTERSECTED2.name)
			}
			// target doesnt exist in the merged list while ref exists
			else if ((targetContainer=="") && (refContainer!="")){
				var newcontent=generalLayout['outer'][refContainer].slice();
				
				if (newcontent.length<listCompartments.length-1){
					newcontent.unshift(refContainer);
					generalLayout['outer'][INTERSECTED.name]=newcontent
					delete generalLayout['outer'][refContainer];
				}
			}
			// target does exist in the merged list while ref doesnt exist
			else if ((targetContainer!="") && (refContainer=="")){
				if (generalLayout['outer'][targetContainer].indexOf(INTERSECTED2.name)==-1){
					generalLayout['outer'][targetContainer].push(INTERSECTED2.name)
				}
			}
			// we want to merge two existing merged groups already
			else{
				var newcontent=$.unique(generalLayout['outer'][targetContainer].concat(generalLayout['outer'][refContainer]));
				if (newcontent.length<listCompartments.length-1){
					newcontent.unshift(refContainer);
					generalLayout['outer'][targetContainer]=newcontent;
					delete generalLayout['outer'][refContainer];
				}
				
			}
			
			
			//compLayout["outer"].push([INTERSECTED2.name, INTERSECTED.name] );
			//console.log(compLayout);
			placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name,'outer');
			$('#layout1menu').hide();
		});
		var button5 = document.getElementById( 'b_outer' );
		button5.addEventListener( 'click', function ( event ) {
			//console.log("outer");
			stopThreeJsMouseEvent=false;
			
			var targetContainer=isMerged(INTERSECTED.name,'outer');
			var refContainer=isMerged(INTERSECTED2.name,'outer');
			// target and ref items dont exist in the merged list
			if ((targetContainer=="") && (refContainer=="")){
				generalLayout['outer'][INTERSECTED2.name]=[];
				generalLayout['outer'][INTERSECTED2.name].push(INTERSECTED.name)
			}
			// target doesnt exist in the merged list while ref exists
			else if ((targetContainer=="") && (refContainer!="")){
				if (generalLayout['outer'][refContainer].indexOf(INTERSECTED.name)==-1){
					generalLayout['outer'][refContainer].push(INTERSECTED.name)
				}
			}
			// target doesnt exist in the merged list while ref exists
			else if ((targetContainer!="") && (refContainer=="")){
				if (generalLayout['outer'][targetContainer].indexOf(INTERSECTED2.name)==-1){
					generalLayout['outer'][targetContainer].push(INTERSECTED2.name)
				}
			}
			// we want to merge two existing merged groups already
			else{
				var newcontent=$.unique(generalLayout['outer'][targetContainer].concat(generalLayout['outer'][refContainer]));
				if (newcontent.length<listCompartments.length-1){
					newcontent.push(targetContainer);
					generalLayout['outer'][refContainer]=newcontent;
					delete generalLayout['outer'][targetContainer];
				}
				
			}
			//console.log(generalLayout['outer']);
			//compLayout["outer"].push([INTERSECTED.name, INTERSECTED2.name] );
			//console.log(compLayout);
			placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name,'outer');
			$('#layout1menu').hide();
		});
		var button6 = document.getElementById( 'b_satellite' );
		button6.addEventListener( 'click', function ( event ) {
			//console.log(INTERSECTED2.name);
			
			stopThreeJsMouseEvent=false;
			var refComp=INTERSECTED2.name;
			for (var ref in generalLayout["outer"]){
				if (generalLayout["outer"].hasOwnProperty(ref)){
					var indComp=generalLayout["outer"][ref].indexOf(INTERSECTED2.name);
					if (INTERSECTED2.name==ref || indComp!=-1 ){
						refComp=ref;
					}
				}
			}
			//console.log(refComp);
			var targetContainer=isCenterMerged(INTERSECTED.name,'satellite');
			var targetContainer2=isPeripheralMerged(INTERSECTED.name,'satellite');
			var refContainer=isCenterMerged(refComp,'satellite');
			var refContainer2=isPeripheralMerged(refComp,'satellite');
			if (!(targetContainer2!="")){
				if((targetContainer=="") && (refContainer=="")){
					generalLayout['satellite'][refComp]=[];
					generalLayout['satellite'][refComp].push(INTERSECTED.name)
				}
				else if ((targetContainer=="") && !(refContainer=="")){
					if (generalLayout['satellite'][refComp].indexOf(INTERSECTED.name)==-1){
						generalLayout['satellite'][refComp].push(INTERSECTED.name);
					}
				}
				else if (!(targetContainer=="") && (refContainer=="")){
					generalLayout['satellite'][refComp.name]=[];
					if (generalLayout['satellite'][refComp].indexOf(INTERSECTED.name)==-1){
						generalLayout['satellite'][refComp].push(INTERSECTED.name);
					}
				}
				else{
					if (generalLayout['satellite'][refComp].indexOf(INTERSECTED.name)==-1){
						generalLayout['satellite'][refComp].push(INTERSECTED.name);
					}
				}
				
				
			}
			
			//compLayout["satellite"].push([INTERSECTED.name, INTERSECTED2.name] );
			//console.log(generalLayout['satellite']);
			placeCompFromLayout(INTERSECTED.name, refComp,'satellite');
			$('#layout1menu').hide();
		});
		var button7 = document.getElementById( 'b_subset' );
		button7.addEventListener( 'click', function ( event ) {
			//console.log("subset");
			stopThreeJsMouseEvent=false;
			
			var targetContainer=isCenterMerged(INTERSECTED.name,'in');
			var targetContainer2=isPeripheralMerged(INTERSECTED.name,'in');
			var refContainer=isCenterMerged(INTERSECTED2.name,'in');
			var refContainer2=isPeripheralMerged(INTERSECTED2.name,'in');
			if (!(targetContainer2!="")){
				if((targetContainer=="") && (refContainer=="")){
					generalLayout['in'][INTERSECTED2.name]=[];
					generalLayout['in'][INTERSECTED2.name].push(INTERSECTED.name)
				}
				else if ((targetContainer=="") && !(refContainer=="")){
					if (generalLayout['in'][INTERSECTED2.name].indexOf(INTERSECTED.name)==-1){
						generalLayout['in'][INTERSECTED2.name].push(INTERSECTED.name);
					}
				}
				else if (!(targetContainer=="") && (refContainer=="")){
					generalLayout['in'][INTERSECTED2.name]=[];
					if (generalLayout['in'][INTERSECTED2.name].indexOf(INTERSECTED.name)==-1){
						generalLayout['in'][INTERSECTED2.name].push(INTERSECTED.name);
					}
				}
				else{
					if (generalLayout['in'][INTERSECTED2.name].indexOf(INTERSECTED.name)==-1){
						generalLayout['in'][INTERSECTED2.name].push(INTERSECTED.name);
					}
				}
				
				
			}
			
			//compLayout["in"].push([INTERSECTED.name,INTERSECTED2.name] );
			//console.log(compLayout);
			placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name,'in');
			$('#layout1menu').hide();
		});
		var button8 = document.getElementById( 'b_cancel' );
		button8.addEventListener( 'click', function ( event ) {
			//console.log("cancel");
			stopThreeJsMouseEvent=false;
			for ( var i = 0; i < listCompartments.length; i ++ ) {
				if (objects[i].name==initialName){
					objects[i].position.x=initialPos.x;
					objects[i].position.y=initialPos.y;
					objects[i].position.z=initialPos.z;
					SELECTED = null;
					SELECTED2=null;
				}
			}
			
			
			
			$('#layout1menu').hide();
		});
			

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {
				if (stopThreeJsMouseEvent==false){
					event.preventDefault();
					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( (event.clientY-$("#container").position().top+window.pageYOffset) / window.innerHeight ) * 2 + 1;
					var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );
					var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
					if ( SELECTED ) {
						var intersects2 = raycaster.intersectObjects( objects );
						if ( intersects2.length > 1 ) {
							if (SELECTED.name==intersects2[0].object.name)
								INTERSECTED2=intersects2[1].object;
							else
								INTERSECTED2=intersects2[0].object;
						}
						else{
							INTERSECTED2=null;
						}
						//plane.position.y=SELECTED.position.y;
						var intersects = raycaster.intersectObject( plane );						
						var mustMove=true;
						
						
						
						if( mustMove==true){
						SELECTED.position.copy( intersects[ 0 ].point );
						
						
						}
						
						
						stackCompToMove=[];
						
						function addToStack(cname){
							for (var typeComp in generalLayout){
								if (generalLayout.hasOwnProperty(typeComp)){
									for (var ref in generalLayout[typeComp]){
										if (generalLayout[typeComp].hasOwnProperty(ref)){
											var indComp=generalLayout[typeComp][ref].indexOf(cname);
											if (cname==ref || indComp!=-1 ){
												if (stackCompToMove.indexOf(ref)==-1){
													stackCompToMove.push(ref);
												}
												for (var i=0; i<generalLayout[typeComp][ref].length;i++ ){
													if (stackCompToMove.indexOf(generalLayout[typeComp][ref][i])==-1){
														stackCompToMove.push(generalLayout[typeComp][ref][i]);
													}
												}
											}
										}
									}
								}
							}
						}
						
						
						addToStack(SELECTED.name);
						for (var i=0; i<stackCompToMove.length;i++ ){
							addToStack(stackCompToMove[i]);
						}
						//console.log(stackCompToMove)
						
						var displacement =new THREE.Vector3();
						displacement.subVectors(SELECTED.position,initialPos );
						displacement.y=0;
						//console.log(displacement)
						
						
						
						function moveComp(compName){
							for (var ref in generalLayout["merged"]){
								if (generalLayout["merged"].hasOwnProperty(ref)){
									if (compName==ref || generalLayout["merged"][ref].indexOf(compName)!=-1 ){
										mustMove=true;
										for (var j=0; j<listCompartments.length;j++ ){
											if (objects[j].name==ref || generalLayout["merged"][ref].indexOf(objects[j].name)!=-1){	
												objects[j].position.addVectors(stackCompInitialPos[objects[j].name],displacement);	
											}
										}
									}
								}
							}
							for (var ref in generalLayout["above"]){
								if (generalLayout["above"].hasOwnProperty(ref)){
									if (compName==ref || generalLayout["above"][ref].indexOf(compName)!=-1 ){
										mustMove=true;
										for (var j=0; j<listCompartments.length;j++ ){
											if (objects[j].name==ref || generalLayout["above"][ref].indexOf(objects[j].name)!=-1){	
												objects[j].position.addVectors(stackCompInitialPos[objects[j].name],displacement);	
											}
										}
									}
								}
							}
							for (var ref in generalLayout["outer"]){
								if (generalLayout["outer"].hasOwnProperty(ref)){
									if (compName==ref || generalLayout["outer"][ref].indexOf(compName)!=-1 ){
										mustMove=true;
										for (var j=0; j<listCompartments.length;j++ ){
											if (objects[j].name==ref || generalLayout["outer"][ref].indexOf(objects[j].name)!=-1){	
												objects[j].position.addVectors(stackCompInitialPos[objects[j].name],displacement);	
											}
										}
									}
								}
							}
							for (var ref in generalLayout["in"]){
								if (generalLayout["in"].hasOwnProperty(ref)){
									if (compName==ref || generalLayout["in"][ref].indexOf(compName)!=-1 ){
										mustMove=true;
										for (var j=0; j<listCompartments.length;j++ ){
											if (objects[j].name==ref || generalLayout["in"][ref].indexOf(objects[j].name)!=-1){	
												objects[j].position.addVectors(stackCompInitialPos[objects[j].name],displacement);	
											}
										}
									}
								}
							}
							for (var ref in generalLayout["satellite"]){
								if (generalLayout["satellite"].hasOwnProperty(ref)){
									if (compName==ref || generalLayout["satellite"][ref].indexOf(compName)!=-1 ){
										mustMove=true;
										for (var j=0; j<listCompartments.length;j++ ){
											if (objects[j].name==ref || generalLayout["satellite"][ref].indexOf(objects[j].name)!=-1){	
												objects[j].position.addVectors(stackCompInitialPos[objects[j].name],displacement);	
											}
										}
									}
								}
							}
						}
						
						for (var i=0; i<stackCompToMove.length;i++ ){
							moveComp(stackCompToMove[i]);
							//console.log(stackCompInitialPos)
						}
						
						
						
						//plane.position.copy( intersects[ 0 ].point);						
						return;
					}
					var intersects = raycaster.intersectObjects( objects );
					if ( intersects.length > 0 ) {						
							if ( INTERSECTED != intersects[ 0 ].object ) {
								if ( INTERSECTED ) {
									INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
								}
								INTERSECTED = intersects[ 0 ].object;
								INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
								//console.log(generalLayout);
								//plane.rotation.x -= (90*(Math.PI / 180));
							}
							container.style.cursor = 'pointer';						
					} else {

						if ( INTERSECTED ) {
							INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
						}
						INTERSECTED = null;
						INTERSECTED2 = null;
						container.style.cursor = 'auto';
					}
				}
			}

			function onDocumentMouseDown( event ) {				
				event.preventDefault();
				switch ( event.button ) {
					case 0: // left 
						var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );
						var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
						var intersects = raycaster.intersectObjects( objects );
						if ( intersects.length > 0 ) {							
								controls.enabled = false;
								if(SELECTED==null){
									initialPos.x=intersects[ 0 ].object.position.x;
									initialPos.y=intersects[ 0 ].object.position.y;
									initialPos.z=intersects[ 0 ].object.position.z;
									initialName = intersects[ 0 ].object.name;
									//console.log(initialPos)
								}
								SELECTED = intersects[ 0 ].object;
								plane.position.y=SELECTED.position.y;
								
								// store initial position of all other compartments 
								stackCompInitialPos={};
								for (var i=0; i<listCompartments.length;i++ ){
									stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
								}
								
								//var intersects = raycaster.intersectObject( plane );
								//offset.copy( intersects[ 0 ].point ).sub( plane.position );
								container.style.cursor = 'move';							
						}
					case 1: // middle
						break;
					case 2: // right
						break;
				}
			}
			function onDocumentMouseUp( event ) {
			//console.log("up")
				switch ( event.button ) {
					case 0: // left 						
						event.preventDefault();
						controls.enabled = true;
						if ( INTERSECTED ) {							
							if ( INTERSECTED2!=null ) {								
								var prevent =false;								
								for (var typeLink in generalLayout){
									if (generalLayout.hasOwnProperty(typeLink)){
										for (var ref in generalLayout[typeLink]){
											if (generalLayout[typeLink].hasOwnProperty(ref)){
												if ((INTERSECTED2.name==ref && generalLayout[typeLink][ref].indexOf(INTERSECTED.name)!=-1)||
												(INTERSECTED.name==ref && generalLayout[typeLink][ref].indexOf(INTERSECTED2.name)!=-1) ||
												(generalLayout[typeLink][ref].indexOf(INTERSECTED.name)!=-1 && generalLayout[typeLink][ref].indexOf(INTERSECTED2.name)!=-1)
												){
													prevent =true;
												}
											}
										}
									}
								}
								if (prevent ==false){
								
								
								
								
								//console.log(INTERSECTED.name+" dragged and dropped on :"+INTERSECTED2.name)
								$('#layout1menu').show();
								var vector = new THREE.Vector3(INTERSECTED2.position.x,INTERSECTED2.position.y,INTERSECTED2.position.z);
								var pp = toXYCoords(vector	);
					
					
								document.getElementById("layout1menu").style.top = (pp.y+$('#container').position().top) + 'px';
								document.getElementById("layout1menu").style.left = (pp.x)+ 'px';
								stopThreeJsMouseEvent=true;
								}
							}
							SELECTED = null;
							myLayout["compartments_layout"]["structure"]=generalLayout;
							var layoutdata={};
							for (var j=0; j<listCompartments.length;j++ ){
								layoutdata[objects[j].name]={"position":objects[j].position, "scale":objects[j].scale}
							}
							myLayout["compartments_layout"]["spatial-layout"]=layoutdata;
							//console.log(myLayout)
						}						
						container.style.cursor = 'auto';
					case 1: // middle
						break;
					case 2: // right
						break;
				}
			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {
				controls.update();
				var poscont = $("#container");
				//var cnt_merged=0;
				var cnt_merged_comp={};
				for ( var i = 0; i < listCompartments.length; i ++ ) {
					//cnt_merged=0;
					var vector = new THREE.Vector3( objects[i].position.x+(-radiusComp*objects[i].scale.x),objects[i].position.y,objects[i].position.z);
					var pp = toXYCoords(vector	);
					
					if (pp.x >=0 && pp.y >=0 && pp.x <=poscont.width()-10 && pp.y <=poscont.height()-10){
						document.getElementById("txt"+i).style.top = (pp.y+poscont.position().top+(0*12)) + 'px';
						document.getElementById("txt"+i).style.left = (pp.x +20)+ 'px';
					}
					else{
						document.getElementById("txt"+i).style.top = 4000 + 'px';
						document.getElementById("txt"+i).style.left = 4000+ 'px';
					}
					for (el in list_merged_chains){
						if (list_merged_chains.hasOwnProperty(el)){
							if (objects[i].name==el){
								document.getElementById("txt"+i).style.top = (pp.y+poscont.position().top+(0*12)) + 'px';
								document.getElementById("txt"+i).style.left = (pp.x +20)+ 'px';
							}
							for (var j=0;j<list_merged_chains[el].length;j++){
								if (objects[i].name==list_merged_chains[el][j]){
									document.getElementById("txt"+i).style.top = (pp.y+poscont.position().top+((j+1)*12)) + 'px';
									document.getElementById("txt"+i).style.left = (pp.x +20)+ 'px';
								}
								
							}
						}
					}					
					document.getElementById("txt"+i).innerHTML = objects[i].name;			
				}			
				renderer.render( scene, camera );
			}

	var $container1 = $("#compTable");
	$container1.handsontable({
	  data: [],
	  width: 400,
	  height:200,
	  dataSchema: {c_id: null, c_name: null},
	  startRows: 1,
	  startCols: 2,
	  contextMenu: ['remove_row'],
	  //maxRows: 1,
	  colHeaders: ['Comp. id', 'Comp. name'],
	  columns: [
		{data: "c_id"},
		{data: "c_name"}
	  ],
	  beforeRemoveRow: function(ind, numb){
		var dt = this.getData();
		
		if (dt[0]['c_id']!=null){
			
			var id_removed = dt[ind]['c_id']+" "+dt[ind]['c_name'];
			//console.log(id_removed)
			var listL = Object.keys(compLayout);
			for (var i=0; i<listL.length;i++){
				var listI=[];
				for (var j=0; j<compLayout[listL[i]].length;j++){
					
					if ((compLayout[listL[i]][j][0]==id_removed) || (compLayout[listL[i]][j][1]==id_removed)){
						
					}
					else{
						listI.push(compLayout[listL[i]][j])
					}
				}
				compLayout[listL[i]]=listI;
			}
			
			//console.log(compLayout);
			//console.log(dt.length);
			
			
		}
	  },
	  afterRemoveRow: function(ind, numb){
		var dt = this.getData();
		
		if (dt[0]['c_id']!=null){
			listCompartments=[];
			for (var i=0, j= dt.length;i<j-1;i++){
				listCompartments.push([dt[i]['c_id'],dt[i]['c_name']]);
				
			}
			// delete meshes
			for ( var i = 0; i < maxNbComp; i ++ ) {
					objects[i].position.x = -9999999;
					objects[i].position.y = -9999999;
					objects[i].position.z = -9999999;
					objects[i].name="";
					txtComp[i].innerHTML = 'hello ';
					txtComp[i].style.top = 4000 + 'px';
					txtComp[i].style.left = 4000 + 'px';
			}
			for ( var i = 0; i < listCompartments.length; i ++ ) {
			
				objects[i].position.x = 0;
				objects[i].position.y = 0;
				objects[i].position.z = 0;
				
				objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
				objects[i].castShadow = true;
				objects[i].receiveShadow = true;	
				
			}
			
			//console.log(dt.length);
			
			
		}
	  },
	  afterChange: function(changes, source) {
		var dt = this.getData();		
		if (dt[0]['c_id']!=null){
			listCompartments=[];
			for (var i=0, j= dt.length;i<j-1;i++){
				listCompartments.push([dt[i]['c_id'],dt[i]['c_name']]);
				
			}
			compIds=[];
			for (var i=0; i<listCompartments.length;i++){
				compIds.push(listCompartments[i][0]);
			}
			// delete meshes
			for ( var i = 0; i < maxNbComp; i ++ ) {
					objects[i].position.x = -9999999;
					objects[i].position.y = -9999999;
					objects[i].position.z = -9999999;
					objects[i].name="";
					txtComp[i].innerHTML = 'hello ';
					txtComp[i].style.top = 4000 + 'px';
					txtComp[i].style.left = 4000 + 'px';
			}
			for ( var i = 0; i < listCompartments.length; i ++ ) {
				objects[i].position.x = 0;
				objects[i].position.y = 0;
				objects[i].position.z = 0;
				objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
				objects[i].castShadow = true;
				objects[i].receiveShadow = true;	
				
			}
			//console.log(listCompartments);
			//console.log(dt.length);
			
			selectedMetabolicData[0]=listCompartments;
			//console.log(selectedMetabolicData[0]);
		}
		
	  },
	  minSpareRows: 1
	});
	var tempdata1=listCompartments;

	var ht = $('#compTable').handsontable('getInstance');
	if ($.isArray(tempdata1) && tempdata1[0] && $.isArray(tempdata1[0])){
		ht.populateFromArray (0, 0, tempdata1,tempdata1.length-1, 1);
	}
	$("#compTable").css({top:  $("#titleComp").position().top + $("#titleComp").height()+40});
	
	var $container1 = $("#mtnTable");
	$container1.handsontable({
	  data: [],
	  width: 700,
	  height:200,
	  colWidths: [100, 400,150],
	  dataSchema: {n_id:null, n_name: null, c_name: null},
	  startRows: 1,
	  startCols: 3,
	  colHeaders: ['Node nb','Node name', 'Comp. name'],
	  columns: [
		{data: "n_id"},
		{data: "n_name"},
		{data: "c_name"},//, type: 'dropdown',source: compIds}
	  ],
	  beforeChange: function(changes, source) {
		if ((Array.isArray(changes[0])) && changes[0][2] ){
			if (changes[0][1]!="c_name" && changes[0][1]!="n_name"){
				changes.length=0;
				return false;
			}
			else{ 
				if (changes[0][1]=="c_name" && compIds.indexOf(changes[0][3])==-1){
					changes.length=0;
					return false;
				}
			}
		}
		
	  },
	  afterChange: function(changes, source) {
		if (changes && changes[0] && changes[0][2]){			
			var dt = this.getData(changes[0][0],0,0,2);			
			// change name			
			selectedMetabolicData[1][dt[0][0]][1]=dt[0][1];
			// change compartment
			selectedMetabolicData[1][dt[0][0]][3]=dt[0][2];
		}
		
		
	  },
	  columnSorting: true,
	  minSpareRows: 1
	});
	
	
	
	var tempdata2=[];
	for (var i=0, j= listNodes.length;i<j;i++){
		tempdata2.push([i,listNodes[i][1],listNodes[i][3]])
	}
	

	var ht = $('#mtnTable').handsontable('getInstance');
	if ($.isArray(tempdata2) && tempdata2[0] && $.isArray(tempdata2[0])){
		ht.populateFromArray (0, 0, tempdata2,tempdata2.length-1, 2);
	}
	//console.log(ht)
	//ht.data.columns[0].readOnly=true;
	//ht.columns[1].readOnly=true;
	//$("#compTable").css({top:  $("#container").position().top + $("#container").height()+40});
	$("#searchfield").css({top:  $("#compTable").position().top + $("#compTable").height()+40});
	$("#mtnTable").css({top:  $("#searchfield").position().top + $("#searchfield").height()+10});
	$("#titleEditor").css({top:  $("#mtnTable").position().top + $("#mtnTable").height()+40});
	$("#container").css({top:  $("#titleEditor").position().top + $("#titleEditor").height()+40});
	
	
	$('#searchgrid').on('keyup',function(event){
		var value = ('' + this.value).toLowerCase(),row,col,r_len,c_len,td;
		
		tempdata2=[];
		for (var i=0, j= listNodes.length;i<j;i++){
			tempdata2.push([i,listNodes[i][1],listNodes[i][3]])
		}
		var data = tempdata2;
		
		//var data = $('#tab2id').handsontable('getData');
		//console.log(data)
		var searcharray = [];
		if(value){
			
			for(row=0,r_len = data.length;row< r_len;row++){
				for(col=0,c_len = data[row].length;col < c_len-1; col++){
					if(data[row][col] == null){
						continue;
					}
					if(('' + data[row][col]).toLowerCase().indexOf(value) > -1){
						searcharray.push(data[row]);
						break;
					}
					else{
					}
				}
			}
			
			//console.log(searcharray.length)
			var ht = $('#mtnTable').handsontable('getInstance');
			//ht.clear();
			ht.alter('remove_row', 0, tempdata2.length);
			//console.log(searcharray)
			tempdata2=searcharray;
			if ($.isArray(searcharray) && searcharray[0] && $.isArray(searcharray[0])){
				ht.populateFromArray (0, 0, searcharray,searcharray.length-1, 2);
			}
		}
		else{
			tempdata2=[];
			for (var i=0, j= listNodes.length;i<j;i++){
				tempdata2.push([i,listNodes[i][1],listNodes[i][3]])
			}
			var ht = $('#mtnTable').handsontable('getInstance');
			ht.alter('remove_row', 0, tempdata2.length);
			if ($.isArray(tempdata2) && tempdata2[0] && $.isArray(tempdata2[0])){
				ht.populateFromArray (0, 0, tempdata2,tempdata2.length-1, 2);
			}
		}
		$('#mtnTable').handsontable('deselectCell');
			
		
	});
	
	function placeCompFromLayout(cName, cRef, dropType){
		if (dropType=='merged'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			for (var ref in generalLayout["merged"]){
				if (generalLayout["merged"].hasOwnProperty(ref)){
					if (cName==ref || generalLayout["merged"][ref].indexOf(cName)!=-1 ){
						
						for (var j=0; j<listCompartments.length;j++ ){
							if (objects[j].name==ref || generalLayout["merged"][ref].indexOf(objects[j].name)!=-1){
								objects[j].position.copy( objects[indRef].position );
								objects[j].scale.x=objects[indRef].scale.x;
								objects[j].scale.y=objects[indRef].scale.y;
								objects[j].scale.z=objects[indRef].scale.z;
							}
						}
					}
				}
			}
		}
		if (dropType=='outer'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			for (var ref in generalLayout["outer"]){
				if (generalLayout["outer"].hasOwnProperty(ref)){
					if (cName==ref || generalLayout["outer"][ref].indexOf(cName)!=-1 ){
						mustMove=true;
						for (var j=0; j<listCompartments.length;j++ ){
							var indPos = generalLayout["outer"][ref].indexOf(objects[j].name);
							if (objects[j].name==ref ){
								objects[j].position.copy( objects[indRef].position );
							}
							else if (indPos!=-1){
								objects[j].position.copy( objects[indRef].position );
								//console.log(indPos)
								objects[j].scale.x = 2+indPos;
								objects[j].scale.z = 2+indPos;
							}
							else{}
						}
					}
				}
			}
		}
		if (dropType=='satellite'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			var isRefSatellite=false;
			for (var ref in generalLayout["satellite"]){
				if (generalLayout["satellite"].hasOwnProperty(ref)){
					if (generalLayout["satellite"][ref].indexOf(cRef)!=-1){
						isRefSatellite=true;
					}
				}
			}
			
			var lenOuter=0;
			var nameOuterRef="";
			for (var ref in generalLayout["outer"]){
				if (generalLayout["outer"].hasOwnProperty(ref)){
					var tmpInd=generalLayout["outer"][ref].indexOf(cRef);
					if (cRef==ref ){
						nameOuterRef=ref;
						lenOuter=generalLayout["outer"][ref].length+1;
					}
					else if (tmpInd!=-1 ){
						nameOuterRef=ref;
						lenOuter=generalLayout["outer"][ref].length+1;
					}
					else{}
				}
			}
			var indOuterRef;
			for (var i=0; i<listCompartments.length;i++ ){
				if (objects[i].name==nameOuterRef && objects[i].name!=""){
					indOuterRef=i;
				}
			}
			//console.log(lenOuter)
			for (var ref in generalLayout["satellite"]){
				if (generalLayout["satellite"].hasOwnProperty(ref)){
					var indSat=generalLayout["satellite"][ref].indexOf(cName);
					if (cName==ref || indSat!=-1 ){
						mustMove=true;
						if (indSat!=-1){
							if (lenOuter==0){
								for (var j=0; j<generalLayout["satellite"][ref].length;j++ ){
									var max_rotation_count=generalLayout["satellite"][ref].length;
									var dilation_count=0;
									var tmpNode= generalLayout["satellite"][ref][j];
									for (var j1=0; j1<listCompartments.length;j1++ ){
										if (objects[j1].name==tmpNode && objects[j1].name!=""){
											var scaledSpacing=spacing;
											if (isRefSatellite){
												objects[j1].scale.x=objects[indRef].scale.x*0.417777;
												objects[j1].scale.y=objects[indRef].scale.y*0.417777;
												objects[j1].scale.z=objects[indRef].scale.z*0.417777;
												scaledSpacing=scaledSpacing/((1/(objects[indRef].scale.x)));
											}
											objects[j1].position.x=objects[indRef].position.x+Math.cos(((2 * Math.PI)*(1/max_rotation_count))*j)*(scaledSpacing+((lenOuter)*scaledSpacing/2));
											objects[j1].position.y=objects[indRef].position.y;
											objects[j1].position.z=objects[indRef].position.z+Math.sin(((2 * Math.PI)*(1/max_rotation_count))*j)*(scaledSpacing+((lenOuter)*scaledSpacing/2));
											objects[j1].scale.x=objects[indRef].scale.x*0.417777;
											objects[j1].scale.y=objects[indRef].scale.y*0.417777;
											objects[j1].scale.z=objects[indRef].scale.z*0.417777;
										}
									}
								}
							}
							if (lenOuter>0){
								for (var j=0; j<generalLayout["satellite"][ref].length;j++ ){
									var max_rotation_count=generalLayout["satellite"][ref].length;
									var dilation_count=0;
									var tmpNode= generalLayout["satellite"][ref][j];
									for (var j1=0; j1<listCompartments.length;j1++ ){
										if (objects[j1].name==tmpNode && objects[j1].name!=""){
											var scaledSpacing=spacing;
											if (isRefSatellite){
												objects[j1].scale.x=objects[indOuterRef].scale.x*lenOuter*0.417777;
												objects[j1].scale.y=objects[indOuterRef].scale.y*lenOuter*0.417777;
												objects[j1].scale.z=objects[indOuterRef].scale.z*lenOuter*0.417777;
												scaledSpacing=scaledSpacing/((1/(objects[indOuterRef].scale.x)));
											}
											objects[j1].position.x=objects[indRef].position.x+Math.cos(((2 * Math.PI)*(1/max_rotation_count))*j)*(scaledSpacing+((lenOuter)*scaledSpacing/2));
											objects[j1].position.y=objects[indRef].position.y;
											objects[j1].position.z=objects[indRef].position.z+Math.sin(((2 * Math.PI)*(1/max_rotation_count))*j)*(scaledSpacing+((lenOuter)*scaledSpacing/2));
											objects[j1].scale.x=objects[indOuterRef].scale.x*lenOuter*0.417777;
											objects[j1].scale.y=objects[indOuterRef].scale.y*lenOuter*0.417777;
											objects[j1].scale.z=objects[indOuterRef].scale.z*lenOuter*0.417777;
										}
									}
								}
							}
						}
						else{}
					}
				}
			}
			
		}
		
		
		if (dropType=='in'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			var isRefSatellite=false;
			for (var ref in generalLayout["in"]){
				if (generalLayout["in"].hasOwnProperty(ref)){
					if (generalLayout["in"][ref].indexOf(cRef)!=-1){
						isRefSatellite=true;
					}
				}
			}
			var indOuter=-1;
			var lenOuter=0;
			for (var ref in generalLayout["outer"]){
				if (generalLayout["outer"].hasOwnProperty(ref)){
					var tmpInd=generalLayout["outer"][ref].indexOf(cRef);
					if (cName==ref ){
						indOuter=0;
						lenOuter=generalLayout["outer"][ref].length+1;
					}
					else if (tmpInd!=-1 ){
						indOuter=tmpInd+1;
						lenOuter=generalLayout["outer"][ref].length+1;
					}
					else{}
				}
			}
			
			for (var ref in generalLayout["in"]){
				if (generalLayout["in"].hasOwnProperty(ref)){
					var indSat=generalLayout["in"][ref].indexOf(cName);
					if (cName==ref || indSat!=-1 ){
						mustMove=true;
						if (indSat!=-1){
							for (var j=0; j<generalLayout["in"][ref].length;j++ ){
								var max_rotation_count=generalLayout["in"][ref].length;								
								var tmpNode= generalLayout["in"][ref][j];								
								for (var j1=0; j1<listCompartments.length;j1++ ){
									if (objects[j1].name==tmpNode && objects[j1].name!=""){
										var scaledSpacing=radiusComp*objects[indRef].scale.x*0.72;
										if (lenOuter>1){
												scaledSpacing=(radiusComp*objects[indRef].scale.x)-(radiusComp*objects[indRef].scale.x*(1/((lenOuter+1)*2))*1.4);
										}
										
										if (isRefSatellite){
											objects[j1].scale.x=objects[indRef].scale.x*0.20;
											objects[j1].scale.y=objects[indRef].scale.y*0.20;
											objects[j1].scale.z=objects[indRef].scale.z*0.20;
											scaledSpacing=scaledSpacing/((1/(objects[indRef].scale.x)));
											
										}
										objects[j1].position.x=objects[indRef].position.x+Math.cos(((2 * Math.PI)*(1/max_rotation_count))*j)*(scaledSpacing);
										objects[j1].position.y=objects[indRef].position.y;
										objects[j1].position.z=objects[indRef].position.z+Math.sin(((2 * Math.PI)*(1/max_rotation_count))*j)*(scaledSpacing);
										
										if (lenOuter>1){
											objects[j1].scale.x=objects[indRef].scale.x*(1/((lenOuter+1)*2));
											objects[j1].scale.y=objects[indRef].scale.y*(1/((lenOuter+1)*2));
											objects[j1].scale.z=objects[indRef].scale.z*(1/((lenOuter+1)*2));
										}
										else{
											objects[j1].scale.x=objects[indRef].scale.x*0.20;
											objects[j1].scale.y=objects[indRef].scale.y*0.20;
											objects[j1].scale.z=objects[indRef].scale.z*0.20;
										}
										var maxDiameter=((2 * Math.PI)*objects[indRef].scale.x*radiusComp*0.72)*(1/(max_rotation_count*2));
										var presentDiameter=(objects[j1].scale.x*radiusComp*2);
										if (maxDiameter<=presentDiameter){
											objects[j1].scale.x=objects[j1].scale.x*((maxDiameter/presentDiameter)*1.1)
											objects[j1].scale.y=objects[j1].scale.y*((maxDiameter/presentDiameter)*1.1)
											objects[j1].scale.z=objects[j1].scale.z*((maxDiameter/presentDiameter)*1.1)
										}
										//console.log("max: "+maxDiameter + " present: "+presentDiameter);
									}
								}
							}
						}
						else{}
					}
				}
			}
		}
		
		if (dropType=='above'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			var indCname;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cName){
					indCname=j;
				}
			}
			for (var ref in generalLayout["above"]){
				if (generalLayout["above"].hasOwnProperty(ref)){
					if (cName==ref || generalLayout["above"][ref].indexOf(cName)!=-1 ){
						
						
						var ind=generalLayout["above"][ref].indexOf(cName);
						
						if (cName==ref ){
							var tmpRef;
							for (var j=0; j<listCompartments.length;j++ ){
								if (objects[j].name==ref){
									tmpRef=j;
									objects[j].position.setX(objects[indRef].position.x);
									objects[j].position.setZ(objects[indRef].position.z);
									//console.log(ref)
								}
							}
							for (var j=0; j<generalLayout["above"][ref].length;j++ ){
								var tmpNode= generalLayout["above"][ref][j];
								for (var j1=0; j1<listCompartments.length;j1++ ){
									if (objects[j1].name==tmpNode && objects[j1].name!=""){
										objects[j1].position.setX(objects[tmpRef].position.x);
										objects[j1].position.setZ(objects[tmpRef].position.z);
										objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
									}
								}
							}
						}
						
						if (ind!=-1){
							var tmpRef;
							for (var j=0; j<listCompartments.length;j++ ){
								if (objects[j].name==ref){
									tmpRef=j;
									objects[j].position.setX(objects[indRef].position.x);
									objects[j].position.setZ(objects[indRef].position.z);
									//objects[j].position.setZ(SELECTED.position.z);
								}
							}
							for (var j=0; j<generalLayout["above"][ref].length;j++ ){
								var tmpNode= generalLayout["above"][ref][j];
								for (var j1=0; j1<listCompartments.length;j1++ ){
									if (objects[j1].name==tmpNode && objects[j1].name!=""){
										objects[j1].position.setX(objects[tmpRef].position.x);
										objects[j1].position.setZ(objects[tmpRef].position.z);
										objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
									}
								}
							}
						}
						
						
							
								
					}
				}
			}
		}
		
		if (dropType=='below'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			
			var indCname;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cName){
					indCname=j;
				}
			}
			for (var ref in generalLayout["above"]){
			
				if (generalLayout["above"].hasOwnProperty(ref)){
					if (cName==ref || generalLayout["above"][ref].indexOf(cName)!=-1 ){
						
						
						var ind=generalLayout["above"][ref].indexOf(cName);
						
						if (cName==ref ){
							var tmpRef;
							for (var j=0; j<listCompartments.length;j++ ){
								if (objects[j].name==ref){
									tmpRef=j;
									objects[indRef].position.y-=spacing;
									objects[j].position.setX(objects[indRef].position.x);
									objects[j].position.setZ(objects[indRef].position.z);
									objects[j].position.setY(objects[indRef].position.y);
									//console.log(ref)
								}
							}
							for (var j=0; j<generalLayout["above"][ref].length;j++ ){
								var tmpNode= generalLayout["above"][ref][j];
								for (var j1=0; j1<listCompartments.length;j1++ ){
									if (objects[j1].name==tmpNode && objects[j1].name!=""){
										objects[j1].position.setX(objects[tmpRef].position.x);
										objects[j1].position.setZ(objects[tmpRef].position.z);
										objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
									}
								}
							}
						}
						
						if (ind!=-1){
							var tmpRef;
							for (var j=0; j<listCompartments.length;j++ ){
								if (objects[j].name==ref){
									tmpRef=j;
									objects[j].position.setX(objects[indRef].position.x);
									objects[j].position.setZ(objects[indRef].position.z);
									//objects[j].position.setZ(SELECTED.position.z);
								}
							}
							for (var j=0; j<generalLayout["above"][ref].length;j++ ){
								var tmpNode= generalLayout["above"][ref][j];
								for (var j1=0; j1<listCompartments.length;j1++ ){
									if (objects[j1].name==tmpNode && objects[j1].name!=""){
										objects[j1].position.setX(objects[tmpRef].position.x);
										objects[j1].position.setZ(objects[tmpRef].position.z);
										objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
									}
								}
							}
						}
						
						
							
								
					}
				}
			}
		}
		
		
		for (var ref in generalLayout["merged"]){
			if (generalLayout["merged"].hasOwnProperty(ref)){	
					var indC;
					for (var j=0; j<listCompartments.length;j++ ){
						if (objects[j].name==ref ){
							indC=j;
						}
					}
					for (var j=0; j<listCompartments.length;j++ ){
						if (objects[j].name==ref || generalLayout["merged"][ref].indexOf(objects[j].name)!=-1){
							objects[j].position.copy( objects[indC].position );
							objects[j].scale.x=objects[indC].scale.x;
							objects[j].scale.y=objects[indC].scale.y;
							objects[j].scale.z=objects[indC].scale.z;
						}
					}
				
			}
		}
		
		myLayout["compartments_layout"]["structure"]=generalLayout;
		var layoutdata={};
		for (var j=0; j<listCompartments.length;j++ ){
			layoutdata[objects[j].name]={"position":objects[j].position, "scale":objects[j].scale}
		}
		myLayout["compartments_layout"]["spatial-layout"]=layoutdata;
		//console.log(myLayout);
	}
	
	$("#container2").css({top:  $("#mtnTable").position().top + $("#mtnTable").height()+40});
	
	function runModeSelector(){
		console.log($('#modeSelector').val());
	}
	
	</script>	
	
	
	
	
