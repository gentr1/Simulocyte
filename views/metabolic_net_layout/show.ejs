<div class='container'>
<br><br>
	<h1>Metabolic Network Layout </h1>
	<hr>
	<h2>Name: <%= mtnl.name %> </h2>
	<hr>
	<h2>Comment: </h2>
	<%= mtnl.comment %>
	<h2>Metabolic network: </h2>
	<%= mtnl.metabolic_net %>
	<%
	var allLayout=JSON.stringify({});
	%>
	<% if (session.User.name==mtnl.owner) {%>
	<hr>
	<a href="/metabolic_net_layout/editusers/<%=mtnl.id%>" class="btn btn-sm btn-success">Edit/View list of users privileges</a>
	<%}%>
	<hr>
	<h3 id="titleComp" style="position: absolute;left: 20px;">Edit/Add New Compartments:</h3>
	<div id="compTable" style="position: absolute;left: 20px;"></div>
	<br>	
	<br>
	
	<div id="searchfield" style="position: absolute;left: 20px;"><h3>Edit Metabolites Nodes Compartments:</h3><br>Search Term: <input id="searchgrid" type="text" /></div>
	<br>
	<div id="mtnTable" style="position: absolute;left: 20px;"></div>	
	<br>
	<div id="searchfield2" style="position: absolute;left: 20px;"><h3>Edit Reaction Nodes Compartments:</h3><br>Search Term: <input id="searchgrid2" type="text" /></div>
	<br>
	<div id="mtnTable2" style="position: absolute;left: 20px;height: 300px; overflow: scroll"></div>	
	<br>
	<div id="searchfield3" style="position: absolute;left: 20px;">Search Term: <input id="searchgrid3" type="text" /></div>
	<br>
	<h3 id="titleCurrency" style="position: absolute;left: 20px;">Identify and hide currency metabolites:</h3>
	<br>
	<div id="CurrencyTable" style="position: absolute;left: 20px;height: 300px; overflow: scroll"></div>
	<br>
	<h3 id="titleEditor" style="position: absolute;left: 20px;">Layout Editor:  
	<select id="modeSelector" onchange="runModeSelector()">
  <option value="0">for compartments</option>
  <option value="1">for nodes</option>
	</select>
	
	</h3>
	
	<div id="container"  style="position: absolute;left: 0px; overflow: inherit">  </div>
	<input type="image" id ="editplane" src="/images/editplane1.png" value="0" width="32" height="32" style="position: absolute;left: 0px; overflow: inherit" onclick="changeEditingPlane()">
	<div id="container2"  style="position: absolute;left: 0px; overflow: inherit">  </div>
	<div id="layout1menu" class="btn-group-vertical" role="group" aria-label="..." style="position: absolute;left: 0px;">
		<button class="btn btn-default btn-xs" title="Merge" id="b_merge" style="position: relative;left: 20px;">Merge</button>
		<button class="btn btn-default btn-xs" title="Stack above" id="b_above" style="position: relative;left: 20px;">Place Above</button>
		<button class="btn btn-default btn-xs" title="Stack below" id="b_below" style="position: relative;left: 20px;">Place Below</button>
		<button class="btn btn-default btn-xs" title="Add as Inner Circle" id="b_inner" style="position: relative;left: 20px;">Add as Inner</button>
		<button class="btn btn-default btn-xs" title="Add as Outer Circle" id="b_outer" style="position: relative;left: 20px;">Add as Outer</button>
		<button class="btn btn-default btn-xs" title="Add as Satellite" id="b_satellite" style="position: relative;left: 20px;">Add as Satellite</button>
		<button class="btn btn-default btn-xs" title="Add as Subset" id="b_subset" style="position: relative;left: 20px;">Add as Subset</button>
		<button class="btn btn-warning btn-xs" title="Cancel" id="b_cancel" style="position: relative;left: 20px;">Cancel</button>
	</div>
	<br>
	<h3 id="layoutEditor" style="position: absolute;left: 20px;">Manual Layout - Select compartment :  
	<select id="compSelector" onchange="runCompSelector()"><option value="none" selected>None</option> 
	</select></h3><br>
	
	<div id="layouttools" style="position: absolute;left: 20px;"> <br>
	Choose Layout: <select name="select" id="selectLayout" onchange="selectValue(this)">
	  <option value="0" selected>None</option> 
	  <option value="1">Tree</option> 
	  <option value="2">Circular</option>
	  <option value="3">Concentric</option>
	  <option value="4">Grid</option>
	</select> &nbsp;&nbsp;&nbsp;  <button type="button" class="btn btn-sm btn-primary" onclick="updateLayout()" id="update-button">Update Layout</button></div>
	<div id="cy"  style="height: 40%;width: 40%;position: absolute;left: 0;top: 0;"></div>
	
	
<form action="/metabolic_net_layout/update/<%= mtnl.id %>" id="mtnl-update-form"  method="POST" style="left:0px;height:5%;width:40%;position: absolute;">	
	<input type="text" name="layouts0" id ="layouts0" style="visibility: hidden;" value=<%=allLayout%>>
	<input type="text"  name="layouts1" id ="layouts1" style="visibility: hidden;" value="">
	<input type="text"  name="layouts2" id ="layouts2" style="visibility: hidden;" value="">
	<input type="text"  name="layouts3" id ="layouts3" style="visibility: hidden;" value="">
	<input type="text"  name="layouts4" id ="layouts4" style="visibility: hidden;" value="">
	<input type="text"  name="layouts5" id ="layouts5" style="visibility: hidden;" value="">
	<input type="text"  name="layouts6" id ="layouts6" style="visibility: hidden;" value="">
	<input type="text"  name="layouts7" id ="layouts7" style="visibility: hidden;" value="">
	<input type="text"  name="layouts8" id ="layouts8" style="visibility: hidden;" value="">
	<input type="text"  name="layouts9" id ="layouts9" style="visibility: hidden;" value="">
	<input type="submit" value="Save" class="btn btn-lg btn-primary btn-block"  style="top:0px;left:0px;position: relative;"/>
	<input type="hidden" name="_csrf" value="<%= _csrf %>" />
	</form>			
</div>	

<nav>
		<a href="" id="menuToggle" title="show menu">
		<span class="navClosed"><i>show menu</i></span>
		</a>
		<a href="#" title="Item 1">Hide/Show</a>		
		<br><p style="position: relative;left: 20px;color:white">Line Opacity: <input id="defaultSlider" type="range" min="0.0" max="20.0" value="15" step="0.005" onchange="updateSlider(this.value)" style="position: relative;left: 20px"/></p>			
	</nav>
	
	<div id="menu" >
	
	
	</div>

	<script id="fragmentShader" type="x-shader/x-fragment">
			
			varying vec2 vUv;

			#define FB_ZOOM 0.075
			#define BEAM_WIDTH 0.0005

			void main(void)
			{
				float t = 0.0;
				float intensity = BEAM_WIDTH;
				vec2 unit = vec2(cos(t), sin(t));
				float aspect = 0.5;
				vec2 position = vUv;
				//position.y *= resolution.y / resolution.x;
				vec2 ms = vec2(0.5, 0.5);
				//ms.y *= resolution.y / resolution.x;
				vec2 uv = ((gl_FragCoord.xy ) - vec2(0.5)) * FB_ZOOM + vec2(0.5);
				float f = 0.0;

				f += intensity / abs(dot(position - ms, unit));
				f += intensity / abs(dot(position - ms, vec2(unit.y, -unit.x)));
				f += intensity / abs(dot(position - ms, vec2(2.0*ms.x, -unit.x)));
				f += intensity / abs(dot(position - ms, vec2(-2.0*ms.x, -unit.x)));
				f += intensity / abs(0.3 - length(position - ms));
				f += intensity / abs(0.2 - length(position - ms));
				f += intensity / abs(0.1 - length(position - ms));
				
				gl_FragColor = vec4(f * 1.0, f * 0.0, f * 0., 0.3);
			}

	</script>
	
	<script id="vertexShader" type="x-shader/x-vertex">

			varying vec2 vUv;

			void main()
			{
				vUv = uv;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
			}

		</script>
	
	
	<script type="x-shader/x-vertex" id="vertexshaderP1">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP1">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP2">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP2">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderL1">
			attribute vec3 ca;
			varying vec3 vColor;
			varying float opacity;
			attribute float op;
			void main() {
				vColor = ca;
				opacity =op;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderL1">
			uniform vec3 color;
			varying float opacity;
			varying vec3 vColor;
			void main() {

				gl_FragColor = vec4( vColor * color, opacity );

			}
		</script>
	
	
	<script>
	
	(function($){
		$(document).ready(function(){
		$('#menuToggle').click(function(e){
		var $parent = $(this).parent('nav');
		$parent.toggleClass("open");
		var navState = $parent.hasClass('open') ? "hide" : "show";
		$(this).attr("title", navState + " navigation");
		// Set the timeout to the animation length in the CSS.
		setTimeout(function(){
		//console.log("timeout set");
		$('#menuToggle > span').toggleClass("navClosed").toggleClass("navOpen");
		}, 200);
		e.preventDefault();
		});
		});
	})(jQuery);
	
	if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
	
	$('#layout1menu').hide();
	$('#layout1menu').zIndex(2000);
	
	var mtnlLayout = <%-JSON.stringify(mtnl.layout)%>
	//console.log(mtnlLayout)
	
	var generalLayout ={'merged':{},'above':{},'outer':{},'satellite':{},'in':{}};
	var stopThreeJsMouseEvent = false;	
	var initialPos=new THREE.Vector3( 0, 0, 0 );
	var initialName="";
	var spacing=1650;
	var radiusComp=550;
	var yStartDisplacement=100;
	var nodeSize=5;
	var lineOpacity=0.1;
	var closest;
	var selectedMetabolicData = <%-JSON.stringify(mtb.file)%>
	//console.log("getting metabolic data from default file recon2");
	//if (mtnlLayout["list_compartments"])
	
	var listCompartments=[];
	var selectedLinesPaths=[];
	var selectedLinesPathsIds=[];
	var linesMap=[];
	if (mtnlLayout["list_compartments"] && mtnlLayout["list_compartments"].length==0){
		listCompartments=selectedMetabolicData[0];
		
		//console.log("initial empty list of compartments")
	}
	else if (mtnlLayout["list_compartments"] && mtnlLayout["list_compartments"].length>0){
		listCompartments=mtnlLayout["list_compartments"];
		//console.log("initial existing list of compartments")
	}
	mtnlLayout["list_compartments"]=listCompartments;
	
	//console.log(listCompartments)
	var nbCompartments=listCompartments.length
	var compIds=[];
	var compselector = document.getElementById("compSelector");
	
	for (var i=0; i<listCompartments.length;i++){
		compIds.push(listCompartments[i][0]);
		var option = document.createElement("option");
		option.value = i;
		option.text = listCompartments[i][1];
		//console.log(i)
		compselector.add(option);
	}
	
	
	
	
	
	var txtComp=[]
	var maxNbComp=20;
	var stackCompToMove=[];
	var stackCompInitialPos={};
	var positionContainer;
	var text1 = document.createElement('div');
	text1.style.position = 'absolute';
	text1.style.width = 100;
	text1.style.height = 100;
	text1.style.color = "black";
	text1.style.backgroundColor = "#FFFFCC";
	//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
	text1.innerHTML = 'hello ';
	text1.style.top = 2000 + 'px';
	text1.style.left = 2000 + 'px';
	//text1.style.zIndex = -1;
	document.body.appendChild(text1);
	
	//console.log(listCompartments.length)
	for (var i=0;i<maxNbComp;i++){
		txtComp[i] = document.createElement('div');
		txtComp[i].style.position = 'absolute';
		txtComp[i].style.width = 100;
		txtComp[i].style.height = 100;
		txtComp[i].style.color = "black";
		txtComp[i].style.fontSize="xx-small";
		txtComp[i].id = "txt"+i;
		//txtComp[i].style.fontWeight="1900";
		txtComp[i].style.backgroundColor = "#99FFCC";
		txtComp[i].style.opacity = 0.5;
		//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
		txtComp[i].innerHTML = 'hello ';
		txtComp[i].style.top = 4000 + 'px';
		txtComp[i].style.left = 4000 + 'px';
		txtComp[i].style.zIndex = 1000;
		txtComp[i].className="disabled";
		//txtComp[i].style="cursor: none"
		//txtComp[i].pointer-events:none;
		document.body.appendChild(txtComp[i]);
		
	}
	var text1PreviousPos= new THREE.Vector3( 2000, 2000, 1 );
	var text1PreviousString="";
	
	var container, stats;
	var camera, controls, scene, renderer, uniforms;
	var objects = [], plane;

	var mouse = new THREE.Vector2(),
	offset = new THREE.Vector3(),
	INTERSECTED,INTERSECTED2, SELECTED,INTERSECTED_P;
	INTERSECTED_P=-1;
	//var myLayout = <%-JSON.stringify(mtnl.layout)%>
		
	
	var metabolicNodes;	
	var metabolicEdges;
	
	// change compartment nodes attribution from data
	if (mtnlLayout["nodes_compartments"]){
		var listChangedNodes = Object.keys(mtnlLayout["nodes_compartments"]);
		if (listChangedNodes.length>0){
		
			for(var i=0, ii= listChangedNodes.length;i<ii;i++){			
				//console.log(selectedMetabolicData[1][listChangedNodes[i]])
				selectedMetabolicData[1][listChangedNodes[i]][1]=mtnlLayout["nodes_compartments"][listChangedNodes[i]][0];
				selectedMetabolicData[1][listChangedNodes[i]][3]=mtnlLayout["nodes_compartments"][listChangedNodes[i]][1];
				//console.log(selectedMetabolicData[1][listChangedNodes[i]])
			}
		}
		
	}
	
	
	var listNodes=selectedMetabolicData[1];
	metabolicNodes = selectedMetabolicData[1];
	metabolicEdges = selectedMetabolicData[2];	
	//console.log(metabolicEdges.length)
	var nbMetabolites=0;
	var nbReactions=0;
	for (var i = 0, ii= metabolicNodes.length;i<ii;i++){
			if (metabolicNodes[i][6]==2){
				nbMetabolites++;
			}
			if (metabolicNodes[i][6]==4){
				nbReactions++;
			}
	}	
	
	
	var nameComp=[];
	var mapComp = {'-1':-1};
	
	for (var i=0;i<listCompartments.length;i++){
		mapComp[listCompartments[i][0]]=i;
		nameComp.push(listCompartments[i][1]);
	}
	//console.log(listCompartments)
	//console.log(mapComp)
	//console.log(nameComp)
	var subSystems;
	var totalSubSystems;
	var nbAreas;
	
	var segments =metabolicEdges.length;
	var segmentPts =segments*2;
	//console.log(nbMetabolites)
	//console.log(nbReactions)
	//console.log(segments)
	//console.log(segmentPts)
	
	var particleP1Attributes;
	var particleP1Uniforms;
	var particle1ShaderMaterial;
	var bgeometryP1;
	var PointCloud1;
	
	var particleP2Attributes;
	var particleP2Uniforms;
	var particle2ShaderMaterial;
	var bgeometryP2;
	var PointCloud2;
	
	var linesAttributes;
	var linesUniforms;
	var linesShaderMaterial;
	var bgeometryL1;
	var meshL1;
	
	var idMap=[];
	var typesMap=[];
	for (var i=0;i<7;i++){
		typesMap[i]=[];
	};
	var reactionMap=[];
	var linesMap=[];
	
	var NodeEditingPlane;
	var moveNode=false;
	
	var arrowX;
	var arrowY;
	var arrowz;
	
	init();
	animate();
		
		function toXYCoords (pos) {
			//var vector = projector.projectVector(pos.clone(), camera);
			
			var vector = pos.clone().project(camera);//projector.projectVector(pos.clone(), camera);
			vector.x = (vector.x + 1)/2 * window.innerWidth;
			vector.y = -(vector.y - 1)/2 * window.innerHeight;
			return vector;
		}
		function init() {

		
			//////////////////////////////////////////////////
			// define shader attributes for group of particles proteins
			particleP1Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};
			particleP1Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/disc.png" ) }
				

			};
			particleP1Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;		
			particle1ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP1Uniforms,
				attributes:     particleP1Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP1' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP1' ).textContent,
				depthTest: 		true,
				transparent:	true

			});
			//////////////////////////////////////////////////
			// define shader attributes for group of particles standard pn
			particleP2Attributes = {
				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};
			particleP2Uniforms = {
				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/PN1.png" ) }
			};
			particleP2Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			particle2ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP2Uniforms,
				attributes:     particleP2Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP2' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP2' ).textContent,
				depthTest: 		true,
				transparent:	true

			});
			//////////////////////////////////////////////
			// define shader attributes for group of lines
			linesAttributes = {

				//displacement: {	type: 'v3', value: [] },
				ca: {	type: 'c', value: [] },
				op:{ type: "f", value: [] }

			};
			linesUniforms = {
				//amplitude: { type: "f", value: 1.0 },
				opacity:   { type: "f", value: 0.7 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) }

			};
			// define shader material for group of lines
			linesShaderMaterial = new THREE.ShaderMaterial( {
				uniforms:       linesUniforms,
				attributes:     linesAttributes,
				vertexShader:   document.getElementById( 'vertexshaderL1' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderL1' ).textContent,
				blending:       THREE.AdditiveBlending,
				depthTest:      false,
				transparent:    true

			});
			linesShaderMaterial.linewidth = 0.1;
			linesShaderMaterial.blending = THREE.AdditiveBlending;//THREE.SubtractiveBlending;//THREE.NoBlending;//THREE.MultiplyBlending;//THREE.NormalBlending;//THREE.AdditiveBlending;
			
			linesShaderMaterial.transparent = true;
			//linesShaderMaterial.depthTest = true;
			
			container = document.getElementById( 'container' );
			//document.body.appendChild( container );

			camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000000 );
			camera.position.z = -8000;
			camera.position.y = 5000;
			//camera.position.x = -800;
			
			scene = new THREE.Scene();
			scene.add( new THREE.AmbientLight( 0xffffff,0.5 ) );

			var light = new THREE.SpotLight( 0xffffff, 1.5 );
			light.position.set( 0, 5000, 20000 );
			//light.castShadow = true;
			
			//light.shadowCameraNear = 2000;
			//light.shadowCameraFar = camera.far;
			//light.shadowCameraFov = 50;

			//light.shadowBias = -0.00022;
			//light.shadowDarkness = 0.5;

			//light.shadowMapWidth = 2048;
			//light.shadowMapHeight = 2048;

			scene.add( light );

			//var geometry = new THREE.BoxGeometry( 40, 40, 40 );
			var geometry = new THREE.SphereGeometry( radiusComp, 50, 15 );

			for ( var i = 0; i < maxNbComp; i ++ ) {
				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x777777, side: THREE.BackSide}));//THREE.BackSide}));//, transparent: true, opacity: 0.5} ) );
				//var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: (1.0-((i/maxNbComp)*0.5)) * 0xffffff, side: THREE.BackSide}));
				object.material.ambient = object.material.color;
				object.position.x = -99999999;
				object.position.y = -99999999;
				object.position.z = -99999999;
				object.scale.y = 0.5;
				
				scene.add( object );
				objects.push( object );
			}
			
			//mtnlLayout["compartments_layout"]["name-position-scale"]=[];
			//for (var i=0; i<listCompartments.length;i++ ){
			//	mtnlLayout["compartments_layout"]["name-position-scale"][i]=[objects[i].name, objects[i].position , objects[i].scale];
			//}
			for ( var i = 0; i < listCompartments.length; i ++ ) {
				objects[i].position.x = 0;
				objects[i].position.y = 0;
				objects[i].position.z = 0;
				objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
				stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
				//objects[i].castShadow = true;
				//objects[i].receiveShadow = true;	
			}
			if (mtnlLayout["compartments_layout"] && mtnlLayout["compartments_layout"].hasOwnProperty("name-position-scale")){
				if (mtnlLayout["compartments_layout"]["name-position-scale"].length>0){
					for ( var i = 0; i < mtnlLayout["compartments_layout"]["name-position-scale"].length; i ++ ) {
						objects[i].position.x = mtnlLayout["compartments_layout"]["name-position-scale"][i][1].x;
						objects[i].position.y = mtnlLayout["compartments_layout"]["name-position-scale"][i][1].y;
						objects[i].position.z = mtnlLayout["compartments_layout"]["name-position-scale"][i][1].z;
						objects[i].name = mtnlLayout["compartments_layout"]["name-position-scale"][i][0];
						stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
						objects[i].scale.x = mtnlLayout["compartments_layout"]["name-position-scale"][i][2].x;
						objects[i].scale.y = mtnlLayout["compartments_layout"]["name-position-scale"][i][2].y;
						objects[i].scale.z = mtnlLayout["compartments_layout"]["name-position-scale"][i][2].z;
					}
				}
			}
			
			if (mtnlLayout["compartments_layout"] && mtnlLayout["compartments_layout"].hasOwnProperty("relations")){
				generalLayout=mtnlLayout["compartments_layout"]["relations"];
			}
			
			
			
			
			
			uniforms = {
				time: { type: "f", value: 1.0 },
				resolution: { type: "v2", value: new THREE.Vector2() }
			};

			var smaterial = new THREE.ShaderMaterial( {

				uniforms: uniforms,
				vertexShader: document.getElementById( 'vertexShader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
				 opacity: 0.15, transparent: true ,
				side: THREE.DoubleSide 
			} );
			
			
			plane = new THREE.Mesh(
				new THREE.PlaneBufferGeometry( 20000, 20000, 8, 8 ),
				smaterial
				//new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.45, transparent: true } )
			);
			plane.rotation.x -= (90*(Math.PI / 180));
			//KeggMapPlan.rotation.z += (90*(Math.PI / 180));
			plane.visible = true;
			scene.add( plane );

			
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for protein particles
			bgeometryP1 = new THREE.BufferGeometry();			
			bgeometryP1.dynamic = true;
			var positionsP1 = new Float32Array( nbMetabolites * 3 );
			var values_colorP1 = new Float32Array( nbMetabolites * 3 );
			var values_sizeP1 = new Float32Array( nbMetabolites );
			var compartmentP1 = new Float32Array( nbMetabolites );
			var color = new THREE.Color( 0xff9900 );;
			var color2 = new THREE.Color( 0x55ff55 );
			var radius =400;
			var bv=0;
			for( var bw = 0 , bww= metabolicNodes.length; bw < bww; bw++ ) {
				if (metabolicNodes[bw][6]==2){
					values_sizeP1[ bv ] = nodeSize;
					compartmentP1[ bv ] = mapComp[metabolicNodes[bw][3]];
					idMap[bw]=[2,bv];
					typesMap[2][bv]=bw;
					
					var rm;
					var rr;
					
					
					rm=bv*0.008*2*Math.PI;
					rr = ((bv*0.02)+0.05*radius);
					positionsP1[ bv * 3 + 0 ] = Math.cos(rm) *rr;
					positionsP1[ bv * 3 + 1 ] = yStartDisplacement+0+(bv*0.02);
					
					
					positionsP1[ bv * 3 + 2 ] = Math.sin(rm) *rr;
					
					values_colorP1[ bv * 3 + 0 ] = color.r;
					values_colorP1[ bv * 3 + 1 ] = color.g;
					values_colorP1[ bv * 3 + 2 ] = color.b;
					bv++;
				}
			}
			
			
			
			
			
			
			bgeometryP1.addAttribute( 'position', new THREE.BufferAttribute( positionsP1, 3 ) );
			bgeometryP1.addAttribute( 'ca', new THREE.BufferAttribute( values_colorP1, 3 ) );
			bgeometryP1.addAttribute( 'size', new THREE.BufferAttribute( values_sizeP1, 1 ) );
			bgeometryP1.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentP1, 1 ) );
			
			b1values_size = bgeometryP1.attributes.size.array;
			b1positions = bgeometryP1.attributes.position.array;
			b1values_color = bgeometryP1.attributes.ca.array;
			b1values_compartment = bgeometryP1.attributes.compartment.array;
			
			bgeometryP1.computeBoundingSphere();
			// associate first particle system with bufferGeometry
			PointCloud1 = new THREE.PointCloud( bgeometryP1, particle1ShaderMaterial );

			PointCloud1.dynamic = true;
			PointCloud1.sortParticles = true;
			PointCloud1.geometry.__dirtyVertices = true;
			PointCloud1.frustumCulled = false;
			scene.add( PointCloud1 );
			
			/////////////////////////////////////////////
			// defines first buffergeometry for PN particles
			bgeometryP2 = new THREE.BufferGeometry();
			var positionsP2 = new Float32Array( nbReactions * 3 );
			var values_colorP2 = new Float32Array( nbReactions * 3 );
			var values_sizeP2 = new Float32Array( nbReactions );
			var compartmentP2 = new Float32Array( nbReactions );
			bgeometryP2.dynamic = true;
			var color = new THREE.Color( 0xffffff );					
			var color2 = new THREE.Color( 0x55ffff );
			var radius =400;
			var bv=0;
			// now allocate a nb of nodes by sub systems
			subSystems={};
			totalSubSystems=0;			
			totalNbreactions=0;
			for( var bs = 0 , bww= metabolicNodes.length; bs < bww; bs++ ) {
				if (metabolicNodes[bs][6]==4){
					if (metabolicNodes[bs][4][1] && metabolicNodes[bs][4][1][0]){
						if (subSystems[metabolicNodes[bs][4][1][0]]=== undefined){
							subSystems[metabolicNodes[bs][4][1][0]]=1;
							totalSubSystems++;
						}
						else{
							subSystems[metabolicNodes[bs][4][1][0]]++;
							totalSubSystems++;
						}
						
					}
					totalNbreactions++;
				}
			}
			totalOutsideSubSystems=totalNbreactions-totalSubSystems;
			nbSubSystems=Object.keys(subSystems).length
			if (totalOutsideSubSystems>0){
				nbAreas=nbSubSystems+1;
				subSystems["Not present"]=totalOutsideSubSystems;
			}
			else{
				nbAreas=nbSubSystems;
			}
			// if there is no subsystem identified just use standard spiral layout			
			// if there are n subsystems then display circular region of width proportional to the nb of nodes in each subsystem
			// first make a list of widths
			// total nb of reactions will dictate the overall nb of points that must be displayed on the ring.
			// depth of the ring is 30 points. there are for 0.004 *2Pi=1.44 degrees = 250 graduations on a circle 
			var listWidthSubSystems={};
			var nbCircleGraduations=250;
			var minCircleFraction=1/nbCircleGraduations;
			var nbNodesDepth=40;
			var totalWidth=0;
			for (var key in subSystems) {
				if (subSystems.hasOwnProperty(key)) {
					var width= Math.ceil(subSystems[key]/nbNodesDepth);
					listWidthSubSystems[key]=[subSystems[key]/*nb of nodes*/,width,/*counter value*/0];
					totalWidth+=width;
				}
			}
			nbNodesDepth=Math.ceil((40*totalWidth)/244);
			listWidthSubSystems={};
			var totalWidth=0;
			var cumulativeWidth=0;
			var colorswap=1.0;
			for (var key in subSystems) {
				if (subSystems.hasOwnProperty(key)) {
					var width= Math.ceil(subSystems[key]/nbNodesDepth);
					listWidthSubSystems[key]=[subSystems[key]/*nb of nodes*/,width,cumulativeWidth,/*counter value*/0,colorswap];
					totalWidth+=width;
					cumulativeWidth+=width;
					if (colorswap==1.0){
					colorswap=0.7;
					}
					else{colorswap=1.0}
				}
			}
			
			var localRSeparator=0;
			for( var bw = 0 , bww= metabolicNodes.length; bw < bww; bw++ ) {
				if (metabolicNodes[bw][6]==4){
					values_sizeP2[ bv ] = nodeSize;
					//b5values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;					
					// try to assign the compartment of the majority of the products the reaction is linked to 
					// if there is no product, assign the compartment of the majority of modifiers
					// if there is no modifier, assign the compartment of the majority of reactants
					var listProducts= metabolicNodes[bw][11][1];
					var listModifiers= metabolicNodes[bw][11][2];
					var listReactants= metabolicNodes[bw][11][0];
					
					if (listProducts.length>0){
						var votes=[];
						for (var ncc=0;ncc<nbCompartments;ncc++){
							votes[ncc]=0;
						}
						for(var lp=0;lp<listProducts.length;lp++){
							if (mapComp[metabolicNodes[listProducts[lp]][3]]>=0)
								votes[mapComp[metabolicNodes[listProducts[lp]][3]]]++;
						}
						var winner= votes.indexOf(Math.max.apply( Math, votes ));
						compartmentP2[ bv ] = winner;
						if (winner==-1){
							compartmentP2[ bv ] = mapComp[metabolicNodes[bw][3]];
						}
					} 
					else if (listModifiers.length>0){
						var votes=[];
						for (var ncc=0;ncc<nbCompartments;ncc++){
							votes[ncc]=0;
						}
						for(var lp=0;lp<listModifiers.length;lp++){
							if (mapComp[metabolicNodes[listModifiers[lp]][3]]>=0)
								votes[mapComp[metabolicNodes[listModifiers[lp]][3]]]++;
						}
						var winner= votes.indexOf(Math.max.apply( Math, votes ));
						compartmentP2[ bv ] = winner;
						if (winner==-1){
							compartmentP2[ bv ] = mapComp[metabolicNodes[bw][3]];
						}
					}
					else if (listReactants.length>0){
						var votes=[];
						for (var ncc=0;ncc<nbCompartments;ncc++){
							votes[ncc]=0;
						}
						for(var lp=0;lp<listReactants.length;lp++){
							if (mapComp[metabolicNodes[listReactants[lp]][3]]>=0)
								votes[mapComp[metabolicNodes[listReactants[lp]][3]]]++;
						}
						var winner= votes.indexOf(Math.max.apply( Math, votes ));
						compartmentP2[ bv ] = winner;
						if (winner==-1){
							compartmentP2[ bv ] = mapComp[metabolicNodes[bw][3]];
						}
					}
					else {
						compartmentP2[ bv ] = mapComp[metabolicNodes[bw][3]];
					}
					idMap[bw]=[4,bv];
					typesMap[4][bv]=bw;
					var rm;
					var rr; 
					var yModifier=0;
					var mDepth=0;
					if (metabolicNodes[bw][4][1] && metabolicNodes[bw][4][1][0]){						
						if (listWidthSubSystems.hasOwnProperty(metabolicNodes[bw][4][1][0])) {
						
							var startingW=listWidthSubSystems[metabolicNodes[bw][4][1][0]][2];
							var maxWidth=listWidthSubSystems[metabolicNodes[bw][4][1][0]][1];
							var maxDepth=nbNodesDepth;
							var maxNbNodes=listWidthSubSystems[metabolicNodes[bw][4][1][0]][0];
							var presentIndex= listWidthSubSystems[metabolicNodes[bw][4][1][0]][3];
							if (presentIndex<maxNbNodes){							
								var localWPos=0;
								var localRR=0;
								localWPos=Math.floor(presentIndex/maxDepth);
								localRR=presentIndex%maxDepth;
								yModifier=	localRR;
								mDepth=maxDepth;
								rm=((startingW+localRSeparator+localWPos)*0.004*(2*Math.PI));								
								rr= ((radius-maxDepth*5)+(localRR*5));
								listWidthSubSystems[metabolicNodes[bw][4][1][0]][3]++;
								color.r=listWidthSubSystems[metabolicNodes[bw][4][1][0]][4];
								if (color.r==1.0){
								color.g=1.0;
								color.b=1.0;
								}
								else{
								color.g=0.4;
								color.b=1.0;
								}
							}
						}
					}
					else{						
						if (listWidthSubSystems.hasOwnProperty("Not present")) {						
							var startingW=listWidthSubSystems["Not present"][2];
							var maxWidth=listWidthSubSystems["Not present"][1];
							var maxDepth=nbNodesDepth;
							var maxNbNodes=listWidthSubSystems["Not present"][0];
							var presentIndex= listWidthSubSystems["Not present"][3];
							if (presentIndex<maxNbNodes){
								var localWPos=0;
								var localRR=0;
								localWPos=Math.floor(presentIndex/maxDepth);
								localRR=presentIndex%maxDepth;
								yModifier=	localRR;	
								mDepth=maxDepth;
								rm=((startingW+localRSeparator+localWPos)*0.004*(2*Math.PI));
								rr= ((radius-maxDepth*5)+(localRR*5));
								listWidthSubSystems["Not present"][3]++;
								color = new THREE.Color( 0xff0000 );
							}
						}
					}
					positionsP2[ bv * 3 + 1 ] = yStartDisplacement-(mDepth*4)+(yModifier*4);
					positionsP2[ bv * 3 + 0 ] = Math.cos(rm) *rr;
					positionsP2[ bv * 3 + 2 ] = Math.sin(rm) *rr;
					values_colorP2[ bv * 3 + 0 ] = color.r;
					values_colorP2[ bv * 3 + 1 ] = color.g;
					values_colorP2[ bv * 3 + 2 ] = color.b;
					bv++;
				}
			}
			bgeometryP2.addAttribute( 'position', new THREE.BufferAttribute( positionsP2, 3 ) );
			bgeometryP2.addAttribute( 'ca', new THREE.BufferAttribute( values_colorP2, 3 ) );
			bgeometryP2.addAttribute( 'size', new THREE.BufferAttribute( values_sizeP2, 1 ) );
			bgeometryP2.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentP2, 1 ) );
			
			//bgeometryP5.attributes.size.needsUpdate = true;
			//bgeometryP5.attributes.position.needsUpdate = true;
			//bgeometryP5.attributes.ca.needsUpdate = true;
			//bgeometryP5.attributes.compartment.needsUpdate = true;

			b2values_size = bgeometryP2.attributes.size.array;
			b2positions = bgeometryP2.attributes.position.array;
			b2values_color = bgeometryP2.attributes.ca.array;
			b2values_compartment = bgeometryP2.attributes.compartment.array;
									
			// associate first particle system with bufferGeometry
			PointCloud2 = new THREE.PointCloud( bgeometryP2, particle2ShaderMaterial );

			PointCloud2.dynamic = true;
			PointCloud2.sortParticles = true;
			PointCloud2.geometry.__dirtyVertices = true;
			PointCloud2.frustumCulled = false;
			scene.add( PointCloud2 );
			
			/////////////////////////////////////////////
			// defines buffergeometry for lines
			bgeometryL1 = new THREE.BufferGeometry();
			var positionsL1 = new Float32Array( (segmentPts) * 3 );
			var colorsL1 = new Float32Array( (segmentPts) * 3 );
			var opL1 = new Float32Array((segmentPts));
			var compartmentL1 = new Float32Array( (segments)*2 );
			var fluxL1 = new Float32Array( (segments) );
			var boundsL1= new Float32Array( (segments) * 2 );
			var r = 800;
			var col = new THREE.Color( 0x00ffff );
			var col2 = new THREE.Color( 0x55ff55 );
			
			var iv=0;
			for ( var i = 0; i < segments; i ++ ) {
			
				var t1 = metabolicNodes[metabolicEdges[i][0]][6]
				var t2 = metabolicNodes[metabolicEdges[i][1]][6]
				var ivList=[]
				
				if (t1==2){
					
					positionsL1[ (iv * 3)+0 ] = b1positions[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					positionsL1[ (iv * 3) + 1 ] = b1positions[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
					positionsL1[ (iv * 3) + 2 ] = b1positions[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					compartmentL1[ (i*2)+0 ] = b1values_compartment[ (idMap[metabolicEdges[i][0]][1]) ];
					opL1[iv]=lineOpacity;
					//colorsL1[ iv * 3 ] = 0.0;
					//colorsL1[ iv * 3 + 1 ] = 1.0;
					//colorsL1[ iv * 3 + 2 ] = 1.0;
					if(metabolicEdges[i][2]==1){
						colorsL1[ iv * 3 ] = 0.2;
						colorsL1[ iv * 3 + 1 ] = 1.0;
						colorsL1[ iv * 3 + 2 ] = 1.0;
					}
					else if(metabolicEdges[i][2]==0){
						
						colorsL1[ iv * 3 ] = 1.0;
						colorsL1[ iv * 3 + 1 ] = 0.5;
						colorsL1[ iv * 3 + 2 ] = 0.0;
					}
					else{
						colorsL1[ iv * 3 ] = 1.0;
						colorsL1[ iv * 3 + 1 ] = 0.0;
						colorsL1[ iv * 3 + 2 ] = 0.1;
					}
					ivList.push(iv)
					//linesMap[i]=iv
					
					iv++;
				}
				else if (t1==4){
					
					positionsL1[ (iv * 3)+0 ] = b2positions[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					positionsL1[ (iv * 3) + 1 ] = b2positions[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
					positionsL1[ (iv * 3) + 2 ] = b2positions[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					compartmentL1[ (i*2)+0 ] = b2values_compartment[ (idMap[metabolicEdges[i][0]][1]) ];
					opL1[iv]=lineOpacity;
					if(metabolicEdges[i][2]==1){
						colorsL1[ iv * 3 ] = 0.2;
						colorsL1[ iv * 3 + 1 ] = 1.0;
						colorsL1[ iv * 3 + 2 ] = 1.0;
					}
					else if(metabolicEdges[i][2]==0){
						
						colorsL1[ iv * 3 ] = 1.0;
						colorsL1[ iv * 3 + 1 ] = 0.5;
						colorsL1[ iv * 3 + 2 ] = 0.0;
					}
					else{
						colorsL1[ iv * 3 ] = 1.0;
						colorsL1[ iv * 3 + 1 ] = 0.0;
						colorsL1[ iv * 3 + 2 ] = 0.1;
					}
					//linesMap[i]=iv
					ivList.push(iv)
					iv++;
				}
				if (t2 ==2){
					//console.log(b1positions[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ])
					positionsL1[ (iv * 3)+0 ] = b1positions[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					positionsL1[ (iv * 3) + 1 ] = b1positions[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
					positionsL1[ (iv * 3) + 2 ] = b1positions[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;
					compartmentL1[ (i*2)+1 ] = b1values_compartment[ (idMap[metabolicEdges[i][1]][1]) ];
					opL1[iv]=lineOpacity;
					if(metabolicEdges[i][2]==1){
						colorsL1[ iv * 3 ] = 0.2;
						colorsL1[ iv * 3 + 1 ] = 1.0;
						colorsL1[ iv * 3 + 2 ] = 1.0;
					}
					else if(metabolicEdges[i][2]==0){
						
						colorsL1[ iv * 3 ] = 1.0;
						colorsL1[ iv * 3 + 1 ] = 0.5;
						colorsL1[ iv * 3 + 2 ] = 0.0;
					}
					else{
						colorsL1[ iv * 3 ] = 1.0;
						colorsL1[ iv * 3 + 1 ] = 0.0;
						colorsL1[ iv * 3 + 2 ] = 0.1;
					}
					//linesMap[i]=iv
					ivList.push(iv)
					iv++;
				}
				else if (t2 ==4){
					positionsL1[ (iv * 3)+0 ] = b2positions[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					positionsL1[ (iv * 3) + 1 ] = b2positions[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
					positionsL1[ (iv * 3) + 2 ] = b2positions[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;
					compartmentL1[ (i*2)+1 ] = b2values_compartment[ (idMap[metabolicEdges[i][1]][1]) ];
					opL1[iv]=lineOpacity;
					if(metabolicEdges[i][2]==1){
						colorsL1[ iv * 3 ] = 0.2;
						colorsL1[ iv * 3 + 1 ] = 1.0;
						colorsL1[ iv * 3 + 2 ] = 1.0;
					}
					else if(metabolicEdges[i][2]==0){
						
						colorsL1[ iv * 3 ] = 1.0;
						colorsL1[ iv * 3 + 1 ] = 0.5;
						colorsL1[ iv * 3 + 2 ] = 0.0;
					}
					else{
						colorsL1[ iv * 3 ] = 1.0;
						colorsL1[ iv * 3 + 1 ] = 0.0;
						colorsL1[ iv * 3 + 2 ] = 0.1;
					}
					//linesMap[i]=iv
					ivList.push(iv)
					iv++;
				}
				linesMap[i]=ivList
			}
			bgeometryL1.addAttribute( 'position', new THREE.BufferAttribute( positionsL1, 3 ) );	
			bgeometryL1.addAttribute( 'ca', new THREE.BufferAttribute( colorsL1, 3 ) );
			bgeometryL1.addAttribute( 'op', new THREE.BufferAttribute( opL1, 1 ) );
			bgeometryL1.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentL1, 2 ) );
			bgeometryL1.computeBoundingSphere();
			meshL1 = new THREE.Line( bgeometryL1, linesShaderMaterial,THREE.LinePieces );
			linesShaderMaterial.blending = false;
			meshL1.frustumCulled = false;
			scene.add( meshL1 );
			
			var spriteMaterial = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/glow.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false, blending: THREE.AdditiveBlending
			});
			sprite = new THREE.Sprite( spriteMaterial );
			sprite.scale.set(8, 8, 8);
			//crateGlow.add(sprite); // this centers the glow at the mesh
			//if (marker==0){
			sprite.position.set(-50000,-10000,10000);
			//sprite.transparent=true;
			//}		
			scene.add( sprite );
			
			NodeEditingPlane= new THREE.Mesh(
				new THREE.PlaneBufferGeometry( 20000, 20000, 8, 8 ),
				new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.0, transparent: true,side: THREE.DoubleSide } )
			);
			NodeEditingPlane.rotation.x -= (90*(Math.PI / 180));
			NodeEditingPlane.visible = false;
			scene.add( NodeEditingPlane );
			
			arrowX = new THREE.ArrowHelper( new THREE.Vector3( radiusComp, 0, 0 ), new THREE.Vector3( 0, 0, 0 ), 50 );
			arrowX.position.set( -99999999, -99999999, -99999999 );
			scene.add( arrowX );
			
			arrowY = new THREE.ArrowHelper( new THREE.Vector3( 0, radiusComp, 0 ), new THREE.Vector3( 0, 0, 0 ), 50 );
			arrowY.position.set( -99999999, -99999999, -99999999 );
			scene.add( arrowY );
			
			arrowZ = new THREE.ArrowHelper( new THREE.Vector3( 0, 0, radiusComp ), new THREE.Vector3( 0, 0, 0 ), 50 );
			arrowZ.position.set( -99999999, -99999999, -99999999 );
			scene.add( arrowZ );
			
			
		
			
			
			
			
			
			renderer = new THREE.WebGLRenderer( { antialias: true } );
			//renderer.setClearColor( 0xf5f5f5 );
			renderer.setClearColor( 0xe0e0e0 );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.sortObjects = false;

			renderer.shadowMapEnabled = true;
			renderer.shadowMapType = THREE.PCFShadowMap;

			container.appendChild( renderer.domElement );
			positionContainer = $("#container").position();
			controls = new THREE.OrbitControls( camera, renderer.domElement) ;
			
			controls.damping = 0.2;
			

			controls.noZoom = false;
			controls.noPan = false;

			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3;
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			container.appendChild( stats.domElement );

			renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
			renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
			renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );

			//

			window.addEventListener( 'resize', onWindowResize, false );
			
			
			
			
			

		}
			
		
		
		//generalLayout['merged']
		
		function isMerged(comp,cType) {
			var result ="";
			if (generalLayout[cType].hasOwnProperty(comp)){
				result=comp;
			}
			else {
				for (var elem in generalLayout[cType]){
					if (generalLayout[cType].hasOwnProperty(elem)){
						for (var i=0;i<generalLayout[cType][elem].length;i++ ){
							if (generalLayout[cType][elem][i]==comp){
								result=elem;
							}
						}
					} 
				}
			}
			return result;
		}
		
		function isCenterMerged(comp,cType) {
			var result ="";
			if (generalLayout[cType].hasOwnProperty(comp)){
				result=comp;
			}
			
			return result;
		}
		function isPeripheralMerged(comp,cType) {
			var result ="";
			for (var elem in generalLayout[cType]){
				if (generalLayout[cType].hasOwnProperty(elem)){
					for (var i=0;i<generalLayout[cType][elem].length;i++ ){
						if (generalLayout[cType][elem][i]==comp){
							result=elem;
						}
					}
				} 
			}
			
			return result;
		}
			
		var button1 = document.getElementById( 'b_merge' );
			button1.addEventListener( 'click', function ( event ) {
			if ($('#modeSelector').val()=="0"){
				stopThreeJsMouseEvent=false;
				
				
				var targetContainer=isMerged(INTERSECTED.name,'merged');
				var refContainer=isMerged(INTERSECTED2.name,'merged');
				// target and ref items dont exist in the merged list
				if ((targetContainer=="") && (refContainer=="")){
					generalLayout['merged'][INTERSECTED2.name]=[];
					generalLayout['merged'][INTERSECTED2.name].push(INTERSECTED.name)
				}
				// target doesnt exist in the merged list while ref exists
				else if ((targetContainer=="") && (refContainer!="")){
					if (generalLayout['merged'][refContainer].indexOf(INTERSECTED.name)==-1){
						generalLayout['merged'][refContainer].push(INTERSECTED.name)
					}
				}
				// target doesnt exist in the merged list while ref exists
				else if ((targetContainer!="") && (refContainer=="")){
					if (generalLayout['merged'][targetContainer].indexOf(INTERSECTED2.name)==-1){
						generalLayout['merged'][targetContainer].push(INTERSECTED2.name)
					}
				}
				// we want to merge two existing merged groups already
				else{
					var newcontent=$.unique(generalLayout['merged'][targetContainer].concat(generalLayout['merged'][refContainer]));
					if (newcontent.length<listCompartments.length-1){
						newcontent.push(targetContainer);
						generalLayout['merged'][refContainer]=newcontent;
						delete generalLayout['merged'][targetContainer];
					}					
				}								
				placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name, 'merged');
				$('#layout1menu').hide();
			}
		});
			
		var button2 = document.getElementById( 'b_above' );
		button2.addEventListener( 'click', function ( event ) {
			if ($('#modeSelector').val()=="0"){
				//console.log("above");
				stopThreeJsMouseEvent=false;
				
				var targetContainer=isMerged(INTERSECTED.name,'above');
				var refContainer=isMerged(INTERSECTED2.name,'above');
				// target and ref items dont exist in the merged list
				if ((targetContainer=="") && (refContainer=="")){
					generalLayout['above'][INTERSECTED2.name]=[];
					generalLayout['above'][INTERSECTED2.name].push(INTERSECTED.name)
				}
				// target doesnt exist in the merged list while ref exists
				else if ((targetContainer=="") && (refContainer!="")){
					if (generalLayout['above'][refContainer].indexOf(INTERSECTED.name)==-1){
						generalLayout['above'][refContainer].push(INTERSECTED.name)
					}
				}
				// target doesnt exist in the merged list while ref exists
				else if ((targetContainer!="") && (refContainer=="")){
					if (generalLayout['above'][targetContainer].indexOf(INTERSECTED2.name)==-1){
						generalLayout['above'][targetContainer].push(INTERSECTED2.name)
					}
				}
				// we want to merge two existing merged groups already
				else{
					var newcontent=$.unique(generalLayout['above'][targetContainer].concat(generalLayout['above'][refContainer]));
					if (newcontent.length<listCompartments.length-1){
						newcontent.push(targetContainer);
						generalLayout['above'][refContainer]=newcontent;
						delete generalLayout['above'][targetContainer];
					}
					
				}
				
				
				
				//compLayout["above"].push([INTERSECTED.name, INTERSECTED2.name] );
				//console.log(compLayout);
				placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name,'above');
				$('#layout1menu').hide();
			}
		});
		var button3 = document.getElementById( 'b_below' );
		button3.addEventListener( 'click', function ( event ) {
			if ($('#modeSelector').val()=="0"){
				//console.log("below");
				stopThreeJsMouseEvent=false;
				
				var targetContainer=isMerged(INTERSECTED.name,'above');
				var refContainer=isMerged(INTERSECTED2.name,'above');
				// target and ref items dont exist in the merged list
				if ((targetContainer=="") && (refContainer=="")){
					generalLayout['above'][INTERSECTED.name]=[];
					generalLayout['above'][INTERSECTED.name].push(INTERSECTED2.name)
				}
				// target doesnt exist in the merged list while ref exists
				else if ((targetContainer=="") && (refContainer!="")){
					var newcontent=generalLayout['above'][refContainer].slice();
					
					if (newcontent.length<listCompartments.length-1){
						newcontent.unshift(refContainer);
						generalLayout['above'][INTERSECTED.name]=newcontent
						delete generalLayout['above'][refContainer];
					}
				}
				// target does exist in the merged list while ref doesnt exist
				else if ((targetContainer!="") && (refContainer=="")){
					if (generalLayout['above'][targetContainer].indexOf(INTERSECTED2.name)==-1){
						generalLayout['above'][targetContainer].push(INTERSECTED2.name)
					}
				}
				// we want to merge two existing merged groups already
				else{
					var newcontent=$.unique(generalLayout['above'][targetContainer].concat(generalLayout['above'][refContainer]));
					if (newcontent.length<listCompartments.length-1){
						newcontent.unshift(refContainer);
						generalLayout['above'][targetContainer]=newcontent;
						delete generalLayout['above'][refContainer];
					}
					
				}
				
				
				//compLayout["above"].push([INTERSECTED2.name, INTERSECTED.name] );
				//console.log(compLayout);
				placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name,'below');
				$('#layout1menu').hide();
			}
		});
		var button4 = document.getElementById( 'b_inner' );
		button4.addEventListener( 'click', function ( event ) {
			if ($('#modeSelector').val()=="0"){
				//console.log("inner");
				stopThreeJsMouseEvent=false;
				
				var targetContainer=isMerged(INTERSECTED.name,'outer');
				var refContainer=isMerged(INTERSECTED2.name,'outer');
				// target and ref items dont exist in the merged list
				if ((targetContainer=="") && (refContainer=="")){
					generalLayout['outer'][INTERSECTED.name]=[];
					generalLayout['outer'][INTERSECTED.name].push(INTERSECTED2.name)
				}
				// target doesnt exist in the merged list while ref exists
				else if ((targetContainer=="") && (refContainer!="")){
					var newcontent=generalLayout['outer'][refContainer].slice();
					
					if (newcontent.length<listCompartments.length-1){
						newcontent.unshift(refContainer);
						generalLayout['outer'][INTERSECTED.name]=newcontent
						delete generalLayout['outer'][refContainer];
					}
				}
				// target does exist in the merged list while ref doesnt exist
				else if ((targetContainer!="") && (refContainer=="")){
					if (generalLayout['outer'][targetContainer].indexOf(INTERSECTED2.name)==-1){
						generalLayout['outer'][targetContainer].push(INTERSECTED2.name)
					}
				}
				// we want to merge two existing merged groups already
				else{
					var newcontent=$.unique(generalLayout['outer'][targetContainer].concat(generalLayout['outer'][refContainer]));
					if (newcontent.length<listCompartments.length-1){
						newcontent.unshift(refContainer);
						generalLayout['outer'][targetContainer]=newcontent;
						delete generalLayout['outer'][refContainer];
					}
					
				}
				
				
				//compLayout["outer"].push([INTERSECTED2.name, INTERSECTED.name] );
				//console.log(compLayout);
				placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name,'outer');
				$('#layout1menu').hide();
			}
		});
		var button5 = document.getElementById( 'b_outer' );
		button5.addEventListener( 'click', function ( event ) {
			if ($('#modeSelector').val()=="0"){
				//console.log("outer");
				stopThreeJsMouseEvent=false;
				
				var targetContainer=isMerged(INTERSECTED.name,'outer');
				var refContainer=isMerged(INTERSECTED2.name,'outer');
				// target and ref items dont exist in the merged list
				if ((targetContainer=="") && (refContainer=="")){
					generalLayout['outer'][INTERSECTED2.name]=[];
					generalLayout['outer'][INTERSECTED2.name].push(INTERSECTED.name)
				}
				// target doesnt exist in the merged list while ref exists
				else if ((targetContainer=="") && (refContainer!="")){
					if (generalLayout['outer'][refContainer].indexOf(INTERSECTED.name)==-1){
						generalLayout['outer'][refContainer].push(INTERSECTED.name)
					}
				}
				// target doesnt exist in the merged list while ref exists
				else if ((targetContainer!="") && (refContainer=="")){
					if (generalLayout['outer'][targetContainer].indexOf(INTERSECTED2.name)==-1){
						generalLayout['outer'][targetContainer].push(INTERSECTED2.name)
					}
				}
				// we want to merge two existing merged groups already
				else{
					var newcontent=$.unique(generalLayout['outer'][targetContainer].concat(generalLayout['outer'][refContainer]));
					if (newcontent.length<listCompartments.length-1){
						newcontent.push(targetContainer);
						generalLayout['outer'][refContainer]=newcontent;
						delete generalLayout['outer'][targetContainer];
					}
					
				}
				//console.log(generalLayout['outer']);
				//compLayout["outer"].push([INTERSECTED.name, INTERSECTED2.name] );
				//console.log(compLayout);
				placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name,'outer');
				$('#layout1menu').hide();
			}
		});
		var button6 = document.getElementById( 'b_satellite' );
		button6.addEventListener( 'click', function ( event ) {
			//console.log(INTERSECTED2.name);
			if ($('#modeSelector').val()=="0"){
				stopThreeJsMouseEvent=false;
				var refComp=INTERSECTED2.name;
				for (var ref in generalLayout["outer"]){
					if (generalLayout["outer"].hasOwnProperty(ref)){
						var indComp=generalLayout["outer"][ref].indexOf(INTERSECTED2.name);
						if (INTERSECTED2.name==ref || indComp!=-1 ){
							refComp=ref;
						}
					}
				}
				//console.log(refComp);
				var targetContainer=isCenterMerged(INTERSECTED.name,'satellite');
				var targetContainer2=isPeripheralMerged(INTERSECTED.name,'satellite');
				var refContainer=isCenterMerged(refComp,'satellite');
				var refContainer2=isPeripheralMerged(refComp,'satellite');
				if (!(targetContainer2!="")){
					if((targetContainer=="") && (refContainer=="")){
						generalLayout['satellite'][refComp]=[];
						generalLayout['satellite'][refComp].push(INTERSECTED.name)
					}
					else if ((targetContainer=="") && !(refContainer=="")){
						if (generalLayout['satellite'][refComp].indexOf(INTERSECTED.name)==-1){
							generalLayout['satellite'][refComp].push(INTERSECTED.name);
						}
					}
					else if (!(targetContainer=="") && (refContainer=="")){
						generalLayout['satellite'][refComp.name]=[];
						if (generalLayout['satellite'][refComp].indexOf(INTERSECTED.name)==-1){
							generalLayout['satellite'][refComp].push(INTERSECTED.name);
						}
					}
					else{
						if (generalLayout['satellite'][refComp].indexOf(INTERSECTED.name)==-1){
							generalLayout['satellite'][refComp].push(INTERSECTED.name);
						}
					}
					
					
				}
				
				//compLayout["satellite"].push([INTERSECTED.name, INTERSECTED2.name] );
				//console.log(generalLayout['satellite']);
				placeCompFromLayout(INTERSECTED.name, refComp,'satellite');
				$('#layout1menu').hide();
			}
		});
		var button7 = document.getElementById( 'b_subset' );
		button7.addEventListener( 'click', function ( event ) {
			if ($('#modeSelector').val()=="0"){
				//console.log("subset");
				stopThreeJsMouseEvent=false;
				
				var targetContainer=isCenterMerged(INTERSECTED.name,'in');
				var targetContainer2=isPeripheralMerged(INTERSECTED.name,'in');
				var refContainer=isCenterMerged(INTERSECTED2.name,'in');
				var refContainer2=isPeripheralMerged(INTERSECTED2.name,'in');
				if (!(targetContainer2!="")){
					if((targetContainer=="") && (refContainer=="")){
						generalLayout['in'][INTERSECTED2.name]=[];
						generalLayout['in'][INTERSECTED2.name].push(INTERSECTED.name)
					}
					else if ((targetContainer=="") && !(refContainer=="")){
						if (generalLayout['in'][INTERSECTED2.name].indexOf(INTERSECTED.name)==-1){
							generalLayout['in'][INTERSECTED2.name].push(INTERSECTED.name);
						}
					}
					else if (!(targetContainer=="") && (refContainer=="")){
						generalLayout['in'][INTERSECTED2.name]=[];
						if (generalLayout['in'][INTERSECTED2.name].indexOf(INTERSECTED.name)==-1){
							generalLayout['in'][INTERSECTED2.name].push(INTERSECTED.name);
						}
					}
					else{
						if (generalLayout['in'][INTERSECTED2.name].indexOf(INTERSECTED.name)==-1){
							generalLayout['in'][INTERSECTED2.name].push(INTERSECTED.name);
						}
					}
					
					
				}
				
				//compLayout["in"].push([INTERSECTED.name,INTERSECTED2.name] );
				//console.log(compLayout);
				placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name,'in');
				$('#layout1menu').hide();
			}
		});
		var button8 = document.getElementById( 'b_cancel' );
		button8.addEventListener( 'click', function ( event ) {
			if ($('#modeSelector').val()=="0"){
				//console.log("cancel");
				stopThreeJsMouseEvent=false;
				for ( var i = 0; i < listCompartments.length; i ++ ) {
					if (objects[i].name==initialName){
						objects[i].position.x=initialPos.x;
						objects[i].position.y=initialPos.y;
						objects[i].position.z=initialPos.z;
						SELECTED = null;
						SELECTED2=null;
					}
				}
				
				
				
				$('#layout1menu').hide();
			}
		});
			

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {
				if ($('#modeSelector').val()=="0"){
					if (stopThreeJsMouseEvent==false){
						event.preventDefault();
						mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
						mouse.y = - ( (event.clientY-$("#container").position().top+window.pageYOffset) / window.innerHeight ) * 2 + 1;
						var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );
						var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
						if ( SELECTED ) {
							var intersects2 = raycaster.intersectObjects( objects );
							if ( intersects2.length > 1 ) {
								if (SELECTED.name==intersects2[0].object.name)
									INTERSECTED2=intersects2[1].object;
								else
									INTERSECTED2=intersects2[0].object;
							}
							else{
								INTERSECTED2=null;
							}
							//plane.position.y=SELECTED.position.y;
							var intersects = raycaster.intersectObject( plane );						
							var mustMove=true;
							
							
							
							if( mustMove==true){
							SELECTED.position.copy( intersects[ 0 ].point );
							
							
							}
							
							
							stackCompToMove=[];
							
							function addToStack(cname){
								for (var typeComp in generalLayout){
									if (generalLayout.hasOwnProperty(typeComp)){
										for (var ref in generalLayout[typeComp]){
											if (generalLayout[typeComp].hasOwnProperty(ref)){
												var indComp=generalLayout[typeComp][ref].indexOf(cname);
												if (cname==ref || indComp!=-1 ){
													if (stackCompToMove.indexOf(ref)==-1){
														stackCompToMove.push(ref);
													}
													for (var i=0; i<generalLayout[typeComp][ref].length;i++ ){
														if (stackCompToMove.indexOf(generalLayout[typeComp][ref][i])==-1){
															stackCompToMove.push(generalLayout[typeComp][ref][i]);
														}
													}
												}
											}
										}
									}
								}
							}
							
							
							addToStack(SELECTED.name);
							for (var i=0; i<stackCompToMove.length;i++ ){
								addToStack(stackCompToMove[i]);
							}
							//console.log(stackCompToMove)
							
							var displacement =new THREE.Vector3();
							displacement.subVectors(SELECTED.position,initialPos );
							displacement.y=0;
							//console.log(displacement)
							
							
							
							function moveComp(compName){
								for (var ref in generalLayout["merged"]){
									if (generalLayout["merged"].hasOwnProperty(ref)){
										if (compName==ref || generalLayout["merged"][ref].indexOf(compName)!=-1 ){
											mustMove=true;
											for (var j=0; j<listCompartments.length;j++ ){
												if (objects[j].name==ref || generalLayout["merged"][ref].indexOf(objects[j].name)!=-1){	
													objects[j].position.addVectors(stackCompInitialPos[objects[j].name],displacement);	
												}
											}
										}
									}
								}
								for (var ref in generalLayout["above"]){
									if (generalLayout["above"].hasOwnProperty(ref)){
										if (compName==ref || generalLayout["above"][ref].indexOf(compName)!=-1 ){
											mustMove=true;
											for (var j=0; j<listCompartments.length;j++ ){
												if (objects[j].name==ref || generalLayout["above"][ref].indexOf(objects[j].name)!=-1){	
													objects[j].position.addVectors(stackCompInitialPos[objects[j].name],displacement);	
												}
											}
										}
									}
								}
								for (var ref in generalLayout["outer"]){
									if (generalLayout["outer"].hasOwnProperty(ref)){
										if (compName==ref || generalLayout["outer"][ref].indexOf(compName)!=-1 ){
											mustMove=true;
											for (var j=0; j<listCompartments.length;j++ ){
												if (objects[j].name==ref || generalLayout["outer"][ref].indexOf(objects[j].name)!=-1){	
													objects[j].position.addVectors(stackCompInitialPos[objects[j].name],displacement);	
												}
											}
										}
									}
								}
								for (var ref in generalLayout["in"]){
									if (generalLayout["in"].hasOwnProperty(ref)){
										if (compName==ref || generalLayout["in"][ref].indexOf(compName)!=-1 ){
											mustMove=true;
											for (var j=0; j<listCompartments.length;j++ ){
												if (objects[j].name==ref || generalLayout["in"][ref].indexOf(objects[j].name)!=-1){	
													objects[j].position.addVectors(stackCompInitialPos[objects[j].name],displacement);	
												}
											}
										}
									}
								}
								for (var ref in generalLayout["satellite"]){
									if (generalLayout["satellite"].hasOwnProperty(ref)){
										if (compName==ref || generalLayout["satellite"][ref].indexOf(compName)!=-1 ){
											mustMove=true;
											for (var j=0; j<listCompartments.length;j++ ){
												if (objects[j].name==ref || generalLayout["satellite"][ref].indexOf(objects[j].name)!=-1){	
													objects[j].position.addVectors(stackCompInitialPos[objects[j].name],displacement);	
												}
											}
										}
									}
								}
							}
							
							for (var i=0; i<stackCompToMove.length;i++ ){
								moveComp(stackCompToMove[i]);
								//console.log(stackCompInitialPos)
							}
							
							
							
							//plane.position.copy( intersects[ 0 ].point);						
							return;
						}
						var intersects = raycaster.intersectObjects( objects );
						if ( intersects.length > 0 ) {						
								if ( INTERSECTED != intersects[ 0 ].object ) {
									if ( INTERSECTED ) {
										INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
									}
									INTERSECTED = intersects[ 0 ].object;
									INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
									//console.log(generalLayout);
									//plane.rotation.x -= (90*(Math.PI / 180));
								}
								container.style.cursor = 'pointer';						
						} else {

							if ( INTERSECTED ) {
								INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
							}
							INTERSECTED = null;
							INTERSECTED2 = null;
							container.style.cursor = 'auto';
						}
					}
				}
				if ($('#modeSelector').val()=="1"){
					event.preventDefault();
					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( (event.clientY-$("#container").position().top+window.pageYOffset) / window.innerHeight ) * 2 + 1;
					var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );
					var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
					
					
					
									
							
							
							
								
							if (moveNode==true && INTERSECTED_P>-1 && container.style.cursor == 'pointer'){
								if (idMap[INTERSECTED_P]){
									
									var indexStartNodes=maxNbComp+3;
									if (idMap[INTERSECTED_P][0]==2){
										sprite.position.set(scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0],scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1],scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2]);	
										if ($('#editplane').val()=="0"){
											
											NodeEditingPlane.position.y= scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1];
											NodeEditingPlane.updateMatrixWorld( true );
											var intersects = raycaster.intersectObject( NodeEditingPlane );	
											if (intersects && intersects[ 0 ]){
												scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0]=intersects[ 0 ].point.x;
												//scene.children[23].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1]=intersects[ 0 ].point.y;
												scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2]=intersects[ 0 ].point.z;
												scene.children[indexStartNodes].geometry.attributes.position.needsUpdate = true;
												mtnlLayout["nodes_layout"][INTERSECTED_P]=new THREE.Vector3(intersects[ 0 ].point.x,scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1],intersects[ 0 ].point.z);
												//console.log(INTERSECTED_P)
											}
											arrowX.position.set( scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0], scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1], scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2] );
											arrowX.position.needsUpdate = true;
											arrowZ.position.set( scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0], scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1], scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2] );
											arrowZ.position.needsUpdate = true;
										}
										if ($('#editplane').val()=="1"){
											NodeEditingPlane.position.z= scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2];
											NodeEditingPlane.updateMatrixWorld( true );
											var intersects = raycaster.intersectObject( NodeEditingPlane );	
											if (intersects && intersects[ 0 ]){
												scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0]=intersects[ 0 ].point.x;
												//scene.children[23].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1]=intersects[ 0 ].point.y;
												scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1]=intersects[ 0 ].point.y;
												scene.children[indexStartNodes].geometry.attributes.position.needsUpdate = true;
												mtnlLayout["nodes_layout"][INTERSECTED_P]=new THREE.Vector3(intersects[ 0 ].point.x,intersects[ 0 ].point.y,scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2]);
												//console.log(INTERSECTED_P)
											}
											arrowX.position.set( scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0], scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1], scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2] );
											arrowX.position.needsUpdate = true;
											arrowY.position.set( scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0], scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1], scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2] );
											arrowY.position.needsUpdate = true;
										}
										
										//console.log(scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0])
									}
									if (idMap[INTERSECTED_P][0]==4){
										sprite.position.set(scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0],scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1],scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2]);	
										if ($('#editplane').val()=="0"){
											NodeEditingPlane.position.y= scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1];
											NodeEditingPlane.updateMatrixWorld( true );
											var intersects = raycaster.intersectObject( NodeEditingPlane );	
											if (intersects && intersects[ 0 ]){
												scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0]=intersects[ 0 ].point.x;
												//scene.children[23].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1]=intersects[ 0 ].point.y;
												scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2]=intersects[ 0 ].point.z;
												scene.children[indexStartNodes+1].geometry.attributes.position.needsUpdate = true;
												mtnlLayout["nodes_layout"][INTERSECTED_P]=new THREE.Vector3(intersects[ 0 ].point.x,scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1],intersects[ 0 ].point.z);
											}
											arrowX.position.set( scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0], scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1], scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2] );
											arrowX.position.needsUpdate = true;
											arrowZ.position.set( scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0], scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1], scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2] );
											arrowZ.position.needsUpdate = true;
											
										}
										if ($('#editplane').val()=="1"){
											NodeEditingPlane.position.z= scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2];
											NodeEditingPlane.updateMatrixWorld( true );
											var intersects = raycaster.intersectObject( NodeEditingPlane );	
											if (intersects && intersects[ 0 ]){
												scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0]=intersects[ 0 ].point.x;
												//scene.children[23].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1]=intersects[ 0 ].point.y;
												scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1]=intersects[ 0 ].point.y;
												scene.children[indexStartNodes+1].geometry.attributes.position.needsUpdate = true;
												mtnlLayout["nodes_layout"][INTERSECTED_P]=new THREE.Vector3(intersects[ 0 ].point.x,intersects[ 0 ].point.y,scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2]);
											}
											arrowX.position.set( scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0], scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1], scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2] );
											arrowX.position.needsUpdate = true;
											arrowY.position.set( scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0], scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1], scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2] );
											arrowY.position.needsUpdate = true;
										}
										//console.log(scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0])
									}
									
									
									//console.log(intersects[ 0 ].point)		
								}		
							}
							else {
							
							var indexStartNodes=maxNbComp+3;
						var particles;
						var distance=99999999;
						var listretPointsIndexes=[];
						var listretPointsDistances=[];	
						var listretPointsTypes=[];	
						var listretPointsIndexesL=[];
						var listretPointsDistancesL=[];	
						var listretPointsTypesL=[];	
						var point = new THREE.Vector3(0,0,0);		
						var myray=raycaster.ray;
						var point1 = new THREE.Vector3(0,0,0);	
						var point2 = new THREE.Vector3(0,0,0);
						for(var i=indexStartNodes, ii=indexStartNodes+2;i<ii;i++){
							if (scene.children[i] instanceof THREE.PointCloud){
								var a1 = scene.children[i].geometry.attributes.position.array;
								var a2 = scene.children[i].geometry.attributes.size.array;
								particles = a2.length;
								var a3 = scene.children[i].geometry.attributes.ca.array;
								for(var j=0;j<particles;j++){
									point.x = (a1[j*3]);
									point.y = (a1[j*3+1]);
									point.z = (a1[j*3+2]);
									distance = myray.distanceToPoint(point);
									if ( distance <=2 ) {
										listretPointsIndexes.push(j);
										listretPointsDistances.push(distance);	
										listretPointsTypes.push(i);	
									}
								}
							}
							var h1 = listretPointsDistances.length;
							var myr;
							var mymin = Math.min.apply(Math, listretPointsDistances);
							var v1=0;
							while(h1--){
								if (listretPointsDistances[h1]==mymin){
									myr=h1;
										}
										if (myr==h1)
											break;
										
							}			
							closest = listretPointsIndexes[myr];
								if (closest>=0){
								
									//console.log(closest)
									//console.log(myr)
									//console.log(listretPointsTypes[myr])
									if (listretPointsTypes[myr]>=0){
										sprite.position.set(scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3],scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3+1],scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3+2]);	
										var pp = toXYCoords(sprite.position);
										var dat;
										if (listretPointsTypes[myr]==indexStartNodes)
											dat=typesMap[2][closest];
										if (listretPointsTypes[myr]==(indexStartNodes+1))
											dat=typesMap[4][closest];
										
										//if (INTERSECTED_P>-1){
										
										//else{
											INTERSECTED_P=dat;
										//}
										//console.log(INTERSECTED_P)
										if ((text1PreviousPos.x != pp.x) && (text1PreviousPos.y != pp.y)){
											text1.style.top = (positionContainer.top )+ 'px';								
											text1.style.left = (positionContainer.left+100)+ 'px';
											text1PreviousPos = pp;
											var stringTxt="";
											//console.log(listretPointsTypes[myr])
											var dat;
											if (listretPointsTypes[myr]==indexStartNodes)
												dat=typesMap[2][closest];
											if (listretPointsTypes[myr]==(indexStartNodes+1))
												dat=typesMap[4][closest];
											
											if(metabolicNodes[dat]){
												
												stringTxt = metabolicNodes[dat][0]+" "+metabolicNodes[dat][2];
												if (metabolicNodes[dat][4][1] && metabolicNodes[dat][4][1][0]){
													stringTxt = metabolicNodes[dat][0]+" "+metabolicNodes[dat][2]+" ("+metabolicNodes[dat][4][1][0]+")";
												}
											}
											if (text1PreviousString!=stringTxt){
												text1.innerHTML=stringTxt;
												text1PreviousString=stringTxt;
											}
										}
									
									
									}
									container.style.cursor = 'pointer';	
								}
								else{
									//INTERSECTED_P=-1;
									container.style.cursor = 'auto';
								}
							}
						}
					
				}
			}

			function onDocumentMouseDown( event ) {				
				event.preventDefault();
				switch ( event.button ) {
					case 0: // left 
						if ($('#modeSelector').val()=="0"){
							var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );
							var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
							var intersects = raycaster.intersectObjects( objects );
							if ( intersects.length > 0 ) {							
									controls.enabled = false;
									if(SELECTED==null){
										initialPos.x=intersects[ 0 ].object.position.x;
										initialPos.y=intersects[ 0 ].object.position.y;
										initialPos.z=intersects[ 0 ].object.position.z;
										initialName = intersects[ 0 ].object.name;
										//console.log(initialPos)
									}
									SELECTED = intersects[ 0 ].object;
									plane.position.y=SELECTED.position.y;
									
									// store initial position of all other compartments 
									stackCompInitialPos={};
									for (var i=0; i<listCompartments.length;i++ ){
										stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
									}
									
									//var intersects = raycaster.intersectObject( plane );
									//offset.copy( intersects[ 0 ].point ).sub( plane.position );
									container.style.cursor = 'move';							
							}
						}
						if ($('#modeSelector').val()=="1"){
							if (INTERSECTED_P!=-1){
								controls.enabled = false;
								container.style.cursor = 'move';
								moveNode=true;
								//var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );
								//var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
								//NodeEditingPlane.position.y= 
								// if (idMap[INTERSECTED_P]){
									
									// var indexStartNodes=maxNbComp+3;
									// if (idMap[INTERSECTED_P][0]==2){
										// NodeEditingPlane.position.y= scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1];
										// NodeEditingPlane.updateMatrixWorld( true );
										// var intersects = raycaster.intersectObject( NodeEditingPlane );	
										// scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0]=intersects[ 0 ].point.x;
										// //scene.children[23].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1]=intersects[ 0 ].point.y;
										// scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2]=intersects[ 0 ].point.z;
										// scene.children[indexStartNodes].geometry.attributes.position.needsUpdate = true;
										// //console.log(scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0])
									// }
									// if (idMap[INTERSECTED_P][0]==4){
										// NodeEditingPlane.position.y= scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1];
										// NodeEditingPlane.updateMatrixWorld( true );
										// var intersects = raycaster.intersectObject( NodeEditingPlane );	
										// scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0]=intersects[ 0 ].point.x;
										// //scene.children[23].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1]=intersects[ 0 ].point.y;
										// scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2]=intersects[ 0 ].point.z;
										// scene.children[indexStartNodes+1].geometry.attributes.position.needsUpdate = true;
										// //console.log(scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0])
									// }
									
									
									// //console.log(intersects[ 0 ].point)		
								// }								
								//var mustMove=true;
								//scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3],scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3+1],scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3+2]);
							
							
								//if( mustMove==true){
								//SELECTED.position.copy( intersects[ 0 ].point );
								
								
								//}
							}
							//INTERSECTED_P=null;
							
						}
					case 1: // middle
						break;
					case 2: // right
						break;
				}
			}
			function onDocumentMouseUp( event ) {
			//console.log("up")
				switch ( event.button ) {
					case 0: // left 						
						event.preventDefault();
						if ($('#modeSelector').val()=="0"){
							controls.enabled = true;
							if ( INTERSECTED ) {							
								if ( INTERSECTED2 ) {
								
									var prevent =false;								
									for (var typeLink in generalLayout){
										if (generalLayout.hasOwnProperty(typeLink)){
											for (var ref in generalLayout[typeLink]){
												if (generalLayout[typeLink].hasOwnProperty(ref)){
													if ((INTERSECTED2.name==ref && generalLayout[typeLink][ref].indexOf(INTERSECTED.name)!=-1)||
													(INTERSECTED.name==ref && generalLayout[typeLink][ref].indexOf(INTERSECTED2.name)!=-1) ||
													(generalLayout[typeLink][ref].indexOf(INTERSECTED.name)!=-1 && generalLayout[typeLink][ref].indexOf(INTERSECTED2.name)!=-1)
													){
														prevent =true;
													}
												}
											}
										}
									}
									if (prevent ==false){
									
									
									
									
									//console.log(INTERSECTED.name+" dragged and dropped on :"+INTERSECTED2.name)
									$('#layout1menu').show();
									var vector = new THREE.Vector3(INTERSECTED2.position.x,INTERSECTED2.position.y,INTERSECTED2.position.z);
									var pp = toXYCoords(vector	);
						
						
									document.getElementById("layout1menu").style.top = (pp.y+$('#container').position().top) + 'px';
									document.getElementById("layout1menu").style.left = (pp.x)+ 'px';
									stopThreeJsMouseEvent=true;
									
									}
									else{
										// adjust all metabolic nodes and lines positions
										var indexStartNodes=maxNbComp+3;
										nbCompartments= listCompartments.length;
										//var indSelectedComp= SELECTED
										var sInd=-1;
										for (var i=0; i<listCompartments.length;i++ ){
											if (SELECTED.name==objects[i].name){
												sInd=i;
											}
										}
										//console.log(SELECTED.name)
										//console.log(listCompartments.length);
										//console.log(scene.children[indexStartNodes])
										for (var c=indexStartNodes;c<indexStartNodes+2;c++){
											for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
												for (var g=0;g<nbCompartments;g++){
													if (scene.children[c].geometry.attributes.compartment.array[h]==g){
													//nameComp[g]
													scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x;
													scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y;
													scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z;
													//scene.children[c].geometry.attributes.position.array[h*3+1]+=1000;
													//scene.children[c].geometry.attributes.position.array[h*3+2]+=1000;
													}
												}
											}
											scene.children[c].geometry.attributes.position.needsUpdate = true;
										}
										var iv=0;
										for ( var i = 0; i < segments; i ++ ) {
											var t1 = metabolicNodes[metabolicEdges[i][0]][6]
											var t2 = metabolicNodes[metabolicEdges[i][1]][6]
											//console.log(t1)
											//console.log(t2)
											//var ivList=[]
											var doIt=0
											if (t1==2){
												//console.log(idMap[jsonObj2[i][0]][1])
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
												
												iv++;
											}
											else if (t1==4){
												//console.log(idMap[jsonObj2[i][0]][1])
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
												iv++;
											}
											if (t2 ==2){
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
												iv++;
											}
											else if (t2 ==4){
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
												iv++;
											}
											
										}
										scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
									}
									
								}
								else{
									// adjust all metabolic nodes and lines positions
									var indexStartNodes=maxNbComp+3;
									nbCompartments= listCompartments.length;
									//var indSelectedComp= SELECTED
									
									//console.log(SELECTED.name)
									//console.log(listCompartments.length);
									//console.log(scene.children[indexStartNodes])
									for (var c=indexStartNodes;c<indexStartNodes+2;c++){
										for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
											for (var g=0;g<nbCompartments;g++){
												if (scene.children[c].geometry.attributes.compartment.array[h]==g){
												//nameComp[g]
												scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x;
												scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y;
												scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z;
												//scene.children[c].geometry.attributes.position.array[h*3+1]+=1000;
												//scene.children[c].geometry.attributes.position.array[h*3+2]+=1000;
												}
											}
										}
										scene.children[c].geometry.attributes.position.needsUpdate = true;
									}
									var iv=0;
									for ( var i = 0; i < segments; i ++ ) {
										var t1 = metabolicNodes[metabolicEdges[i][0]][6]
										var t2 = metabolicNodes[metabolicEdges[i][1]][6]
										//console.log(t1)
										//console.log(t2)
										//var ivList=[]
										var doIt=0
										if (t1==2){
											//console.log(idMap[jsonObj2[i][0]][1])
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
											
											iv++;
										}
										else if (t1==4){
											//console.log(idMap[jsonObj2[i][0]][1])
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
											iv++;
										}
										if (t2 ==2){
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
											iv++;
										}
										else if (t2 ==4){
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
											iv++;
										}
										
									}
									scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
									//console.log("reset initial positions")
									for ( var i = 0; i < listCompartments.length; i ++ ) {
										stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
									}
								}
								
								
								
								SELECTED = null;
								
								
								mtnlLayout["compartments_layout"]["name-position-scale"]=[];
								for (var i=0; i<listCompartments.length;i++ ){
									mtnlLayout["compartments_layout"]["name-position-scale"][i]=[objects[i].name, objects[i].position , objects[i].scale];
								}
								
								saveLayout();
								
								
							}
							
							container.style.cursor = 'auto';
						}
						
						if ($('#modeSelector').val()=="1"){
							var indexStartNodes=maxNbComp+3;
							var iv=0;
							for ( var i = 0; i < segments; i ++ ) {
								var t1 = metabolicNodes[metabolicEdges[i][0]][6]
								var t2 = metabolicNodes[metabolicEdges[i][1]][6]
								//console.log(t1)
								//console.log(t2)
								//var ivList=[]
								var doIt=0
								if (t1==2){
									//console.log(idMap[jsonObj2[i][0]][1])
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
									
									iv++;
								}
								else if (t1==4){
									//console.log(idMap[jsonObj2[i][0]][1])
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
									iv++;
								}
								if (t2 ==2){
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
									iv++;
								}
								else if (t2 ==4){
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
									iv++;
								}
								
							}
							scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
							controls.enabled = true;
							container.style.cursor = 'auto';
							INTERSECTED_P=-1;
							moveNode=false;
							arrowX.position.set(-99999999,-99999999,-99999999);
							arrowX.position.needsUpdate = true;
							arrowY.position.set( -99999999,-99999999,-99999999);
							arrowY.position.needsUpdate = true;
							arrowZ.position.set( -99999999,-99999999,-99999999);
							arrowZ.position.needsUpdate = true;
							saveLayout();
						}
					case 1: // middle
						break;
					case 2: // right
						break;
				}
			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {
				controls.update();
				var poscont = $("#container");
				//var cnt_merged=0;
				var cnt_merged_comp={};
				for ( var i = 0; i < listCompartments.length; i ++ ) {
					//cnt_merged=0;
					var vector = new THREE.Vector3( objects[i].position.x+(-radiusComp*objects[i].scale.x),objects[i].position.y,objects[i].position.z);
					var pp = toXYCoords(vector	);
					
					if (pp.x >=0 && pp.y >=0 && pp.x <=poscont.width()-10 && pp.y <=poscont.height()-10){
						document.getElementById("txt"+i).style.top = (pp.y+poscont.position().top+(0*12)) + 'px';
						document.getElementById("txt"+i).style.left = (pp.x +20)+ 'px';
					}
					else{
						document.getElementById("txt"+i).style.top = 4000 + 'px';
						document.getElementById("txt"+i).style.left = 4000+ 'px';
					}
					for (var ref in generalLayout["merged"]){
						if (generalLayout["merged"].hasOwnProperty(ref)){
							if (objects[i].name==ref){
								document.getElementById("txt"+i).style.top = (pp.y+poscont.position().top+(0*12)) + 'px';
								document.getElementById("txt"+i).style.left = (pp.x +20)+ 'px';
							}
							for (var j=0;j<generalLayout["merged"][ref].length;j++){
								if (objects[i].name==generalLayout["merged"][ref][j]){
									 document.getElementById("txt"+i).style.top = (pp.y+poscont.position().top+((j+1)*12)) + 'px';
									 document.getElementById("txt"+i).style.left = (pp.x +20)+ 'px';
								}
							}
						}
					}
					// for (el in list_merged_chains){
						// if (list_merged_chains.hasOwnProperty(el)){
							// if (objects[i].name==el){
								// document.getElementById("txt"+i).style.top = (pp.y+poscont.position().top+(0*12)) + 'px';
								// document.getElementById("txt"+i).style.left = (pp.x +20)+ 'px';
							// }
							// for (var j=0;j<list_merged_chains[el].length;j++){
								// if (objects[i].name==list_merged_chains[el][j]){
									// document.getElementById("txt"+i).style.top = (pp.y+poscont.position().top+((j+1)*12)) + 'px';
									// document.getElementById("txt"+i).style.left = (pp.x +20)+ 'px';
								// }
								
							// }
						// }
					// }					
					document.getElementById("txt"+i).innerHTML = objects[i].name;			
				}			
				renderer.render( scene, camera );
			}

	var $container1 = $("#compTable");
	$container1.handsontable({
	  data: [],
	  width: 400,
	  height:200,
	  dataSchema: {c_id: null, c_name: null},
	  startRows: 1,
	  startCols: 2,
	  contextMenu: ['remove_row'],
	  //maxRows: 1,
	  colHeaders: ['Comp. id', 'Comp. name'],
	  columns: [
		{data: "c_id"},
		{data: "c_name"}
	  ],
	  beforeRemoveRow: function(ind, numb){
		var dt = this.getData();
		
		
	  },
	  afterRemoveRow: function(ind, numb){
		var dt = this.getData();
		
		if (dt[0]['c_id']!=null){
			listCompartments=[];
			for (var i=0, j= dt.length;i<j-1;i++){
				listCompartments.push([dt[i]['c_id'],dt[i]['c_name']]);
				
			}
			nbCompartments= listCompartments.length;
			compIds=[];
			for (var i=0; i<listCompartments.length;i++){
				compIds.push(listCompartments[i][0]);
			}
			// delete meshes
			for ( var i = nbCompartments; i < maxNbComp; i ++ ) {
					objects[i].position.x = -99999999;
					objects[i].position.y = -99999999;
					objects[i].position.z = -99999999;
					objects[i].name="";
					txtComp[i].innerHTML = 'hello ';
					txtComp[i].style.top = 4000 + 'px';
					txtComp[i].style.left = 4000 + 'px';
			}
			// for ( var i = 0; i < listCompartments.length; i ++ ) {
			
				// objects[i].position.x = 0;
				// objects[i].position.y = 0;
				// objects[i].position.z = 0;
				
				// objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
				// objects[i].castShadow = true;
				// objects[i].receiveShadow = true;	
				
			// }
			
			//console.log(dt.length);
			
			
		}
	  },
	  afterChange: function(changes, source) {
		//console.log(changes)
		var dt = this.getData();		
		if (dt[0]['c_id']!=null){
			listCompartments=[];
			for (var i=0, j= dt.length;i<j-1;i++){
				listCompartments.push([dt[i]['c_id'],dt[i]['c_name']]);
				
			}
			nbCompartments= listCompartments.length;
			compIds=[];
			for (var i=0; i<listCompartments.length;i++){
				compIds.push(listCompartments[i][0]);
			}
			
			
			
			for ( var i = 0; i < listCompartments.length; i ++ ) {
				if (!objects[i].name){
					objects[i].position.x = 0;
					objects[i].position.y = 0;
					objects[i].position.z = 0;
					objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
					//objects[i].castShadow = true;
					//objects[i].receiveShadow = true;	
				}
				
			}
			
			nameComp=[];
			mapComp = {'-1':-1};
			
			for (var i=0;i<listCompartments.length;i++){
				mapComp[listCompartments[i][0]]=i;
				nameComp.push(listCompartments[i][1]);
			}
			
			var indexStartNodes=maxNbComp+3;
			
			for ( var i = 0; i < listCompartments.length; i ++ ) {
				stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
				objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
			}
			mtnlLayout["list_compartments"]=listCompartments;
			saveLayout();
			//console.log(mtnlLayout["list_compartments"])
			
			//console.log(listCompartments);
			//console.log(dt.length);
			
			// selectedMetabolicData[0]=listCompartments;
			// var indexStartNodes=maxNbComp+3;
			// nbCompartments= listCompartments.length;
			// stackCompInitialPos={};
			// for (var i=0; i<listCompartments.length;i++ ){
				// stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
			// }
			// for (var c=indexStartNodes;c<indexStartNodes+2;c++){
				// for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
					// for (var g=0;g<nbCompartments;g++){
						// if (scene.children[c].geometry.attributes.compartment.array[h]==g){
						// //nameComp[g]
						// scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x;
						// scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y;
						// scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z;
						// //scene.children[c].geometry.attributes.position.array[h*3+1]+=1000;
						// //scene.children[c].geometry.attributes.position.array[h*3+2]+=1000;
						// }
					// }
				// }
				// scene.children[c].geometry.attributes.position.needsUpdate = true;
			// }
			// var iv=0;
			// for ( var i = 0; i < segments; i ++ ) {
				// var t1 = metabolicNodes[metabolicEdges[i][0]][6]
				// var t2 = metabolicNodes[metabolicEdges[i][1]][6]
				// //console.log(t1)
				// //console.log(t2)
				// //var ivList=[]
				// var doIt=0
				// if (t1==2){
					// //console.log(idMap[jsonObj2[i][0]][1])
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					
					// iv++;
				// }
				// else if (t1==4){
					// //console.log(idMap[jsonObj2[i][0]][1])
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					// iv++;
				// }
				// if (t2 ==2){
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
					// iv++;
				// }
				// else if (t2 ==4){
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
					// iv++;
				// }
				
			// }
			// scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
			//console.log(selectedMetabolicData[0]);
		}
		
	  },
	  minSpareRows: 1
	});
	var tempdata1=listCompartments;
	//for (var i=0;i<tempdata1.length;i++){
	//	tempdata1[i].push('auto')
	//}
	
	var ht = $('#compTable').handsontable('getInstance');
	if ($.isArray(tempdata1) && tempdata1[0] && $.isArray(tempdata1[0])){
		ht.populateFromArray (0, 0, tempdata1,tempdata1.length-1, 1);
	}
	$("#compTable").css({top:  $("#titleComp").position().top + $("#titleComp").height()+40});
	
	var $container1 = $("#mtnTable");
	$container1.handsontable({
	  data: [],
	  width: 700,
	  height:200,
	  colWidths: [100, 400,150],
	  dataSchema: {n_id:null, n_name: null, c_name: null},
	  startRows: 1,
	  startCols: 3,
	  colHeaders: ['Node nb','Node name', 'Comp. name'],
	  columns: [
		{data: "n_id"},
		{data: "n_name"},
		{data: "c_name"},//, type: 'dropdown',source: compIds}
	  ],
	  beforeChange: function(changes, source) {
		if ((Array.isArray(changes[0])) && changes[0][2] ){
			if (changes[0][1]!="c_name" && changes[0][1]!="n_name"){
				changes.length=0;
				return false;
			}
			else{ 
				if (changes[0][1]=="c_name" && compIds.indexOf(changes[0][3])==-1){
					changes.length=0;
					return false;
				}
			}
		}
		
	  },
	  afterChange: function(changes, source) {
		
		if (changes && changes[0] && changes[0][2]){	
		
			var indexStartNodes=maxNbComp+3;
			nbCompartments= listCompartments.length;
			nameComp=[];
			mapComp = {'-1':-1};
			for (var i=0;i<listCompartments.length;i++){
				mapComp[listCompartments[i][0]]=i;
				nameComp.push(listCompartments[i][1]);
			}
			var oldComp={};
			for ( var i = 0; i < listCompartments.length; i ++ ) {
				stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
				objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
			}
			//var dt = this.getData(changes[0][0],0,0,2);	
			var dt = this.getData(changes[0][0],0,changes[changes.length-1][0],2);
			//console.log(dt)	
			//console.log(dt2)	
			//var dt = this.getData(changes[0][0],0,changes[changes.length-1][0],2);	
			for (var c=0;c<dt.length;c++){
				selectedMetabolicData[1][dt[c][0]][1]=dt[c][1];
				// change compartment
				selectedMetabolicData[1][dt[c][0]][3]=dt[c][2];
				metabolicNodes=selectedMetabolicData[1];
				mtnlLayout["nodes_compartments"][dt[c][0]]=[];
				mtnlLayout["nodes_compartments"][dt[c][0]].push(dt[c][1]);
				mtnlLayout["nodes_compartments"][dt[c][0]].push(dt[c][2]);
				
				if (idMap[dt[c][0]] && idMap[dt[c][0]][0]==2){
					oldComp[dt[c][0]] = scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[dt[c][0]][1]];
					scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[dt[c][0]][1]]=mapComp[dt[c][2]];
					scene.children[indexStartNodes].geometry.attributes.compartment.needsUpdate = true;
				}
			}
			var oldCompReac={};
			var bv=0;
			for( var bw = 0 , bww= metabolicNodes.length; bw < bww; bw++ ) {
				if (metabolicNodes[bw][6]==4){
					
					//b5values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;					
					// try to assign the compartment of the majority of the products the reaction is linked to 
					// if there is no product, assign the compartment of the majority of modifiers
					// if there is no modifier, assign the compartment of the majority of reactants
					var listProducts= metabolicNodes[bw][11][1];
					var listModifiers= metabolicNodes[bw][11][2];
					var listReactants= metabolicNodes[bw][11][0];
					//if (bv==0){console.log(listProducts)}
					if (listProducts.length>0){
						var votes=[];
						for (var ncc=0;ncc<nbCompartments;ncc++){
							votes[ncc]=0;
						}
						for(var lp=0;lp<listProducts.length;lp++){
							if (mapComp[metabolicNodes[listProducts[lp]][3]]>=0)
								votes[mapComp[metabolicNodes[listProducts[lp]][3]]]++;
						}
						var winner= votes.indexOf(Math.max.apply( Math, votes ));
						if (scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv]!=winner && scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] !=mapComp[metabolicNodes[bw][3]]){
							oldCompReac[bv]=scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv];
							scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv]= winner;
							if (winner==-1){
								scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = mapComp[metabolicNodes[bw][3]];
							}
						}
					} 
					else if (listModifiers.length>0){
						var votes=[];
						for (var ncc=0;ncc<nbCompartments;ncc++){
							votes[ncc]=0;
						}
						for(var lp=0;lp<listModifiers.length;lp++){
							if (mapComp[metabolicNodes[listModifiers[lp]][3]]>=0)
								votes[mapComp[metabolicNodes[listModifiers[lp]][3]]]++;
						}
						var winner= votes.indexOf(Math.max.apply( Math, votes ));
						if (scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv]!=winner && scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] !=mapComp[metabolicNodes[bw][3]]){
							oldCompReac[bv]=scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv];
							scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = winner;
							
							if (winner==-1){
								scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = mapComp[metabolicNodes[bw][3]];
							}
						}
					}
					else if (listReactants.length>0){
						var votes=[];
						for (var ncc=0;ncc<nbCompartments;ncc++){
							votes[ncc]=0;
						}
						for(var lp=0;lp<listReactants.length;lp++){
							if (mapComp[metabolicNodes[listReactants[lp]][3]]>=0)
								votes[mapComp[metabolicNodes[listReactants[lp]][3]]]++;
						}
						var winner= votes.indexOf(Math.max.apply( Math, votes ));
						if (scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv]!=winner && scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] !=mapComp[metabolicNodes[bw][3]]){
							oldCompReac[bv]=scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv];
							scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = winner;
							if (winner==-1){
								scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = mapComp[metabolicNodes[bw][3]];
							}
						}
					}
					else {
						if (scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv]!=mapComp[metabolicNodes[bw][3]]){
							oldCompReac[bv]=scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv];
							scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv]= mapComp[metabolicNodes[bw][3]];
						}
					}
					bv++;
				}	
			}		
			
			scene.children[indexStartNodes+1].geometry.attributes.compartment.needsUpdate = true;
			
			for (var c=0;c<dt.length;c++){
					for (var h=0, hh=scene.children[indexStartNodes].geometry.attributes.size.array.length;h<hh;h++){
						for (var g=0;g<nbCompartments;g++){
							if (scene.children[indexStartNodes].geometry.attributes.compartment.array[h]==g){
								if (g==mapComp[dt[c][2]] && h==idMap[dt[c][0]][1]){
									scene.children[indexStartNodes].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x+(stackCompInitialPos[objects[g].name].x-stackCompInitialPos[objects[oldComp[dt[c][0]]].name].x);//+stackCompInitialPos[objects[oldComp].name].x;
									scene.children[indexStartNodes].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y+(stackCompInitialPos[objects[g].name].y-stackCompInitialPos[objects[oldComp[dt[c][0]]].name].y);//+stackCompInitialPos[objects[oldComp].name].y;
									scene.children[indexStartNodes].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z+(stackCompInitialPos[objects[g].name].z-stackCompInitialPos[objects[oldComp[dt[c][0]]].name].z);//+stackCompInitialPos[objects[oldComp].name].z;
								}
								else{
								//nameComp[g]
								scene.children[indexStartNodes].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x;
								scene.children[indexStartNodes].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y;
								scene.children[indexStartNodes].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z;
								}
							}
						}
					}
					scene.children[indexStartNodes].geometry.attributes.position.needsUpdate = true;
			}
			var tableMod={};
			var listMod2 = Object.keys(oldCompReac);
			for (var i=0;i<listMod2.length;i++){
				var tempcompnb=scene.children[indexStartNodes+1].geometry.attributes.compartment.array[listMod2[i]];//typesMap[4][listMod2[i]];//oldCompReac[listMod2[i]];
				var tempindexnb=listMod2[i];
				var g=tempcompnb;
				var oldg= oldCompReac[listMod2[i]];
				if (g!=oldg && oldg!=-1){

					scene.children[indexStartNodes+1].geometry.attributes.position.array[tempindexnb*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x+(stackCompInitialPos[objects[g].name].x-stackCompInitialPos[objects[oldg].name].x);//+stackCompInitialPos[objects[oldComp].name].x;
					scene.children[indexStartNodes+1].geometry.attributes.position.array[tempindexnb*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y+(stackCompInitialPos[objects[g].name].y-stackCompInitialPos[objects[oldg].name].y);//+stackCompInitialPos[objects[oldComp].name].y;
					scene.children[indexStartNodes+1].geometry.attributes.position.array[tempindexnb*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z+(stackCompInitialPos[objects[g].name].z-stackCompInitialPos[objects[oldg].name].z);//+stackCompInitialPos[objects[oldComp].name].z;
				}
				else{
					scene.children[indexStartNodes+1].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x;
					scene.children[indexStartNodes+1].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y;
					scene.children[indexStartNodes+1].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z;
				}
				//console.log(typesMap[4][listMod2[i]])
				tableMod[typesMap[4][listMod2[i]]]=g;
			}
			scene.children[indexStartNodes+1].geometry.attributes.position.needsUpdate = true;
			
			var iv=0;
			for ( var i = 0; i < segments; i ++ ) {
				var t1 = metabolicNodes[metabolicEdges[i][0]][6]
				var t2 = metabolicNodes[metabolicEdges[i][1]][6]
				//console.log(t1)
				//console.log(t2)
				//var ivList=[]
				var doIt=0
				if (t1==2){
					//console.log(idMap[jsonObj2[i][0]][1])
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					
					iv++;
				}
				else if (t1==4){
					//console.log(idMap[jsonObj2[i][0]][1])
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					iv++;
				}
				if (t2 ==2){
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
					iv++;
				}
				else if (t2 ==4){
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
					iv++;
				}
				
			}
			scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
			
			
			var tableMod2 = Object.keys(tableMod);
			for (var i=0;i<tempdata3.length;i++){
				for (var j=0;j<tableMod2.length;j++){
					if (tempdata3[i][0]==tableMod2[j]){
						tempdata3[i][2]= compIds[tableMod[tableMod2[j]]];
					}
				
				}
			}
			
			var ht = $('#mtnTable2').handsontable('getInstance');
			//ht.clear();
			ht.alter('remove_row', 0, tempdata3.length);
			//console.log(searcharray)
			if ($.isArray(tempdata3) && tempdata3[0] && $.isArray(tempdata3[0])){
				ht.populateFromArray (0, 0, tempdata3,tempdata3.length-1, 4);
			}
			
			
			
			
			saveLayout();
			
			
			
			
			
			
			
		}
			//console.log(mtnlLayout["nodes_compartments"])
			//console.log(mtnlLayout["nodes_compartments"][dt[dt.length-1][0]])
			//console.log(dt)
			//console.log("new name: "+dt[changes[0][0]][1])
			//console.log("new comp: "+dt[changes[0][0]][2])
			
			// var indexStartNodes=maxNbComp+3;
			// nbCompartments= listCompartments.length;
			
			// nameComp=[];
			// mapComp = {'-1':-1};
			
			// for (var i=0;i<listCompartments.length;i++){
				// mapComp[listCompartments[i][0]]=i;
				// nameComp.push(listCompartments[i][1]);
			// }
			
			// //idMap[bw]=[2,bv];
			// //scene.children[indexStartNodes].geometry.attributes.compartment.array[h]
			// var oldComp;
			// if (idMap[dt[changes[0][0]][0]] && idMap[dt[changes[0][0]][0]][0]==2){
				// //console.log(dt[changes[0][0]][2])
				// //console.log(mapComp[dt[0][2]]);
				// //console.log (scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[dt[0][0]][1]]);
				// oldComp = scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[dt[changes[0][0]][0]][1]];
				// scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[dt[changes[0][0]][0]][1]]=mapComp[dt[changes[0][0]][2]];
				// scene.children[indexStartNodes].geometry.attributes.compartment.needsUpdate = true;
			// }
			// for ( var i = 0; i < listCompartments.length; i ++ ) {
				// stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
				// objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
			// }
			
			
			// var bv=0;
			// for( var bw = 0 , bww= metabolicNodes.length; bw < bww; bw++ ) {
				// if (metabolicNodes[bw][6]==4){
					
					// //b5values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;					
					// // try to assign the compartment of the majority of the products the reaction is linked to 
					// // if there is no product, assign the compartment of the majority of modifiers
					// // if there is no modifier, assign the compartment of the majority of reactants
					// var listProducts= metabolicNodes[bw][11][1];
					// var listModifiers= metabolicNodes[bw][11][2];
					// var listReactants= metabolicNodes[bw][11][0];
					// //if (bv==0){console.log(listProducts)}
					// if (listProducts.length>0){
						// var votes=[];
						// for (var ncc=0;ncc<nbCompartments;ncc++){
							// votes[ncc]=0;
						// }
						// for(var lp=0;lp<listProducts.length;lp++){
							// if (mapComp[metabolicNodes[listProducts[lp]][3]]>=0)
								// votes[mapComp[metabolicNodes[listProducts[lp]][3]]]++;
						// }
						// var winner= votes.indexOf(Math.max.apply( Math, votes ));
						// //compartmentP2[ bv ] = winner;
						// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv]= winner;
						// if (winner==-1){
							// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = mapComp[metabolicNodes[bw][3]];
						// }
					// } 
					// else if (listModifiers.length>0){
						// var votes=[];
						// for (var ncc=0;ncc<nbCompartments;ncc++){
							// votes[ncc]=0;
						// }
						// for(var lp=0;lp<listModifiers.length;lp++){
							// if (mapComp[metabolicNodes[listModifiers[lp]][3]]>=0)
								// votes[mapComp[metabolicNodes[listModifiers[lp]][3]]]++;
						// }
						// var winner= votes.indexOf(Math.max.apply( Math, votes ));
						// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = winner;
						
						// if (winner==-1){
							// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = mapComp[metabolicNodes[bw][3]];
						// }
					// }
					// else if (listReactants.length>0){
						// var votes=[];
						// for (var ncc=0;ncc<nbCompartments;ncc++){
							// votes[ncc]=0;
						// }
						// for(var lp=0;lp<listReactants.length;lp++){
							// if (mapComp[metabolicNodes[listReactants[lp]][3]]>=0)
								// votes[mapComp[metabolicNodes[listReactants[lp]][3]]]++;
						// }
						// var winner= votes.indexOf(Math.max.apply( Math, votes ));
						// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = winner;
						// if (winner==-1){
							// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = mapComp[metabolicNodes[bw][3]];
						// }
					// }
					// else {
						// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv]= mapComp[metabolicNodes[bw][3]];
					// }
					// bv++;
				// }	
			// }		
			
			// scene.children[indexStartNodes+1].geometry.attributes.compartment.needsUpdate = true;
	
			// for (var c=indexStartNodes;c<indexStartNodes+2;c++){
				// for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
					// for (var g=0;g<nbCompartments;g++){
						// if (scene.children[c].geometry.attributes.compartment.array[h]==g){
							// if (g==mapComp[dt[changes[0][0]][2]] && h==idMap[dt[changes[0][0]][0]][1]){
								// scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x+(stackCompInitialPos[objects[g].name].x-stackCompInitialPos[objects[oldComp].name].x);//+stackCompInitialPos[objects[oldComp].name].x;
								// scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y+(stackCompInitialPos[objects[g].name].y-stackCompInitialPos[objects[oldComp].name].y);//+stackCompInitialPos[objects[oldComp].name].y;
								// scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z+(stackCompInitialPos[objects[g].name].z-stackCompInitialPos[objects[oldComp].name].z);//+stackCompInitialPos[objects[oldComp].name].z;
							// }
							// else{
						// //nameComp[g]
						// scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x;
						// scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y;
						// scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z;
						// }
						// //scene.children[c].geometry.attributes.position.array[h*3+1]+=1000;
						// //scene.children[c].geometry.attributes.position.array[h*3+2]+=1000;
						// }
					// }
				// }
				// scene.children[c].geometry.attributes.position.needsUpdate = true;
			// }
			// var iv=0;
			// for ( var i = 0; i < segments; i ++ ) {
				// var t1 = metabolicNodes[metabolicEdges[i][0]][6]
				// var t2 = metabolicNodes[metabolicEdges[i][1]][6]
				// //console.log(t1)
				// //console.log(t2)
				// //var ivList=[]
				// var doIt=0
				// if (t1==2){
					// //console.log(idMap[jsonObj2[i][0]][1])
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					
					// iv++;
				// }
				// else if (t1==4){
					// //console.log(idMap[jsonObj2[i][0]][1])
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					// iv++;
				// }
				// if (t2 ==2){
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
					// iv++;
				// }
				// else if (t2 ==4){
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
					// iv++;
				// }
				
			// }
			// scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
			
		// }
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			//console.log(changes)	
			
			//console.log(dt[changes[0][0]])	
			// change name			
			// selectedMetabolicData[1][dt[dt.length-1][0]][1]=dt[dt.length-1][1];
			// // change compartment
			// selectedMetabolicData[1][dt[dt.length-1][0]][3]=dt[dt.length-1][2];
			// metabolicNodes=selectedMetabolicData[1];
			// mtnlLayout["nodes_compartments"][dt[dt.length-1][0]]=[];
			// mtnlLayout["nodes_compartments"][dt[dt.length-1][0]].push(dt[dt.length-1][1]);
			// mtnlLayout["nodes_compartments"][dt[dt.length-1][0]].push(dt[dt.length-1][2]);
			// saveLayout();
			// //console.log(mtnlLayout["nodes_compartments"])
			// //console.log(mtnlLayout["nodes_compartments"][dt[dt.length-1][0]])
			// //console.log(dt)
			// //console.log("new name: "+dt[changes[0][0]][1])
			// //console.log("new comp: "+dt[changes[0][0]][2])
			
			// var indexStartNodes=maxNbComp+3;
			// nbCompartments= listCompartments.length;
			
			// nameComp=[];
			// mapComp = {'-1':-1};
			
			// for (var i=0;i<listCompartments.length;i++){
				// mapComp[listCompartments[i][0]]=i;
				// nameComp.push(listCompartments[i][1]);
			// }
			
			// //idMap[bw]=[2,bv];
			// //scene.children[indexStartNodes].geometry.attributes.compartment.array[h]
			// var oldComp;
			// if (idMap[dt[changes[0][0]][0]] && idMap[dt[changes[0][0]][0]][0]==2){
				// //console.log(dt[changes[0][0]][2])
				// //console.log(mapComp[dt[0][2]]);
				// //console.log (scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[dt[0][0]][1]]);
				// oldComp = scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[dt[changes[0][0]][0]][1]];
				// scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[dt[changes[0][0]][0]][1]]=mapComp[dt[changes[0][0]][2]];
				// scene.children[indexStartNodes].geometry.attributes.compartment.needsUpdate = true;
			// }
			// for ( var i = 0; i < listCompartments.length; i ++ ) {
				// stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
				// objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
			// }
			
			
			// var bv=0;
			// for( var bw = 0 , bww= metabolicNodes.length; bw < bww; bw++ ) {
				// if (metabolicNodes[bw][6]==4){
					
					// //b5values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;					
					// // try to assign the compartment of the majority of the products the reaction is linked to 
					// // if there is no product, assign the compartment of the majority of modifiers
					// // if there is no modifier, assign the compartment of the majority of reactants
					// var listProducts= metabolicNodes[bw][11][1];
					// var listModifiers= metabolicNodes[bw][11][2];
					// var listReactants= metabolicNodes[bw][11][0];
					// //if (bv==0){console.log(listProducts)}
					// if (listProducts.length>0){
						// var votes=[];
						// for (var ncc=0;ncc<nbCompartments;ncc++){
							// votes[ncc]=0;
						// }
						// for(var lp=0;lp<listProducts.length;lp++){
							// if (mapComp[metabolicNodes[listProducts[lp]][3]]>=0)
								// votes[mapComp[metabolicNodes[listProducts[lp]][3]]]++;
						// }
						// var winner= votes.indexOf(Math.max.apply( Math, votes ));
						// //compartmentP2[ bv ] = winner;
						// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv]= winner;
						// if (winner==-1){
							// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = mapComp[metabolicNodes[bw][3]];
						// }
					// } 
					// else if (listModifiers.length>0){
						// var votes=[];
						// for (var ncc=0;ncc<nbCompartments;ncc++){
							// votes[ncc]=0;
						// }
						// for(var lp=0;lp<listModifiers.length;lp++){
							// if (mapComp[metabolicNodes[listModifiers[lp]][3]]>=0)
								// votes[mapComp[metabolicNodes[listModifiers[lp]][3]]]++;
						// }
						// var winner= votes.indexOf(Math.max.apply( Math, votes ));
						// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = winner;
						
						// if (winner==-1){
							// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = mapComp[metabolicNodes[bw][3]];
						// }
					// }
					// else if (listReactants.length>0){
						// var votes=[];
						// for (var ncc=0;ncc<nbCompartments;ncc++){
							// votes[ncc]=0;
						// }
						// for(var lp=0;lp<listReactants.length;lp++){
							// if (mapComp[metabolicNodes[listReactants[lp]][3]]>=0)
								// votes[mapComp[metabolicNodes[listReactants[lp]][3]]]++;
						// }
						// var winner= votes.indexOf(Math.max.apply( Math, votes ));
						// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = winner;
						// if (winner==-1){
							// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = mapComp[metabolicNodes[bw][3]];
						// }
					// }
					// else {
						// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv]= mapComp[metabolicNodes[bw][3]];
					// }
					// bv++;
				// }	
			// }		
			
			// scene.children[indexStartNodes+1].geometry.attributes.compartment.needsUpdate = true;
	
			// for (var c=indexStartNodes;c<indexStartNodes+2;c++){
				// for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
					// for (var g=0;g<nbCompartments;g++){
						// if (scene.children[c].geometry.attributes.compartment.array[h]==g){
							// if (g==mapComp[dt[changes[0][0]][2]] && h==idMap[dt[changes[0][0]][0]][1]){
								// scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x+(stackCompInitialPos[objects[g].name].x-stackCompInitialPos[objects[oldComp].name].x);//+stackCompInitialPos[objects[oldComp].name].x;
								// scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y+(stackCompInitialPos[objects[g].name].y-stackCompInitialPos[objects[oldComp].name].y);//+stackCompInitialPos[objects[oldComp].name].y;
								// scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z+(stackCompInitialPos[objects[g].name].z-stackCompInitialPos[objects[oldComp].name].z);//+stackCompInitialPos[objects[oldComp].name].z;
							// }
							// else{
						// //nameComp[g]
						// scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x;
						// scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y;
						// scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z;
						// }
						// //scene.children[c].geometry.attributes.position.array[h*3+1]+=1000;
						// //scene.children[c].geometry.attributes.position.array[h*3+2]+=1000;
						// }
					// }
				// }
				// scene.children[c].geometry.attributes.position.needsUpdate = true;
			// }
			// var iv=0;
			// for ( var i = 0; i < segments; i ++ ) {
				// var t1 = metabolicNodes[metabolicEdges[i][0]][6]
				// var t2 = metabolicNodes[metabolicEdges[i][1]][6]
				// //console.log(t1)
				// //console.log(t2)
				// //var ivList=[]
				// var doIt=0
				// if (t1==2){
					// //console.log(idMap[jsonObj2[i][0]][1])
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					
					// iv++;
				// }
				// else if (t1==4){
					// //console.log(idMap[jsonObj2[i][0]][1])
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					// iv++;
				// }
				// if (t2 ==2){
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
					// iv++;
				// }
				// else if (t2 ==4){
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
					// iv++;
				// }
				
			// }
			// scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
			
		// }
		
		
	  },
	  columnSorting: true,
	  minSpareRows: 1
	});
	
	
	
	//listNodes=selectedMetabolicData[1];
	var tempdata2=[];
	for (var i=0, j= listNodes.length;i<j;i++){
		if (listNodes[i][6]==2){
			tempdata2.push([i,listNodes[i][1],listNodes[i][3]])
		}
	}
	

	var ht = $('#mtnTable').handsontable('getInstance');
	if ($.isArray(tempdata2) && tempdata2[0] && $.isArray(tempdata2[0])){
		ht.populateFromArray (0, 0, tempdata2,tempdata2.length-1, 2);
	}
	
	
	var $container2 = $("#mtnTable2");
	$container2.handsontable({
	  data: [],
	  width: 1150,
	  height:200,
	  colWidths: [100, 400,100,200,300],
	  dataSchema: {n_id:null, n_name: null, c_name: null, subsystem: null, rule:null},
	  startRows: 1,
	  startCols: 5,
	  colHeaders: ['Node nb','Node name', 'Comp. name', 'Sub-System','Rule'],
	  columns: [
		{data: "n_id"},
		{data: "n_name"},
		{data: "c_name"},
		{data: "subsystem"},
		{data: "rule"}//, type: 'dropdown',source: compIds}
	  ],
	  beforeChange: function(changes, source) {
		if ((Array.isArray(changes[0])) && changes[0][2] ){
			if (changes[0][1]!="c_name" ){
				changes.length=0;
				return false;
			}
			else{ 
				if (changes[0][1]=="c_name" && compIds.indexOf(changes[0][3])==-1){
					changes.length=0;
					return false;
				}
			}
		}
		
	  },
	  afterChange: function(changes, source) {
		if (changes && changes[0] && changes[0][2]){	
			var oldComp={};
			var oldReacComp={};
			var dt = this.getData(changes[0][0],0,changes[changes.length-1][0],2);	
			//console.log(changes)	
			var indexStartNodes=maxNbComp+3;
			
			nbCompartments= listCompartments.length;
			
			nameComp=[];
			mapComp = {'-1':-1};
			
			for (var i=0;i<listCompartments.length;i++){
				mapComp[listCompartments[i][0]]=i;
				nameComp.push(listCompartments[i][1]);
			}
			//nbCompartments= listCompartments.length;
			for ( var i2 = 0; i2 < listCompartments.length; i2 ++ ) {
				stackCompInitialPos[objects[i2].name]= new THREE.Vector3(objects[i2].position.x,objects[i2].position.y,objects[i2].position.z);
				objects[i2].name=listCompartments[i2][0]+" "+listCompartments[i2][1];
			}
			for (var i=0;i<dt.length;i++){
			
			
				
				
				//mtnlLayout["nodes_compartments"][dt[c][0]]=[];
				//mtnlLayout["nodes_compartments"][dt[c][0]].push(dt[c][1]);
				
				//console.log(dt[c])
				if (idMap[dt[i][0]] && idMap[dt[i][0]][0]==2){
					oldComp[dt[i][0]] = scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[dt[i][0]][1]];
					scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[dt[i][0]][1]]=mapComp[dt[i][2]];
					scene.children[indexStartNodes].geometry.attributes.compartment.needsUpdate = true;
				}
			
			
				var cp=-1;
				if (compIds.indexOf(dt[i][2])!=-1){
					cp = compIds.indexOf(dt[i][2]);
				}
				listNodes[dt[i][0]][3]= dt[i][2];
				if (listNodes[dt[i][0]][11]){
					//console.log(listNodes[dt[i][0]][11])
					// reactants
					if (listNodes[dt[i][0]][11][0]){
						for (var i1=0;i1<listNodes[dt[i][0]][11][0].length;i1++){
							oldComp[listNodes[dt[i][0]][11][0][i1]] = listNodes[listNodes[dt[i][0]][11][0][i1]][3];
							listNodes[listNodes[dt[i][0]][11][0][i1]][3]= dt[i][2];
							selectedMetabolicData[1][listNodes[dt[i][0]][11][0][i1]][3]=dt[i][2];
							scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[listNodes[dt[i][0]][11][0][i1]][1]]=cp;
							//console.log(mtnlLayout["nodes_compartments"][listNodes[dt[i][0]][11][0][i1]]);
							//console.log(listNodes[dt[i][0]][11][0][i1]);
							mtnlLayout["nodes_compartments"][listNodes[dt[i][0]][11][0][i1]]=[listNodes[listNodes[dt[i][0]][11][0][i1]][1],listNodes[listNodes[dt[i][0]][11][0][i1]][3]];
							//mtnlLayout["nodes_compartments"][listNodes[dt[i][0]][11][0][i1]][1]=dt[i][2];
							//console.log(mtnlLayout["nodes_compartments"][listNodes[dt[i][0]][11][0][i1]][1])
						}
					}
					// products
					if (listNodes[dt[i][0]][11][1]){
						for (var i1=0;i1<listNodes[dt[i][0]][11][1].length;i1++){
							oldComp[listNodes[dt[i][0]][11][1][i1]] = listNodes[listNodes[dt[i][0]][11][1][i1]][3];
							listNodes[listNodes[dt[i][0]][11][1][i1]][3]= dt[i][2];
							selectedMetabolicData[1][listNodes[dt[i][0]][11][1][i1]][3]=dt[i][2];
							scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[listNodes[dt[i][0]][11][1][i1]][1]]=cp;
							mtnlLayout["nodes_compartments"][listNodes[dt[i][0]][11][1][i1]]=[listNodes[listNodes[dt[i][0]][11][1][i1]][1],listNodes[listNodes[dt[i][0]][11][1][i1]][3]];
							//mtnlLayout["nodes_compartments"][listNodes[dt[i][0]][11][1][i1]][1]=dt[i][2];
							//console.log(mtnlLayout["nodes_compartments"][listNodes[dt[i][0]][11][1][i1]][1])
							
						}
					}
					// modifiers
					if (listNodes[dt[i][0]][11][2]){
						for (var i1=0;i1<listNodes[dt[i][0]][11][2].length;i1++){
							oldComp[listNodes[dt[i][0]][11][2][i1]] = listNodes[listNodes[dt[i][0]][11][2][i1]][3];
							listNodes[listNodes[dt[i][0]][11][2][i1]][3]= dt[i][2];
							selectedMetabolicData[1][listNodes[dt[i][0]][11][2][i1]][3]=dt[i][2];
							scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[listNodes[dt[i][0]][11][2][i1]][1]]=cp;
							mtnlLayout["nodes_compartments"][listNodes[dt[i][0]][11][2][i1]]=[listNodes[listNodes[dt[i][0]][11][2][i1]][1],listNodes[listNodes[dt[i][0]][11][2][i1]][3]];
							//mtnlLayout["nodes_compartments"][listNodes[dt[i][0]][11][2][i1]][1]=dt[i][2];
							//console.log(mtnlLayout["nodes_compartments"][listNodes[dt[i][0]][11][2][i1]][1])
							
						}
					}
				}
				//console.log(scene.children[indexStartNodes+1].geometry.attributes.compartment.array[idMap[dt[i][0]][1]])
				oldReacComp[dt[i][0]] = scene.children[indexStartNodes+1].geometry.attributes.compartment.array[idMap[dt[i][0]][1]];
				listNodes[dt[i][0]][3]= dt[i][2];
				selectedMetabolicData[1][dt[i][0]][3]=dt[i][2];
				scene.children[indexStartNodes+1].geometry.attributes.compartment.array[idMap[dt[i][0]][1]]= cp;
				//console.log(scene.children[indexStartNodes+1].geometry.attributes.compartment.array[idMap[dt[i][0]][1]])				
			}
			metabolicNodes=selectedMetabolicData[1];
			saveLayout();
			scene.children[indexStartNodes].geometry.attributes.compartment.needsUpdate = true;
			scene.children[indexStartNodes+1].geometry.attributes.compartment.needsUpdate = true;
			//console.log(oldComp)
			var listMod = Object.keys(oldComp);
			for (var i=0;i<listMod.length;i++){
				var tempcompnb=idMap[listMod[i]][0];
				var tempindexnb=idMap[listMod[i]][1];
					var g=compIds.indexOf(listNodes[listMod[i]][3]);
					var oldg= compIds.indexOf(oldComp[listMod[i]]);
					if (g!=oldg){
	
						scene.children[indexStartNodes].geometry.attributes.position.array[tempindexnb*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x+(stackCompInitialPos[objects[g].name].x-stackCompInitialPos[objects[oldg].name].x);//+stackCompInitialPos[objects[oldComp].name].x;
						scene.children[indexStartNodes].geometry.attributes.position.array[tempindexnb*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y+(stackCompInitialPos[objects[g].name].y-stackCompInitialPos[objects[oldg].name].y);//+stackCompInitialPos[objects[oldComp].name].y;
						scene.children[indexStartNodes].geometry.attributes.position.array[tempindexnb*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z+(stackCompInitialPos[objects[g].name].z-stackCompInitialPos[objects[oldg].name].z);//+stackCompInitialPos[objects[oldComp].name].z;
					}
					else{
						scene.children[indexStartNodes].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x;
						scene.children[indexStartNodes].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y;
						scene.children[indexStartNodes].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z;
					}
			}
			scene.children[indexStartNodes].geometry.attributes.position.needsUpdate = true;
			
			var listMod2 = Object.keys(oldReacComp);
			for (var i=0;i<listMod2.length;i++){
				var tempcompnb=idMap[listMod2[i]][0];
				var tempindexnb=idMap[listMod2[i]][1];
					var g=compIds.indexOf(listNodes[listMod2[i]][3]);
					var oldg= oldReacComp[listMod2[i]];
					//console.log(oldReacComp[listMod2[i]])
					//console.log(g)
					//console.log(oldg)
					if (g!=oldg && oldg!=-1){
	
						scene.children[indexStartNodes+1].geometry.attributes.position.array[tempindexnb*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x+(stackCompInitialPos[objects[g].name].x-stackCompInitialPos[objects[oldg].name].x);//+stackCompInitialPos[objects[oldComp].name].x;
						scene.children[indexStartNodes+1].geometry.attributes.position.array[tempindexnb*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y+(stackCompInitialPos[objects[g].name].y-stackCompInitialPos[objects[oldg].name].y);//+stackCompInitialPos[objects[oldComp].name].y;
						scene.children[indexStartNodes+1].geometry.attributes.position.array[tempindexnb*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z+(stackCompInitialPos[objects[g].name].z-stackCompInitialPos[objects[oldg].name].z);//+stackCompInitialPos[objects[oldComp].name].z;
					}
					else{
						scene.children[indexStartNodes+1].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x;
						scene.children[indexStartNodes+1].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y;
						scene.children[indexStartNodes+1].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z;
					}
			}
			scene.children[indexStartNodes+1].geometry.attributes.position.needsUpdate = true;
			
			
			var iv=0;
			for ( var i = 0; i < segments; i ++ ) {
				var t1 = metabolicNodes[metabolicEdges[i][0]][6]
				var t2 = metabolicNodes[metabolicEdges[i][1]][6]
				//console.log(t1)
				//console.log(t2)
				//var ivList=[]
				var doIt=0
				if (t1==2){
					//console.log(idMap[jsonObj2[i][0]][1])
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					
					iv++;
				}
				else if (t1==4){
					//console.log(idMap[jsonObj2[i][0]][1])
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					iv++;
				}
				if (t2 ==2){
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
					iv++;
				}
				else if (t2 ==4){
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
					iv++;
				}
				
			}
			scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
			
			
			// var indexStartNodes=maxNbComp+3;
			// nbCompartments= listCompartments.length;
			
			// nameComp=[];
			// mapComp = {'-1':-1};
			
			// for (var i=0;i<listCompartments.length;i++){
				// mapComp[listCompartments[i][0]]=i;
				// nameComp.push(listCompartments[i][1]);
			// }
			// var oldComp;
			// if (idMap[dt[changes[0][0]][0]] && idMap[dt[changes[0][0]][0]][0]==2){
				// //console.log(dt[0][2])
				// //console.log(mapComp[dt[0][2]]);
				// //console.log (scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[dt[0][0]][1]]);
				// oldComp = scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[dt[changes[0][0]][0]][1]];
				// scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[dt[changes[0][0]][0]][1]]=mapComp[dt[changes[0][0]][2]];
				// scene.children[indexStartNodes].geometry.attributes.compartment.needsUpdate = true;
			// }
			// for ( var i = 0; i < listCompartments.length; i ++ ) {
				// stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
				// objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
			// }
			
			
			// var bv=0;
			// for( var bw = 0 , bww= metabolicNodes.length; bw < bww; bw++ ) {
				// if (metabolicNodes[bw][6]==4){
					
					// //b5values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;					
					// // try to assign the compartment of the majority of the products the reaction is linked to 
					// // if there is no product, assign the compartment of the majority of modifiers
					// // if there is no modifier, assign the compartment of the majority of reactants
					// var listProducts= metabolicNodes[bw][11][0];
					// var listModifiers= metabolicNodes[bw][11][1];
					// var listReactants= metabolicNodes[bw][11][2];
					
					// if (listProducts.length>0){
						// var votes=[];
						// for (var ncc=0;ncc<nbCompartments;ncc++){
							// votes[ncc]=0;
						// }
						// for(var lp=0;lp<listProducts.length;lp++){
							// if (mapComp[metabolicNodes[listProducts[lp]][3]]>=0)
								// votes[mapComp[metabolicNodes[listProducts[lp]][3]]]++;
						// }
						// var winner= votes.indexOf(Math.max.apply( Math, votes ));
						// //compartmentP2[ bv ] = winner;
						// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv]= winner;
						// if (winner==-1){
							// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = mapComp[metabolicNodes[bw][3]];
						// }
					// } 
					// else if (listModifiers.length>0){
						// var votes=[];
						// for (var ncc=0;ncc<nbCompartments;ncc++){
							// votes[ncc]=0;
						// }
						// for(var lp=0;lp<listModifiers.length;lp++){
							// if (mapComp[metabolicNodes[listModifiers[lp]][3]]>=0)
								// votes[mapComp[metabolicNodes[listModifiers[lp]][3]]]++;
						// }
						// var winner= votes.indexOf(Math.max.apply( Math, votes ));
						// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = winner;
						
						// if (winner==-1){
							// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = mapComp[metabolicNodes[bw][3]];
						// }
					// }
					// else if (listReactants.length>0){
						// var votes=[];
						// for (var ncc=0;ncc<nbCompartments;ncc++){
							// votes[ncc]=0;
						// }
						// for(var lp=0;lp<listReactants.length;lp++){
							// if (mapComp[metabolicNodes[listReactants[lp]][3]]>=0)
								// votes[mapComp[metabolicNodes[listReactants[lp]][3]]]++;
						// }
						// var winner= votes.indexOf(Math.max.apply( Math, votes ));
						// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = winner;
						// if (winner==-1){
							// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = mapComp[metabolicNodes[bw][3]];
						// }
					// }
					// else {
						// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv]= mapComp[metabolicNodes[bw][3]];
					// }
					// bv++;
				// }	
			// }		
			// scene.children[indexStartNodes+1].geometry.attributes.compartment.needsUpdate = true;
	
			// for (var c=indexStartNodes;c<indexStartNodes+2;c++){
				// for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
					// for (var g=0;g<nbCompartments;g++){
						// if (scene.children[c].geometry.attributes.compartment.array[h]==g){
							// if (g==mapComp[dt[changes[0][0]][2]] && h==idMap[dt[changes[0][0]][0]][1]){
								// scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x+(stackCompInitialPos[objects[g].name].x-stackCompInitialPos[objects[oldComp].name].x);//+stackCompInitialPos[objects[oldComp].name].x;
								// scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y+(stackCompInitialPos[objects[g].name].y-stackCompInitialPos[objects[oldComp].name].y);//+stackCompInitialPos[objects[oldComp].name].y;
								// scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z+(stackCompInitialPos[objects[g].name].z-stackCompInitialPos[objects[oldComp].name].z);//+stackCompInitialPos[objects[oldComp].name].z;
							// }
							// else{
						// //nameComp[g]
						// scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x;
						// scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y;
						// scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z;
						// }
						// //scene.children[c].geometry.attributes.position.array[h*3+1]+=1000;
						// //scene.children[c].geometry.attributes.position.array[h*3+2]+=1000;
						// }
					// }
				// }
				// scene.children[c].geometry.attributes.position.needsUpdate = true;
			// }
			// var iv=0;
			// for ( var i = 0; i < segments; i ++ ) {
				// var t1 = metabolicNodes[metabolicEdges[i][0]][6]
				// var t2 = metabolicNodes[metabolicEdges[i][1]][6]
				// //console.log(t1)
				// //console.log(t2)
				// //var ivList=[]
				// var doIt=0
				// if (t1==2){
					// //console.log(idMap[jsonObj2[i][0]][1])
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					
					// iv++;
				// }
				// else if (t1==4){
					// //console.log(idMap[jsonObj2[i][0]][1])
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					// iv++;
				// }
				// if (t2 ==2){
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
					// iv++;
				// }
				// else if (t2 ==4){
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
					// iv++;
				// }
				
			// }
			// scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
			
			
			
			
			
			var value = ('' + document.getElementById("searchgrid").value).toLowerCase(),row,col,r_len,c_len,td;
		
			tempdata2=[];
			for (var i=0, j= listNodes.length;i<j;i++){
				tempdata2.push([i,listNodes[i][1],listNodes[i][3]])
			}
			var data = tempdata2;
			
			//var data = $('#tab2id').handsontable('getData');
			//console.log(data)
			var searcharray = [];
			if(value){
				if( value.length>1){
					for(row=0,r_len = data.length;row< r_len;row++){
						for(col=0,c_len = data[row].length;col < c_len-1; col++){
							if(data[row][col] == null){
								continue;
							}
							if(('' + data[row][col]).toLowerCase().indexOf(value) > -1){
								searcharray.push(data[row]);
								break;
							}
							else{
							}
						}
					}
					
					//console.log(searcharray.length)
					var ht = $('#mtnTable').handsontable('getInstance');
					//ht.clear();
					ht.alter('remove_row', 0, tempdata2.length);
					//console.log(searcharray)
					tempdata2=searcharray;
					if ($.isArray(searcharray) && searcharray[0] && $.isArray(searcharray[0])){
						ht.populateFromArray (0, 0, searcharray,searcharray.length-1, 2);
					}
				}
			}
			else{
				tempdata2=[];
				for (var i=0, j= listNodes.length;i<j;i++){
					tempdata2.push([i,listNodes[i][1],listNodes[i][3]])
				}
				var ht = $('#mtnTable').handsontable('getInstance');
				ht.alter('remove_row', 0, tempdata2.length);
				if ($.isArray(tempdata2) && tempdata2[0] && $.isArray(tempdata2[0])){
					ht.populateFromArray (0, 0, tempdata2,tempdata2.length-1, 2);
				}
			}
			$('#mtnTable').handsontable('deselectCell');
			
			
			
		}
		
	  },
	  columnSorting: true,
	  minSpareRows: 1
	});
	
	//listNodes=selectedMetabolicData[1];
	var tempdata3=[];
	for (var i=0, j= listNodes.length;i<j;i++){
		if (listNodes[i][6]==4){
			
			var sbsys=""
			if (listNodes[i][4] && listNodes[i][4][1] && listNodes[i][4][1][0]){
				sbsys = listNodes[i][4][1][0];
			}
			var rule="";
			var listProducts= [];
			var listModifiers= [];
			var listReactants= [];
			var winner;
			if (listNodes[i][11]){
				
				if (listNodes[i][11][0]){
					
					listReactants =listNodes[i][11][0];
					for (var k=0;k<listNodes[i][11][0].length;k++){
						if (k!=listNodes[i][11][0].length-1){
							rule += listNodes[listNodes[i][11][0][k]][1]+" + ";
						}
						else{
							rule += listNodes[listNodes[i][11][0][k]][1]+" ";
						}
					}
					
				}
				if (listNodes[i][11][2]){
					listModifiers = listNodes[i][11][2];
					for (var k=0;k<listNodes[i][11][2].length;k++){
						if (k!=listNodes[i][11][2].length-1){
							rule += listNodes[listNodes[i][11][2][k]][1]+" + ";
						}
						else{
							rule += listNodes[listNodes[i][11][2][k]][1]+" ";
						}
					}
					
				}
				if (listNodes[i][11][1]){
					listProducts=listNodes[i][11][1];
					
					rule += " = "
					for (var k=0;k<listNodes[i][11][1].length;k++){
						if (k!=listNodes[i][11][1].length-1){
							rule += listNodes[listNodes[i][11][1][k]][1]+" + ";
						}
						else{
							rule += listNodes[listNodes[i][11][1][k]][1]+" ";
						}
					}
					
				}
				
			}
			if (listProducts.length>0){
				var votes=[];
				for (var ncc=0;ncc<nbCompartments;ncc++){
					votes[ncc]=0;
				}
				for(var lp=0;lp<listProducts.length;lp++){
					if (mapComp[listNodes[listProducts[lp]][3]]>=0)
						votes[mapComp[listNodes[listProducts[lp]][3]]]++;
				}
				winner= votes.indexOf(Math.max.apply( Math, votes ));
			}
			else if (listModifiers.length>0){
				var votes=[];
				for (var ncc=0;ncc<nbCompartments;ncc++){
					votes[ncc]=0;
				}
				for(var lp=0;lp<listModifiers.length;lp++){
					if (mapComp[listNodes[listModifiers[lp]][3]]>=0)
						votes[mapComp[listNodes[listModifiers[lp]][3]]]++;
				}
				winner= votes.indexOf(Math.max.apply( Math, votes ));
			}
			else if (listReactants.length>0){
				var votes=[];
				for (var ncc=0;ncc<nbCompartments;ncc++){
					votes[ncc]=0;
				}
				for(var lp=0;lp<listReactants.length;lp++){
					if (mapComp[listNodes[listReactants[lp]][3]]>=0)
						votes[mapComp[listNodes[listReactants[lp]][3]]]++;
				}
				winner= votes.indexOf(Math.max.apply( Math, votes ));
			}
			else {
				winner= mapComp[listNodes[i][3]];
			}		
			var cp =winner;
			if (winner==-1){
				cp="";
			}
			else{
				cp=compIds[winner]
			}
			tempdata3.push([i,listNodes[i][1],cp,sbsys,rule])
			
		}
	}
	

	var ht = $('#mtnTable2').handsontable('getInstance');
	if ($.isArray(tempdata3) && tempdata3[0] && $.isArray(tempdata3[0])){
		ht.populateFromArray (0, 0, tempdata3,tempdata3.length-1, 4);
	}
	
	
	
	
	var metabolitesDegree={};
	for (var i=0, j=tempdata3.length; i<j;i++){
		if (listNodes[tempdata3[i][0]][11]){
			if (listNodes[tempdata3[i][0]][11][0]){
				for (var k=0;k<listNodes[tempdata3[i][0]][11][0].length;k++){
					var idMet = listNodes[tempdata3[i][0]][11][0][k];
					if (metabolitesDegree.hasOwnProperty(idMet)){
						metabolitesDegree[idMet]+=1;
					}
					else{
						metabolitesDegree[idMet]=1;
					}
				}
		
			}
			if (listNodes[tempdata3[i][0]][11][1]){
				for (var k=0;k<listNodes[tempdata3[i][0]][11][1].length;k++){
					var idMet = listNodes[tempdata3[i][0]][11][1][k];
					if (metabolitesDegree.hasOwnProperty(idMet)){
						metabolitesDegree[idMet]+=1;
					}
					else{
						metabolitesDegree[idMet]=1;
					}
				}
		
			}
			if (listNodes[tempdata3[i][0]][11][2]){
				for (var k=0;k<listNodes[tempdata3[i][0]][11][2].length;k++){
					var idMet = listNodes[tempdata3[i][0]][11][2][k];
					if (metabolitesDegree.hasOwnProperty(idMet)){
						metabolitesDegree[idMet]+=1;
					}
					else{
						metabolitesDegree[idMet]=1;
					}
				}
		
			}
		
		}
	
	}
	//console.log(metabolitesDegree)
	var dataCurrency=new Array(tempdata2.length);//=[];
	var max =0;
	if (mtnlLayout["currency_nodes"] && mtnlLayout["currency_nodes"].length>0){
		//console.log(mtnlLayout["currency_nodes"])
		for (var i=0, j=tempdata2.length; i<j;i++){
			//if (metabolitesDegree[tempdata2[i][0]]>max){
			//	dataCurrency.shift([tempdata2[i][0],tempdata2[i][1],metabolitesDegree[tempdata2[i][0]],false])
			//	max = metabolitesDegree[tempdata2[i][0]];
			//}
			//else{
			//	dataCurrency.push([tempdata2[i][0],tempdata2[i][1],metabolitesDegree[tempdata2[i][0]],false])
			//}
			dataCurrency[i]=new Array(5);
			dataCurrency[i][0]=tempdata2[i][0];
			dataCurrency[i][1]=tempdata2[i][1];
			dataCurrency[i][2]=listNodes[tempdata2[i][0]][2];
			if (metabolitesDegree.hasOwnProperty(tempdata2[i][0])){
				dataCurrency[i][3]=metabolitesDegree[tempdata2[i][0]];
			}
			else{
				metabolitesDegree[tempdata2[i][0]]=0;
				dataCurrency[i][3]=metabolitesDegree[tempdata2[i][0]];
			}
			if (mtnlLayout["currency_nodes"].indexOf(dataCurrency[i][0])>-1){
				dataCurrency[i][4]=true
			}
			else{
				dataCurrency[i][4]=false;
			}
		}
		
		
	}
	else{
		for (var i=0, j=tempdata2.length; i<j;i++){
			//if (metabolitesDegree[tempdata2[i][0]]>max){
			//	dataCurrency.shift([tempdata2[i][0],tempdata2[i][1],metabolitesDegree[tempdata2[i][0]],false])
			//	max = metabolitesDegree[tempdata2[i][0]];
			//}
			//else{
			//	dataCurrency.push([tempdata2[i][0],tempdata2[i][1],metabolitesDegree[tempdata2[i][0]],false])
			//}
			dataCurrency[i]=new Array(5);
			dataCurrency[i][0]=tempdata2[i][0];
			dataCurrency[i][1]=tempdata2[i][1];
			dataCurrency[i][2]=listNodes[tempdata2[i][0]][2];
			if (metabolitesDegree.hasOwnProperty(tempdata2[i][0])){
				dataCurrency[i][3]=metabolitesDegree[tempdata2[i][0]];
			}
			else{
				metabolitesDegree[tempdata2[i][0]]=0;
				dataCurrency[i][3]=metabolitesDegree[tempdata2[i][0]];
			}
			
			dataCurrency[i][4]=false;
		}
	}
	
	
	
	
	
	dataCurrency.sort(function(a, b){
		return (b[3] - a[3]) //causes an array to be sorted numerically and ascending
	})
	var recordedChanges={};
	var $containerCurrency = $("#CurrencyTable");
	$containerCurrency.handsontable({
		data: dataCurrency,
		width: 1200,
		height:200,
		colWidths: [100, 200,400,200,100],
		//dataSchema: {n_id:null, n_name: null, n_hide: null},
		startRows: 1,
		startCols: 5,
		
		colHeaders: ['Node nb','Node unique id','Node name','connections','Hide'],
		columns: [
		{},
		{},
		{},
		{type: 'numeric'},
		{type: 'checkbox'}
		],
		beforeChange: function(changes, source) {
		},
		afterChange: function(changes, source) {
			if (changes){
				var obj = this;
				
				for (var i =0; i< changes.length;i++){
					if (changes[i]){
						var rowChanged=changes[i][0];
						var colChanged=changes[i][1];
							if (colChanged==4){
								//recordedChanges[]=changes[i][4]);
								//console.log(changes)
								//console.log(obj.getDataAtCell (rowChanged,0))
								recordedChanges[obj.getDataAtCell (rowChanged,0)]=obj.getDataAtCell (rowChanged,colChanged)
								var index = mtnlLayout["currency_nodes"].indexOf(obj.getDataAtCell (rowChanged,0));
								//console.log(index)
								if (recordedChanges[obj.getDataAtCell (rowChanged,0)]==true){
									
									if (index ==-1){
										mtnlLayout["currency_nodes"].push(obj.getDataAtCell (rowChanged,0));
										var mcy = $("#cy").cytoscape("get");											
										mcy.$('#'+listNodes[obj.getDataAtCell (rowChanged,0)][1]).style('display','none');
										// mute 3d and 2d graph nodes and lines corresponding to selected currency nodes
										var indexStartNodes=maxNbComp+3;
										
										var identifier=obj.getDataAtCell (rowChanged,0);
										var typeNode=idMap[identifier][0];
										var indexNode=idMap[identifier][1];
										//console.log(typeNode+' '+indexNode)
										
										if (typeNode==2){
											scene.children[indexStartNodes].geometry.attributes.size.array[indexNode]=0;
											//scene.children[indexStartNodes].geometry.attributes.position.array[indexNode*3+0]+=5000000;
											//scene.children[indexStartNodes].geometry.attributes.position.array[indexNode*3+1]+=5000000;
											//scene.children[indexStartNodes].geometry.attributes.position.array[indexNode*3+2]+=5000000;
										}
										//scene.children[indexStartNodes].geometry.attributes.position.needsUpdate = true;
										scene.children[indexStartNodes].geometry.attributes.size.needsUpdate = true;
										selectedLinesPaths=[]
										for (var i=0; i<metabolicEdges.length;i++){
											if (metabolicEdges[i][0]==identifier){
												selectedLinesPaths.push(i)
												//txtListLinks += '<li >'+jsonObj1[jsonObj2[i][1]][2]+'</li>';
												//nbS+=1;
											}
											if (metabolicEdges[i][1]==identifier){
												selectedLinesPaths.push(i)
												//txtListLinks += '<li >'+jsonObj1[jsonObj2[i][0]][2]+'</li>';
												//nbS+=1;
											}
										}
										//for (var i=0; i<selectedLinesPathsIds.length;i++){
										//	scene.children[indexStartNodes+2].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] -=5000000;
										//}
										selectedLinesPathsIds=[]
										for (var i=0; i<selectedLinesPaths.length;i++){
											for (var j=0;j<linesMap[selectedLinesPaths[i]].length;j+=1){
												selectedLinesPathsIds.push(linesMap[selectedLinesPaths[i]][j])
											}
										}
										selectedLinesPathsIds = unique(selectedLinesPathsIds)
										//console.log(selectedLinesPathsIds)
										for (var i=0;i<selectedLinesPathsIds.length;i+=1){
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] +=5000000;
										}
										scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
										
										
									}
								}
								else{
									if (index >-1){
										mtnlLayout["currency_nodes"].splice(index, 1);
										var indexStartNodes=maxNbComp+3;
										var mcy = $("#cy").cytoscape("get");											
										mcy.$('#'+listNodes[obj.getDataAtCell (rowChanged,0)][1]).style('display','element');
										var identifier=obj.getDataAtCell (rowChanged,0);
										var typeNode=idMap[identifier][0];
										var indexNode=idMap[identifier][1];
										//console.log(typeNode+' '+indexNode)
										if (typeNode==2){
											scene.children[indexStartNodes].geometry.attributes.size.array[indexNode]=nodeSize;
										//	scene.children[indexStartNodes].geometry.attributes.position.array[indexNode*3+0]-=5000000;
										//	scene.children[indexStartNodes].geometry.attributes.position.array[indexNode*3+1]-=5000000;
										//	scene.children[indexStartNodes].geometry.attributes.position.array[indexNode*3+2]-=5000000;
										}
										scene.children[indexStartNodes].geometry.attributes.size.needsUpdate = true;
										selectedLinesPaths=[]
										for (var i=0; i<metabolicEdges.length;i++){
											if (metabolicEdges[i][0]==identifier){
												selectedLinesPaths.push(i)
												//txtListLinks += '<li >'+jsonObj1[jsonObj2[i][1]][2]+'</li>';
												//nbS+=1;
											}
											if (metabolicEdges[i][1]==identifier){
												selectedLinesPaths.push(i)
												//txtListLinks += '<li >'+jsonObj1[jsonObj2[i][0]][2]+'</li>';
												//nbS+=1;
											}
										}
										//for (var i=0; i<selectedLinesPathsIds.length;i++){
										//	scene.children[indexStartNodes+2].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] -=5000000;
										//}
										selectedLinesPathsIds=[]
										for (var i=0; i<selectedLinesPaths.length;i++){
											for (var j=0;j<linesMap[selectedLinesPaths[i]].length;j+=1){
												selectedLinesPathsIds.push(linesMap[selectedLinesPaths[i]][j])
											}
										}
										selectedLinesPathsIds = unique(selectedLinesPathsIds)
										//console.log(selectedLinesPathsIds)
										for (var i=0;i<selectedLinesPathsIds.length;i+=1){
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] -=5000000;
										}
										scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
									}
								}
								//if (){mtnlLayout["currency_nodes"].push()}
							}
						
					}
				}
				//console.log(mtnlLayout["currency_nodes"])
				
				//obj.setDataAtCell (recordedChanges)
				
				//obj.render()
			}
		},
		columnSorting: true,
		minSpareRows: 1
	});
	
	$('#searchgrid3').on('keyup',function(event){
		var value = ('' + this.value).toLowerCase(),row,col,r_len,c_len,td;
		
		//tempdata2=[];
		//for (var i=0, j= listNodes.length;i<j;i++){
		//	tempdata2.push([i,listNodes[i][1],listNodes[i][3]])
		//}
		
		var data = dataCurrency;
		
		//var data = $('#tab2id').handsontable('getData');
		//console.log(data)
		var searcharray = [];
		if(value){
			if( value.length>1){
				for(row=0,r_len = data.length;row< r_len;row++){
					for(col=0,c_len = data[row].length;col < c_len-1; col++){
						//var col = 2;
						if(data[row][col] == null){
							continue;
						}
						if(('' + data[row][col]).toLowerCase().indexOf(value) > -1){
							if (recordedChanges.hasOwnProperty(data[row][0])){
								data[row][4]= recordedChanges[data[row][0]];
								searcharray.push(data[row]);
							}
							//if (recordedChanges.hasOwnProperty(tempdata2[i][0])){
							//	dataCurrency[i][4]=recordedChanges[tempdata2[i][0]]
							//}
							break;
						}
						else{
						}
					}
				}
				
				//console.log(searcharray.length)
				var ht = $('#CurrencyTable').handsontable('getInstance');
				//ht.clear();
				ht.alter('remove_row', 0, $('#CurrencyTable').handsontable('countRows'));
				//console.log(searcharray)
				//dataCurrency=searcharray;
				if ($.isArray(searcharray) && searcharray[0] && $.isArray(searcharray[0])){
					ht.populateFromArray (0, 0, searcharray,searcharray.length-1, 4);
				}
			}
		}
		else{
			dataCurrency=new Array(tempdata2.length);//=[];
			var max =0;
			for (var i=0, j=tempdata2.length; i<j;i++){
				//if (metabolitesDegree[tempdata2[i][0]]>max){
				//	dataCurrency.shift([tempdata2[i][0],tempdata2[i][1],metabolitesDegree[tempdata2[i][0]],false])
				//	max = metabolitesDegree[tempdata2[i][0]];
				//}
				//else{
				//	dataCurrency.push([tempdata2[i][0],tempdata2[i][1],metabolitesDegree[tempdata2[i][0]],false])
				//}
				dataCurrency[i]=new Array(5);
				dataCurrency[i][0]=tempdata2[i][0];
				dataCurrency[i][1]=tempdata2[i][1];
				dataCurrency[i][2]=listNodes[tempdata2[i][0]][2];
				dataCurrency[i][3]=metabolitesDegree[tempdata2[i][0]];
				dataCurrency[i][4]=false;
				if (recordedChanges.hasOwnProperty(tempdata2[i][0])){
					dataCurrency[i][4]=recordedChanges[tempdata2[i][0]]
				}
			}
			//console.log(dataCurrency.length)
			var ht = $('#CurrencyTable').handsontable('getInstance');
			ht.alter('remove_row', 0, $('#CurrencyTable').handsontable('countRows'));
			if ($.isArray(dataCurrency) && dataCurrency[0] && $.isArray(dataCurrency[0])){
				ht.populateFromArray (0, 0, dataCurrency,dataCurrency.length-1, 4);
			}
			
		//	//dataCurrency=[];
		//	//for (var i=0, j= listNodes.length;i<j;i++){
		//	//	dataCurrency.push([i,listNodes[i][1],listNodes[i][3]])
		//	//}
		//	var ht = $('#CurrencyTable').handsontable('getInstance');
		//	ht.alter('remove_row', 0, dataCurrency.length);
		//	if ($.isArray(dataCurrency) && dataCurrency[0] && $.isArray(dataCurrency[0])){
		//		ht.populateFromArray (0, 0, dataCurrency,dataCurrency.length-1, 2);
		//	}
		}
		console.log()
		$('#CurrencyTable').handsontable('deselectCell');
			
		
	});
	
	//var hot = $('#CurrencyTable').handsontable('getInstance');
	//if (hot.sortingEnabled) {
	//  // will sort table using values from the first column in descending order
	//  hot.sort(2, false);
	//}
	//hot.render()
	
	
	//console.log(ht)
	//ht.data.columns[0].readOnly=true;
	//ht.columns[1].readOnly=true;
	//$("#compTable").css({top:  $("#container").position().top + $("#container").height()+40});
	$("#searchfield").css({top:  $("#compTable").position().top + $("#compTable").height()+40});
	$("#mtnTable").css({top:  $("#searchfield").position().top + $("#searchfield").height()+10});
	$("#searchfield2").css({top:  $("#mtnTable").position().top + $("#mtnTable").height()+40});
	$("#mtnTable2").css({top:  $("#searchfield2").position().top + $("#searchfield2").height()+10});
	$("#titleCurrency").css({top:  $("#mtnTable2").position().top + $("#mtnTable2").height()+10});
	$("#searchfield3").css({top:  $("#titleCurrency").position().top + $("#titleCurrency").height()+40});
	$("#CurrencyTable").css({top:  $("#searchfield3").position().top + $("#searchfield3").height()+10});
	$("#titleEditor").css({top:  $("#CurrencyTable").position().top + $("#CurrencyTable").height()+40});
	$("#container").css({top:  $("#titleEditor").position().top + $("#titleEditor").height()+40});
	$("#editplane").css({top:  $("#container").position().top + $("#container").height()-40});
	$("#layoutEditor").css({top:  $("#container").position().top + $("#container").height()+40});
	$("#layouttools").css({top:  $("#layoutEditor").position().top + $("#layoutEditor").height()+40});
	$("#cy").css({top:  $("#layouttools").height()+$("#layouttools").position().top+80, left:0, width:"80%",height:'400pt', border:"thin solid #000000"});
	$("#mtnl-update-form").css({top:  $("#cy").position().top + $("#cy").height()+40});
	$('#searchgrid').on('keyup',function(event){
		var value = ('' + this.value).toLowerCase(),row,col,r_len,c_len,td;
		
		tempdata2=[];
		for (var i=0, j= listNodes.length;i<j;i++){
			tempdata2.push([i,listNodes[i][1],listNodes[i][3]])
		}
		var data = tempdata2;
		
		//var data = $('#tab2id').handsontable('getData');
		//console.log(data)
		var searcharray = [];
		if(value){
			if( value.length>1){
				for(row=0,r_len = data.length;row< r_len;row++){
					for(col=0,c_len = data[row].length;col < c_len-1; col++){
						if(data[row][col] == null){
							continue;
						}
						if(('' + data[row][col]).toLowerCase().indexOf(value) > -1){
							searcharray.push(data[row]);
							break;
						}
						else{
						}
					}
				}
				
				//console.log(searcharray.length)
				var ht = $('#mtnTable').handsontable('getInstance');
				//ht.clear();
				ht.alter('remove_row', 0, tempdata2.length);
				//console.log(searcharray)
				tempdata2=searcharray;
				if ($.isArray(searcharray) && searcharray[0] && $.isArray(searcharray[0])){
					ht.populateFromArray (0, 0, searcharray,searcharray.length-1, 2);
				}
			}
		}
		else{
			tempdata2=[];
			for (var i=0, j= listNodes.length;i<j;i++){
				tempdata2.push([i,listNodes[i][1],listNodes[i][3]])
			}
			var ht = $('#mtnTable').handsontable('getInstance');
			ht.alter('remove_row', 0, tempdata2.length);
			if ($.isArray(tempdata2) && tempdata2[0] && $.isArray(tempdata2[0])){
				ht.populateFromArray (0, 0, tempdata2,tempdata2.length-1, 2);
			}
		}
		$('#mtnTable').handsontable('deselectCell');
			
		
	});
	
	$('#searchgrid2').on('keyup',function(event){
		var value = ('' + this.value).toLowerCase(),row,col,r_len,c_len,td;
		
		
		
		
		//var data = $('#tab2id').handsontable('getData');
		//console.log(data)
		var searcharray = [];
		if(value ){
			if( value.length>1){
				if (tempdata3){
					var data = tempdata3;
					for(row=0,r_len = data.length;row< r_len;row++){
						for(col=0,c_len = data[row].length;col < c_len-1; col++){
							if(data[row][col] == null){
								continue;
							}
							if(('' + data[row][col]).toLowerCase().indexOf(value) > -1){
								searcharray.push(data[row]);
								break;
							}
							else{
							}
						}
					}
					
					//console.log(searcharray.length)
					var ht = $('#mtnTable2').handsontable('getInstance');
					//ht.clear();
					ht.alter('remove_row', 0, tempdata2.length);
					//console.log(searcharray)
					tempdata3=searcharray;
					if ($.isArray(searcharray) && searcharray[0] && $.isArray(searcharray[0])){
						ht.populateFromArray (0, 0, searcharray,searcharray.length-1, 4);
					}
				}
			}
		}
		else{
			tempdata3=[];
			for (var i=0, j= listNodes.length;i<j;i++){
				if (listNodes[i][6]==4){
					
					var sbsys=""
					if (listNodes[i][4] && listNodes[i][4][1] && listNodes[i][4][1][0]){
						sbsys = listNodes[i][4][1][0];
					}
					var rule="";
					var listProducts= [];
					var listModifiers= [];
					var listReactants= [];
					var winner;
					if (listNodes[i][11]){
						
						if (listNodes[i][11][0]){
							
							listReactants =listNodes[i][11][0];
							for (var k=0;k<listNodes[i][11][0].length;k++){
								if (k!=listNodes[i][11][0].length-1){
									rule += listNodes[listNodes[i][11][0][k]][1]+" + ";
								}
								else{
									rule += listNodes[listNodes[i][11][0][k]][1]+" ";
								}
							}
							
						}
						if (listNodes[i][11][2]){
							listModifiers = listNodes[i][11][2];
							for (var k=0;k<listNodes[i][11][2].length;k++){
								if (k!=listNodes[i][11][2].length-1){
									rule += listNodes[listNodes[i][11][2][k]][1]+" + ";
								}
								else{
									rule += listNodes[listNodes[i][11][2][k]][1]+" ";
								}
							}
							
						}
						if (listNodes[i][11][1]){
							listProducts=listNodes[i][11][1];
							
							rule += " = "
							for (var k=0;k<listNodes[i][11][1].length;k++){
								if (k!=listNodes[i][11][1].length-1){
									rule += listNodes[listNodes[i][11][1][k]][1]+" + ";
								}
								else{
									rule += listNodes[listNodes[i][11][1][k]][1]+" ";
								}
							}
							
						}
						
					}
					if (listProducts.length>0){
						var votes=[];
						for (var ncc=0;ncc<nbCompartments;ncc++){
							votes[ncc]=0;
						}
						for(var lp=0;lp<listProducts.length;lp++){
							if (mapComp[listNodes[listProducts[lp]][3]]>=0)
								votes[mapComp[listNodes[listProducts[lp]][3]]]++;
						}
						winner= votes.indexOf(Math.max.apply( Math, votes ));
					}
					else if (listModifiers.length>0){
						var votes=[];
						for (var ncc=0;ncc<nbCompartments;ncc++){
							votes[ncc]=0;
						}
						for(var lp=0;lp<listModifiers.length;lp++){
							if (mapComp[listNodes[listModifiers[lp]][3]]>=0)
								votes[mapComp[listNodes[listModifiers[lp]][3]]]++;
						}
						winner= votes.indexOf(Math.max.apply( Math, votes ));
					}
					else if (listReactants.length>0){
						var votes=[];
						for (var ncc=0;ncc<nbCompartments;ncc++){
							votes[ncc]=0;
						}
						for(var lp=0;lp<listReactants.length;lp++){
							if (mapComp[listNodes[listReactants[lp]][3]]>=0)
								votes[mapComp[listNodes[listReactants[lp]][3]]]++;
						}
						winner= votes.indexOf(Math.max.apply( Math, votes ));
					}
					else {
						winner= mapComp[listNodes[i][3]];
					}		
					var cp =winner;
					if (winner==-1){
						cp="automated";
					}
					else{
						cp=compIds[winner]
					}
					tempdata3.push([i,listNodes[i][1],cp,sbsys,rule])
					
				}
			}
			var ht = $('#mtnTable2').handsontable('getInstance');
			ht.alter('remove_row', 0, tempdata3.length);
			if ($.isArray(tempdata3) && tempdata3[0] && $.isArray(tempdata3[0])){
				ht.populateFromArray (0, 0, tempdata3,tempdata3.length-1, 4);
			}
		}
		$('#mtnTable').handsontable('deselectCell');
			
		
	});
	
	function placeCompFromLayout(cName, cRef, dropType){
		var initialCnamePos= new THREE.Vector3(0,0,0);
		
		
								
		if (dropType=='merged'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			for (var ref in generalLayout["merged"]){
				if (generalLayout["merged"].hasOwnProperty(ref)){
					if (cName==ref || generalLayout["merged"][ref].indexOf(cName)!=-1 ){
						
						for (var j=0; j<listCompartments.length;j++ ){
							if (objects[j].name==ref || generalLayout["merged"][ref].indexOf(objects[j].name)!=-1){
								//if (generalLayout["merged"][ref].indexOf(objects[j].name)!=-1){
								//stackCompInitialPos[objects[j].name].x=objects[indRef].position.x;
								//stackCompInitialPos[objects[j].name].y=objects[indRef].position.y;
								//stackCompInitialPos[objects[j].name].z=objects[indRef].position.z;
								//}
								//if (objects[j].name==cName){
								//console.log(objects[j].position.x)
								//console.log(stackCompInitialPos[cRef].x)
								//initialCnamePos.x=stackCompInitialPos[cRef].x;
								//initialCnamePos.y=stackCompInitialPos[cRef].y;
								//initialCnamePos.z=stackCompInitialPos[cRef].z;
								//}
								
								//objects[j].position.copy( objects[indRef].position );
								//objects[j].position.x=objects[indRef].position.x;
								//objects[j].position.y=objects[indRef].position.y;
								//objects[j].position.z=objects[indRef].position.z;
								
								objects[j].scale.x=objects[indRef].scale.x;
								objects[j].scale.y=objects[indRef].scale.y;
								objects[j].scale.z=objects[indRef].scale.z;
							}
						}
					}
				}
			}
		}
		if (dropType=='outer'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			for (var ref in generalLayout["outer"]){
				if (generalLayout["outer"].hasOwnProperty(ref)){
					if (cName==ref || generalLayout["outer"][ref].indexOf(cName)!=-1 ){
						mustMove=true;
						for (var j=0; j<listCompartments.length;j++ ){
							var indPos = generalLayout["outer"][ref].indexOf(objects[j].name);
							if (objects[j].name==ref ){
								objects[j].position.copy( objects[indRef].position );
							}
							else if (indPos!=-1){
								objects[j].position.copy( objects[indRef].position );
								//console.log(indPos)
								objects[j].scale.x = 2+indPos;
								objects[j].scale.z = 2+indPos;
							}
							else{}
						}
					}
				}
			}
		}
		if (dropType=='satellite'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			var isRefSatellite=false;
			for (var ref in generalLayout["satellite"]){
				if (generalLayout["satellite"].hasOwnProperty(ref)){
					if (generalLayout["satellite"][ref].indexOf(cRef)!=-1){
						isRefSatellite=true;
					}
				}
			}
			
			var lenOuter=0;
			var nameOuterRef="";
			for (var ref in generalLayout["outer"]){
				if (generalLayout["outer"].hasOwnProperty(ref)){
					var tmpInd=generalLayout["outer"][ref].indexOf(cRef);
					if (cRef==ref ){
						nameOuterRef=ref;
						lenOuter=generalLayout["outer"][ref].length+1;
					}
					else if (tmpInd!=-1 ){
						nameOuterRef=ref;
						lenOuter=generalLayout["outer"][ref].length+1;
					}
					else{}
				}
			}
			var indOuterRef;
			for (var i=0; i<listCompartments.length;i++ ){
				if (objects[i].name==nameOuterRef && objects[i].name!=""){
					indOuterRef=i;
				}
			}
			//console.log(lenOuter)
			for (var ref in generalLayout["satellite"]){
				if (generalLayout["satellite"].hasOwnProperty(ref)){
					var indSat=generalLayout["satellite"][ref].indexOf(cName);
					if (cName==ref || indSat!=-1 ){
						mustMove=true;
						if (indSat!=-1){
							if (lenOuter==0){
								for (var j=0; j<generalLayout["satellite"][ref].length;j++ ){
									var max_rotation_count=generalLayout["satellite"][ref].length;
									var dilation_count=0;
									var tmpNode= generalLayout["satellite"][ref][j];
									for (var j1=0; j1<listCompartments.length;j1++ ){
										if (objects[j1].name==tmpNode && objects[j1].name!=""){
											var scaledSpacing=spacing;
											if (isRefSatellite){
												objects[j1].scale.x=objects[indRef].scale.x*0.417777;
												objects[j1].scale.y=objects[indRef].scale.y*0.417777;
												objects[j1].scale.z=objects[indRef].scale.z*0.417777;
												scaledSpacing=scaledSpacing/((1/(objects[indRef].scale.x)));
											}
											objects[j1].position.x=objects[indRef].position.x+Math.cos(((2 * Math.PI)*(1/max_rotation_count))*j)*(scaledSpacing+((lenOuter)*scaledSpacing/2));
											objects[j1].position.y=objects[indRef].position.y;
											objects[j1].position.z=objects[indRef].position.z+Math.sin(((2 * Math.PI)*(1/max_rotation_count))*j)*(scaledSpacing+((lenOuter)*scaledSpacing/2));
											objects[j1].scale.x=objects[indRef].scale.x*0.417777;
											objects[j1].scale.y=objects[indRef].scale.y*0.417777;
											objects[j1].scale.z=objects[indRef].scale.z*0.417777;
										}
									}
								}
							}
							if (lenOuter>0){
								for (var j=0; j<generalLayout["satellite"][ref].length;j++ ){
									var max_rotation_count=generalLayout["satellite"][ref].length;
									var dilation_count=0;
									var tmpNode= generalLayout["satellite"][ref][j];
									for (var j1=0; j1<listCompartments.length;j1++ ){
										if (objects[j1].name==tmpNode && objects[j1].name!=""){
											var scaledSpacing=spacing;
											if (isRefSatellite){
												objects[j1].scale.x=objects[indOuterRef].scale.x*lenOuter*0.417777;
												objects[j1].scale.y=objects[indOuterRef].scale.y*lenOuter*0.417777;
												objects[j1].scale.z=objects[indOuterRef].scale.z*lenOuter*0.417777;
												scaledSpacing=scaledSpacing/((1/(objects[indOuterRef].scale.x)));
											}
											objects[j1].position.x=objects[indRef].position.x+Math.cos(((2 * Math.PI)*(1/max_rotation_count))*j)*(scaledSpacing+((lenOuter)*scaledSpacing/2));
											objects[j1].position.y=objects[indRef].position.y;
											objects[j1].position.z=objects[indRef].position.z+Math.sin(((2 * Math.PI)*(1/max_rotation_count))*j)*(scaledSpacing+((lenOuter)*scaledSpacing/2));
											objects[j1].scale.x=objects[indOuterRef].scale.x*lenOuter*0.417777;
											objects[j1].scale.y=objects[indOuterRef].scale.y*lenOuter*0.417777;
											objects[j1].scale.z=objects[indOuterRef].scale.z*lenOuter*0.417777;
										}
									}
								}
							}
						}
						else{}
					}
				}
			}
			
		}
		
		
		if (dropType=='in'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			var isRefSatellite=false;
			for (var ref in generalLayout["in"]){
				if (generalLayout["in"].hasOwnProperty(ref)){
					if (generalLayout["in"][ref].indexOf(cRef)!=-1){
						isRefSatellite=true;
					}
				}
			}
			var indOuter=-1;
			var lenOuter=0;
			for (var ref in generalLayout["outer"]){
				if (generalLayout["outer"].hasOwnProperty(ref)){
					var tmpInd=generalLayout["outer"][ref].indexOf(cRef);
					if (cName==ref ){
						indOuter=0;
						lenOuter=generalLayout["outer"][ref].length+1;
					}
					else if (tmpInd!=-1 ){
						indOuter=tmpInd+1;
						lenOuter=generalLayout["outer"][ref].length+1;
					}
					else{}
				}
			}
			
			for (var ref in generalLayout["in"]){
				if (generalLayout["in"].hasOwnProperty(ref)){
					var indSat=generalLayout["in"][ref].indexOf(cName);
					if (cName==ref || indSat!=-1 ){
						mustMove=true;
						if (indSat!=-1){
							for (var j=0; j<generalLayout["in"][ref].length;j++ ){
								var max_rotation_count=generalLayout["in"][ref].length;								
								var tmpNode= generalLayout["in"][ref][j];								
								for (var j1=0; j1<listCompartments.length;j1++ ){
									if (objects[j1].name==tmpNode && objects[j1].name!=""){
										var scaledSpacing=radiusComp*objects[indRef].scale.x*0.72;
										if (lenOuter>1){
												scaledSpacing=(radiusComp*objects[indRef].scale.x)-(radiusComp*objects[indRef].scale.x*(1/((lenOuter+1)*2))*1.4);
										}
										
										if (isRefSatellite){
											objects[j1].scale.x=objects[indRef].scale.x*0.20;
											objects[j1].scale.y=objects[indRef].scale.y*0.20;
											objects[j1].scale.z=objects[indRef].scale.z*0.20;
											scaledSpacing=scaledSpacing/((1/(objects[indRef].scale.x)));
											
										}
										objects[j1].position.x=objects[indRef].position.x+Math.cos(((2 * Math.PI)*(1/max_rotation_count))*j)*(scaledSpacing);
										objects[j1].position.y=objects[indRef].position.y;
										objects[j1].position.z=objects[indRef].position.z+Math.sin(((2 * Math.PI)*(1/max_rotation_count))*j)*(scaledSpacing);
										
										if (lenOuter>1){
											objects[j1].scale.x=objects[indRef].scale.x*(1/((lenOuter+1)*2));
											objects[j1].scale.y=objects[indRef].scale.y*(1/((lenOuter+1)*2));
											objects[j1].scale.z=objects[indRef].scale.z*(1/((lenOuter+1)*2));
										}
										else{
											objects[j1].scale.x=objects[indRef].scale.x*0.20;
											objects[j1].scale.y=objects[indRef].scale.y*0.20;
											objects[j1].scale.z=objects[indRef].scale.z*0.20;
										}
										var maxDiameter=((2 * Math.PI)*objects[indRef].scale.x*radiusComp*0.72)*(1/(max_rotation_count*2));
										var presentDiameter=(objects[j1].scale.x*radiusComp*2);
										if (maxDiameter<=presentDiameter){
											objects[j1].scale.x=objects[j1].scale.x*((maxDiameter/presentDiameter)*1.1)
											objects[j1].scale.y=objects[j1].scale.y*((maxDiameter/presentDiameter)*1.1)
											objects[j1].scale.z=objects[j1].scale.z*((maxDiameter/presentDiameter)*1.1)
										}
										//console.log("max: "+maxDiameter + " present: "+presentDiameter);
									}
								}
							}
						}
						else{}
					}
				}
			}
		}
		
		if (dropType=='above'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			var indCname;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cName){
					indCname=j;
				}
			}
			for (var ref in generalLayout["above"]){
				if (generalLayout["above"].hasOwnProperty(ref)){
					if (cName==ref || generalLayout["above"][ref].indexOf(cName)!=-1 ){
						
						
						var ind=generalLayout["above"][ref].indexOf(cName);
						
						if (cName==ref ){
							var tmpRef;
							for (var j=0; j<listCompartments.length;j++ ){
								if (objects[j].name==ref){
									tmpRef=j;
									objects[j].position.setX(objects[indRef].position.x);
									objects[j].position.setZ(objects[indRef].position.z);
									//console.log(ref)
								}
							}
							for (var j=0; j<generalLayout["above"][ref].length;j++ ){
								var tmpNode= generalLayout["above"][ref][j];
								for (var j1=0; j1<listCompartments.length;j1++ ){
									if (objects[j1].name==tmpNode && objects[j1].name!=""){
										objects[j1].position.setX(objects[tmpRef].position.x);
										objects[j1].position.setZ(objects[tmpRef].position.z);
										objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
									}
								}
							}
						}
						
						if (ind!=-1){
							var tmpRef;
							for (var j=0; j<listCompartments.length;j++ ){
								if (objects[j].name==ref){
									tmpRef=j;
									objects[j].position.setX(objects[indRef].position.x);
									objects[j].position.setZ(objects[indRef].position.z);
									//objects[j].position.setZ(SELECTED.position.z);
								}
							}
							for (var j=0; j<generalLayout["above"][ref].length;j++ ){
								var tmpNode= generalLayout["above"][ref][j];
								for (var j1=0; j1<listCompartments.length;j1++ ){
									if (objects[j1].name==tmpNode && objects[j1].name!=""){
										objects[j1].position.setX(objects[tmpRef].position.x);
										objects[j1].position.setZ(objects[tmpRef].position.z);
										objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
									}
								}
							}
						}
						
						
							
								
					}
				}
			}
		}
		
		if (dropType=='below'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			
			var indCname;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cName){
					indCname=j;
				}
			}
			for (var ref in generalLayout["above"]){
			
				if (generalLayout["above"].hasOwnProperty(ref)){
					if (cName==ref || generalLayout["above"][ref].indexOf(cName)!=-1 ){
						
						
						var ind=generalLayout["above"][ref].indexOf(cName);
						
						if (cName==ref ){
							var tmpRef;
							for (var j=0; j<listCompartments.length;j++ ){
								if (objects[j].name==ref){
									tmpRef=j;
									objects[indRef].position.y-=spacing;
									objects[j].position.setX(objects[indRef].position.x);
									objects[j].position.setZ(objects[indRef].position.z);
									objects[j].position.setY(objects[indRef].position.y);
									//console.log(ref)
								}
							}
							for (var j=0; j<generalLayout["above"][ref].length;j++ ){
								var tmpNode= generalLayout["above"][ref][j];
								for (var j1=0; j1<listCompartments.length;j1++ ){
									if (objects[j1].name==tmpNode && objects[j1].name!=""){
										objects[j1].position.setX(objects[tmpRef].position.x);
										objects[j1].position.setZ(objects[tmpRef].position.z);
										objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
									}
								}
							}
						}
						
						if (ind!=-1){
							var tmpRef;
							for (var j=0; j<listCompartments.length;j++ ){
								if (objects[j].name==ref){
									tmpRef=j;
									objects[j].position.setX(objects[indRef].position.x);
									objects[j].position.setZ(objects[indRef].position.z);
									//objects[j].position.setZ(SELECTED.position.z);
								}
							}
							for (var j=0; j<generalLayout["above"][ref].length;j++ ){
								var tmpNode= generalLayout["above"][ref][j];
								for (var j1=0; j1<listCompartments.length;j1++ ){
									if (objects[j1].name==tmpNode && objects[j1].name!=""){
										objects[j1].position.setX(objects[tmpRef].position.x);
										objects[j1].position.setZ(objects[tmpRef].position.z);
										objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
									}
								}
							}
						}
						
						
							
								
					}
				}
			}
		}
		
		
		for (var ref in generalLayout["merged"]){
			if (generalLayout["merged"].hasOwnProperty(ref)){	
					var indC;
					for (var j=0; j<listCompartments.length;j++ ){
						if (objects[j].name==ref ){
							indC=j;
						}
					}
					for (var j=0; j<listCompartments.length;j++ ){
						if (objects[j].name==ref || generalLayout["merged"][ref].indexOf(objects[j].name)!=-1){
							
							objects[j].position.copy( objects[indC].position );
							objects[j].scale.x=objects[indC].scale.x;
							objects[j].scale.y=objects[indC].scale.y;
							objects[j].scale.z=objects[indC].scale.z;
							
							
						}
					}
				
			}
		}
		
		//myLayout["compartments_layout"]["structure"]=generalLayout;
		//var layoutdata={};
		//for (var j=0; j<listCompartments.length;j++ ){
		//	layoutdata[objects[j].name]={"position":new THREE.Vector3(objects[j].position.x,objects[j].position.y,objects[j].position.z), "scale":new THREE.Vector3(objects[j].scale.x,objects[j].scale.y,objects[j].scale.z)}
		//}
		//myLayout["compartments_layout"]["spatial-layout"]=layoutdata;
		var indexStartNodes=maxNbComp+3;
		nbCompartments= listCompartments.length;
		//var indSelectedComp= SELECTED
		
		//console.log(SELECTED.name)
		//console.log(listCompartments.length);
		//console.log(scene.children[indexStartNodes])
		
		for (var c=indexStartNodes;c<indexStartNodes+2;c++){
			for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
				for (var g=0;g<nbCompartments;g++){
					//if (objects[g].scale<1.0){
					//	scene.children[c].geometry
					//}
					if (scene.children[c].geometry.attributes.compartment.array[h]==g){
						//console.log(scene.children[c].geometry)
						if (objects[g].name==cName){						
							scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[cName].x;//-stackCompInitialPos[cRef].x-stackCompInitialPos[cRef].x;
							scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[cName].y;//-stackCompInitialPos[cRef].y-stackCompInitialPos[cRef].y;
							scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[cName].z;//-stackCompInitialPos[cRef].z-stackCompInitialPos[cRef].z;
							
							var displacement = new THREE.Vector3(scene.children[c].geometry.attributes.position.array[h*3+0]- objects[g].position.x,
																 scene.children[c].geometry.attributes.position.array[h*3+1]- objects[g].position.y,
																 scene.children[c].geometry.attributes.position.array[h*3+2]- objects[g].position.z)
							if (objects[g].scale.x<1.0){
								scene.children[c].geometry.attributes.position.array[h*3+0]-=(displacement.x*(1-objects[g].scale.x));
								scene.children[c].geometry.attributes.position.array[h*3+1]-=(displacement.y*(1-objects[g].scale.y));
								scene.children[c].geometry.attributes.position.array[h*3+2]-=(displacement.z*(1-objects[g].scale.z));
								scene.children[c].geometry.attributes.size.array[h]*=0.417777;
							}
							if (objects[g].scale.x>1.0){
								var indLayer=-1;
								for (var ref in generalLayout["outer"]){
									if (generalLayout["outer"].hasOwnProperty(ref)){
										indLayer =generalLayout["outer"][ref].indexOf(objects[g].name);
										//if (indLayer!=-1){}
									}
								}
								if (indLayer>-1){
									var lengthV = displacement.length();
									displacement.setLength(lengthV+((indLayer+0.5)*radiusComp));
									scene.children[c].geometry.attributes.position.array[h*3+0]+=(displacement.x);
									scene.children[c].geometry.attributes.position.array[h*3+1]+=(displacement.y+radiusComp);
									scene.children[c].geometry.attributes.position.array[h*3+2]+=(displacement.z);
									scene.children[c].geometry.attributes.size.array[h]/=0.417777;
								}
								
								
							}
							//console.log(objects[g].scale.x)
						}
						else if (objects[g].name==cRef){
							scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x;
							scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y;
							scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z;
						}
						else{
							scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x;
							scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y;
							scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z;
						}
						
						
						
					}
				}
			}
			scene.children[c].geometry.attributes.position.needsUpdate = true;
			scene.children[c].geometry.attributes.size.needsUpdate = true;
		}
		var iv=0;
		for ( var i = 0; i < segments; i ++ ) {
			var t1 = metabolicNodes[metabolicEdges[i][0]][6]
			var t2 = metabolicNodes[metabolicEdges[i][1]][6]
			//console.log(t1)
			//console.log(t2)
			//var ivList=[]
			var doIt=0
			if (t1==2){
				//console.log(idMap[jsonObj2[i][0]][1])
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
				
				iv++;
			}
			else if (t1==4){
				//console.log(idMap[jsonObj2[i][0]][1])
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
				iv++;
			}
			if (t2 ==2){
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
				iv++;
			}
			else if (t2 ==4){
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
				iv++;
			}
			
		}
		scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
		//console.log(myLayout);
		mtnlLayout["compartments_layout"]={};
		mtnlLayout["compartments_layout"]["relations"]=generalLayout;
		mtnlLayout["compartments_layout"]["name-position-scale"]=[];
		for (var i=0; i<listCompartments.length;i++ ){
			mtnlLayout["compartments_layout"]["name-position-scale"][i]=[objects[i].name, objects[i].position , objects[i].scale];
		}
		
		saveLayout();
		//console.log(mtnlLayout)
		//console.log(generalLayout)
	}
	
	//$("#container2").css({top:  $("#mtnTable").position().top + $("#mtnTable").height()+40});
	
	
	
	positionContainer = $("#container").position();
	function runModeSelector(){
		if ($('#modeSelector').val()=="0"){
			plane.visible = true;
			text1.innerHTML = '';
			text1.style.top = 2000 + 'px';
			text1.style.left = 2000 + 'px';
		}
		if ($('#modeSelector').val()=="1"){
			plane.visible = false;
		}
		//console.log($('#modeSelector').val());
	}
	
	function changeEditingPlane(){
		if ($('#editplane').val()=="0"){
			$('#editplane').val("1");
			$('#editplane').attr("src", "/images/editplane12.png");
			NodeEditingPlane.rotation.x += (90*(Math.PI / 180));
			//NodeEditingPlane.visible = true;
			//console.log($('#editplane').val());
		}
		else{
			$('#editplane').val("0");
			$('#editplane').attr("src", "/images/editplane1.png");
			NodeEditingPlane.rotation.x -= (90*(Math.PI / 180));
		}
	}
	
	function updateSlider(slideAmount){
	//console.log(slideAmount)
		var indexStartNodes=maxNbComp+3;
		for (var i=0;i<segmentPts;i++){
			scene.children[indexStartNodes+2].geometry.attributes.op.array[i]=(parseFloat(slideAmount)/100);	
		}
		scene.children[indexStartNodes+2].geometry.attributes.op.needsUpdate = true;
	}
	
	function saveLayout(){
		var mlength=JSON.stringify(mtnlLayout).length;
		//console.log(mlength)
		var nbArrays=1;
		if (mlength>524288){
			nbArrays=parseInt(Math.ceil(mlength/524288.0));
		}
		if (nbArrays==1){
			document.getElementById("layouts0").value=JSON.stringify(mtnlLayout);
			//console.log(document.getElementById("layouts"+0).value.length)
		}
		else{
			var stringSfba=JSON.stringify(mtnlLayout);
			var chunksize=524288;
			var stringChunks=[];
			//console.log(mlength)
			for (var i=0;i<nbArrays;i++){
				stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
				document.getElementById("layouts"+i).value=stringChunks[i];
				//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
				//console.log(document.getElementById("layouts"+i).value.length)
			}
			//console.log(stringChunks)
		}
	}
	
	
		var indexStartNodes=maxNbComp+3;
		nbCompartments= listCompartments.length;
		//var indSelectedComp= SELECTED
		
		
		//console.log(listCompartments.length);
		//console.log(scene.children[indexStartNodes])
		
		for (var c=indexStartNodes;c<indexStartNodes+2;c++){
			for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
				for (var g=0;g<nbCompartments;g++){
					//if (objects[g].scale<1.0){
					//	scene.children[c].geometry
					//}
					if (scene.children[c].geometry.attributes.compartment.array[h]==g){
						//console.log(scene.children[c].geometry)
						
							scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x;//-stackCompInitialPos[cRef].x-stackCompInitialPos[cRef].x;
							scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y;//-stackCompInitialPos[cRef].y-stackCompInitialPos[cRef].y;
							scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z;//-stackCompInitialPos[cRef].z-stackCompInitialPos[cRef].z;
							
							var displacement = new THREE.Vector3(scene.children[c].geometry.attributes.position.array[h*3+0]- objects[g].position.x,
																 scene.children[c].geometry.attributes.position.array[h*3+1]- objects[g].position.y,
																 scene.children[c].geometry.attributes.position.array[h*3+2]- objects[g].position.z)
							if (objects[g].scale.x<1.0){
								scene.children[c].geometry.attributes.position.array[h*3+0]-=(displacement.x*(1-objects[g].scale.x));
								scene.children[c].geometry.attributes.position.array[h*3+1]-=(displacement.y*(1-objects[g].scale.y));
								scene.children[c].geometry.attributes.position.array[h*3+2]-=(displacement.z*(1-objects[g].scale.z));
								scene.children[c].geometry.attributes.size.array[h]*=0.417777;
							}
							if (objects[g].scale.x>1.0){
								var indLayer=-1;
								for (var ref in generalLayout["outer"]){
									if (generalLayout["outer"].hasOwnProperty(ref)){
										indLayer =generalLayout["outer"][ref].indexOf(objects[g].name);
										//if (indLayer!=-1){}
									}
								}
								if (indLayer>-1){
									var lengthV = displacement.length();
									displacement.setLength(lengthV+((indLayer+0.5)*radiusComp));
									scene.children[c].geometry.attributes.position.array[h*3+0]+=(displacement.x);
									scene.children[c].geometry.attributes.position.array[h*3+1]+=(displacement.y+radiusComp/2);
									scene.children[c].geometry.attributes.position.array[h*3+2]+=(displacement.z);
									scene.children[c].geometry.attributes.size.array[h]/=0.417777;
								}
								
								
							}
						
						
					}
				}
			}
			scene.children[c].geometry.attributes.position.needsUpdate = true;
			scene.children[c].geometry.attributes.size.needsUpdate = true;
		}
		
		if (mtnlLayout["nodes_layout"]){
			var listDisplacedNodes = Object.keys(mtnlLayout["nodes_layout"]);
			if (listDisplacedNodes.length>0){
				//console.log(mtnlLayout["nodes_layout"])
				for(var i=0, ii= listDisplacedNodes.length;i<ii;i++){
					var typeNode=idMap[listDisplacedNodes[i]][0];
					var indexNode=idMap[listDisplacedNodes[i]][1];
					if (typeNode==2){
						scene.children[indexStartNodes].geometry.attributes.position.array[indexNode*3+0]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].x;
						scene.children[indexStartNodes].geometry.attributes.position.array[indexNode*3+1]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].y;
						scene.children[indexStartNodes].geometry.attributes.position.array[indexNode*3+2]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].z;
						
					}
					if (typeNode==4){
						scene.children[indexStartNodes+1].geometry.attributes.position.array[indexNode*3+0]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].x;
						scene.children[indexStartNodes+1].geometry.attributes.position.array[indexNode*3+1]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].y;
						scene.children[indexStartNodes+1].geometry.attributes.position.array[indexNode*3+2]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].z;
					}
				}
				scene.children[indexStartNodes].geometry.attributes.position.needsUpdate = true;
				scene.children[indexStartNodes+1].geometry.attributes.position.needsUpdate = true;
				//
				//
				//if (typeNode==2){console.log(""+2)}
				//if (typeNode==4){console.log(""+4)}
				//
				
			}
			//console.log("nodes layout")
			//
		}
		
		//console.log(metabolicNodes[9802])
		
		
		var iv=0;
		for ( var i = 0; i < segments; i ++ ) {
			var t1 = metabolicNodes[metabolicEdges[i][0]][6]
			var t2 = metabolicNodes[metabolicEdges[i][1]][6]
			//console.log(t1)
			//console.log(t2)
			//var ivList=[]
			var doIt=0
			if (t1==2){
				//console.log(idMap[jsonObj2[i][0]][1])
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
				
				iv++;
			}
			else if (t1==4){
				//console.log(idMap[jsonObj2[i][0]][1])
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
				iv++;
			}
			if (t2 ==2){
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
				iv++;
			}
			else if (t2 ==4){
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
				iv++;
			}
			
		}
		scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
		
		
		;(function($$){ 'use strict';
  
		  var defaults = {
			fit: true, // whether to fit the viewport to the graph
			ready: undefined, // callback on layoutready
			stop: undefined, // callback on layoutstop
			directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)
			padding: 30, // padding on fit
			circle: false, // put depths in concentric circles if true, put depths top down if false
			roots: undefined, // the roots of the trees
			maximalAdjustments: 0 // how many times to try to position the nodes in a maximal way (i.e. no backtracking)
		  };
		  
		  function BreadthFirstLayout2( options ){
			this.options = $$.util.extend({}, defaults, options);
		  }
		  
		  BreadthFirstLayout2.prototype.run = function(){
			var params = this.options;
			var options = params;
			
			var cy = params.cy;
			var nodes = cy.nodes();
			var edges = cy.edges();
			var graph = nodes.add(edges);
			var container = cy.container();
			
			var width = container.clientWidth;
			var height = container.clientHeight;

			var roots;
			if( $$.is.elementOrCollection(options.roots) ){
			  roots = options.roots;
			} else if( $$.is.array(options.roots) ){
			  var rootsArray = [];

			  for( var i = 0; i < options.roots.length; i++ ){
				var id = options.roots[i];
				var ele = cy.getElementById( id );
				rootsArray.push( ele );
			  }

			  roots = new $$.Collection( cy, rootsArray );
			} else if( $$.is.string(options.roots) ){
			  roots = cy.$( options.roots );

			} else {
			  if( options.directed ){
				roots = nodes.roots();
			  } else {
				var maxDegree = nodes.maxDegree( false );
				roots = nodes.filter(function(){
				  return this.degree() === maxDegree;
				});
			  }
			}


			var depths = [];
			var foundByBfs = {};
			var id2depth = {};

			// find the depths of the nodes
			graph.bfs(roots, function(i, depth){
			  var ele = this[0];

			  if( !depths[depth] ){
				depths[depth] = [];
			  }

			  depths[depth].push( ele );
			  foundByBfs[ ele.id() ] = true;
			  id2depth[ ele.id() ] = depth;
			}, options.directed);

			// check for nodes not found by bfs
			var orphanNodes = [];
			for( var i = 0; i < nodes.length; i++ ){
			  var ele = nodes[i];

			  if( foundByBfs[ ele.id() ] ){
				continue;
			  } else {
				orphanNodes.push( ele );
			  }
			}

			// assign orphan nodes a depth from their neighborhood
			var maxChecks = orphanNodes.length * 3;
			var checks = 0;
			while( orphanNodes.length !== 0 && checks < maxChecks ){
			  var node = orphanNodes.shift();
			  var neighbors = node.neighborhood().nodes();
			  var assignedDepth = false;

			  for( var i = 0; i < neighbors.length; i++ ){
				var depth = id2depth[ neighbors[i].id() ];

				if( depth !== undefined ){
				  depths[depth].push( node );
				  assignedDepth = true;
				  break;
				}
			  }

			  if( !assignedDepth ){
				orphanNodes.push( node );
			  }

			  checks++;
			}

			// assign orphan nodes that are still left to the depth of their subgraph
			while( orphanNodes.length !== 0 ){
			  var node = orphanNodes.shift();
			  //var subgraph = graph.bfs( node ).path;
			  var assignedDepth = false;

			  // for( var i = 0; i < subgraph.length; i++ ){
			  //   var depth = id2depth[ subgraph[i].id() ];

			  //   if( depth !== undefined ){
			  //     depths[depth].push( node );
			  //     assignedDepth = true;
			  //     break;
			  //   }
			  // }

			  if( !assignedDepth ){ // worst case if the graph really isn't tree friendly, then just dump it in 0
				if( depths.length === 0 ){
				  depths.push([]);
				}
				
				depths[0].push( node );
			  }
			}

			// assign the nodes a depth and index
			var assignDepthsToEles = function(){
			  for( var i = 0; i < depths.length; i++ ){
				var eles = depths[i];

				for( var j = 0; j < eles.length; j++ ){
				  var ele = eles[j];

				  ele._private.scratch.BreadthFirstLayout = {
					depth: i,
					index: j
				  };
				}
			  }
			};
			assignDepthsToEles();


			var intersectsDepth = function( node ){ // returns true if has edges pointing in from a higher depth
			  var edges = node.connectedEdges(function(){
				return this.data('target') === node.id();
			  });
			  var thisInfo = node._private.scratch.BreadthFirstLayout;
			  var highestDepthOfOther = 0;
			  var highestOther;
			  for( var i = 0; i < edges.length; i++ ){
				var edge = edges[i];
				var otherNode = edge.source()[0];
				var otherInfo = otherNode._private.scratch.BreadthFirstLayout;

				if( thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth ){
				  highestDepthOfOther = otherInfo.depth;
				  highestOther = otherNode;
				}
			  }

			  return highestOther;
			};

			 // make maximal if so set by adjusting depths
			for( var adj = 0; adj < options.maximalAdjustments; adj++ ){

			  var nDepths = depths.length;
			  var elesToMove = [];
			  for( var i = 0; i < nDepths; i++ ){
				var depth = depths[i];

				var nDepth = depth.length;
				for( var j = 0; j < nDepth; j++ ){
				  var ele = depth[j];
				  var info = ele._private.scratch.BreadthFirstLayout;
				  var intEle = intersectsDepth(ele);

				  if( intEle ){
					info.intEle = intEle;
					elesToMove.push( ele );
				  }
				}
			  }

			  for( var i = 0; i < elesToMove.length; i++ ){ 
				var ele = elesToMove[i];
				var info = ele._private.scratch.BreadthFirstLayout;
				var intEle = info.intEle;
				var intInfo = intEle._private.scratch.BreadthFirstLayout;

				depths[ info.depth ].splice( info.index, 1 ); // remove from old depth & index

				// add to end of new depth
				var newDepth = intInfo.depth + 1;
				while( newDepth > depths.length - 1 ){
				  depths.push([]);
				}
				depths[ newDepth ].push( ele );

				info.depth = newDepth;
				info.index = depths[newDepth].length - 1;
			  }

			  assignDepthsToEles();
			}

			// find min distance we need to leave between nodes
			var minDistance = 0;
			for( var i = 0; i < nodes.length; i++ ){
			  var w = nodes[i].outerWidth();
			  var h = nodes[i].outerHeight();
			  
			  minDistance = Math.max(minDistance, w, h);
			}
			minDistance *= 1.75; // just to have some nice spacing

			// get the weighted percent for an element based on its connectivity to other levels
			var cachedWeightedPercent = {};
			var getWeightedPercent = function( ele ){
			  if( cachedWeightedPercent[ ele.id() ] ){
				return cachedWeightedPercent[ ele.id() ];
			  }

			  var eleDepth = ele._private.scratch.BreadthFirstLayout.depth;
			  var neighbors = ele.neighborhood().nodes();
			  var percent = 0;
			  var samples = 0;

			  for( var i = 0; i < neighbors.length; i++ ){
				var neighbor = neighbors[i];
				var index = neighbor._private.scratch.BreadthFirstLayout.index;
				var depth = neighbor._private.scratch.BreadthFirstLayout.depth;
				var nDepth = depths[depth].length;

				if( eleDepth > depth || eleDepth === 0 ){ // only get influenced by elements above
				  percent += index / nDepth;
				  samples++;
				}
			  }

			  samples = Math.max(1, samples);
			  percent = percent / samples;

			  if( samples === 0 ){ // so lone nodes have a "don't care" state in sorting
				percent = undefined;
			  }

			  cachedWeightedPercent[ ele.id() ] = percent;
			  return percent;
			};


			// rearrange the indices in each depth level based on connectivity

			var sortFn = function(a, b){
			  var apct = getWeightedPercent( a );
			  var bpct = getWeightedPercent( b );

			  return apct - bpct;
			};

			for( var times = 0; times < 3; times++ ){ // do it a few times b/c the depths are dynamic and we want a more stable result

			  for( var i = 0; i < depths.length; i++ ){
				depths[i] = depths[i].sort( sortFn );
			  }
			  assignDepthsToEles(); // and update

			}

			var center = {
			  x: width/2,
			  y: height/2
			};
			nodes.positions(function(){
			  var ele = this[0];
			  var info = ele._private.scratch.BreadthFirstLayout;
			  var depth = info.depth;
			  var index = info.index;
			  var depthSize = depths[depth].length;

			  var distanceX = Math.max( width / (depthSize + 1), minDistance );
			  var distanceY = Math.max( height / (depths.length + 1), minDistance );
			  var radiusStepSize = Math.min( width / 2 / depths.length, height / 2 / depths.length );
			  radiusStepSize = Math.max( radiusStepSize, minDistance );

			  if( options.circle ){
				var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize/2 : 0);
				var theta = 2 * Math.PI / depths[depth].length * index;

				if( depth === 0 && depths[0].length === 1 ){
				  radius = 1;
				}

				return {
				  x: center.x + radius * Math.cos(theta),
				  y: center.y + radius * Math.sin(theta)
				};

			  } else {
				return {
				  x: center.x + (index + 1 - (depthSize + 1)/2) * distanceX*2,
				  y: (depths.length <= 6) ? (depth + 1) * distanceY: (depth + 1) * distanceY*6,
				};
			  }
			  
			});
			
			if( params.fit ){
			  cy.fit( options.padding );
			} 
			
			cy.one('layoutready', params.ready);
			cy.trigger('layoutready');
			
			cy.one('layoutstop', params.stop);
			cy.trigger('layoutstop');
		  };

		  BreadthFirstLayout2.prototype.stop = function(){
			// not a continuous layout
		  };
		  
		  $$('layout', 'breadthfirst2', BreadthFirstLayout2);
		  
		})( cytoscape );


		;(function($$){ 'use strict';
		  
		  var defaults = {
			fit: true, // whether to fit the viewport to the graph
			padding: 30, // padding used on fit
			rows: undefined, // force num of rows in the grid
			columns: undefined, // force num of cols in the grid
			position: function( node ){}, // returns { row, col } for element
			ready: undefined, // callback on layoutready
			stop: undefined // callback on layoutstop
		  };
		  
		  function GridLayout2( options ){
			this.options = $$.util.extend({}, defaults, options);
		  }
		  
		  GridLayout2.prototype.run = function(){
			var params = this.options;
			var options = params;
			
			var cy = params.cy;
			var nodes = cy.nodes();
			var container = cy.container();
			
			var width = container.clientWidth;
			var height = container.clientHeight;

			if( height === 0 || width === 0){
			  nodes.positions(function(){
				return { x: 0, y: 0 };
			  });
			  
			} else {
			  
			  // width/height * splits^2 = cells where splits is number of times to split width
			  var cells = nodes.size();
			  var splits = Math.sqrt( cells * height/width );
			  var rows = Math.round( splits );
			  var cols = Math.round( width/height * splits );

			  var small = function(val){
				if( val == null ){
				  return Math.min(rows, cols);
				} else {
				  var min = Math.min(rows, cols);
				  if( min == rows ){
					rows = val;
				  } else {
					cols = val;
				  }
				}
			  };
			  
			  var large = function(val){
				if( val == null ){
				  return Math.max(rows, cols);
				} else {
				  var max = Math.max(rows, cols);
				  if( max == rows ){
					rows = val;
				  } else {
					cols = val;
				  }
				}
			  };
			  
			  // if rows or columns were set in options, use those values
			  if( options.rows != null && options.columns != null ){
				rows = options.rows;
				cols = options.columns;
			  } else if( options.rows != null && options.columns == null ){
				rows = options.rows;
				cols = Math.ceil( cells / rows );
			  } else if( options.rows == null && options.columns != null ){
				cols = options.columns;
				rows = Math.ceil( cells / cols );
			  }
			  
			  // otherwise use the automatic values and adjust accordingly
			  
			  // if rounding was up, see if we can reduce rows or columns
			  else if( cols * rows > cells ){
				var sm = small();
				var lg = large();
				
				// reducing the small side takes away the most cells, so try it first
				if( (sm - 1) * lg >= cells ){
				  small(sm - 1);
				} else if( (lg - 1) * sm >= cells ){
				  large(lg - 1);
				} 
			  } else {
				
				// if rounding was too low, add rows or columns
				while( cols * rows < cells ){
				  var sm = small();
				  var lg = large();
				  
				  // try to add to larger side first (adds less in multiplication)
				  if( (lg + 1) * sm >= cells ){
					large(lg + 1);
				  } else {
					small(sm + 1);
				  }
				}
			  }
			  
			  var cellWidth = width / cols;
			  var cellHeight = height / rows;

			  for( var i = 0; i < nodes.length; i++ ){
				var node = nodes[i];
				var w = node.outerWidth();
				var h = node.outerHeight();

				cellWidth = Math.max( cellWidth, w );
				cellHeight = Math.max( cellHeight, h );
			  }
			  
			  var cellUsed = {}; // e.g. 'c-0-2' => true
			  
			  var used = function(row, col){
				return cellUsed['c-' + row + '-' + col] ? true : false;
			  };
			  
			  var use = function(row, col){
				cellUsed['c-' + row + '-' + col] = true;
			  };

			  // to keep track of current cell position
			  var row = 0;
			  var col = 0;
			  var moveToNextCell = function(){
				col++;
				if( col >= cols ){
				  col = 0;
				  row++;
				}
			  };

			  // get a cache of all the manual positions
			  var id2manPos = {};
			  for( var i = 0; i < nodes.length; i++ ){
				var node = nodes[i];
				var rcPos = options.position( node );

				if( rcPos && (rcPos.row !== undefined || rcPos.col !== undefined) ){ // must have at least row or col def'd
				  var pos = {
					row: rcPos.row,
					col: rcPos.col
				  };

				  if( pos.col === undefined ){ // find unused col
					pos.col = 0;

					while( used(pos.row, pos.col) ){
					  pos.col++;
					}
				  } else if( pos.row === undefined ){ // find unused row
					pos.row = 0;

					while( used(pos.row, pos.col) ){
					  pos.row++;
					}
				  }

				  id2manPos[ node.id() ] = pos;
				  use( pos.row, pos.col );
				}
			  }

			  nodes.positions(function(i, element){
				var x, y;

				if( element.locked() || element.isFullAutoParent() ){
				  return false;
				}

				// see if we have a manual position set
				var rcPos = id2manPos[ element.id() ];
				if( rcPos ){
				  x = rcPos.col * cellWidth + cellWidth/2;
				  y = rcPos.row * cellHeight + cellHeight/2;
				
				} else { // otherwise set automatically
				
				  while( used(row, col) ){
					moveToNextCell();
				  }

				  x = (cols <= 10) ? col * cellWidth + cellWidth/2 : col * cellWidth*4 + cellWidth/2;//col * cellWidth*4 + cellWidth/2; 
				  y = (rows <= 10) ? row * cellHeight + cellHeight/2 : row * cellHeight*4 + cellHeight/2;//row * cellHeight*4 + cellHeight/2;
				  use( row, col );
				  
				  moveToNextCell();
				}
				
				return { x: x, y: y };
				
			  });
			}
			
			if( params.fit ){
			  cy.fit( options.padding );
			} 
			
			cy.one('layoutready', params.ready);
			cy.trigger('layoutready');
			
			cy.one('layoutstop', params.stop);
			cy.trigger('layoutstop');
		  };

		  GridLayout2.prototype.stop = function(){
			// not a continuous layout
		  };
		  
		  $$('layout', 'grid2', GridLayout2);
		  
		})( cytoscape );

		
		
		// initialise cytoscape.js on a html dom element with some options:
		cy = cytoscape( options = {
		  container: document.getElementById('cy'),
		 
		  minZoom: 0.0,
		  maxZoom: 10,
		  pixelRatio: 1,
		  // style can be specified as plain JSON, a stylesheet string (probably a CSS-like
		  // file pulled from the server), or in a functional format
		  style: [
			{
			  selector: 'node',
			  css: {
				'content': 'data(name)',
				'shape': 'data[faveShape]',
				'background-color': 'data(faveColor)',
				'border-width': 1,
				//'font-family': 'helvetica',
				'font-size': 10,
				//'text-outline-width': 3,
				//'text-outline-color': '#888',
				//'text-valign': 'center',
				'color': '#61210B',
				//'width': 'mapData(weight, 30, 80, 20, 50)',
				//'height': 'mapData(height, 0, 200, 10, 45)',
				//'border-color': '#fff'
			  }
			},

			{
			  selector: 'node:selected',
			  css: {
				'background-color': '#5555ff',
				
				//'width': 4,
				
				//'text-outline-color': '#000'
			  }
			},
			{
			  selector: 'edge:selected',
			  css: {
				'background-color': '#5555ff',
				'line-color': '#5555ff',
				'width': 4,
				'target-arrow-color': '#5555ff',
				//'text-outline-color': '#000'
			  }
			},

			{
			  selector: 'edge',
			  css: {
				'width': 'data(faveWidth)',
				'line-color': 'data(faveColor)',
				'target-arrow-shape': 'data(faveShape)',
				'curve-style': 'unbundled-bezier',//'haystack',
				//'control-point-weight': 0.8,
				'target-arrow-color': 'data(faveColor)'
			  }
			}
		  ],

		  // specify the elements in the graph
		  elements: {
			nodes: [
			  //{ data: { id: 'e', name: 'e', nameid: 'ee',nameCp: 'eee',faveColor: '#ffffff', faveShape: 'circle'} },
			 //{ data: { id: 'f', name: 'f', nameid: 'ee',nameCp: 'eee',faveColor: '#ffffff', faveShape: 'rectangle'} }
			  //{ data: { id: 'e', name: 'Elaine', weight: 48, height: 160 } },
			 // { data: { id: 'k', name: 'Kramer', weight: 75, height: 185 } },
			  //{ data: { id: 'g', name: 'George', weight: 70, height: 150 } }
			],

			edges: [
			 //{ data: { source: 'e', target: 'f' ,faveColor: '#ffa500', faveShape: 'triangle', faveWidth: 2} }
			  //{ data: { source: 'j', target: 'k' } },
			  //{ data: { source: 'j', target: 'g' } },

			  //{ data: { source: 'e', target: 'j' } },
			 // { data: { source: 'e', target: 'k' } },

			  //{ data: { source: 'k', target: 'j' } },
			  //{ data: { source: 'k', target: 'e' } },
			  //{ data: { source: 'k', target: 'g' } },

			  //{ data: { source: 'g', target: 'j' } }
			],
		  },

		  
		  
		} );
		//cy.panningEnabled();

		cy.boxSelectionEnabled(true);
  
		var nodeClicked = cy.on('click', 'node', function(e) {
			// get json of graph
			// console.log(cy.elements().jsons())
			// load json of graph
			// cy.add( the json object of elements )
			
			//console.log(e.cyTarget._private.position)
			clearTimeout( timeout );
		   var timeout = setTimeout(function(){
			 //window["selectedNodes"] = cy.$('node:selected');

		   
			e.cyTarget._private.selected=true;
			for (elem in e.cyTarget._private.ids){
				if (e.cyTarget._private.ids.hasOwnProperty(elem)){
					var edgesFromNode = cy.elements('edge[source="'+elem+'"], edge[target = "'+elem+'"]');
					//console.log(edgesFromNode)
					edgesFromNode.select();
					
				}
			}
			
			  // and so on...
		   }, 1); // may have to adjust this val
			
			
			
			
		});
		
		
		
		
		var dataTempLayout=[];
		
		
		function changeDataElements(nameC){
			if (cy){
				var allElements = cy.elements();
				//var allEdges  = allElements.filter('edge');                
				//var allNodes = allElements.filter('node');
				cy.remove(allElements);
				var myelems=[];
				var idEdge=0;
				var listElem = dataTempLayout;
				//console.log(listElem)
				var idEdge=0;
				for (var nb=0, maxnb=listElem.length; nb<maxnb; nb++){
					//console.log(nb)
					if (listNodes[listElem[nb][0]] && listNodes[listElem[nb][0]][6]){
						//if (listNodes[listElem[nb][0]][6]==2){
						//	myelems.push({ group: "nodes", data: { id: listElem[nb][1], name: listElem[nb][1] ,faveColor: '#ffffff', faveShape: 'circle'} });
						//}
						
						if (listNodes[listElem[nb][0]][6]==4){
						
							myelems.push({ group: "nodes", data: { id: listElem[nb][1], name: listElem[nb][1] , nameid: listElem[nb][0],nameCp: nameC, faveColor: '#bbbbbb', faveShape: 'rectangle'} });
							if (listNodes[listElem[nb][0]][11]){
								if (listNodes[listElem[nb][0]][11][0]){
								//console.log("a")
									// reactants
									for (var i=0; i<listNodes[listElem[nb][0]][11][0].length; i++){
										if (listNodes[listNodes[listElem[nb][0]][11][0][i]][3]==nameC){
											myelems.push({ group: "nodes", data: { id: listNodes[listNodes[listElem[nb][0]][11][0][i]][1], name: listNodes[listNodes[listElem[nb][0]][11][0][i]][1], nameid: listNodes[listNodes[listElem[nb][0]][11][0][i]][0],nameCp: nameC,faveColor: '#ffffff', faveShape: 'circle'} });
											myelems.push({ group: "edges", data: { id: "e"+idEdge, source: listNodes[listNodes[listElem[nb][0]][11][0][i]][1], target: listElem[nb][1] ,faveColor: '#ffa500', faveShape: 'triangle', faveWidth: 2} });
											idEdge++;
										}
									}
								}
								// products
								if (listNodes[listElem[nb][0]][11][1]){
									for (var i=0; i<listNodes[listElem[nb][0]][11][1].length; i++){
										if (listNodes[listNodes[listElem[nb][0]][11][1][i]][3]==nameC){
											myelems.push({ group: "nodes", data: { id: listNodes[listNodes[listElem[nb][0]][11][1][i]][1], name: listNodes[listNodes[listElem[nb][0]][11][1][i]][1], nameid: listNodes[listNodes[listElem[nb][0]][11][1][i]][0] ,nameCp: nameC,faveColor: '#ffffff', faveShape: 'circle'} });
											myelems.push({ group: "edges", data: { id: "e"+idEdge, source: listElem[nb][1], target: listNodes[listNodes[listElem[nb][0]][11][1][i]][1],faveColor: '#008000', faveShape: 'triangle', faveWidth: 2} });
											idEdge++;
										}
									}
								}
								// modifiers
								if (listNodes[listElem[nb][0]][11][2]){
								//console.log("a")
									for (var i=0; i<listNodes[listElem[nb][0]][11][2].length; i++){
										if (listNodes[listNodes[listElem[nb][0]][11][2][i]][3]==nameC){
											myelems.push({ group: "nodes", data: { id: listNodes[listNodes[listElem[nb][0]][11][2][i]][1], name: listNodes[listNodes[listElem[nb][0]][11][2][i]][1], nameid: listNodes[listNodes[listElem[nb][0]][11][2][i]][0] ,nameCp: nameC,faveColor: '#ffffff', faveShape: 'circle'} });
											myelems.push({ group: "edges", data: { id: "e"+idEdge, source: listNodes[listNodes[listElem[nb][0]][11][2][i]][1], target: listElem[nb][1] ,faveColor: '#800080', faveShape: 'triangle', faveWidth: 2} });
											idEdge++;
										}
									}
								}
							}
						}
					}
					
					// if (placesTypesListPerTransition[listElem[nb]] ){
						// if (placesTypesListPerTransition[listElem[nb]].hasOwnProperty('activators')){
							// for(var i=0, j=placesTypesListPerTransition[listElem[nb]]['activators'].length; i<j;i++){
								// myelems.push({ group: "nodes", data: { id: placesTypesListPerTransition[listElem[nb]]['activators'][i], name: placesTypesListPerTransition[listElem[nb]]['activators'][i] ,faveColor: '#ffffff', faveShape: 'circle'} });
								// myelems.push({ group: "edges", data: { id: "e"+idEdge, source: placesTypesListPerTransition[listElem[nb]]['activators'][i], target: listElem[nb] ,faveColor: '#000000', faveShape: 'circle', faveWidth: 2} });
								// idEdge++;
							// }
						// }
						// if (placesTypesListPerTransition[listElem[nb]].hasOwnProperty('suppressors')){
							// for(var i=0, j=placesTypesListPerTransition[listElem[nb]]['suppressors'].length; i<j;i++){
								// myelems.push({ group: "nodes", data: { id: placesTypesListPerTransition[listElem[nb]]['suppressors'][i], name: placesTypesListPerTransition[listElem[nb]]['suppressors'][i] ,faveColor: '#ffffff', faveShape: 'circle'} });
								// myelems.push({ group: "edges", data: { id: "e"+idEdge, source: placesTypesListPerTransition[listElem[nb]]['suppressors'][i], target: listElem[nb] ,faveColor: '#000000', faveShape: 'tee', faveWidth: 2} });
								// idEdge++;
							// }
						// }
						// if (placesTypesListPerTransition[listElem[nb]].hasOwnProperty('consumed')){
							// for(var i=0, j=placesTypesListPerTransition[listElem[nb]]['consumed'].length; i<j;i++){
								// myelems.push({ group: "nodes", data: { id: placesTypesListPerTransition[listElem[nb]]['consumed'][i], name: placesTypesListPerTransition[listElem[nb]]['consumed'][i],faveColor: '#ffffff', faveShape: 'circle' } });
								// myelems.push({ group: "edges", data: { id: "e"+idEdge, source: placesTypesListPerTransition[listElem[nb]]['consumed'][i], target: listElem[nb],faveColor: '#000000' , faveShape: 'triangle', faveWidth: 2} });
								// idEdge++;
							// }
						// }
						// if (placesTypesListPerTransition[listElem[nb]].hasOwnProperty('postplaces')){
							// for(var i=0, j=placesTypesListPerTransition[listElem[nb]]['postplaces'].length; i<j;i++){
								// myelems.push({ group: "nodes", data: { id: placesTypesListPerTransition[listElem[nb]]['postplaces'][i], name: placesTypesListPerTransition[listElem[nb]]['postplaces'][i],faveColor: '#ffffff', faveShape: 'circle' } });
								// myelems.push({ group: "edges", data: { id: "e"+idEdge, source: listElem[nb], target: placesTypesListPerTransition[listElem[nb]]['postplaces'][i] ,faveColor: '#000000', faveShape: 'triangle', faveWidth: 2} });
								// idEdge++;
							// }
						// }
					// }
				}
				cy.add( myelems);
				
				
			var el =document.getElementById("selectLayout");
			if (parseInt(el.value)==0){
					var options = {
						name: 'breadthfirst2',

						fit: true, // whether to fit the viewport to the graph
						ready: undefined, // callback on layoutready
						stop: undefined, // callback on layoutstop
						directed: true, // whether the tree is directed downwards (or edges can point in any direction if false)
						pan: true, 
						textureOnViewport: false,
						padding: 30, // padding on fit
						circle: false, // put depths in concentric circles if true, put depths top down if false
						roots: undefined, // the roots of the trees
						maximalAdjustments: 5 // how many times to try to position the nodes in a maximal way (i.e. no backtracking)
					};
					
			}
			else if (parseInt(el.value)==1){
					var options = {
						name: 'breadthfirst2',

						fit: true, // whether to fit the viewport to the graph
						ready: undefined, // callback on layoutready
						stop: undefined, // callback on layoutstop
						directed: true, // whether the tree is directed downwards (or edges can point in any direction if false)
						pan: true, 
						textureOnViewport: false,
						padding: 30, // padding on fit
						circle: false, // put depths in concentric circles if true, put depths top down if false
						roots: undefined, // the roots of the trees
						maximalAdjustments: 5 // how many times to try to position the nodes in a maximal way (i.e. no backtracking)
					};
					
			}
			else if (parseInt(el.value)==2){
					var options = {
						name: 'circle',

						fit: true, // whether to fit the viewport to the graph
						ready: undefined, // callback on layoutready
						stop: undefined, // callback on layoutstop
						rStepSize: 10, // the step size for increasing the radius if the nodes don't fit on screen
						padding: 30, // the padding on fit
						startAngle: 3/2 * Math.PI, // the position of the first node
						counterclockwise: false // whether the layout should go counterclockwise (true) or clockwise (false)
					};
					
			}
			else if (parseInt(el.value)==3){
					var options = {
						name: 'concentric',

						fit: true, // whether to fit the viewport to the graph
						ready: undefined, // callback on layoutready
						stop: undefined, // callback on layoutstop
						padding: 30, // the padding on fit
						startAngle: 3/2 * Math.PI, // the position of the first node
						counterclockwise: false, // whether the layout should go counterclockwise (true) or clockwise (false)
						minNodeSpacing: 60, // min spacing between outside of nodes (used for radius adjustment)
						height: undefined, // height of layout area (overrides container height)
						width: undefined, // width of layout area (overrides container width)
						concentric: function(){ // returns numeric value for each node, placing higher nodes in levels towards the centre
							//console.log(this._private.data['faveShape'])
							var val =0;
							if (this._private.data['faveShape']=="rectangle"){
								val =10;
							}
						  return val;
						},
						levelWidth: function(nodes){ // the variation of concentric values in each level
						  return 0.5//nodes.maxDegree() / 4;
						}
					}
					
			}
			else if (parseInt(el.value)==4){
					var options = {
						name: 'grid2',

						fit: true, // whether to fit the viewport to the graph
						padding: 30, // padding used on fit
						rows: undefined, // force num of rows in the grid
						columns: undefined, // force num of cols in the grid
						position: function( node ){}, // returns { row, col } for element
						ready: undefined, // callback on layoutready
						stop: undefined // callback on layoutstop
					};
					
			}
			//console.log(el.value)	

				cy.layout( options );
			}
		}
		
		
		
		
		
		function runCompSelector(){
			//console.log(tempdata3);
			var nameComp =document.getElementById("compSelector").value;
			dataTempLayout=[];
			if (nameComp!="none"){
				
				//console.log(tempdata3)
				//for (var i=0, j=tempdata2.length; i<j; i++){
				//	if (tempdata2[i][2]== compIds[parseInt(nameComp)] ){
				//		dataTempLayout.push(tempdata2[i]);
				//	}
				//}
				for (var i=0, j=tempdata3.length; i<j; i++){
					if (tempdata3[i][2]== compIds[parseInt(nameComp)] ){
						dataTempLayout.push(tempdata3[i]);
					}
				}
				
			}
			//console.log(dataTempLayout)
			changeDataElements(compIds[parseInt(nameComp)]);
			//var mcy = $("#cy").cytoscape("get");
			for (var i=0, j=mtnlLayout["currency_nodes"].length; i<j;i++){
				//console.log(listNodes[mtnlLayout["currency_nodes"][i]][1])
				cy.$('#'+listNodes[mtnlLayout["currency_nodes"][i]][1]).style('display','none');
				//console.log(mcy.$('#'+listNodes[mtnlLayout["currency_nodes"][i]][1]))
				//console.log(mcy.nodes('#'+mtnlLayout["currency_nodes"][i]));
			}
			if (parseInt(document.getElementById("selectLayout").value)==0){
				cy.nodes().positions(function( i, node ){
					//console.log(node['_private']['data']['nameCp'])
					var nameidnode= node['_private']['data']['nameid'];
					if (mtnlLayout["nodes_layout"] && mtnlLayout["nodes_layout"][nameidnode]){
						return {
							x: -mtnlLayout["nodes_layout"][nameidnode].x,
							y: -mtnlLayout["nodes_layout"][nameidnode].z
						  };
					}else {
						return {
							x: 0,
							y: 0
						  };
					}
				  
				});
				
				cy.fit(30);
			}
		}
		
		
		
		
		
		
		
		function selectValue(el){
			if (parseInt(el.value)==0){
				//var options = {
				//	name: 'null',

					//fit: true, // whether to fit the viewport to the graph
					//ready: undefined, // callback on layoutready
					//stop: undefined, // callback on layoutstop
					//directed: true, // whether the tree is directed downwards (or edges can point in any direction if false)
					//pan: true, 
					//textureOnViewport: false,
					//padding: 30, // padding on fit
					//circle: false, // put depths in concentric circles if true, put depths top down if false
					//roots: undefined, // the roots of the trees
					//maximalAdjustments: 5 // how many times to try to position the nodes in a maximal way (i.e. no backtracking)
				//};
				//cy.layout( null );
				
				// if (mtnlLayout["nodes_layout"]){
					// var listDisplacedNodes = Object.keys(mtnlLayout["nodes_layout"]);
					// if (listDisplacedNodes.length>0){
						// //console.log(mtnlLayout["nodes_layout"])
						// for(var i=0, ii= listDisplacedNodes.length;i<ii;i++){
							// var typeNode=idMap[listDisplacedNodes[i]][0];
							// var indexNode=idMap[listDisplacedNodes[i]][1];
							// if (typeNode==2){
								// scene.children[indexStartNodes].geometry.attributes.position.array[indexNode*3+0]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].x;
								// scene.children[indexStartNodes].geometry.attributes.position.array[indexNode*3+1]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].y;
								// scene.children[indexStartNodes].geometry.attributes.position.array[indexNode*3+2]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].z;
								
							// }
							// if (typeNode==4){
								// scene.children[indexStartNodes+1].geometry.attributes.position.array[indexNode*3+0]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].x;
								// scene.children[indexStartNodes+1].geometry.attributes.position.array[indexNode*3+1]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].y;
								// scene.children[indexStartNodes+1].geometry.attributes.position.array[indexNode*3+2]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].z;
							// }
						// }
						// scene.children[indexStartNodes].geometry.attributes.position.needsUpdate = true;
						// scene.children[indexStartNodes+1].geometry.attributes.position.needsUpdate = true;
						// //
						// //
						// //if (typeNode==2){console.log(""+2)}
						// //if (typeNode==4){console.log(""+4)}
						// //
						
					// }
					// //console.log("nodes layout")
					// //
				// }
				
				
				
				cy.nodes().positions(function( i, node ){
					//console.log(node['_private']['data']['nameCp'])
					var nameidnode= node['_private']['data']['nameid'];
					if (mtnlLayout["nodes_layout"] && mtnlLayout["nodes_layout"][nameidnode]){
						return {
							x: -mtnlLayout["nodes_layout"][nameidnode].x,
							y: -mtnlLayout["nodes_layout"][nameidnode].z
						  };
					}else {
						return {
							x: 0,
							y: 0
						  };
					}
				  
				});
				
				cy.fit(30);
				
				
				
			}
			else if (parseInt(el.value)==1){
				var options = {
					name: 'breadthfirst2',

					fit: true, // whether to fit the viewport to the graph
					ready: undefined, // callback on layoutready
					stop: undefined, // callback on layoutstop
					directed: true, // whether the tree is directed downwards (or edges can point in any direction if false)
					pan: true, 
					textureOnViewport: false,
					padding: 30, // padding on fit
					circle: false, // put depths in concentric circles if true, put depths top down if false
					roots: undefined, // the roots of the trees
					maximalAdjustments: 5 // how many times to try to position the nodes in a maximal way (i.e. no backtracking)
				};
				cy.layout( options );
				cy.fit(30);
			}
			else if (parseInt(el.value)==2){
				var options = {
					name: 'circle',

					fit: true, // whether to fit the viewport to the graph
					ready: undefined, // callback on layoutready
					stop: undefined, // callback on layoutstop
					rStepSize: 10, // the step size for increasing the radius if the nodes don't fit on screen
					padding: 30, // the padding on fit
					startAngle: 3/2 * Math.PI, // the position of the first node
					counterclockwise: false // whether the layout should go counterclockwise (true) or clockwise (false)
				};
				cy.layout( options );
				cy.fit(30);
			}
			else if (parseInt(el.value)==3){
				var options = {
					name: 'concentric',

					fit: true, // whether to fit the viewport to the graph
					ready: undefined, // callback on layoutready
					stop: undefined, // callback on layoutstop
					padding: 30, // the padding on fit
					startAngle: 3/2 * Math.PI, // the position of the first node
					counterclockwise: false, // whether the layout should go counterclockwise (true) or clockwise (false)
					minNodeSpacing: 60, // min spacing between outside of nodes (used for radius adjustment)
					height: undefined, // height of layout area (overrides container height)
					width: undefined, // width of layout area (overrides container width)
					concentric: function(){ // returns numeric value for each node, placing higher nodes in levels towards the centre
						//console.log(this._private.data['faveShape'])
						var val =0;
						if (this._private.data['faveShape']=="rectangle"){
							val =10;
						}
					  return val;
					},
					levelWidth: function(nodes){ // the variation of concentric values in each level
					  return 0.5//nodes.maxDegree() / 4;
					}
				}
				cy.layout( options );
				cy.fit(30);
			}
			else if (parseInt(el.value)==4){
				var options = {
					name: 'grid2',

					fit: true, // whether to fit the viewport to the graph
					padding: 30, // padding used on fit
					rows: undefined, // force num of rows in the grid
					columns: undefined, // force num of cols in the grid
					position: function( node ){}, // returns { row, col } for element
					ready: undefined, // callback on layoutready
					stop: undefined // callback on layoutstop
				};
				cy.layout( options );
				cy.fit(30);
			}
			else{
				var allElements = cy.elements();
				cy.remove(allElements);
				cy.add( layoutJSON[el.value] )
				cy.fit(30)
			}
			
		}
		
		function updateLayout(){
			//console.log("update coordinates")
			//console.log(cy.extent());
			//console.log(cy.boundingBox())
			//console.log(cy.extent())
			var boundingBox=cy.extent();//cy.boundingBox();
			var boundWidth=boundingBox['w'];
			var boundHeight=boundingBox['h'];
			var centerBoundX=(boundingBox['x2']+boundingBox['x1'])/2.0
			var centerBoundY=(boundingBox['y2']+boundingBox['y1'])/2.0
			var scalingFactor= ((radiusComp*2)*0.9) / Math.max(boundWidth, boundWidth) ;
			if (cy.nodes()){
				var allElements = cy.nodes();
				for (var el in allElements){
					if (allElements.hasOwnProperty(el) && allElements[el]['_private']){
						
						//console.log(allElements[el]['_private']['data']['nameid']);
						//console.log(idMap[allElements[el]['_private']['data']['nameid']]);
						//console.log(allElements[el]['_private']['data']['nameCp']);
						// position compartment:
						var posComp = new THREE.Vector3();
						var nComp= allElements[el]['_private']['data']['nameCp'];
						var scalecomp=1.0;
						for ( var i = 0; i < listCompartments.length; i ++ ) {
							if (objects[i].name.split(" ")[0]==nComp){
								posComp.x=objects[i].position.x;
								posComp.y=objects[i].position.y;
								posComp.z=objects[i].position.z;
								scalecomp=objects[i].scale.x;
							}
						}
						
						//console.log(posComp)
						var ind= idMap[allElements[el]['_private']['data']['nameid']];
						if (ind[0]==2){
							scene.children[indexStartNodes].geometry.attributes.position.array[ind[1]*3+0]=posComp.x-((allElements[el]['_private']['position']['x']-centerBoundX)*scalingFactor*scalecomp);
							scene.children[indexStartNodes].geometry.attributes.position.array[ind[1]*3+1]=posComp.y;
							scene.children[indexStartNodes].geometry.attributes.position.array[ind[1]*3+2]=posComp.z-((allElements[el]['_private']['position']['y']-centerBoundY)*scalingFactor*scalecomp);
							mtnlLayout["nodes_layout"][allElements[el]['_private']['data']['nameid']]=new THREE.Vector3(scene.children[indexStartNodes].geometry.attributes.position.array[ind[1]*3+0],scene.children[indexStartNodes].geometry.attributes.position.array[ind[1]*3+1],scene.children[indexStartNodes].geometry.attributes.position.array[ind[1]*3+2]);
						}
						else if (ind[0]==4){
							scene.children[indexStartNodes+1].geometry.attributes.position.array[ind[1]*3+0]=posComp.x-((allElements[el]['_private']['position']['x']-centerBoundX)*scalingFactor*scalecomp);
							scene.children[indexStartNodes+1].geometry.attributes.position.array[ind[1]*3+1]=posComp.y;
							scene.children[indexStartNodes+1].geometry.attributes.position.array[ind[1]*3+2]=posComp.z-((allElements[el]['_private']['position']['y']-centerBoundY)*scalingFactor*scalecomp);
							mtnlLayout["nodes_layout"][allElements[el]['_private']['data']['nameid']]=new THREE.Vector3(scene.children[indexStartNodes+1].geometry.attributes.position.array[ind[1]*3+0],scene.children[indexStartNodes+1].geometry.attributes.position.array[ind[1]*3+1],scene.children[indexStartNodes+1].geometry.attributes.position.array[ind[1]*3+2]);
						}
						//console.log((allElements[el]['_private']['position']['x']-centerBoundX)*scalingFactor)
						//console.log((allElements[el]['_private']['position']['y']-centerBoundY)*scalingFactor)
						
					}
				}
				//console.log(mtnlLayout["nodes_layout"])
				scene.children[indexStartNodes].geometry.attributes.position.needsUpdate = true;
				scene.children[indexStartNodes+1].geometry.attributes.position.needsUpdate = true;
				var iv=0;
				for ( var i = 0; i < segments; i ++ ) {
					var t1 = metabolicNodes[metabolicEdges[i][0]][6]
					var t2 = metabolicNodes[metabolicEdges[i][1]][6]
					//console.log(t1)
					//console.log(t2)
					//var ivList=[]
					var doIt=0
					if (t1==2){
						//console.log(idMap[jsonObj2[i][0]][1])
						scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
						scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
						scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
						
						iv++;
					}
					else if (t1==4){
						//console.log(idMap[jsonObj2[i][0]][1])
						scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
						scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
						scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
						iv++;
					}
					if (t2 ==2){
						scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
						scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
						scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
						iv++;
					}
					else if (t2 ==4){
						scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
						scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
						scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
						iv++;
					}
					
				}
				scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
			}
			saveLayout();
			//console.log(allElements)
		}
		
		//cy.on('free', function (e) {
		//	cy.boundingBox();
		//});
		
		function unique(a){
			var arr = [];
			for (var i=0;i<a.length;i++){
				if ( arr.indexOf(a[i]) == -1){
					arr.push(a[i]);
				}
			}
			return arr
		}
		
		// mute 3d and 2d graph nodes and lines corresponding to selected currency nodes
		var indexStartNodes=maxNbComp+3;
		for (var i=0, j=mtnlLayout["currency_nodes"].length; i<j;i++){
			var identifier=mtnlLayout["currency_nodes"][i];
			var typeNode=idMap[identifier][0];
			var indexNode=idMap[identifier][1];
			// //console.log(typeNode+' '+indexNode)
			 if (typeNode==2){
				scene.children[indexStartNodes].geometry.attributes.size.array[indexNode]=0;					
				// scene.children[indexStartNodes].geometry.attributes.position.array[indexNode*3+0]+=5000000;
				// scene.children[indexStartNodes].geometry.attributes.position.array[indexNode*3+1]+=5000000;
				// scene.children[indexStartNodes].geometry.attributes.position.array[indexNode*3+2]+=5000000;
			}
			scene.children[indexStartNodes].geometry.attributes.size.needsUpdate = true;
			for (var i=0; i<metabolicEdges.length;i++){
				if (metabolicEdges[i][0]==identifier){
					selectedLinesPaths.push(i)
					//txtListLinks += '<li >'+jsonObj1[jsonObj2[i][1]][2]+'</li>';
					//nbS+=1;
				}
				if (metabolicEdges[i][1]==identifier){
					selectedLinesPaths.push(i)
					//txtListLinks += '<li >'+jsonObj1[jsonObj2[i][0]][2]+'</li>';
					//nbS+=1;
				}
			}
		
			
		}
		// //console.log(selectedLinesPaths)
		// for (var i=0; i<selectedLinesPathsIds.length;i++){
			// scene.children[indexStartNodes+2].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] -=5000000;
		// }
		selectedLinesPathsIds=[]
		for (var i=0; i<selectedLinesPaths.length;i++){
			for (var j=0;j<linesMap[selectedLinesPaths[i]].length;j+=1){
				selectedLinesPathsIds.push(linesMap[selectedLinesPaths[i]][j])
			}
		}
		selectedLinesPathsIds = unique(selectedLinesPathsIds)
		//console.log(selectedLinesPathsIds)
		for (var i=0;i<selectedLinesPathsIds.length;i+=1){
			scene.children[indexStartNodes+2].geometry.attributes.position.array[ ((selectedLinesPathsIds[i])* 3) + 2 ] +=5000000;
		}
		scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
		
	
	</script>	
	
	
	
	
