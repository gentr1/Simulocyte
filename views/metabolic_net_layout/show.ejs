<div class='container'>
<br><br>
	<h1>Metabolic Network Layout </h1>
	<hr>
	<h2>Name: <%= mtnl.name %> </h2>
	<hr>
	<h2>Comment: </h2>
	<%= mtnl.comment %>
	<h2>Metabolic network: </h2>
	<%= mtnl.metabolic_net %>
	<%
	var allLayout=JSON.stringify({});
	%>
	<% if (session.User.name==mtnl.owner) {%>
	<hr>
	<a href="/metabolic_net_layout/editusers/<%=mtnl.id%>" class="btn btn-sm btn-success">Edit/View list of users privileges</a>
	<%}%>
	<hr>
	<h3 id="titleComp" style="position: absolute;left: 20px;">Edit/Add New Compartments:</h3>
	<div id="compTable" style="position: absolute;left: 20px;"></div>
	<br>	
	<br>
	
	<div id="searchfield" style="position: absolute;left: 20px;"><h3>Edit Metabolites Nodes Compartments:</h3><br>Search Term: <input id="searchgrid" type="text" /></div>
	<br>
	<div id="mtnTable" style="position: absolute;left: 20px;"></div>	
	<br>
	<div id="searchfield2" style="position: absolute;left: 20px;"><h3>Edit Reaction Nodes Compartments:</h3><br>Search Term: <input id="searchgrid2" type="text" /></div>
	<br>
	<div id="mtnTable2" style="position: absolute;left: 20px;height: 300px; overflow: scroll"></div>	
	<br>
	<h3 id="titleEditor" style="position: absolute;left: 20px;">Layout Editor:  
	<select id="modeSelector" onchange="runModeSelector()">
  <option value="0">for compartments</option>
  <option value="1">for nodes</option>
	</select>
	
	</h3>
	
	<div id="container"  style="position: absolute;left: 0px; overflow: inherit">  </div>
	<input type="image" id ="editplane" src="/images/editplane1.png" value="0" width="32" height="32" style="position: absolute;left: 0px; overflow: inherit" onclick="changeEditingPlane()">
	<div id="container2"  style="position: absolute;left: 0px; overflow: inherit">  </div>
	<div id="layout1menu" class="btn-group-vertical" role="group" aria-label="..." style="position: absolute;left: 0px;">
		<button class="btn btn-default btn-xs" title="Merge" id="b_merge" style="position: relative;left: 20px;">Merge</button>
		<button class="btn btn-default btn-xs" title="Stack above" id="b_above" style="position: relative;left: 20px;">Place Above</button>
		<button class="btn btn-default btn-xs" title="Stack below" id="b_below" style="position: relative;left: 20px;">Place Below</button>
		<button class="btn btn-default btn-xs" title="Add as Inner Circle" id="b_inner" style="position: relative;left: 20px;">Add as Inner</button>
		<button class="btn btn-default btn-xs" title="Add as Outer Circle" id="b_outer" style="position: relative;left: 20px;">Add as Outer</button>
		<button class="btn btn-default btn-xs" title="Add as Satellite" id="b_satellite" style="position: relative;left: 20px;">Add as Satellite</button>
		<button class="btn btn-default btn-xs" title="Add as Subset" id="b_subset" style="position: relative;left: 20px;">Add as Subset</button>
		<button class="btn btn-warning btn-xs" title="Cancel" id="b_cancel" style="position: relative;left: 20px;">Cancel</button>
	</div>
	
<form action="/metabolic_net_layout/update/<%= mtnl.id %>" id="mtnl-update-form"  method="POST" style="left:0px;height:5%;width:40%;position: absolute;">	
	<input type="text" name="layouts0" id ="layouts0" style="visibility: hidden;" value=<%=allLayout%>>
	<input type="text"  name="layouts1" id ="layouts1" style="visibility: hidden;" value="">
	<input type="text"  name="layouts2" id ="layouts2" style="visibility: hidden;" value="">
	<input type="text"  name="layouts3" id ="layouts3" style="visibility: hidden;" value="">
	<input type="text"  name="layouts4" id ="layouts4" style="visibility: hidden;" value="">
	<input type="text"  name="layouts5" id ="layouts5" style="visibility: hidden;" value="">
	<input type="text"  name="layouts6" id ="layouts6" style="visibility: hidden;" value="">
	<input type="text"  name="layouts7" id ="layouts7" style="visibility: hidden;" value="">
	<input type="text"  name="layouts8" id ="layouts8" style="visibility: hidden;" value="">
	<input type="text"  name="layouts9" id ="layouts9" style="visibility: hidden;" value="">
	<input type="submit" value="Save" class="btn btn-lg btn-primary btn-block"  style="top:0px;left:0px;position: relative;"/>
	<input type="hidden" name="_csrf" value="<%= _csrf %>" />
	</form>			
</div>	

<nav>
		<a href="" id="menuToggle" title="show menu">
		<span class="navClosed"><i>show menu</i></span>
		</a>
		<a href="#" title="Item 1">Hide/Show</a>		
		<br><p style="position: relative;left: 20px;color:white">Line Opacity: <input id="defaultSlider" type="range" min="0.0" max="20.0" value="15" step="0.005" onchange="updateSlider(this.value)" style="position: relative;left: 20px"/></p>			
	</nav>
	
	<div id="menu" >
	
	
	</div>

	<script id="fragmentShader" type="x-shader/x-fragment">
			
			varying vec2 vUv;

			#define FB_ZOOM 0.075
			#define BEAM_WIDTH 0.0005

			void main(void)
			{
				float t = 0.0;
				float intensity = BEAM_WIDTH;
				vec2 unit = vec2(cos(t), sin(t));
				float aspect = 0.5;
				vec2 position = vUv;
				//position.y *= resolution.y / resolution.x;
				vec2 ms = vec2(0.5, 0.5);
				//ms.y *= resolution.y / resolution.x;
				vec2 uv = ((gl_FragCoord.xy ) - vec2(0.5)) * FB_ZOOM + vec2(0.5);
				float f = 0.0;

				f += intensity / abs(dot(position - ms, unit));
				f += intensity / abs(dot(position - ms, vec2(unit.y, -unit.x)));
				f += intensity / abs(dot(position - ms, vec2(2.0*ms.x, -unit.x)));
				f += intensity / abs(dot(position - ms, vec2(-2.0*ms.x, -unit.x)));
				f += intensity / abs(0.3 - length(position - ms));
				f += intensity / abs(0.2 - length(position - ms));
				f += intensity / abs(0.1 - length(position - ms));
				
				gl_FragColor = vec4(f * 1.0, f * 0.0, f * 0., 0.3);
			}

	</script>
	
	<script id="vertexShader" type="x-shader/x-vertex">

			varying vec2 vUv;

			void main()
			{
				vUv = uv;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
			}

		</script>
	
	
	<script type="x-shader/x-vertex" id="vertexshaderP1">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP1">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderP2">

			attribute float size;
			attribute vec3 ca;
			varying vec3 vColor;
			attribute float customVisible;
			void main() {
				vColor = ca;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );				
				//gl_PointSize = size;
				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderP2">

			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}

		</script>
		
		<script type="x-shader/x-vertex" id="vertexshaderL1">
			attribute vec3 ca;
			varying vec3 vColor;
			varying float opacity;
			attribute float op;
			void main() {
				vColor = ca;
				opacity =op;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
		</script>

		<script type="x-shader/x-fragment" id="fragmentshaderL1">
			uniform vec3 color;
			varying float opacity;
			varying vec3 vColor;
			void main() {

				gl_FragColor = vec4( vColor * color, opacity );

			}
		</script>
	
	
	<script>
	
	(function($){
		$(document).ready(function(){
		$('#menuToggle').click(function(e){
		var $parent = $(this).parent('nav');
		$parent.toggleClass("open");
		var navState = $parent.hasClass('open') ? "hide" : "show";
		$(this).attr("title", navState + " navigation");
		// Set the timeout to the animation length in the CSS.
		setTimeout(function(){
		//console.log("timeout set");
		$('#menuToggle > span').toggleClass("navClosed").toggleClass("navOpen");
		}, 200);
		e.preventDefault();
		});
		});
	})(jQuery);
	
	if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
	
	$('#layout1menu').hide();
	$('#layout1menu').zIndex(2000);
	
	var mtnlLayout = <%-JSON.stringify(mtnl.layout)%>
	//console.log(mtnlLayout)
	
	var generalLayout ={'merged':{},'above':{},'outer':{},'satellite':{},'in':{}};
	var stopThreeJsMouseEvent = false;	
	var initialPos=new THREE.Vector3( 0, 0, 0 );
	var initialName="";
	var spacing=1650;
	var radiusComp=550;
	var yStartDisplacement=100;
	var nodeSize=5;
	var lineOpacity=0.1;
	var closest;
	var selectedMetabolicData = <%-JSON.stringify(mtb.file)%>
	//console.log("getting metabolic data from default file recon2");
	//if (mtnlLayout["list_compartments"])
	
	var listCompartments=[];
	
	if (mtnlLayout["list_compartments"] && mtnlLayout["list_compartments"].length==0){
		listCompartments=selectedMetabolicData[0];
		
		//console.log("initial empty list of compartments")
	}
	else if (mtnlLayout["list_compartments"] && mtnlLayout["list_compartments"].length>0){
		listCompartments=mtnlLayout["list_compartments"];
		//console.log("initial existing list of compartments")
	}
	mtnlLayout["list_compartments"]=listCompartments;
	
	//console.log(listCompartments)
	var nbCompartments=listCompartments.length
	var compIds=[];
	for (var i=0; i<listCompartments.length;i++){
		compIds.push(listCompartments[i][0]);
	}
	
	var txtComp=[]
	var maxNbComp=20;
	var stackCompToMove=[];
	var stackCompInitialPos={};
	var positionContainer;
	var text1 = document.createElement('div');
	text1.style.position = 'absolute';
	text1.style.width = 100;
	text1.style.height = 100;
	text1.style.color = "black";
	text1.style.backgroundColor = "#FFFFCC";
	//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
	text1.innerHTML = 'hello ';
	text1.style.top = 2000 + 'px';
	text1.style.left = 2000 + 'px';
	//text1.style.zIndex = -1;
	document.body.appendChild(text1);
	
	//console.log(listCompartments.length)
	for (var i=0;i<maxNbComp;i++){
		txtComp[i] = document.createElement('div');
		txtComp[i].style.position = 'absolute';
		txtComp[i].style.width = 100;
		txtComp[i].style.height = 100;
		txtComp[i].style.color = "black";
		txtComp[i].style.fontSize="xx-small";
		txtComp[i].id = "txt"+i;
		//txtComp[i].style.fontWeight="1900";
		txtComp[i].style.backgroundColor = "#99FFCC";
		txtComp[i].style.opacity = 0.5;
		//text1.innerHTML = ' <input type="text" name="first_name" value="" maxlength="100" />';
		txtComp[i].innerHTML = 'hello ';
		txtComp[i].style.top = 4000 + 'px';
		txtComp[i].style.left = 4000 + 'px';
		txtComp[i].style.zIndex = 1000;
		txtComp[i].className="disabled";
		//txtComp[i].style="cursor: none"
		//txtComp[i].pointer-events:none;
		document.body.appendChild(txtComp[i]);
		
	}
	var text1PreviousPos= new THREE.Vector3( 2000, 2000, 1 );
	var text1PreviousString="";
	
	var container, stats;
	var camera, controls, scene, renderer, uniforms;
	var objects = [], plane;

	var mouse = new THREE.Vector2(),
	offset = new THREE.Vector3(),
	INTERSECTED,INTERSECTED2, SELECTED,INTERSECTED_P;
	INTERSECTED_P=-1;
	//var myLayout = <%-JSON.stringify(mtnl.layout)%>
		
	
	var metabolicNodes;	
	var metabolicEdges;
	
	// change compartment nodes attribution from data
	if (mtnlLayout["nodes_compartments"]){
		var listChangedNodes = Object.keys(mtnlLayout["nodes_compartments"]);
		if (listChangedNodes.length>0){
		
			for(var i=0, ii= listChangedNodes.length;i<ii;i++){			
				//console.log(selectedMetabolicData[1][listChangedNodes[i]])
				selectedMetabolicData[1][listChangedNodes[i]][1]=mtnlLayout["nodes_compartments"][listChangedNodes[i]][0];
				selectedMetabolicData[1][listChangedNodes[i]][3]=mtnlLayout["nodes_compartments"][listChangedNodes[i]][1];
				//console.log(selectedMetabolicData[1][listChangedNodes[i]])
			}
		}
		
	}
	
	
	var listNodes=selectedMetabolicData[1];
	metabolicNodes = selectedMetabolicData[1];
	metabolicEdges = selectedMetabolicData[2];	
	//console.log(metabolicEdges.length)
	var nbMetabolites=0;
	var nbReactions=0;
	for (var i = 0, ii= metabolicNodes.length;i<ii;i++){
			if (metabolicNodes[i][6]==2){
				nbMetabolites++;
			}
			if (metabolicNodes[i][6]==4){
				nbReactions++;
			}
	}	
	
	
	var nameComp=[];
	var mapComp = {'-1':-1};
	
	for (var i=0;i<listCompartments.length;i++){
		mapComp[listCompartments[i][0]]=i;
		nameComp.push(listCompartments[i][1]);
	}
	//console.log(listCompartments)
	//console.log(mapComp)
	//console.log(nameComp)
	var subSystems;
	var totalSubSystems;
	var nbAreas;
	
	var segments =metabolicEdges.length;
	var segmentPts =segments*2;
	//console.log(nbMetabolites)
	//console.log(nbReactions)
	//console.log(segments)
	//console.log(segmentPts)
	
	var particleP1Attributes;
	var particleP1Uniforms;
	var particle1ShaderMaterial;
	var bgeometryP1;
	var PointCloud1;
	
	var particleP2Attributes;
	var particleP2Uniforms;
	var particle2ShaderMaterial;
	var bgeometryP2;
	var PointCloud2;
	
	var linesAttributes;
	var linesUniforms;
	var linesShaderMaterial;
	var bgeometryL1;
	var meshL1;
	
	var idMap=[];
	var typesMap=[];
	for (var i=0;i<7;i++){
		typesMap[i]=[];
	};
	var reactionMap=[];
	var linesMap=[];
	
	var NodeEditingPlane;
	var moveNode=false;
	
	var arrowX;
	var arrowY;
	var arrowz;
	
	init();
	animate();
		
		function toXYCoords (pos) {
			//var vector = projector.projectVector(pos.clone(), camera);
			
			var vector = pos.clone().project(camera);//projector.projectVector(pos.clone(), camera);
			vector.x = (vector.x + 1)/2 * window.innerWidth;
			vector.y = -(vector.y - 1)/2 * window.innerHeight;
			return vector;
		}
		function init() {

		
			//////////////////////////////////////////////////
			// define shader attributes for group of particles proteins
			particleP1Attributes = {

				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};
			particleP1Uniforms = {

				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/disc.png" ) }
				

			};
			particleP1Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;		
			particle1ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP1Uniforms,
				attributes:     particleP1Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP1' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP1' ).textContent,
				depthTest: 		true,
				transparent:	true

			});
			//////////////////////////////////////////////////
			// define shader attributes for group of particles standard pn
			particleP2Attributes = {
				size: {	type: 'f', value: [] },
				ca:   {	type: 'c', value: [] }
				
			};
			particleP2Uniforms = {
				//amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "/images/PN1.png" ) }
			};
			particleP2Uniforms.texture.value.wrapS = particleP1Uniforms.texture.value.wrapT = THREE.RepeatWrapping;
			particle2ShaderMaterial = new THREE.ShaderMaterial( {

				uniforms: 		particleP2Uniforms,
				attributes:     particleP2Attributes,
				vertexShader:   document.getElementById( 'vertexshaderP2' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderP2' ).textContent,
				depthTest: 		true,
				transparent:	true

			});
			//////////////////////////////////////////////
			// define shader attributes for group of lines
			linesAttributes = {

				//displacement: {	type: 'v3', value: [] },
				ca: {	type: 'c', value: [] },
				op:{ type: "f", value: [] }

			};
			linesUniforms = {
				//amplitude: { type: "f", value: 1.0 },
				opacity:   { type: "f", value: 0.7 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) }

			};
			// define shader material for group of lines
			linesShaderMaterial = new THREE.ShaderMaterial( {
				uniforms:       linesUniforms,
				attributes:     linesAttributes,
				vertexShader:   document.getElementById( 'vertexshaderL1' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshaderL1' ).textContent,
				blending:       THREE.AdditiveBlending,
				depthTest:      false,
				transparent:    true

			});
			linesShaderMaterial.linewidth = 0.1;
			linesShaderMaterial.blending = THREE.AdditiveBlending;//THREE.SubtractiveBlending;//THREE.NoBlending;//THREE.MultiplyBlending;//THREE.NormalBlending;//THREE.AdditiveBlending;
			
			linesShaderMaterial.transparent = true;
			//linesShaderMaterial.depthTest = true;
			
			container = document.getElementById( 'container' );
			//document.body.appendChild( container );

			camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000000 );
			camera.position.z = -8000;
			camera.position.y = 5000;
			//camera.position.x = -800;
			
			scene = new THREE.Scene();
			scene.add( new THREE.AmbientLight( 0xffffff,0.5 ) );

			var light = new THREE.SpotLight( 0xffffff, 1.5 );
			light.position.set( 0, 5000, 20000 );
			//light.castShadow = true;
			
			//light.shadowCameraNear = 2000;
			//light.shadowCameraFar = camera.far;
			//light.shadowCameraFov = 50;

			//light.shadowBias = -0.00022;
			//light.shadowDarkness = 0.5;

			//light.shadowMapWidth = 2048;
			//light.shadowMapHeight = 2048;

			scene.add( light );

			//var geometry = new THREE.BoxGeometry( 40, 40, 40 );
			var geometry = new THREE.SphereGeometry( radiusComp, 50, 15 );

			for ( var i = 0; i < maxNbComp; i ++ ) {
				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x777777, side: THREE.BackSide}));//THREE.BackSide}));//, transparent: true, opacity: 0.5} ) );
				//var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: (1.0-((i/maxNbComp)*0.5)) * 0xffffff, side: THREE.BackSide}));
				object.material.ambient = object.material.color;
				object.position.x = -99999999;
				object.position.y = -99999999;
				object.position.z = -99999999;
				object.scale.y = 0.5;
				
				scene.add( object );
				objects.push( object );
			}
			
			//mtnlLayout["compartments_layout"]["name-position-scale"]=[];
			//for (var i=0; i<listCompartments.length;i++ ){
			//	mtnlLayout["compartments_layout"]["name-position-scale"][i]=[objects[i].name, objects[i].position , objects[i].scale];
			//}
			for ( var i = 0; i < listCompartments.length; i ++ ) {
				objects[i].position.x = 0;
				objects[i].position.y = 0;
				objects[i].position.z = 0;
				objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
				stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
				//objects[i].castShadow = true;
				//objects[i].receiveShadow = true;	
			}
			if (mtnlLayout["compartments_layout"] && mtnlLayout["compartments_layout"].hasOwnProperty("name-position-scale")){
				if (mtnlLayout["compartments_layout"]["name-position-scale"].length>0){
					for ( var i = 0; i < mtnlLayout["compartments_layout"]["name-position-scale"].length; i ++ ) {
						objects[i].position.x = mtnlLayout["compartments_layout"]["name-position-scale"][i][1].x;
						objects[i].position.y = mtnlLayout["compartments_layout"]["name-position-scale"][i][1].y;
						objects[i].position.z = mtnlLayout["compartments_layout"]["name-position-scale"][i][1].z;
						objects[i].name = mtnlLayout["compartments_layout"]["name-position-scale"][i][0];
						stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
						objects[i].scale.x = mtnlLayout["compartments_layout"]["name-position-scale"][i][2].x;
						objects[i].scale.y = mtnlLayout["compartments_layout"]["name-position-scale"][i][2].y;
						objects[i].scale.z = mtnlLayout["compartments_layout"]["name-position-scale"][i][2].z;
					}
				}
			}
			
			if (mtnlLayout["compartments_layout"] && mtnlLayout["compartments_layout"].hasOwnProperty("relations")){
				generalLayout=mtnlLayout["compartments_layout"]["relations"];
			}
			
			
			
			
			
			uniforms = {
				time: { type: "f", value: 1.0 },
				resolution: { type: "v2", value: new THREE.Vector2() }
			};

			var smaterial = new THREE.ShaderMaterial( {

				uniforms: uniforms,
				vertexShader: document.getElementById( 'vertexShader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
				 opacity: 0.15, transparent: true ,
				side: THREE.DoubleSide 
			} );
			
			
			plane = new THREE.Mesh(
				new THREE.PlaneBufferGeometry( 20000, 20000, 8, 8 ),
				smaterial
				//new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.45, transparent: true } )
			);
			plane.rotation.x -= (90*(Math.PI / 180));
			//KeggMapPlan.rotation.z += (90*(Math.PI / 180));
			plane.visible = true;
			scene.add( plane );

			
			
			
			/////////////////////////////////////////////
			// defines first buffergeometry for protein particles
			bgeometryP1 = new THREE.BufferGeometry();			
			bgeometryP1.dynamic = true;
			var positionsP1 = new Float32Array( nbMetabolites * 3 );
			var values_colorP1 = new Float32Array( nbMetabolites * 3 );
			var values_sizeP1 = new Float32Array( nbMetabolites );
			var compartmentP1 = new Float32Array( nbMetabolites );
			var color = new THREE.Color( 0xff9900 );;
			var color2 = new THREE.Color( 0x55ff55 );
			var radius =400;
			var bv=0;
			for( var bw = 0 , bww= metabolicNodes.length; bw < bww; bw++ ) {
				if (metabolicNodes[bw][6]==2){
					values_sizeP1[ bv ] = nodeSize;
					compartmentP1[ bv ] = mapComp[metabolicNodes[bw][3]];
					idMap[bw]=[2,bv];
					typesMap[2][bv]=bw;
					
					var rm;
					var rr;
					
					
					rm=bv*0.008*2*Math.PI;
					rr = ((bv*0.02)+0.05*radius);
					positionsP1[ bv * 3 + 0 ] = Math.cos(rm) *rr;
					positionsP1[ bv * 3 + 1 ] = yStartDisplacement+0+(bv*0.02);
					
					
					positionsP1[ bv * 3 + 2 ] = Math.sin(rm) *rr;
					
					values_colorP1[ bv * 3 + 0 ] = color.r;
					values_colorP1[ bv * 3 + 1 ] = color.g;
					values_colorP1[ bv * 3 + 2 ] = color.b;
					bv++;
				}
			}
			
			
			
			
			
			
			bgeometryP1.addAttribute( 'position', new THREE.BufferAttribute( positionsP1, 3 ) );
			bgeometryP1.addAttribute( 'ca', new THREE.BufferAttribute( values_colorP1, 3 ) );
			bgeometryP1.addAttribute( 'size', new THREE.BufferAttribute( values_sizeP1, 1 ) );
			bgeometryP1.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentP1, 1 ) );
			
			b1values_size = bgeometryP1.attributes.size.array;
			b1positions = bgeometryP1.attributes.position.array;
			b1values_color = bgeometryP1.attributes.ca.array;
			b1values_compartment = bgeometryP1.attributes.compartment.array;
			
			bgeometryP1.computeBoundingSphere();
			// associate first particle system with bufferGeometry
			PointCloud1 = new THREE.PointCloud( bgeometryP1, particle1ShaderMaterial );

			PointCloud1.dynamic = true;
			PointCloud1.sortParticles = true;
			PointCloud1.geometry.__dirtyVertices = true;
			PointCloud1.frustumCulled = false;
			scene.add( PointCloud1 );
			
			/////////////////////////////////////////////
			// defines first buffergeometry for PN particles
			bgeometryP2 = new THREE.BufferGeometry();
			var positionsP2 = new Float32Array( nbReactions * 3 );
			var values_colorP2 = new Float32Array( nbReactions * 3 );
			var values_sizeP2 = new Float32Array( nbReactions );
			var compartmentP2 = new Float32Array( nbReactions );
			bgeometryP2.dynamic = true;
			var color = new THREE.Color( 0xffffff );					
			var color2 = new THREE.Color( 0x55ffff );
			var radius =400;
			var bv=0;
			// now allocate a nb of nodes by sub systems
			subSystems={};
			totalSubSystems=0;			
			totalNbreactions=0;
			for( var bs = 0 , bww= metabolicNodes.length; bs < bww; bs++ ) {
				if (metabolicNodes[bs][6]==4){
					if (metabolicNodes[bs][4][1] && metabolicNodes[bs][4][1][0]){
						if (subSystems[metabolicNodes[bs][4][1][0]]=== undefined){
							subSystems[metabolicNodes[bs][4][1][0]]=1;
							totalSubSystems++;
						}
						else{
							subSystems[metabolicNodes[bs][4][1][0]]++;
							totalSubSystems++;
						}
						
					}
					totalNbreactions++;
				}
			}
			totalOutsideSubSystems=totalNbreactions-totalSubSystems;
			nbSubSystems=Object.keys(subSystems).length
			if (totalOutsideSubSystems>0){
				nbAreas=nbSubSystems+1;
				subSystems["Not present"]=totalOutsideSubSystems;
			}
			else{
				nbAreas=nbSubSystems;
			}
			// if there is no subsystem identified just use standard spiral layout			
			// if there are n subsystems then display circular region of width proportional to the nb of nodes in each subsystem
			// first make a list of widths
			// total nb of reactions will dictate the overall nb of points that must be displayed on the ring.
			// depth of the ring is 30 points. there are for 0.004 *2Pi=1.44 degrees = 250 graduations on a circle 
			var listWidthSubSystems={};
			var nbCircleGraduations=250;
			var minCircleFraction=1/nbCircleGraduations;
			var nbNodesDepth=40;
			var totalWidth=0;
			for (var key in subSystems) {
				if (subSystems.hasOwnProperty(key)) {
					var width= Math.ceil(subSystems[key]/nbNodesDepth);
					listWidthSubSystems[key]=[subSystems[key]/*nb of nodes*/,width,/*counter value*/0];
					totalWidth+=width;
				}
			}
			nbNodesDepth=Math.ceil((40*totalWidth)/244);
			listWidthSubSystems={};
			var totalWidth=0;
			var cumulativeWidth=0;
			var colorswap=1.0;
			for (var key in subSystems) {
				if (subSystems.hasOwnProperty(key)) {
					var width= Math.ceil(subSystems[key]/nbNodesDepth);
					listWidthSubSystems[key]=[subSystems[key]/*nb of nodes*/,width,cumulativeWidth,/*counter value*/0,colorswap];
					totalWidth+=width;
					cumulativeWidth+=width;
					if (colorswap==1.0){
					colorswap=0.7;
					}
					else{colorswap=1.0}
				}
			}
			
			var localRSeparator=0;
			for( var bw = 0 , bww= metabolicNodes.length; bw < bww; bw++ ) {
				if (metabolicNodes[bw][6]==4){
					values_sizeP2[ bv ] = nodeSize;
					//b5values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;					
					// try to assign the compartment of the majority of the products the reaction is linked to 
					// if there is no product, assign the compartment of the majority of modifiers
					// if there is no modifier, assign the compartment of the majority of reactants
					var listProducts= metabolicNodes[bw][11][0];
					var listModifiers= metabolicNodes[bw][11][1];
					var listReactants= metabolicNodes[bw][11][2];
					
					if (listProducts.length>0){
						var votes=[];
						for (var ncc=0;ncc<nbCompartments;ncc++){
							votes[ncc]=0;
						}
						for(var lp=0;lp<listProducts.length;lp++){
							if (mapComp[metabolicNodes[listProducts[lp]][3]]>=0)
								votes[mapComp[metabolicNodes[listProducts[lp]][3]]]++;
						}
						var winner= votes.indexOf(Math.max.apply( Math, votes ));
						compartmentP2[ bv ] = winner;
						if (winner==-1){
							compartmentP2[ bv ] = mapComp[metabolicNodes[bw][3]];
						}
					} 
					else if (listModifiers.length>0){
						var votes=[];
						for (var ncc=0;ncc<nbCompartments;ncc++){
							votes[ncc]=0;
						}
						for(var lp=0;lp<listModifiers.length;lp++){
							if (mapComp[metabolicNodes[listModifiers[lp]][3]]>=0)
								votes[mapComp[metabolicNodes[listModifiers[lp]][3]]]++;
						}
						var winner= votes.indexOf(Math.max.apply( Math, votes ));
						compartmentP2[ bv ] = winner;
						if (winner==-1){
							compartmentP2[ bv ] = mapComp[metabolicNodes[bw][3]];
						}
					}
					else if (listReactants.length>0){
						var votes=[];
						for (var ncc=0;ncc<nbCompartments;ncc++){
							votes[ncc]=0;
						}
						for(var lp=0;lp<listReactants.length;lp++){
							if (mapComp[metabolicNodes[listReactants[lp]][3]]>=0)
								votes[mapComp[metabolicNodes[listReactants[lp]][3]]]++;
						}
						var winner= votes.indexOf(Math.max.apply( Math, votes ));
						compartmentP2[ bv ] = winner;
						if (winner==-1){
							compartmentP2[ bv ] = mapComp[metabolicNodes[bw][3]];
						}
					}
					else {
						compartmentP2[ bv ] = mapComp[metabolicNodes[bw][3]];
					}
					idMap[bw]=[4,bv];
					typesMap[4][bv]=bw;
					var rm;
					var rr; 
					var yModifier=0;
					var mDepth=0;
					if (metabolicNodes[bw][4][1] && metabolicNodes[bw][4][1][0]){						
						if (listWidthSubSystems.hasOwnProperty(metabolicNodes[bw][4][1][0])) {
						
							var startingW=listWidthSubSystems[metabolicNodes[bw][4][1][0]][2];
							var maxWidth=listWidthSubSystems[metabolicNodes[bw][4][1][0]][1];
							var maxDepth=nbNodesDepth;
							var maxNbNodes=listWidthSubSystems[metabolicNodes[bw][4][1][0]][0];
							var presentIndex= listWidthSubSystems[metabolicNodes[bw][4][1][0]][3];
							if (presentIndex<maxNbNodes){							
								var localWPos=0;
								var localRR=0;
								localWPos=Math.floor(presentIndex/maxDepth);
								localRR=presentIndex%maxDepth;
								yModifier=	localRR;
								mDepth=maxDepth;
								rm=((startingW+localRSeparator+localWPos)*0.004*(2*Math.PI));								
								rr= ((radius-maxDepth*5)+(localRR*5));
								listWidthSubSystems[metabolicNodes[bw][4][1][0]][3]++;
								color.r=listWidthSubSystems[metabolicNodes[bw][4][1][0]][4];
								if (color.r==1.0){
								color.g=1.0;
								color.b=1.0;
								}
								else{
								color.g=0.4;
								color.b=1.0;
								}
							}
						}
					}
					else{						
						if (listWidthSubSystems.hasOwnProperty("Not present")) {						
							var startingW=listWidthSubSystems["Not present"][2];
							var maxWidth=listWidthSubSystems["Not present"][1];
							var maxDepth=nbNodesDepth;
							var maxNbNodes=listWidthSubSystems["Not present"][0];
							var presentIndex= listWidthSubSystems["Not present"][3];
							if (presentIndex<maxNbNodes){
								var localWPos=0;
								var localRR=0;
								localWPos=Math.floor(presentIndex/maxDepth);
								localRR=presentIndex%maxDepth;
								yModifier=	localRR;	
								mDepth=maxDepth;
								rm=((startingW+localRSeparator+localWPos)*0.004*(2*Math.PI));
								rr= ((radius-maxDepth*5)+(localRR*5));
								listWidthSubSystems["Not present"][3]++;
								color = new THREE.Color( 0xff0000 );
							}
						}
					}
					positionsP2[ bv * 3 + 1 ] = yStartDisplacement-(mDepth*4)+(yModifier*4);
					positionsP2[ bv * 3 + 0 ] = Math.cos(rm) *rr;
					positionsP2[ bv * 3 + 2 ] = Math.sin(rm) *rr;
					values_colorP2[ bv * 3 + 0 ] = color.r;
					values_colorP2[ bv * 3 + 1 ] = color.g;
					values_colorP2[ bv * 3 + 2 ] = color.b;
					bv++;
				}
			}
			bgeometryP2.addAttribute( 'position', new THREE.BufferAttribute( positionsP2, 3 ) );
			bgeometryP2.addAttribute( 'ca', new THREE.BufferAttribute( values_colorP2, 3 ) );
			bgeometryP2.addAttribute( 'size', new THREE.BufferAttribute( values_sizeP2, 1 ) );
			bgeometryP2.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentP2, 1 ) );
			
			//bgeometryP5.attributes.size.needsUpdate = true;
			//bgeometryP5.attributes.position.needsUpdate = true;
			//bgeometryP5.attributes.ca.needsUpdate = true;
			//bgeometryP5.attributes.compartment.needsUpdate = true;

			b2values_size = bgeometryP2.attributes.size.array;
			b2positions = bgeometryP2.attributes.position.array;
			b2values_color = bgeometryP2.attributes.ca.array;
			b2values_compartment = bgeometryP2.attributes.compartment.array;
									
			// associate first particle system with bufferGeometry
			PointCloud2 = new THREE.PointCloud( bgeometryP2, particle2ShaderMaterial );

			PointCloud2.dynamic = true;
			PointCloud2.sortParticles = true;
			PointCloud2.geometry.__dirtyVertices = true;
			PointCloud2.frustumCulled = false;
			scene.add( PointCloud2 );
			
			/////////////////////////////////////////////
			// defines buffergeometry for lines
			bgeometryL1 = new THREE.BufferGeometry();
			var positionsL1 = new Float32Array( (segmentPts) * 3 );
			var colorsL1 = new Float32Array( (segmentPts) * 3 );
			var opL1 = new Float32Array((segmentPts));
			var compartmentL1 = new Float32Array( (segments)*2 );
			var fluxL1 = new Float32Array( (segments) );
			var boundsL1= new Float32Array( (segments) * 2 );
			var r = 800;
			var col = new THREE.Color( 0x00ffff );
			var col2 = new THREE.Color( 0x55ff55 );
			
			var iv=0;
			for ( var i = 0; i < segments; i ++ ) {
			
				var t1 = metabolicNodes[metabolicEdges[i][0]][6]
				var t2 = metabolicNodes[metabolicEdges[i][1]][6]
				var ivList=[]
				
				if (t1==2){
					positionsL1[ (iv * 3)+0 ] = b1positions[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					positionsL1[ (iv * 3) + 1 ] = b1positions[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
					positionsL1[ (iv * 3) + 2 ] = b1positions[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					compartmentL1[ (i*2)+0 ] = b1values_compartment[ (idMap[metabolicEdges[i][0]][1]) ];
					opL1[iv]=lineOpacity;
					colorsL1[ iv * 3 ] = 0.0;
					colorsL1[ iv * 3 + 1 ] = 1.0;
					colorsL1[ iv * 3 + 2 ] = 1.0;
					ivList.push(iv)
					//linesMap[i]=iv
					
					iv++;
				}
				else if (t1==4){
					positionsL1[ (iv * 3)+0 ] = b2positions[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					positionsL1[ (iv * 3) + 1 ] = b2positions[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
					positionsL1[ (iv * 3) + 2 ] = b2positions[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					compartmentL1[ (i*2)+0 ] = b2values_compartment[ (idMap[metabolicEdges[i][0]][1]) ];
					opL1[iv]=lineOpacity;
					colorsL1[ iv * 3 ] = 0.0;
					colorsL1[ iv * 3 + 1 ] = 1.0;
					colorsL1[ iv * 3 + 2 ] = 1.0;
					//linesMap[i]=iv
					ivList.push(iv)
					iv++;
				}
				if (t2 ==2){
					positionsL1[ (iv * 3)+0 ] = b1positions[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					positionsL1[ (iv * 3) + 1 ] = b1positions[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
					positionsL1[ (iv * 3) + 2 ] = b1positions[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;
					compartmentL1[ (i*2)+1 ] = b1values_compartment[ (idMap[metabolicEdges[i][1]][1]) ];
					opL1[iv]=lineOpacity;
					colorsL1[ iv * 3 ] = 0.0;
					colorsL1[ iv * 3 + 1 ] = 1.0;
					colorsL1[ iv * 3 + 2 ] = 1.0;
					//linesMap[i]=iv
					ivList.push(iv)
					iv++;
				}
				else if (t2 ==4){
					positionsL1[ (iv * 3)+0 ] = b2positions[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					positionsL1[ (iv * 3) + 1 ] = b2positions[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
					positionsL1[ (iv * 3) + 2 ] = b2positions[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;
					compartmentL1[ (i*2)+1 ] = b2values_compartment[ (idMap[metabolicEdges[i][1]][1]) ];
					opL1[iv]=lineOpacity;
					colorsL1[ iv * 3 ] = 0.0;
					colorsL1[ iv * 3 + 1 ] = 1.0;
					colorsL1[ iv * 3 + 2 ] = 1.0;
					//linesMap[i]=iv
					ivList.push(iv)
					iv++;
				}
				linesMap[i]=ivList
			}
			bgeometryL1.addAttribute( 'position', new THREE.BufferAttribute( positionsL1, 3 ) );	
			bgeometryL1.addAttribute( 'ca', new THREE.BufferAttribute( colorsL1, 3 ) );
			bgeometryL1.addAttribute( 'op', new THREE.BufferAttribute( opL1, 1 ) );
			bgeometryL1.addAttribute( 'compartment', new THREE.BufferAttribute( compartmentL1, 2 ) );
			bgeometryL1.computeBoundingSphere();
			meshL1 = new THREE.Line( bgeometryL1, linesShaderMaterial,THREE.LinePieces );
			meshL1.frustumCulled = false;
			scene.add( meshL1 );
			
			var spriteMaterial = new THREE.SpriteMaterial( { 
				map: new THREE.ImageUtils.loadTexture( '/images/glow.png' ), 
				useScreenCoordinates: false, //alignment: THREE.SpriteAlignment.center,
				color: 0xff0000, transparent: false, blending: THREE.AdditiveBlending
			});
			sprite = new THREE.Sprite( spriteMaterial );
			sprite.scale.set(8, 8, 8);
			//crateGlow.add(sprite); // this centers the glow at the mesh
			//if (marker==0){
			sprite.position.set(-50000,-10000,10000);
			//sprite.transparent=true;
			//}		
			scene.add( sprite );
			
			NodeEditingPlane= new THREE.Mesh(
				new THREE.PlaneBufferGeometry( 20000, 20000, 8, 8 ),
				new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.0, transparent: true,side: THREE.DoubleSide } )
			);
			NodeEditingPlane.rotation.x -= (90*(Math.PI / 180));
			NodeEditingPlane.visible = false;
			scene.add( NodeEditingPlane );
			
			arrowX = new THREE.ArrowHelper( new THREE.Vector3( radiusComp, 0, 0 ), new THREE.Vector3( 0, 0, 0 ), 50 );
			arrowX.position.set( -99999999, -99999999, -99999999 );
			scene.add( arrowX );
			
			arrowY = new THREE.ArrowHelper( new THREE.Vector3( 0, radiusComp, 0 ), new THREE.Vector3( 0, 0, 0 ), 50 );
			arrowY.position.set( -99999999, -99999999, -99999999 );
			scene.add( arrowY );
			
			arrowZ = new THREE.ArrowHelper( new THREE.Vector3( 0, 0, radiusComp ), new THREE.Vector3( 0, 0, 0 ), 50 );
			arrowZ.position.set( -99999999, -99999999, -99999999 );
			scene.add( arrowZ );
			
			
		
			
			
			
			
			
			renderer = new THREE.WebGLRenderer( { antialias: true } );
			//renderer.setClearColor( 0xf5f5f5 );
			renderer.setClearColor( 0xe0e0e0 );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.sortObjects = false;

			renderer.shadowMapEnabled = true;
			renderer.shadowMapType = THREE.PCFShadowMap;

			container.appendChild( renderer.domElement );
			positionContainer = $("#container").position();
			controls = new THREE.OrbitControls( camera, renderer.domElement) ;
			
			controls.damping = 0.2;
			

			controls.noZoom = false;
			controls.noPan = false;

			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3;
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			container.appendChild( stats.domElement );

			renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
			renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
			renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );

			//

			window.addEventListener( 'resize', onWindowResize, false );
			
			
			
			
			

		}
			
		
		
		//generalLayout['merged']
		
		function isMerged(comp,cType) {
			var result ="";
			if (generalLayout[cType].hasOwnProperty(comp)){
				result=comp;
			}
			else {
				for (var elem in generalLayout[cType]){
					if (generalLayout[cType].hasOwnProperty(elem)){
						for (var i=0;i<generalLayout[cType][elem].length;i++ ){
							if (generalLayout[cType][elem][i]==comp){
								result=elem;
							}
						}
					} 
				}
			}
			return result;
		}
		
		function isCenterMerged(comp,cType) {
			var result ="";
			if (generalLayout[cType].hasOwnProperty(comp)){
				result=comp;
			}
			
			return result;
		}
		function isPeripheralMerged(comp,cType) {
			var result ="";
			for (var elem in generalLayout[cType]){
				if (generalLayout[cType].hasOwnProperty(elem)){
					for (var i=0;i<generalLayout[cType][elem].length;i++ ){
						if (generalLayout[cType][elem][i]==comp){
							result=elem;
						}
					}
				} 
			}
			
			return result;
		}
			
		var button1 = document.getElementById( 'b_merge' );
			button1.addEventListener( 'click', function ( event ) {
			if ($('#modeSelector').val()=="0"){
				stopThreeJsMouseEvent=false;
				
				
				var targetContainer=isMerged(INTERSECTED.name,'merged');
				var refContainer=isMerged(INTERSECTED2.name,'merged');
				// target and ref items dont exist in the merged list
				if ((targetContainer=="") && (refContainer=="")){
					generalLayout['merged'][INTERSECTED2.name]=[];
					generalLayout['merged'][INTERSECTED2.name].push(INTERSECTED.name)
				}
				// target doesnt exist in the merged list while ref exists
				else if ((targetContainer=="") && (refContainer!="")){
					if (generalLayout['merged'][refContainer].indexOf(INTERSECTED.name)==-1){
						generalLayout['merged'][refContainer].push(INTERSECTED.name)
					}
				}
				// target doesnt exist in the merged list while ref exists
				else if ((targetContainer!="") && (refContainer=="")){
					if (generalLayout['merged'][targetContainer].indexOf(INTERSECTED2.name)==-1){
						generalLayout['merged'][targetContainer].push(INTERSECTED2.name)
					}
				}
				// we want to merge two existing merged groups already
				else{
					var newcontent=$.unique(generalLayout['merged'][targetContainer].concat(generalLayout['merged'][refContainer]));
					if (newcontent.length<listCompartments.length-1){
						newcontent.push(targetContainer);
						generalLayout['merged'][refContainer]=newcontent;
						delete generalLayout['merged'][targetContainer];
					}					
				}								
				placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name, 'merged');
				$('#layout1menu').hide();
			}
		});
			
		var button2 = document.getElementById( 'b_above' );
		button2.addEventListener( 'click', function ( event ) {
			if ($('#modeSelector').val()=="0"){
				//console.log("above");
				stopThreeJsMouseEvent=false;
				
				var targetContainer=isMerged(INTERSECTED.name,'above');
				var refContainer=isMerged(INTERSECTED2.name,'above');
				// target and ref items dont exist in the merged list
				if ((targetContainer=="") && (refContainer=="")){
					generalLayout['above'][INTERSECTED2.name]=[];
					generalLayout['above'][INTERSECTED2.name].push(INTERSECTED.name)
				}
				// target doesnt exist in the merged list while ref exists
				else if ((targetContainer=="") && (refContainer!="")){
					if (generalLayout['above'][refContainer].indexOf(INTERSECTED.name)==-1){
						generalLayout['above'][refContainer].push(INTERSECTED.name)
					}
				}
				// target doesnt exist in the merged list while ref exists
				else if ((targetContainer!="") && (refContainer=="")){
					if (generalLayout['above'][targetContainer].indexOf(INTERSECTED2.name)==-1){
						generalLayout['above'][targetContainer].push(INTERSECTED2.name)
					}
				}
				// we want to merge two existing merged groups already
				else{
					var newcontent=$.unique(generalLayout['above'][targetContainer].concat(generalLayout['above'][refContainer]));
					if (newcontent.length<listCompartments.length-1){
						newcontent.push(targetContainer);
						generalLayout['above'][refContainer]=newcontent;
						delete generalLayout['above'][targetContainer];
					}
					
				}
				
				
				
				//compLayout["above"].push([INTERSECTED.name, INTERSECTED2.name] );
				//console.log(compLayout);
				placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name,'above');
				$('#layout1menu').hide();
			}
		});
		var button3 = document.getElementById( 'b_below' );
		button3.addEventListener( 'click', function ( event ) {
			if ($('#modeSelector').val()=="0"){
				//console.log("below");
				stopThreeJsMouseEvent=false;
				
				var targetContainer=isMerged(INTERSECTED.name,'above');
				var refContainer=isMerged(INTERSECTED2.name,'above');
				// target and ref items dont exist in the merged list
				if ((targetContainer=="") && (refContainer=="")){
					generalLayout['above'][INTERSECTED.name]=[];
					generalLayout['above'][INTERSECTED.name].push(INTERSECTED2.name)
				}
				// target doesnt exist in the merged list while ref exists
				else if ((targetContainer=="") && (refContainer!="")){
					var newcontent=generalLayout['above'][refContainer].slice();
					
					if (newcontent.length<listCompartments.length-1){
						newcontent.unshift(refContainer);
						generalLayout['above'][INTERSECTED.name]=newcontent
						delete generalLayout['above'][refContainer];
					}
				}
				// target does exist in the merged list while ref doesnt exist
				else if ((targetContainer!="") && (refContainer=="")){
					if (generalLayout['above'][targetContainer].indexOf(INTERSECTED2.name)==-1){
						generalLayout['above'][targetContainer].push(INTERSECTED2.name)
					}
				}
				// we want to merge two existing merged groups already
				else{
					var newcontent=$.unique(generalLayout['above'][targetContainer].concat(generalLayout['above'][refContainer]));
					if (newcontent.length<listCompartments.length-1){
						newcontent.unshift(refContainer);
						generalLayout['above'][targetContainer]=newcontent;
						delete generalLayout['above'][refContainer];
					}
					
				}
				
				
				//compLayout["above"].push([INTERSECTED2.name, INTERSECTED.name] );
				//console.log(compLayout);
				placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name,'below');
				$('#layout1menu').hide();
			}
		});
		var button4 = document.getElementById( 'b_inner' );
		button4.addEventListener( 'click', function ( event ) {
			if ($('#modeSelector').val()=="0"){
				//console.log("inner");
				stopThreeJsMouseEvent=false;
				
				var targetContainer=isMerged(INTERSECTED.name,'outer');
				var refContainer=isMerged(INTERSECTED2.name,'outer');
				// target and ref items dont exist in the merged list
				if ((targetContainer=="") && (refContainer=="")){
					generalLayout['outer'][INTERSECTED.name]=[];
					generalLayout['outer'][INTERSECTED.name].push(INTERSECTED2.name)
				}
				// target doesnt exist in the merged list while ref exists
				else if ((targetContainer=="") && (refContainer!="")){
					var newcontent=generalLayout['outer'][refContainer].slice();
					
					if (newcontent.length<listCompartments.length-1){
						newcontent.unshift(refContainer);
						generalLayout['outer'][INTERSECTED.name]=newcontent
						delete generalLayout['outer'][refContainer];
					}
				}
				// target does exist in the merged list while ref doesnt exist
				else if ((targetContainer!="") && (refContainer=="")){
					if (generalLayout['outer'][targetContainer].indexOf(INTERSECTED2.name)==-1){
						generalLayout['outer'][targetContainer].push(INTERSECTED2.name)
					}
				}
				// we want to merge two existing merged groups already
				else{
					var newcontent=$.unique(generalLayout['outer'][targetContainer].concat(generalLayout['outer'][refContainer]));
					if (newcontent.length<listCompartments.length-1){
						newcontent.unshift(refContainer);
						generalLayout['outer'][targetContainer]=newcontent;
						delete generalLayout['outer'][refContainer];
					}
					
				}
				
				
				//compLayout["outer"].push([INTERSECTED2.name, INTERSECTED.name] );
				//console.log(compLayout);
				placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name,'outer');
				$('#layout1menu').hide();
			}
		});
		var button5 = document.getElementById( 'b_outer' );
		button5.addEventListener( 'click', function ( event ) {
			if ($('#modeSelector').val()=="0"){
				//console.log("outer");
				stopThreeJsMouseEvent=false;
				
				var targetContainer=isMerged(INTERSECTED.name,'outer');
				var refContainer=isMerged(INTERSECTED2.name,'outer');
				// target and ref items dont exist in the merged list
				if ((targetContainer=="") && (refContainer=="")){
					generalLayout['outer'][INTERSECTED2.name]=[];
					generalLayout['outer'][INTERSECTED2.name].push(INTERSECTED.name)
				}
				// target doesnt exist in the merged list while ref exists
				else if ((targetContainer=="") && (refContainer!="")){
					if (generalLayout['outer'][refContainer].indexOf(INTERSECTED.name)==-1){
						generalLayout['outer'][refContainer].push(INTERSECTED.name)
					}
				}
				// target doesnt exist in the merged list while ref exists
				else if ((targetContainer!="") && (refContainer=="")){
					if (generalLayout['outer'][targetContainer].indexOf(INTERSECTED2.name)==-1){
						generalLayout['outer'][targetContainer].push(INTERSECTED2.name)
					}
				}
				// we want to merge two existing merged groups already
				else{
					var newcontent=$.unique(generalLayout['outer'][targetContainer].concat(generalLayout['outer'][refContainer]));
					if (newcontent.length<listCompartments.length-1){
						newcontent.push(targetContainer);
						generalLayout['outer'][refContainer]=newcontent;
						delete generalLayout['outer'][targetContainer];
					}
					
				}
				//console.log(generalLayout['outer']);
				//compLayout["outer"].push([INTERSECTED.name, INTERSECTED2.name] );
				//console.log(compLayout);
				placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name,'outer');
				$('#layout1menu').hide();
			}
		});
		var button6 = document.getElementById( 'b_satellite' );
		button6.addEventListener( 'click', function ( event ) {
			//console.log(INTERSECTED2.name);
			if ($('#modeSelector').val()=="0"){
				stopThreeJsMouseEvent=false;
				var refComp=INTERSECTED2.name;
				for (var ref in generalLayout["outer"]){
					if (generalLayout["outer"].hasOwnProperty(ref)){
						var indComp=generalLayout["outer"][ref].indexOf(INTERSECTED2.name);
						if (INTERSECTED2.name==ref || indComp!=-1 ){
							refComp=ref;
						}
					}
				}
				//console.log(refComp);
				var targetContainer=isCenterMerged(INTERSECTED.name,'satellite');
				var targetContainer2=isPeripheralMerged(INTERSECTED.name,'satellite');
				var refContainer=isCenterMerged(refComp,'satellite');
				var refContainer2=isPeripheralMerged(refComp,'satellite');
				if (!(targetContainer2!="")){
					if((targetContainer=="") && (refContainer=="")){
						generalLayout['satellite'][refComp]=[];
						generalLayout['satellite'][refComp].push(INTERSECTED.name)
					}
					else if ((targetContainer=="") && !(refContainer=="")){
						if (generalLayout['satellite'][refComp].indexOf(INTERSECTED.name)==-1){
							generalLayout['satellite'][refComp].push(INTERSECTED.name);
						}
					}
					else if (!(targetContainer=="") && (refContainer=="")){
						generalLayout['satellite'][refComp.name]=[];
						if (generalLayout['satellite'][refComp].indexOf(INTERSECTED.name)==-1){
							generalLayout['satellite'][refComp].push(INTERSECTED.name);
						}
					}
					else{
						if (generalLayout['satellite'][refComp].indexOf(INTERSECTED.name)==-1){
							generalLayout['satellite'][refComp].push(INTERSECTED.name);
						}
					}
					
					
				}
				
				//compLayout["satellite"].push([INTERSECTED.name, INTERSECTED2.name] );
				//console.log(generalLayout['satellite']);
				placeCompFromLayout(INTERSECTED.name, refComp,'satellite');
				$('#layout1menu').hide();
			}
		});
		var button7 = document.getElementById( 'b_subset' );
		button7.addEventListener( 'click', function ( event ) {
			if ($('#modeSelector').val()=="0"){
				//console.log("subset");
				stopThreeJsMouseEvent=false;
				
				var targetContainer=isCenterMerged(INTERSECTED.name,'in');
				var targetContainer2=isPeripheralMerged(INTERSECTED.name,'in');
				var refContainer=isCenterMerged(INTERSECTED2.name,'in');
				var refContainer2=isPeripheralMerged(INTERSECTED2.name,'in');
				if (!(targetContainer2!="")){
					if((targetContainer=="") && (refContainer=="")){
						generalLayout['in'][INTERSECTED2.name]=[];
						generalLayout['in'][INTERSECTED2.name].push(INTERSECTED.name)
					}
					else if ((targetContainer=="") && !(refContainer=="")){
						if (generalLayout['in'][INTERSECTED2.name].indexOf(INTERSECTED.name)==-1){
							generalLayout['in'][INTERSECTED2.name].push(INTERSECTED.name);
						}
					}
					else if (!(targetContainer=="") && (refContainer=="")){
						generalLayout['in'][INTERSECTED2.name]=[];
						if (generalLayout['in'][INTERSECTED2.name].indexOf(INTERSECTED.name)==-1){
							generalLayout['in'][INTERSECTED2.name].push(INTERSECTED.name);
						}
					}
					else{
						if (generalLayout['in'][INTERSECTED2.name].indexOf(INTERSECTED.name)==-1){
							generalLayout['in'][INTERSECTED2.name].push(INTERSECTED.name);
						}
					}
					
					
				}
				
				//compLayout["in"].push([INTERSECTED.name,INTERSECTED2.name] );
				//console.log(compLayout);
				placeCompFromLayout(INTERSECTED.name, INTERSECTED2.name,'in');
				$('#layout1menu').hide();
			}
		});
		var button8 = document.getElementById( 'b_cancel' );
		button8.addEventListener( 'click', function ( event ) {
			if ($('#modeSelector').val()=="0"){
				//console.log("cancel");
				stopThreeJsMouseEvent=false;
				for ( var i = 0; i < listCompartments.length; i ++ ) {
					if (objects[i].name==initialName){
						objects[i].position.x=initialPos.x;
						objects[i].position.y=initialPos.y;
						objects[i].position.z=initialPos.z;
						SELECTED = null;
						SELECTED2=null;
					}
				}
				
				
				
				$('#layout1menu').hide();
			}
		});
			

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {
				if ($('#modeSelector').val()=="0"){
					if (stopThreeJsMouseEvent==false){
						event.preventDefault();
						mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
						mouse.y = - ( (event.clientY-$("#container").position().top+window.pageYOffset) / window.innerHeight ) * 2 + 1;
						var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );
						var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
						if ( SELECTED ) {
							var intersects2 = raycaster.intersectObjects( objects );
							if ( intersects2.length > 1 ) {
								if (SELECTED.name==intersects2[0].object.name)
									INTERSECTED2=intersects2[1].object;
								else
									INTERSECTED2=intersects2[0].object;
							}
							else{
								INTERSECTED2=null;
							}
							//plane.position.y=SELECTED.position.y;
							var intersects = raycaster.intersectObject( plane );						
							var mustMove=true;
							
							
							
							if( mustMove==true){
							SELECTED.position.copy( intersects[ 0 ].point );
							
							
							}
							
							
							stackCompToMove=[];
							
							function addToStack(cname){
								for (var typeComp in generalLayout){
									if (generalLayout.hasOwnProperty(typeComp)){
										for (var ref in generalLayout[typeComp]){
											if (generalLayout[typeComp].hasOwnProperty(ref)){
												var indComp=generalLayout[typeComp][ref].indexOf(cname);
												if (cname==ref || indComp!=-1 ){
													if (stackCompToMove.indexOf(ref)==-1){
														stackCompToMove.push(ref);
													}
													for (var i=0; i<generalLayout[typeComp][ref].length;i++ ){
														if (stackCompToMove.indexOf(generalLayout[typeComp][ref][i])==-1){
															stackCompToMove.push(generalLayout[typeComp][ref][i]);
														}
													}
												}
											}
										}
									}
								}
							}
							
							
							addToStack(SELECTED.name);
							for (var i=0; i<stackCompToMove.length;i++ ){
								addToStack(stackCompToMove[i]);
							}
							//console.log(stackCompToMove)
							
							var displacement =new THREE.Vector3();
							displacement.subVectors(SELECTED.position,initialPos );
							displacement.y=0;
							//console.log(displacement)
							
							
							
							function moveComp(compName){
								for (var ref in generalLayout["merged"]){
									if (generalLayout["merged"].hasOwnProperty(ref)){
										if (compName==ref || generalLayout["merged"][ref].indexOf(compName)!=-1 ){
											mustMove=true;
											for (var j=0; j<listCompartments.length;j++ ){
												if (objects[j].name==ref || generalLayout["merged"][ref].indexOf(objects[j].name)!=-1){	
													objects[j].position.addVectors(stackCompInitialPos[objects[j].name],displacement);	
												}
											}
										}
									}
								}
								for (var ref in generalLayout["above"]){
									if (generalLayout["above"].hasOwnProperty(ref)){
										if (compName==ref || generalLayout["above"][ref].indexOf(compName)!=-1 ){
											mustMove=true;
											for (var j=0; j<listCompartments.length;j++ ){
												if (objects[j].name==ref || generalLayout["above"][ref].indexOf(objects[j].name)!=-1){	
													objects[j].position.addVectors(stackCompInitialPos[objects[j].name],displacement);	
												}
											}
										}
									}
								}
								for (var ref in generalLayout["outer"]){
									if (generalLayout["outer"].hasOwnProperty(ref)){
										if (compName==ref || generalLayout["outer"][ref].indexOf(compName)!=-1 ){
											mustMove=true;
											for (var j=0; j<listCompartments.length;j++ ){
												if (objects[j].name==ref || generalLayout["outer"][ref].indexOf(objects[j].name)!=-1){	
													objects[j].position.addVectors(stackCompInitialPos[objects[j].name],displacement);	
												}
											}
										}
									}
								}
								for (var ref in generalLayout["in"]){
									if (generalLayout["in"].hasOwnProperty(ref)){
										if (compName==ref || generalLayout["in"][ref].indexOf(compName)!=-1 ){
											mustMove=true;
											for (var j=0; j<listCompartments.length;j++ ){
												if (objects[j].name==ref || generalLayout["in"][ref].indexOf(objects[j].name)!=-1){	
													objects[j].position.addVectors(stackCompInitialPos[objects[j].name],displacement);	
												}
											}
										}
									}
								}
								for (var ref in generalLayout["satellite"]){
									if (generalLayout["satellite"].hasOwnProperty(ref)){
										if (compName==ref || generalLayout["satellite"][ref].indexOf(compName)!=-1 ){
											mustMove=true;
											for (var j=0; j<listCompartments.length;j++ ){
												if (objects[j].name==ref || generalLayout["satellite"][ref].indexOf(objects[j].name)!=-1){	
													objects[j].position.addVectors(stackCompInitialPos[objects[j].name],displacement);	
												}
											}
										}
									}
								}
							}
							
							for (var i=0; i<stackCompToMove.length;i++ ){
								moveComp(stackCompToMove[i]);
								//console.log(stackCompInitialPos)
							}
							
							
							
							//plane.position.copy( intersects[ 0 ].point);						
							return;
						}
						var intersects = raycaster.intersectObjects( objects );
						if ( intersects.length > 0 ) {						
								if ( INTERSECTED != intersects[ 0 ].object ) {
									if ( INTERSECTED ) {
										INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
									}
									INTERSECTED = intersects[ 0 ].object;
									INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
									//console.log(generalLayout);
									//plane.rotation.x -= (90*(Math.PI / 180));
								}
								container.style.cursor = 'pointer';						
						} else {

							if ( INTERSECTED ) {
								INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
							}
							INTERSECTED = null;
							INTERSECTED2 = null;
							container.style.cursor = 'auto';
						}
					}
				}
				if ($('#modeSelector').val()=="1"){
					event.preventDefault();
					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( (event.clientY-$("#container").position().top+window.pageYOffset) / window.innerHeight ) * 2 + 1;
					var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );
					var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
					
					
					
									
							
							
							
								
							if (moveNode==true && INTERSECTED_P>-1 && container.style.cursor == 'pointer'){
								if (idMap[INTERSECTED_P]){
									
									var indexStartNodes=maxNbComp+3;
									if (idMap[INTERSECTED_P][0]==2){
										sprite.position.set(scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0],scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1],scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2]);	
										if ($('#editplane').val()=="0"){
											
											NodeEditingPlane.position.y= scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1];
											NodeEditingPlane.updateMatrixWorld( true );
											var intersects = raycaster.intersectObject( NodeEditingPlane );	
											if (intersects && intersects[ 0 ]){
												scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0]=intersects[ 0 ].point.x;
												//scene.children[23].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1]=intersects[ 0 ].point.y;
												scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2]=intersects[ 0 ].point.z;
												scene.children[indexStartNodes].geometry.attributes.position.needsUpdate = true;
												mtnlLayout["nodes_layout"][INTERSECTED_P]=new THREE.Vector3(intersects[ 0 ].point.x,scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1],intersects[ 0 ].point.z);
												//console.log(INTERSECTED_P)
											}
											arrowX.position.set( scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0], scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1], scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2] );
											arrowX.position.needsUpdate = true;
											arrowZ.position.set( scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0], scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1], scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2] );
											arrowZ.position.needsUpdate = true;
										}
										if ($('#editplane').val()=="1"){
											NodeEditingPlane.position.z= scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2];
											NodeEditingPlane.updateMatrixWorld( true );
											var intersects = raycaster.intersectObject( NodeEditingPlane );	
											if (intersects && intersects[ 0 ]){
												scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0]=intersects[ 0 ].point.x;
												//scene.children[23].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1]=intersects[ 0 ].point.y;
												scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1]=intersects[ 0 ].point.y;
												scene.children[indexStartNodes].geometry.attributes.position.needsUpdate = true;
												mtnlLayout["nodes_layout"][INTERSECTED_P]=new THREE.Vector3(intersects[ 0 ].point.x,intersects[ 0 ].point.y,scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2]);
												//console.log(INTERSECTED_P)
											}
											arrowX.position.set( scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0], scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1], scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2] );
											arrowX.position.needsUpdate = true;
											arrowY.position.set( scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0], scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1], scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2] );
											arrowY.position.needsUpdate = true;
										}
										
										//console.log(scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0])
									}
									if (idMap[INTERSECTED_P][0]==4){
										sprite.position.set(scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0],scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1],scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2]);	
										if ($('#editplane').val()=="0"){
											NodeEditingPlane.position.y= scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1];
											NodeEditingPlane.updateMatrixWorld( true );
											var intersects = raycaster.intersectObject( NodeEditingPlane );	
											if (intersects && intersects[ 0 ]){
												scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0]=intersects[ 0 ].point.x;
												//scene.children[23].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1]=intersects[ 0 ].point.y;
												scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2]=intersects[ 0 ].point.z;
												scene.children[indexStartNodes+1].geometry.attributes.position.needsUpdate = true;
												mtnlLayout["nodes_layout"][INTERSECTED_P]=new THREE.Vector3(intersects[ 0 ].point.x,scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1],intersects[ 0 ].point.z);
											}
											arrowX.position.set( scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0], scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1], scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2] );
											arrowX.position.needsUpdate = true;
											arrowZ.position.set( scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0], scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1], scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2] );
											arrowZ.position.needsUpdate = true;
											
										}
										if ($('#editplane').val()=="1"){
											NodeEditingPlane.position.z= scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2];
											NodeEditingPlane.updateMatrixWorld( true );
											var intersects = raycaster.intersectObject( NodeEditingPlane );	
											if (intersects && intersects[ 0 ]){
												scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0]=intersects[ 0 ].point.x;
												//scene.children[23].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1]=intersects[ 0 ].point.y;
												scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1]=intersects[ 0 ].point.y;
												scene.children[indexStartNodes+1].geometry.attributes.position.needsUpdate = true;
												mtnlLayout["nodes_layout"][INTERSECTED_P]=new THREE.Vector3(intersects[ 0 ].point.x,intersects[ 0 ].point.y,scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2]);
											}
											arrowX.position.set( scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0], scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1], scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2] );
											arrowX.position.needsUpdate = true;
											arrowY.position.set( scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0], scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1], scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2] );
											arrowY.position.needsUpdate = true;
										}
										//console.log(scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0])
									}
									
									
									//console.log(intersects[ 0 ].point)		
								}		
							}
							else {
							
							var indexStartNodes=maxNbComp+3;
						var particles;
						var distance=99999999;
						var listretPointsIndexes=[];
						var listretPointsDistances=[];	
						var listretPointsTypes=[];	
						var listretPointsIndexesL=[];
						var listretPointsDistancesL=[];	
						var listretPointsTypesL=[];	
						var point = new THREE.Vector3(0,0,0);		
						var myray=raycaster.ray;
						var point1 = new THREE.Vector3(0,0,0);	
						var point2 = new THREE.Vector3(0,0,0);
						for(var i=indexStartNodes, ii=indexStartNodes+2;i<ii;i++){
							if (scene.children[i] instanceof THREE.PointCloud){
								var a1 = scene.children[i].geometry.attributes.position.array;
								var a2 = scene.children[i].geometry.attributes.size.array;
								particles = a2.length;
								var a3 = scene.children[i].geometry.attributes.ca.array;
								for(var j=0;j<particles;j++){
									point.x = (a1[j*3]);
									point.y = (a1[j*3+1]);
									point.z = (a1[j*3+2]);
									distance = myray.distanceToPoint(point);
									if ( distance <=2 ) {
										listretPointsIndexes.push(j);
										listretPointsDistances.push(distance);	
										listretPointsTypes.push(i);	
									}
								}
							}
							var h1 = listretPointsDistances.length;
							var myr;
							var mymin = Math.min.apply(Math, listretPointsDistances);
							var v1=0;
							while(h1--){
								if (listretPointsDistances[h1]==mymin){
									myr=h1;
										}
										if (myr==h1)
											break;
										
							}			
							closest = listretPointsIndexes[myr];
								if (closest>=0){
								
									//console.log(closest)
									//console.log(myr)
									//console.log(listretPointsTypes[myr])
									if (listretPointsTypes[myr]>=0){
										sprite.position.set(scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3],scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3+1],scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3+2]);	
										var pp = toXYCoords(sprite.position);
										var dat;
										if (listretPointsTypes[myr]==indexStartNodes)
											dat=typesMap[2][closest];
										if (listretPointsTypes[myr]==(indexStartNodes+1))
											dat=typesMap[4][closest];
										
										//if (INTERSECTED_P>-1){
										
										//else{
											INTERSECTED_P=dat;
										//}
										//console.log(INTERSECTED_P)
										if ((text1PreviousPos.x != pp.x) && (text1PreviousPos.y != pp.y)){
											text1.style.top = (positionContainer.top )+ 'px';								
											text1.style.left = (positionContainer.left+100)+ 'px';
											text1PreviousPos = pp;
											var stringTxt="";
											//console.log(listretPointsTypes[myr])
											var dat;
											if (listretPointsTypes[myr]==indexStartNodes)
												dat=typesMap[2][closest];
											if (listretPointsTypes[myr]==(indexStartNodes+1))
												dat=typesMap[4][closest];
											
											if(metabolicNodes[dat]){
												
												stringTxt = metabolicNodes[dat][0]+" "+metabolicNodes[dat][2];
												if (metabolicNodes[dat][4][1] && metabolicNodes[dat][4][1][0]){
													stringTxt = metabolicNodes[dat][0]+" "+metabolicNodes[dat][2]+" ("+metabolicNodes[dat][4][1][0]+")";
												}
											}
											if (text1PreviousString!=stringTxt){
												text1.innerHTML=stringTxt;
												text1PreviousString=stringTxt;
											}
										}
									
									
									}
									container.style.cursor = 'pointer';	
								}
								else{
									//INTERSECTED_P=-1;
									container.style.cursor = 'auto';
								}
							}
						}
					
				}
			}

			function onDocumentMouseDown( event ) {				
				event.preventDefault();
				switch ( event.button ) {
					case 0: // left 
						if ($('#modeSelector').val()=="0"){
							var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );
							var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
							var intersects = raycaster.intersectObjects( objects );
							if ( intersects.length > 0 ) {							
									controls.enabled = false;
									if(SELECTED==null){
										initialPos.x=intersects[ 0 ].object.position.x;
										initialPos.y=intersects[ 0 ].object.position.y;
										initialPos.z=intersects[ 0 ].object.position.z;
										initialName = intersects[ 0 ].object.name;
										//console.log(initialPos)
									}
									SELECTED = intersects[ 0 ].object;
									plane.position.y=SELECTED.position.y;
									
									// store initial position of all other compartments 
									stackCompInitialPos={};
									for (var i=0; i<listCompartments.length;i++ ){
										stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
									}
									
									//var intersects = raycaster.intersectObject( plane );
									//offset.copy( intersects[ 0 ].point ).sub( plane.position );
									container.style.cursor = 'move';							
							}
						}
						if ($('#modeSelector').val()=="1"){
							if (INTERSECTED_P!=-1){
								controls.enabled = false;
								container.style.cursor = 'move';
								moveNode=true;
								//var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );
								//var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
								//NodeEditingPlane.position.y= 
								// if (idMap[INTERSECTED_P]){
									
									// var indexStartNodes=maxNbComp+3;
									// if (idMap[INTERSECTED_P][0]==2){
										// NodeEditingPlane.position.y= scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1];
										// NodeEditingPlane.updateMatrixWorld( true );
										// var intersects = raycaster.intersectObject( NodeEditingPlane );	
										// scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0]=intersects[ 0 ].point.x;
										// //scene.children[23].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1]=intersects[ 0 ].point.y;
										// scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2]=intersects[ 0 ].point.z;
										// scene.children[indexStartNodes].geometry.attributes.position.needsUpdate = true;
										// //console.log(scene.children[indexStartNodes].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0])
									// }
									// if (idMap[INTERSECTED_P][0]==4){
										// NodeEditingPlane.position.y= scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1];
										// NodeEditingPlane.updateMatrixWorld( true );
										// var intersects = raycaster.intersectObject( NodeEditingPlane );	
										// scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0]=intersects[ 0 ].point.x;
										// //scene.children[23].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+1]=intersects[ 0 ].point.y;
										// scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+2]=intersects[ 0 ].point.z;
										// scene.children[indexStartNodes+1].geometry.attributes.position.needsUpdate = true;
										// //console.log(scene.children[indexStartNodes+1].geometry.attributes.position.array[idMap[INTERSECTED_P][1]*3+0])
									// }
									
									
									// //console.log(intersects[ 0 ].point)		
								// }								
								//var mustMove=true;
								//scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3],scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3+1],scene.children[listretPointsTypes[myr]].geometry.attributes.position.array[closest*3+2]);
							
							
								//if( mustMove==true){
								//SELECTED.position.copy( intersects[ 0 ].point );
								
								
								//}
							}
							//INTERSECTED_P=null;
							
						}
					case 1: // middle
						break;
					case 2: // right
						break;
				}
			}
			function onDocumentMouseUp( event ) {
			//console.log("up")
				switch ( event.button ) {
					case 0: // left 						
						event.preventDefault();
						if ($('#modeSelector').val()=="0"){
							controls.enabled = true;
							if ( INTERSECTED ) {							
								if ( INTERSECTED2 ) {
								
									var prevent =false;								
									for (var typeLink in generalLayout){
										if (generalLayout.hasOwnProperty(typeLink)){
											for (var ref in generalLayout[typeLink]){
												if (generalLayout[typeLink].hasOwnProperty(ref)){
													if ((INTERSECTED2.name==ref && generalLayout[typeLink][ref].indexOf(INTERSECTED.name)!=-1)||
													(INTERSECTED.name==ref && generalLayout[typeLink][ref].indexOf(INTERSECTED2.name)!=-1) ||
													(generalLayout[typeLink][ref].indexOf(INTERSECTED.name)!=-1 && generalLayout[typeLink][ref].indexOf(INTERSECTED2.name)!=-1)
													){
														prevent =true;
													}
												}
											}
										}
									}
									if (prevent ==false){
									
									
									
									
									//console.log(INTERSECTED.name+" dragged and dropped on :"+INTERSECTED2.name)
									$('#layout1menu').show();
									var vector = new THREE.Vector3(INTERSECTED2.position.x,INTERSECTED2.position.y,INTERSECTED2.position.z);
									var pp = toXYCoords(vector	);
						
						
									document.getElementById("layout1menu").style.top = (pp.y+$('#container').position().top) + 'px';
									document.getElementById("layout1menu").style.left = (pp.x)+ 'px';
									stopThreeJsMouseEvent=true;
									
									}
									else{
										// adjust all metabolic nodes and lines positions
										var indexStartNodes=maxNbComp+3;
										nbCompartments= listCompartments.length;
										//var indSelectedComp= SELECTED
										var sInd=-1;
										for (var i=0; i<listCompartments.length;i++ ){
											if (SELECTED.name==objects[i].name){
												sInd=i;
											}
										}
										//console.log(SELECTED.name)
										//console.log(listCompartments.length);
										//console.log(scene.children[indexStartNodes])
										for (var c=indexStartNodes;c<indexStartNodes+2;c++){
											for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
												for (var g=0;g<nbCompartments;g++){
													if (scene.children[c].geometry.attributes.compartment.array[h]==g){
													//nameComp[g]
													scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x;
													scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y;
													scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z;
													//scene.children[c].geometry.attributes.position.array[h*3+1]+=1000;
													//scene.children[c].geometry.attributes.position.array[h*3+2]+=1000;
													}
												}
											}
											scene.children[c].geometry.attributes.position.needsUpdate = true;
										}
										var iv=0;
										for ( var i = 0; i < segments; i ++ ) {
											var t1 = metabolicNodes[metabolicEdges[i][0]][6]
											var t2 = metabolicNodes[metabolicEdges[i][1]][6]
											//console.log(t1)
											//console.log(t2)
											//var ivList=[]
											var doIt=0
											if (t1==2){
												//console.log(idMap[jsonObj2[i][0]][1])
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
												
												iv++;
											}
											else if (t1==4){
												//console.log(idMap[jsonObj2[i][0]][1])
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
												iv++;
											}
											if (t2 ==2){
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
												iv++;
											}
											else if (t2 ==4){
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
												scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
												iv++;
											}
											
										}
										scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
									}
									
								}
								else{
									// adjust all metabolic nodes and lines positions
									var indexStartNodes=maxNbComp+3;
									nbCompartments= listCompartments.length;
									//var indSelectedComp= SELECTED
									
									//console.log(SELECTED.name)
									//console.log(listCompartments.length);
									//console.log(scene.children[indexStartNodes])
									for (var c=indexStartNodes;c<indexStartNodes+2;c++){
										for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
											for (var g=0;g<nbCompartments;g++){
												if (scene.children[c].geometry.attributes.compartment.array[h]==g){
												//nameComp[g]
												scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x;
												scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y;
												scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z;
												//scene.children[c].geometry.attributes.position.array[h*3+1]+=1000;
												//scene.children[c].geometry.attributes.position.array[h*3+2]+=1000;
												}
											}
										}
										scene.children[c].geometry.attributes.position.needsUpdate = true;
									}
									var iv=0;
									for ( var i = 0; i < segments; i ++ ) {
										var t1 = metabolicNodes[metabolicEdges[i][0]][6]
										var t2 = metabolicNodes[metabolicEdges[i][1]][6]
										//console.log(t1)
										//console.log(t2)
										//var ivList=[]
										var doIt=0
										if (t1==2){
											//console.log(idMap[jsonObj2[i][0]][1])
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
											
											iv++;
										}
										else if (t1==4){
											//console.log(idMap[jsonObj2[i][0]][1])
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
											iv++;
										}
										if (t2 ==2){
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
											iv++;
										}
										else if (t2 ==4){
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
											scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
											iv++;
										}
										
									}
									scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
									//console.log("reset initial positions")
									for ( var i = 0; i < listCompartments.length; i ++ ) {
										stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
									}
								}
								
								
								
								SELECTED = null;
								
								
								mtnlLayout["compartments_layout"]["name-position-scale"]=[];
								for (var i=0; i<listCompartments.length;i++ ){
									mtnlLayout["compartments_layout"]["name-position-scale"][i]=[objects[i].name, objects[i].position , objects[i].scale];
								}
								
								saveLayout();
								
								
							}
							
							container.style.cursor = 'auto';
						}
						
						if ($('#modeSelector').val()=="1"){
							var indexStartNodes=maxNbComp+3;
							var iv=0;
							for ( var i = 0; i < segments; i ++ ) {
								var t1 = metabolicNodes[metabolicEdges[i][0]][6]
								var t2 = metabolicNodes[metabolicEdges[i][1]][6]
								//console.log(t1)
								//console.log(t2)
								//var ivList=[]
								var doIt=0
								if (t1==2){
									//console.log(idMap[jsonObj2[i][0]][1])
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
									
									iv++;
								}
								else if (t1==4){
									//console.log(idMap[jsonObj2[i][0]][1])
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
									iv++;
								}
								if (t2 ==2){
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
									iv++;
								}
								else if (t2 ==4){
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
									scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
									iv++;
								}
								
							}
							scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
							controls.enabled = true;
							container.style.cursor = 'auto';
							INTERSECTED_P=-1;
							moveNode=false;
							arrowX.position.set(-99999999,-99999999,-99999999);
							arrowX.position.needsUpdate = true;
							arrowY.position.set( -99999999,-99999999,-99999999);
							arrowY.position.needsUpdate = true;
							arrowZ.position.set( -99999999,-99999999,-99999999);
							arrowZ.position.needsUpdate = true;
							saveLayout();
						}
					case 1: // middle
						break;
					case 2: // right
						break;
				}
			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {
				controls.update();
				var poscont = $("#container");
				//var cnt_merged=0;
				var cnt_merged_comp={};
				for ( var i = 0; i < listCompartments.length; i ++ ) {
					//cnt_merged=0;
					var vector = new THREE.Vector3( objects[i].position.x+(-radiusComp*objects[i].scale.x),objects[i].position.y,objects[i].position.z);
					var pp = toXYCoords(vector	);
					
					if (pp.x >=0 && pp.y >=0 && pp.x <=poscont.width()-10 && pp.y <=poscont.height()-10){
						document.getElementById("txt"+i).style.top = (pp.y+poscont.position().top+(0*12)) + 'px';
						document.getElementById("txt"+i).style.left = (pp.x +20)+ 'px';
					}
					else{
						document.getElementById("txt"+i).style.top = 4000 + 'px';
						document.getElementById("txt"+i).style.left = 4000+ 'px';
					}
					for (var ref in generalLayout["merged"]){
						if (generalLayout["merged"].hasOwnProperty(ref)){
							if (objects[i].name==ref){
								document.getElementById("txt"+i).style.top = (pp.y+poscont.position().top+(0*12)) + 'px';
								document.getElementById("txt"+i).style.left = (pp.x +20)+ 'px';
							}
							for (var j=0;j<generalLayout["merged"][ref].length;j++){
								if (objects[i].name==generalLayout["merged"][ref][j]){
									 document.getElementById("txt"+i).style.top = (pp.y+poscont.position().top+((j+1)*12)) + 'px';
									 document.getElementById("txt"+i).style.left = (pp.x +20)+ 'px';
								}
							}
						}
					}
					// for (el in list_merged_chains){
						// if (list_merged_chains.hasOwnProperty(el)){
							// if (objects[i].name==el){
								// document.getElementById("txt"+i).style.top = (pp.y+poscont.position().top+(0*12)) + 'px';
								// document.getElementById("txt"+i).style.left = (pp.x +20)+ 'px';
							// }
							// for (var j=0;j<list_merged_chains[el].length;j++){
								// if (objects[i].name==list_merged_chains[el][j]){
									// document.getElementById("txt"+i).style.top = (pp.y+poscont.position().top+((j+1)*12)) + 'px';
									// document.getElementById("txt"+i).style.left = (pp.x +20)+ 'px';
								// }
								
							// }
						// }
					// }					
					document.getElementById("txt"+i).innerHTML = objects[i].name;			
				}			
				renderer.render( scene, camera );
			}

	var $container1 = $("#compTable");
	$container1.handsontable({
	  data: [],
	  width: 400,
	  height:200,
	  dataSchema: {c_id: null, c_name: null},
	  startRows: 1,
	  startCols: 2,
	  contextMenu: ['remove_row'],
	  //maxRows: 1,
	  colHeaders: ['Comp. id', 'Comp. name'],
	  columns: [
		{data: "c_id"},
		{data: "c_name"}
	  ],
	  beforeRemoveRow: function(ind, numb){
		var dt = this.getData();
		
		
	  },
	  afterRemoveRow: function(ind, numb){
		var dt = this.getData();
		
		if (dt[0]['c_id']!=null){
			listCompartments=[];
			for (var i=0, j= dt.length;i<j-1;i++){
				listCompartments.push([dt[i]['c_id'],dt[i]['c_name']]);
				
			}
			nbCompartments= listCompartments.length;
			compIds=[];
			for (var i=0; i<listCompartments.length;i++){
				compIds.push(listCompartments[i][0]);
			}
			// delete meshes
			for ( var i = nbCompartments; i < maxNbComp; i ++ ) {
					objects[i].position.x = -99999999;
					objects[i].position.y = -99999999;
					objects[i].position.z = -99999999;
					objects[i].name="";
					txtComp[i].innerHTML = 'hello ';
					txtComp[i].style.top = 4000 + 'px';
					txtComp[i].style.left = 4000 + 'px';
			}
			// for ( var i = 0; i < listCompartments.length; i ++ ) {
			
				// objects[i].position.x = 0;
				// objects[i].position.y = 0;
				// objects[i].position.z = 0;
				
				// objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
				// objects[i].castShadow = true;
				// objects[i].receiveShadow = true;	
				
			// }
			
			//console.log(dt.length);
			
			
		}
	  },
	  afterChange: function(changes, source) {
		//console.log(changes)
		var dt = this.getData();		
		if (dt[0]['c_id']!=null){
			listCompartments=[];
			for (var i=0, j= dt.length;i<j-1;i++){
				listCompartments.push([dt[i]['c_id'],dt[i]['c_name']]);
				
			}
			nbCompartments= listCompartments.length;
			compIds=[];
			for (var i=0; i<listCompartments.length;i++){
				compIds.push(listCompartments[i][0]);
			}
			
			
			
			for ( var i = 0; i < listCompartments.length; i ++ ) {
				if (!objects[i].name){
					objects[i].position.x = 0;
					objects[i].position.y = 0;
					objects[i].position.z = 0;
					objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
					//objects[i].castShadow = true;
					//objects[i].receiveShadow = true;	
				}
				
			}
			
			nameComp=[];
			mapComp = {'-1':-1};
			
			for (var i=0;i<listCompartments.length;i++){
				mapComp[listCompartments[i][0]]=i;
				nameComp.push(listCompartments[i][1]);
			}
			
			var indexStartNodes=maxNbComp+3;
			
			for ( var i = 0; i < listCompartments.length; i ++ ) {
				stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
				objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
			}
			mtnlLayout["list_compartments"]=listCompartments;
			saveLayout();
			//console.log(mtnlLayout["list_compartments"])
			
			//console.log(listCompartments);
			//console.log(dt.length);
			
			// selectedMetabolicData[0]=listCompartments;
			// var indexStartNodes=maxNbComp+3;
			// nbCompartments= listCompartments.length;
			// stackCompInitialPos={};
			// for (var i=0; i<listCompartments.length;i++ ){
				// stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
			// }
			// for (var c=indexStartNodes;c<indexStartNodes+2;c++){
				// for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
					// for (var g=0;g<nbCompartments;g++){
						// if (scene.children[c].geometry.attributes.compartment.array[h]==g){
						// //nameComp[g]
						// scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x;
						// scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y;
						// scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z;
						// //scene.children[c].geometry.attributes.position.array[h*3+1]+=1000;
						// //scene.children[c].geometry.attributes.position.array[h*3+2]+=1000;
						// }
					// }
				// }
				// scene.children[c].geometry.attributes.position.needsUpdate = true;
			// }
			// var iv=0;
			// for ( var i = 0; i < segments; i ++ ) {
				// var t1 = metabolicNodes[metabolicEdges[i][0]][6]
				// var t2 = metabolicNodes[metabolicEdges[i][1]][6]
				// //console.log(t1)
				// //console.log(t2)
				// //var ivList=[]
				// var doIt=0
				// if (t1==2){
					// //console.log(idMap[jsonObj2[i][0]][1])
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					
					// iv++;
				// }
				// else if (t1==4){
					// //console.log(idMap[jsonObj2[i][0]][1])
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					// iv++;
				// }
				// if (t2 ==2){
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
					// iv++;
				// }
				// else if (t2 ==4){
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
					// iv++;
				// }
				
			// }
			// scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
			//console.log(selectedMetabolicData[0]);
		}
		
	  },
	  minSpareRows: 1
	});
	var tempdata1=listCompartments;

	var ht = $('#compTable').handsontable('getInstance');
	if ($.isArray(tempdata1) && tempdata1[0] && $.isArray(tempdata1[0])){
		ht.populateFromArray (0, 0, tempdata1,tempdata1.length-1, 1);
	}
	$("#compTable").css({top:  $("#titleComp").position().top + $("#titleComp").height()+40});
	
	var $container1 = $("#mtnTable");
	$container1.handsontable({
	  data: [],
	  width: 700,
	  height:200,
	  colWidths: [100, 400,150],
	  dataSchema: {n_id:null, n_name: null, c_name: null},
	  startRows: 1,
	  startCols: 3,
	  colHeaders: ['Node nb','Node name', 'Comp. name'],
	  columns: [
		{data: "n_id"},
		{data: "n_name"},
		{data: "c_name"},//, type: 'dropdown',source: compIds}
	  ],
	  beforeChange: function(changes, source) {
		if ((Array.isArray(changes[0])) && changes[0][2] ){
			if (changes[0][1]!="c_name" && changes[0][1]!="n_name"){
				changes.length=0;
				return false;
			}
			else{ 
				if (changes[0][1]=="c_name" && compIds.indexOf(changes[0][3])==-1){
					changes.length=0;
					return false;
				}
			}
		}
		
	  },
	  afterChange: function(changes, source) {
		
		if (changes && changes[0] && changes[0][2]){	
			
					
			var dt = this.getData(changes[0][0],0,0,2);		
			//console.log(changes)	
			//console.log(dt)	
			//console.log(dt[changes[0][0]])	
			// change name			
			selectedMetabolicData[1][dt[dt.length-1][0]][1]=dt[dt.length-1][1];
			// change compartment
			selectedMetabolicData[1][dt[dt.length-1][0]][3]=dt[dt.length-1][2];
			metabolicNodes=selectedMetabolicData[1];
			mtnlLayout["nodes_compartments"][dt[dt.length-1][0]]=[];
			mtnlLayout["nodes_compartments"][dt[dt.length-1][0]].push(dt[dt.length-1][1]);
			mtnlLayout["nodes_compartments"][dt[dt.length-1][0]].push(dt[dt.length-1][2]);
			saveLayout();
			//console.log(mtnlLayout["nodes_compartments"])
			//console.log(mtnlLayout["nodes_compartments"][dt[dt.length-1][0]])
			//console.log(dt)
			//console.log("new name: "+dt[changes[0][0]][1])
			//console.log("new comp: "+dt[changes[0][0]][2])
			
			var indexStartNodes=maxNbComp+3;
			nbCompartments= listCompartments.length;
			
			nameComp=[];
			mapComp = {'-1':-1};
			
			for (var i=0;i<listCompartments.length;i++){
				mapComp[listCompartments[i][0]]=i;
				nameComp.push(listCompartments[i][1]);
			}
			
			//idMap[bw]=[2,bv];
			//scene.children[indexStartNodes].geometry.attributes.compartment.array[h]
			var oldComp;
			if (idMap[dt[changes[0][0]][0]] && idMap[dt[changes[0][0]][0]][0]==2){
				//console.log(dt[0][2])
				//console.log(mapComp[dt[0][2]]);
				//console.log (scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[dt[0][0]][1]]);
				oldComp = scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[dt[changes[0][0]][0]][1]];
				scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[dt[changes[0][0]][0]][1]]=mapComp[dt[changes[0][0]][2]];
				scene.children[indexStartNodes].geometry.attributes.compartment.needsUpdate = true;
			}
			for ( var i = 0; i < listCompartments.length; i ++ ) {
				stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
				objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
			}
			
			
			var bv=0;
			for( var bw = 0 , bww= metabolicNodes.length; bw < bww; bw++ ) {
				if (metabolicNodes[bw][6]==4){
					
					//b5values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;					
					// try to assign the compartment of the majority of the products the reaction is linked to 
					// if there is no product, assign the compartment of the majority of modifiers
					// if there is no modifier, assign the compartment of the majority of reactants
					var listProducts= metabolicNodes[bw][11][0];
					var listModifiers= metabolicNodes[bw][11][1];
					var listReactants= metabolicNodes[bw][11][2];
					
					if (listProducts.length>0){
						var votes=[];
						for (var ncc=0;ncc<nbCompartments;ncc++){
							votes[ncc]=0;
						}
						for(var lp=0;lp<listProducts.length;lp++){
							if (mapComp[metabolicNodes[listProducts[lp]][3]]>=0)
								votes[mapComp[metabolicNodes[listProducts[lp]][3]]]++;
						}
						var winner= votes.indexOf(Math.max.apply( Math, votes ));
						//compartmentP2[ bv ] = winner;
						scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv]= winner;
						if (winner==-1){
							scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = mapComp[metabolicNodes[bw][3]];
						}
					} 
					else if (listModifiers.length>0){
						var votes=[];
						for (var ncc=0;ncc<nbCompartments;ncc++){
							votes[ncc]=0;
						}
						for(var lp=0;lp<listModifiers.length;lp++){
							if (mapComp[metabolicNodes[listModifiers[lp]][3]]>=0)
								votes[mapComp[metabolicNodes[listModifiers[lp]][3]]]++;
						}
						var winner= votes.indexOf(Math.max.apply( Math, votes ));
						scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = winner;
						
						if (winner==-1){
							scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = mapComp[metabolicNodes[bw][3]];
						}
					}
					else if (listReactants.length>0){
						var votes=[];
						for (var ncc=0;ncc<nbCompartments;ncc++){
							votes[ncc]=0;
						}
						for(var lp=0;lp<listReactants.length;lp++){
							if (mapComp[metabolicNodes[listReactants[lp]][3]]>=0)
								votes[mapComp[metabolicNodes[listReactants[lp]][3]]]++;
						}
						var winner= votes.indexOf(Math.max.apply( Math, votes ));
						scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = winner;
						if (winner==-1){
							scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = mapComp[metabolicNodes[bw][3]];
						}
					}
					else {
						scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv]= mapComp[metabolicNodes[bw][3]];
					}
					bv++;
				}	
			}		
			scene.children[indexStartNodes+1].geometry.attributes.compartment.needsUpdate = true;
	
			for (var c=indexStartNodes;c<indexStartNodes+2;c++){
				for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
					for (var g=0;g<nbCompartments;g++){
						if (scene.children[c].geometry.attributes.compartment.array[h]==g){
							if (g==mapComp[dt[changes[0][0]][2]] && h==idMap[dt[changes[0][0]][0]][1]){
								scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x+(stackCompInitialPos[objects[g].name].x-stackCompInitialPos[objects[oldComp].name].x);//+stackCompInitialPos[objects[oldComp].name].x;
								scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y+(stackCompInitialPos[objects[g].name].y-stackCompInitialPos[objects[oldComp].name].y);//+stackCompInitialPos[objects[oldComp].name].y;
								scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z+(stackCompInitialPos[objects[g].name].z-stackCompInitialPos[objects[oldComp].name].z);//+stackCompInitialPos[objects[oldComp].name].z;
							}
							else{
						//nameComp[g]
						scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x;
						scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y;
						scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z;
						}
						//scene.children[c].geometry.attributes.position.array[h*3+1]+=1000;
						//scene.children[c].geometry.attributes.position.array[h*3+2]+=1000;
						}
					}
				}
				scene.children[c].geometry.attributes.position.needsUpdate = true;
			}
			var iv=0;
			for ( var i = 0; i < segments; i ++ ) {
				var t1 = metabolicNodes[metabolicEdges[i][0]][6]
				var t2 = metabolicNodes[metabolicEdges[i][1]][6]
				//console.log(t1)
				//console.log(t2)
				//var ivList=[]
				var doIt=0
				if (t1==2){
					//console.log(idMap[jsonObj2[i][0]][1])
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					
					iv++;
				}
				else if (t1==4){
					//console.log(idMap[jsonObj2[i][0]][1])
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					iv++;
				}
				if (t2 ==2){
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
					iv++;
				}
				else if (t2 ==4){
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
					scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
					iv++;
				}
				
			}
			scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
			
		}
		
		
	  },
	  columnSorting: true,
	  minSpareRows: 1
	});
	
	
	
	//listNodes=selectedMetabolicData[1];
	var tempdata2=[];
	for (var i=0, j= listNodes.length;i<j;i++){
		if (listNodes[i][6]==2){
			tempdata2.push([i,listNodes[i][1],listNodes[i][3]])
		}
	}
	

	var ht = $('#mtnTable').handsontable('getInstance');
	if ($.isArray(tempdata2) && tempdata2[0] && $.isArray(tempdata2[0])){
		ht.populateFromArray (0, 0, tempdata2,tempdata2.length-1, 2);
	}
	
	
	var $container2 = $("#mtnTable2");
	$container2.handsontable({
	  data: [],
	  width: 1150,
	  height:200,
	  colWidths: [100, 400,100,200,300],
	  dataSchema: {n_id:null, n_name: null, c_name: null, subsystem: null, rule:null},
	  startRows: 1,
	  startCols: 5,
	  colHeaders: ['Node nb','Node name', 'Comp. name', 'Sub-System','Rule'],
	  columns: [
		{data: "n_id"},
		{data: "n_name"},
		{data: "c_name"},
		{data: "subsystem"},
		{data: "rule"}//, type: 'dropdown',source: compIds}
	  ],
	  beforeChange: function(changes, source) {
		// if ((Array.isArray(changes[0])) && changes[0][2] ){
			// if (changes[0][1]!="c_name" && changes[0][1]!="n_name"){
				// changes.length=0;
				// return false;
			// }
			// else{ 
				// if (changes[0][1]=="c_name" && compIds.indexOf(changes[0][3])==-1){
					// changes.length=0;
					// return false;
				// }
			// }
		// }
		
	  },
	  afterChange: function(changes, source) {
		
		// if (changes && changes[0] && changes[0][2]){	
			
					
			// var dt = this.getData(changes[0][0],0,0,2);		
			// //console.log(changes)	
			// //console.log(dt)	
			// //console.log(dt[changes[0][0]])	
			// // change name			
			// selectedMetabolicData[1][dt[dt.length-1][0]][1]=dt[dt.length-1][1];
			// // change compartment
			// selectedMetabolicData[1][dt[dt.length-1][0]][3]=dt[dt.length-1][2];
			// metabolicNodes=selectedMetabolicData[1];
			// mtnlLayout["nodes_compartments"][dt[dt.length-1][0]]=[];
			// mtnlLayout["nodes_compartments"][dt[dt.length-1][0]].push(dt[dt.length-1][1]);
			// mtnlLayout["nodes_compartments"][dt[dt.length-1][0]].push(dt[dt.length-1][2]);
			// saveLayout();
			// //console.log(mtnlLayout["nodes_compartments"])
			// //console.log(mtnlLayout["nodes_compartments"][dt[dt.length-1][0]])
			// //console.log(dt)
			// //console.log("new name: "+dt[changes[0][0]][1])
			// //console.log("new comp: "+dt[changes[0][0]][2])
			
			// var indexStartNodes=maxNbComp+3;
			// nbCompartments= listCompartments.length;
			
			// nameComp=[];
			// mapComp = {'-1':-1};
			
			// for (var i=0;i<listCompartments.length;i++){
				// mapComp[listCompartments[i][0]]=i;
				// nameComp.push(listCompartments[i][1]);
			// }
			
			// //idMap[bw]=[2,bv];
			// //scene.children[indexStartNodes].geometry.attributes.compartment.array[h]
			// var oldComp;
			// if (idMap[dt[changes[0][0]][0]] && idMap[dt[changes[0][0]][0]][0]==2){
				// //console.log(dt[0][2])
				// //console.log(mapComp[dt[0][2]]);
				// //console.log (scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[dt[0][0]][1]]);
				// oldComp = scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[dt[changes[0][0]][0]][1]];
				// scene.children[indexStartNodes].geometry.attributes.compartment.array[idMap[dt[changes[0][0]][0]][1]]=mapComp[dt[changes[0][0]][2]];
				// scene.children[indexStartNodes].geometry.attributes.compartment.needsUpdate = true;
			// }
			// for ( var i = 0; i < listCompartments.length; i ++ ) {
				// stackCompInitialPos[objects[i].name]= new THREE.Vector3(objects[i].position.x,objects[i].position.y,objects[i].position.z);
				// objects[i].name=listCompartments[i][0]+" "+listCompartments[i][1];
			// }
			
			
			// var bv=0;
			// for( var bw = 0 , bww= metabolicNodes.length; bw < bww; bw++ ) {
				// if (metabolicNodes[bw][6]==4){
					
					// //b5values_compartment[ bv ] = Math.floor(Math.random()*nbCompartments) + 0;					
					// // try to assign the compartment of the majority of the products the reaction is linked to 
					// // if there is no product, assign the compartment of the majority of modifiers
					// // if there is no modifier, assign the compartment of the majority of reactants
					// var listProducts= metabolicNodes[bw][11][0];
					// var listModifiers= metabolicNodes[bw][11][1];
					// var listReactants= metabolicNodes[bw][11][2];
					
					// if (listProducts.length>0){
						// var votes=[];
						// for (var ncc=0;ncc<nbCompartments;ncc++){
							// votes[ncc]=0;
						// }
						// for(var lp=0;lp<listProducts.length;lp++){
							// if (mapComp[metabolicNodes[listProducts[lp]][3]]>=0)
								// votes[mapComp[metabolicNodes[listProducts[lp]][3]]]++;
						// }
						// var winner= votes.indexOf(Math.max.apply( Math, votes ));
						// //compartmentP2[ bv ] = winner;
						// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv]= winner;
						// if (winner==-1){
							// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = mapComp[metabolicNodes[bw][3]];
						// }
					// } 
					// else if (listModifiers.length>0){
						// var votes=[];
						// for (var ncc=0;ncc<nbCompartments;ncc++){
							// votes[ncc]=0;
						// }
						// for(var lp=0;lp<listModifiers.length;lp++){
							// if (mapComp[metabolicNodes[listModifiers[lp]][3]]>=0)
								// votes[mapComp[metabolicNodes[listModifiers[lp]][3]]]++;
						// }
						// var winner= votes.indexOf(Math.max.apply( Math, votes ));
						// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = winner;
						
						// if (winner==-1){
							// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = mapComp[metabolicNodes[bw][3]];
						// }
					// }
					// else if (listReactants.length>0){
						// var votes=[];
						// for (var ncc=0;ncc<nbCompartments;ncc++){
							// votes[ncc]=0;
						// }
						// for(var lp=0;lp<listReactants.length;lp++){
							// if (mapComp[metabolicNodes[listReactants[lp]][3]]>=0)
								// votes[mapComp[metabolicNodes[listReactants[lp]][3]]]++;
						// }
						// var winner= votes.indexOf(Math.max.apply( Math, votes ));
						// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = winner;
						// if (winner==-1){
							// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv] = mapComp[metabolicNodes[bw][3]];
						// }
					// }
					// else {
						// scene.children[indexStartNodes+1].geometry.attributes.compartment.array[bv]= mapComp[metabolicNodes[bw][3]];
					// }
					// bv++;
				// }	
			// }		
			// scene.children[indexStartNodes+1].geometry.attributes.compartment.needsUpdate = true;
	
			// for (var c=indexStartNodes;c<indexStartNodes+2;c++){
				// for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
					// for (var g=0;g<nbCompartments;g++){
						// if (scene.children[c].geometry.attributes.compartment.array[h]==g){
							// if (g==mapComp[dt[changes[0][0]][2]] && h==idMap[dt[changes[0][0]][0]][1]){
								// scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x+(stackCompInitialPos[objects[g].name].x-stackCompInitialPos[objects[oldComp].name].x);//+stackCompInitialPos[objects[oldComp].name].x;
								// scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y+(stackCompInitialPos[objects[g].name].y-stackCompInitialPos[objects[oldComp].name].y);//+stackCompInitialPos[objects[oldComp].name].y;
								// scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z+(stackCompInitialPos[objects[g].name].z-stackCompInitialPos[objects[oldComp].name].z);//+stackCompInitialPos[objects[oldComp].name].z;
							// }
							// else{
						// //nameComp[g]
						// scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x;
						// scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y;
						// scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z;
						// }
						// //scene.children[c].geometry.attributes.position.array[h*3+1]+=1000;
						// //scene.children[c].geometry.attributes.position.array[h*3+2]+=1000;
						// }
					// }
				// }
				// scene.children[c].geometry.attributes.position.needsUpdate = true;
			// }
			// var iv=0;
			// for ( var i = 0; i < segments; i ++ ) {
				// var t1 = metabolicNodes[metabolicEdges[i][0]][6]
				// var t2 = metabolicNodes[metabolicEdges[i][1]][6]
				// //console.log(t1)
				// //console.log(t2)
				// //var ivList=[]
				// var doIt=0
				// if (t1==2){
					// //console.log(idMap[jsonObj2[i][0]][1])
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					
					// iv++;
				// }
				// else if (t1==4){
					// //console.log(idMap[jsonObj2[i][0]][1])
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
					// iv++;
				// }
				// if (t2 ==2){
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
					// iv++;
				// }
				// else if (t2 ==4){
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
					// scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
					// iv++;
				// }
				
			// }
			// scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
			
		// }
		
		
	  },
	  columnSorting: true,
	  minSpareRows: 1
	});
	
	//listNodes=selectedMetabolicData[1];
	var tempdata3=[];
	for (var i=0, j= listNodes.length;i<j;i++){
		if (listNodes[i][6]==4){
			var cp =listNodes[i][3];
			if (listNodes[i][3]=="-1"){
				cp="automated";
			}
			var sbsys=""
			if (listNodes[i][4] && listNodes[i][4][1] && listNodes[i][4][1][0]){
				sbsys = listNodes[i][4][1][0];
			}
			var rule="";
			if (listNodes[i][11]){
				if (listNodes[i][11][0]){
					for (var k=0;k<listNodes[i][11][0].length;k++){
						if (k!=listNodes[i][11][0].length-1){
							rule += listNodes[listNodes[i][11][0][k]][1]+" + ";
						}
						else{
							rule += listNodes[listNodes[i][11][0][k]][1]+" ";
						}
					}
					
				}
				if (listNodes[i][11][2]){
					for (var k=0;k<listNodes[i][11][2].length;k++){
						if (k!=listNodes[i][11][2].length-1){
							rule += listNodes[listNodes[i][11][2][k]][1]+" + ";
						}
						else{
							rule += listNodes[listNodes[i][11][2][k]][1]+" ";
						}
					}
					
				}
				if (listNodes[i][11][1]){
					rule += " = "
					for (var k=0;k<listNodes[i][11][1].length;k++){
						if (k!=listNodes[i][11][1].length-1){
							rule += listNodes[listNodes[i][11][1][k]][1]+" + ";
						}
						else{
							rule += listNodes[listNodes[i][11][1][k]][1]+" ";
						}
					}
					
				}
				
			}
			tempdata3.push([i,listNodes[i][1],cp,sbsys,rule])
			
		}
	}
	

	var ht = $('#mtnTable2').handsontable('getInstance');
	if ($.isArray(tempdata3) && tempdata3[0] && $.isArray(tempdata3[0])){
		ht.populateFromArray (0, 0, tempdata3,tempdata3.length-1, 4);
	}
	
	
	//console.log(ht)
	//ht.data.columns[0].readOnly=true;
	//ht.columns[1].readOnly=true;
	//$("#compTable").css({top:  $("#container").position().top + $("#container").height()+40});
	$("#searchfield").css({top:  $("#compTable").position().top + $("#compTable").height()+40});
	$("#mtnTable").css({top:  $("#searchfield").position().top + $("#searchfield").height()+10});
	$("#searchfield2").css({top:  $("#mtnTable").position().top + $("#mtnTable").height()+40});
	$("#mtnTable2").css({top:  $("#searchfield2").position().top + $("#searchfield2").height()+10});
	$("#titleEditor").css({top:  $("#mtnTable2").position().top + $("#mtnTable2").height()+40});
	$("#container").css({top:  $("#titleEditor").position().top + $("#titleEditor").height()+40});
	$("#editplane").css({top:  $("#container").position().top + $("#container").height()-40});
	
	$('#searchgrid').on('keyup',function(event){
		var value = ('' + this.value).toLowerCase(),row,col,r_len,c_len,td;
		
		tempdata2=[];
		for (var i=0, j= listNodes.length;i<j;i++){
			tempdata2.push([i,listNodes[i][1],listNodes[i][3]])
		}
		var data = tempdata2;
		
		//var data = $('#tab2id').handsontable('getData');
		//console.log(data)
		var searcharray = [];
		if(value){
			
			for(row=0,r_len = data.length;row< r_len;row++){
				for(col=0,c_len = data[row].length;col < c_len-1; col++){
					if(data[row][col] == null){
						continue;
					}
					if(('' + data[row][col]).toLowerCase().indexOf(value) > -1){
						searcharray.push(data[row]);
						break;
					}
					else{
					}
				}
			}
			
			//console.log(searcharray.length)
			var ht = $('#mtnTable').handsontable('getInstance');
			//ht.clear();
			ht.alter('remove_row', 0, tempdata2.length);
			//console.log(searcharray)
			tempdata2=searcharray;
			if ($.isArray(searcharray) && searcharray[0] && $.isArray(searcharray[0])){
				ht.populateFromArray (0, 0, searcharray,searcharray.length-1, 2);
			}
		}
		else{
			tempdata2=[];
			for (var i=0, j= listNodes.length;i<j;i++){
				tempdata2.push([i,listNodes[i][1],listNodes[i][3]])
			}
			var ht = $('#mtnTable').handsontable('getInstance');
			ht.alter('remove_row', 0, tempdata2.length);
			if ($.isArray(tempdata2) && tempdata2[0] && $.isArray(tempdata2[0])){
				ht.populateFromArray (0, 0, tempdata2,tempdata2.length-1, 2);
			}
		}
		$('#mtnTable').handsontable('deselectCell');
			
		
	});
	
	function placeCompFromLayout(cName, cRef, dropType){
		var initialCnamePos= new THREE.Vector3(0,0,0);
		
		
								
		if (dropType=='merged'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			for (var ref in generalLayout["merged"]){
				if (generalLayout["merged"].hasOwnProperty(ref)){
					if (cName==ref || generalLayout["merged"][ref].indexOf(cName)!=-1 ){
						
						for (var j=0; j<listCompartments.length;j++ ){
							if (objects[j].name==ref || generalLayout["merged"][ref].indexOf(objects[j].name)!=-1){
								//if (generalLayout["merged"][ref].indexOf(objects[j].name)!=-1){
								//stackCompInitialPos[objects[j].name].x=objects[indRef].position.x;
								//stackCompInitialPos[objects[j].name].y=objects[indRef].position.y;
								//stackCompInitialPos[objects[j].name].z=objects[indRef].position.z;
								//}
								//if (objects[j].name==cName){
								//console.log(objects[j].position.x)
								//console.log(stackCompInitialPos[cRef].x)
								//initialCnamePos.x=stackCompInitialPos[cRef].x;
								//initialCnamePos.y=stackCompInitialPos[cRef].y;
								//initialCnamePos.z=stackCompInitialPos[cRef].z;
								//}
								
								//objects[j].position.copy( objects[indRef].position );
								//objects[j].position.x=objects[indRef].position.x;
								//objects[j].position.y=objects[indRef].position.y;
								//objects[j].position.z=objects[indRef].position.z;
								
								objects[j].scale.x=objects[indRef].scale.x;
								objects[j].scale.y=objects[indRef].scale.y;
								objects[j].scale.z=objects[indRef].scale.z;
							}
						}
					}
				}
			}
		}
		if (dropType=='outer'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			for (var ref in generalLayout["outer"]){
				if (generalLayout["outer"].hasOwnProperty(ref)){
					if (cName==ref || generalLayout["outer"][ref].indexOf(cName)!=-1 ){
						mustMove=true;
						for (var j=0; j<listCompartments.length;j++ ){
							var indPos = generalLayout["outer"][ref].indexOf(objects[j].name);
							if (objects[j].name==ref ){
								objects[j].position.copy( objects[indRef].position );
							}
							else if (indPos!=-1){
								objects[j].position.copy( objects[indRef].position );
								//console.log(indPos)
								objects[j].scale.x = 2+indPos;
								objects[j].scale.z = 2+indPos;
							}
							else{}
						}
					}
				}
			}
		}
		if (dropType=='satellite'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			var isRefSatellite=false;
			for (var ref in generalLayout["satellite"]){
				if (generalLayout["satellite"].hasOwnProperty(ref)){
					if (generalLayout["satellite"][ref].indexOf(cRef)!=-1){
						isRefSatellite=true;
					}
				}
			}
			
			var lenOuter=0;
			var nameOuterRef="";
			for (var ref in generalLayout["outer"]){
				if (generalLayout["outer"].hasOwnProperty(ref)){
					var tmpInd=generalLayout["outer"][ref].indexOf(cRef);
					if (cRef==ref ){
						nameOuterRef=ref;
						lenOuter=generalLayout["outer"][ref].length+1;
					}
					else if (tmpInd!=-1 ){
						nameOuterRef=ref;
						lenOuter=generalLayout["outer"][ref].length+1;
					}
					else{}
				}
			}
			var indOuterRef;
			for (var i=0; i<listCompartments.length;i++ ){
				if (objects[i].name==nameOuterRef && objects[i].name!=""){
					indOuterRef=i;
				}
			}
			//console.log(lenOuter)
			for (var ref in generalLayout["satellite"]){
				if (generalLayout["satellite"].hasOwnProperty(ref)){
					var indSat=generalLayout["satellite"][ref].indexOf(cName);
					if (cName==ref || indSat!=-1 ){
						mustMove=true;
						if (indSat!=-1){
							if (lenOuter==0){
								for (var j=0; j<generalLayout["satellite"][ref].length;j++ ){
									var max_rotation_count=generalLayout["satellite"][ref].length;
									var dilation_count=0;
									var tmpNode= generalLayout["satellite"][ref][j];
									for (var j1=0; j1<listCompartments.length;j1++ ){
										if (objects[j1].name==tmpNode && objects[j1].name!=""){
											var scaledSpacing=spacing;
											if (isRefSatellite){
												objects[j1].scale.x=objects[indRef].scale.x*0.417777;
												objects[j1].scale.y=objects[indRef].scale.y*0.417777;
												objects[j1].scale.z=objects[indRef].scale.z*0.417777;
												scaledSpacing=scaledSpacing/((1/(objects[indRef].scale.x)));
											}
											objects[j1].position.x=objects[indRef].position.x+Math.cos(((2 * Math.PI)*(1/max_rotation_count))*j)*(scaledSpacing+((lenOuter)*scaledSpacing/2));
											objects[j1].position.y=objects[indRef].position.y;
											objects[j1].position.z=objects[indRef].position.z+Math.sin(((2 * Math.PI)*(1/max_rotation_count))*j)*(scaledSpacing+((lenOuter)*scaledSpacing/2));
											objects[j1].scale.x=objects[indRef].scale.x*0.417777;
											objects[j1].scale.y=objects[indRef].scale.y*0.417777;
											objects[j1].scale.z=objects[indRef].scale.z*0.417777;
										}
									}
								}
							}
							if (lenOuter>0){
								for (var j=0; j<generalLayout["satellite"][ref].length;j++ ){
									var max_rotation_count=generalLayout["satellite"][ref].length;
									var dilation_count=0;
									var tmpNode= generalLayout["satellite"][ref][j];
									for (var j1=0; j1<listCompartments.length;j1++ ){
										if (objects[j1].name==tmpNode && objects[j1].name!=""){
											var scaledSpacing=spacing;
											if (isRefSatellite){
												objects[j1].scale.x=objects[indOuterRef].scale.x*lenOuter*0.417777;
												objects[j1].scale.y=objects[indOuterRef].scale.y*lenOuter*0.417777;
												objects[j1].scale.z=objects[indOuterRef].scale.z*lenOuter*0.417777;
												scaledSpacing=scaledSpacing/((1/(objects[indOuterRef].scale.x)));
											}
											objects[j1].position.x=objects[indRef].position.x+Math.cos(((2 * Math.PI)*(1/max_rotation_count))*j)*(scaledSpacing+((lenOuter)*scaledSpacing/2));
											objects[j1].position.y=objects[indRef].position.y;
											objects[j1].position.z=objects[indRef].position.z+Math.sin(((2 * Math.PI)*(1/max_rotation_count))*j)*(scaledSpacing+((lenOuter)*scaledSpacing/2));
											objects[j1].scale.x=objects[indOuterRef].scale.x*lenOuter*0.417777;
											objects[j1].scale.y=objects[indOuterRef].scale.y*lenOuter*0.417777;
											objects[j1].scale.z=objects[indOuterRef].scale.z*lenOuter*0.417777;
										}
									}
								}
							}
						}
						else{}
					}
				}
			}
			
		}
		
		
		if (dropType=='in'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			var isRefSatellite=false;
			for (var ref in generalLayout["in"]){
				if (generalLayout["in"].hasOwnProperty(ref)){
					if (generalLayout["in"][ref].indexOf(cRef)!=-1){
						isRefSatellite=true;
					}
				}
			}
			var indOuter=-1;
			var lenOuter=0;
			for (var ref in generalLayout["outer"]){
				if (generalLayout["outer"].hasOwnProperty(ref)){
					var tmpInd=generalLayout["outer"][ref].indexOf(cRef);
					if (cName==ref ){
						indOuter=0;
						lenOuter=generalLayout["outer"][ref].length+1;
					}
					else if (tmpInd!=-1 ){
						indOuter=tmpInd+1;
						lenOuter=generalLayout["outer"][ref].length+1;
					}
					else{}
				}
			}
			
			for (var ref in generalLayout["in"]){
				if (generalLayout["in"].hasOwnProperty(ref)){
					var indSat=generalLayout["in"][ref].indexOf(cName);
					if (cName==ref || indSat!=-1 ){
						mustMove=true;
						if (indSat!=-1){
							for (var j=0; j<generalLayout["in"][ref].length;j++ ){
								var max_rotation_count=generalLayout["in"][ref].length;								
								var tmpNode= generalLayout["in"][ref][j];								
								for (var j1=0; j1<listCompartments.length;j1++ ){
									if (objects[j1].name==tmpNode && objects[j1].name!=""){
										var scaledSpacing=radiusComp*objects[indRef].scale.x*0.72;
										if (lenOuter>1){
												scaledSpacing=(radiusComp*objects[indRef].scale.x)-(radiusComp*objects[indRef].scale.x*(1/((lenOuter+1)*2))*1.4);
										}
										
										if (isRefSatellite){
											objects[j1].scale.x=objects[indRef].scale.x*0.20;
											objects[j1].scale.y=objects[indRef].scale.y*0.20;
											objects[j1].scale.z=objects[indRef].scale.z*0.20;
											scaledSpacing=scaledSpacing/((1/(objects[indRef].scale.x)));
											
										}
										objects[j1].position.x=objects[indRef].position.x+Math.cos(((2 * Math.PI)*(1/max_rotation_count))*j)*(scaledSpacing);
										objects[j1].position.y=objects[indRef].position.y;
										objects[j1].position.z=objects[indRef].position.z+Math.sin(((2 * Math.PI)*(1/max_rotation_count))*j)*(scaledSpacing);
										
										if (lenOuter>1){
											objects[j1].scale.x=objects[indRef].scale.x*(1/((lenOuter+1)*2));
											objects[j1].scale.y=objects[indRef].scale.y*(1/((lenOuter+1)*2));
											objects[j1].scale.z=objects[indRef].scale.z*(1/((lenOuter+1)*2));
										}
										else{
											objects[j1].scale.x=objects[indRef].scale.x*0.20;
											objects[j1].scale.y=objects[indRef].scale.y*0.20;
											objects[j1].scale.z=objects[indRef].scale.z*0.20;
										}
										var maxDiameter=((2 * Math.PI)*objects[indRef].scale.x*radiusComp*0.72)*(1/(max_rotation_count*2));
										var presentDiameter=(objects[j1].scale.x*radiusComp*2);
										if (maxDiameter<=presentDiameter){
											objects[j1].scale.x=objects[j1].scale.x*((maxDiameter/presentDiameter)*1.1)
											objects[j1].scale.y=objects[j1].scale.y*((maxDiameter/presentDiameter)*1.1)
											objects[j1].scale.z=objects[j1].scale.z*((maxDiameter/presentDiameter)*1.1)
										}
										//console.log("max: "+maxDiameter + " present: "+presentDiameter);
									}
								}
							}
						}
						else{}
					}
				}
			}
		}
		
		if (dropType=='above'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			var indCname;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cName){
					indCname=j;
				}
			}
			for (var ref in generalLayout["above"]){
				if (generalLayout["above"].hasOwnProperty(ref)){
					if (cName==ref || generalLayout["above"][ref].indexOf(cName)!=-1 ){
						
						
						var ind=generalLayout["above"][ref].indexOf(cName);
						
						if (cName==ref ){
							var tmpRef;
							for (var j=0; j<listCompartments.length;j++ ){
								if (objects[j].name==ref){
									tmpRef=j;
									objects[j].position.setX(objects[indRef].position.x);
									objects[j].position.setZ(objects[indRef].position.z);
									//console.log(ref)
								}
							}
							for (var j=0; j<generalLayout["above"][ref].length;j++ ){
								var tmpNode= generalLayout["above"][ref][j];
								for (var j1=0; j1<listCompartments.length;j1++ ){
									if (objects[j1].name==tmpNode && objects[j1].name!=""){
										objects[j1].position.setX(objects[tmpRef].position.x);
										objects[j1].position.setZ(objects[tmpRef].position.z);
										objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
									}
								}
							}
						}
						
						if (ind!=-1){
							var tmpRef;
							for (var j=0; j<listCompartments.length;j++ ){
								if (objects[j].name==ref){
									tmpRef=j;
									objects[j].position.setX(objects[indRef].position.x);
									objects[j].position.setZ(objects[indRef].position.z);
									//objects[j].position.setZ(SELECTED.position.z);
								}
							}
							for (var j=0; j<generalLayout["above"][ref].length;j++ ){
								var tmpNode= generalLayout["above"][ref][j];
								for (var j1=0; j1<listCompartments.length;j1++ ){
									if (objects[j1].name==tmpNode && objects[j1].name!=""){
										objects[j1].position.setX(objects[tmpRef].position.x);
										objects[j1].position.setZ(objects[tmpRef].position.z);
										objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
									}
								}
							}
						}
						
						
							
								
					}
				}
			}
		}
		
		if (dropType=='below'){
			var indRef;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cRef){
					indRef=j;
				}
			}
			
			var indCname;
			for (var j=0; j<listCompartments.length;j++ ){
				if (objects[j].name==cName){
					indCname=j;
				}
			}
			for (var ref in generalLayout["above"]){
			
				if (generalLayout["above"].hasOwnProperty(ref)){
					if (cName==ref || generalLayout["above"][ref].indexOf(cName)!=-1 ){
						
						
						var ind=generalLayout["above"][ref].indexOf(cName);
						
						if (cName==ref ){
							var tmpRef;
							for (var j=0; j<listCompartments.length;j++ ){
								if (objects[j].name==ref){
									tmpRef=j;
									objects[indRef].position.y-=spacing;
									objects[j].position.setX(objects[indRef].position.x);
									objects[j].position.setZ(objects[indRef].position.z);
									objects[j].position.setY(objects[indRef].position.y);
									//console.log(ref)
								}
							}
							for (var j=0; j<generalLayout["above"][ref].length;j++ ){
								var tmpNode= generalLayout["above"][ref][j];
								for (var j1=0; j1<listCompartments.length;j1++ ){
									if (objects[j1].name==tmpNode && objects[j1].name!=""){
										objects[j1].position.setX(objects[tmpRef].position.x);
										objects[j1].position.setZ(objects[tmpRef].position.z);
										objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
									}
								}
							}
						}
						
						if (ind!=-1){
							var tmpRef;
							for (var j=0; j<listCompartments.length;j++ ){
								if (objects[j].name==ref){
									tmpRef=j;
									objects[j].position.setX(objects[indRef].position.x);
									objects[j].position.setZ(objects[indRef].position.z);
									//objects[j].position.setZ(SELECTED.position.z);
								}
							}
							for (var j=0; j<generalLayout["above"][ref].length;j++ ){
								var tmpNode= generalLayout["above"][ref][j];
								for (var j1=0; j1<listCompartments.length;j1++ ){
									if (objects[j1].name==tmpNode && objects[j1].name!=""){
										objects[j1].position.setX(objects[tmpRef].position.x);
										objects[j1].position.setZ(objects[tmpRef].position.z);
										objects[j1].position.setY(objects[tmpRef].position.y+((j+1)*spacing));
									}
								}
							}
						}
						
						
							
								
					}
				}
			}
		}
		
		
		for (var ref in generalLayout["merged"]){
			if (generalLayout["merged"].hasOwnProperty(ref)){	
					var indC;
					for (var j=0; j<listCompartments.length;j++ ){
						if (objects[j].name==ref ){
							indC=j;
						}
					}
					for (var j=0; j<listCompartments.length;j++ ){
						if (objects[j].name==ref || generalLayout["merged"][ref].indexOf(objects[j].name)!=-1){
							
							objects[j].position.copy( objects[indC].position );
							objects[j].scale.x=objects[indC].scale.x;
							objects[j].scale.y=objects[indC].scale.y;
							objects[j].scale.z=objects[indC].scale.z;
							
							
						}
					}
				
			}
		}
		
		//myLayout["compartments_layout"]["structure"]=generalLayout;
		//var layoutdata={};
		//for (var j=0; j<listCompartments.length;j++ ){
		//	layoutdata[objects[j].name]={"position":new THREE.Vector3(objects[j].position.x,objects[j].position.y,objects[j].position.z), "scale":new THREE.Vector3(objects[j].scale.x,objects[j].scale.y,objects[j].scale.z)}
		//}
		//myLayout["compartments_layout"]["spatial-layout"]=layoutdata;
		var indexStartNodes=maxNbComp+3;
		nbCompartments= listCompartments.length;
		//var indSelectedComp= SELECTED
		
		//console.log(SELECTED.name)
		//console.log(listCompartments.length);
		//console.log(scene.children[indexStartNodes])
		
		for (var c=indexStartNodes;c<indexStartNodes+2;c++){
			for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
				for (var g=0;g<nbCompartments;g++){
					//if (objects[g].scale<1.0){
					//	scene.children[c].geometry
					//}
					if (scene.children[c].geometry.attributes.compartment.array[h]==g){
						//console.log(scene.children[c].geometry)
						if (objects[g].name==cName){						
							scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[cName].x;//-stackCompInitialPos[cRef].x-stackCompInitialPos[cRef].x;
							scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[cName].y;//-stackCompInitialPos[cRef].y-stackCompInitialPos[cRef].y;
							scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[cName].z;//-stackCompInitialPos[cRef].z-stackCompInitialPos[cRef].z;
							
							var displacement = new THREE.Vector3(scene.children[c].geometry.attributes.position.array[h*3+0]- objects[g].position.x,
																 scene.children[c].geometry.attributes.position.array[h*3+1]- objects[g].position.y,
																 scene.children[c].geometry.attributes.position.array[h*3+2]- objects[g].position.z)
							if (objects[g].scale.x<1.0){
								scene.children[c].geometry.attributes.position.array[h*3+0]-=(displacement.x*(1-objects[g].scale.x));
								scene.children[c].geometry.attributes.position.array[h*3+1]-=(displacement.y*(1-objects[g].scale.y));
								scene.children[c].geometry.attributes.position.array[h*3+2]-=(displacement.z*(1-objects[g].scale.z));
								scene.children[c].geometry.attributes.size.array[h]*=0.417777;
							}
							if (objects[g].scale.x>1.0){
								var indLayer=-1;
								for (var ref in generalLayout["outer"]){
									if (generalLayout["outer"].hasOwnProperty(ref)){
										indLayer =generalLayout["outer"][ref].indexOf(objects[g].name);
										//if (indLayer!=-1){}
									}
								}
								if (indLayer>-1){
									var lengthV = displacement.length();
									displacement.setLength(lengthV+((indLayer+0.5)*radiusComp));
									scene.children[c].geometry.attributes.position.array[h*3+0]+=(displacement.x);
									scene.children[c].geometry.attributes.position.array[h*3+1]+=(displacement.y+radiusComp);
									scene.children[c].geometry.attributes.position.array[h*3+2]+=(displacement.z);
									scene.children[c].geometry.attributes.size.array[h]/=0.417777;
								}
								
								
							}
							//console.log(objects[g].scale.x)
						}
						else if (objects[g].name==cRef){
							scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x;
							scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y;
							scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z;
						}
						else{
							scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x-stackCompInitialPos[objects[g].name].x;
							scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y-stackCompInitialPos[objects[g].name].y;
							scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z-stackCompInitialPos[objects[g].name].z;
						}
						
						
						
					}
				}
			}
			scene.children[c].geometry.attributes.position.needsUpdate = true;
			scene.children[c].geometry.attributes.size.needsUpdate = true;
		}
		var iv=0;
		for ( var i = 0; i < segments; i ++ ) {
			var t1 = metabolicNodes[metabolicEdges[i][0]][6]
			var t2 = metabolicNodes[metabolicEdges[i][1]][6]
			//console.log(t1)
			//console.log(t2)
			//var ivList=[]
			var doIt=0
			if (t1==2){
				//console.log(idMap[jsonObj2[i][0]][1])
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
				
				iv++;
			}
			else if (t1==4){
				//console.log(idMap[jsonObj2[i][0]][1])
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
				iv++;
			}
			if (t2 ==2){
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
				iv++;
			}
			else if (t2 ==4){
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
				iv++;
			}
			
		}
		scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
		//console.log(myLayout);
		mtnlLayout["compartments_layout"]={};
		mtnlLayout["compartments_layout"]["relations"]=generalLayout;
		mtnlLayout["compartments_layout"]["name-position-scale"]=[];
		for (var i=0; i<listCompartments.length;i++ ){
			mtnlLayout["compartments_layout"]["name-position-scale"][i]=[objects[i].name, objects[i].position , objects[i].scale];
		}
		
		saveLayout();
		//console.log(mtnlLayout)
		//console.log(generalLayout)
	}
	
	//$("#container2").css({top:  $("#mtnTable").position().top + $("#mtnTable").height()+40});
	$("#mtnl-update-form").css({top:  $("#container").position().top + $("#container").height()+40});
	
	
	positionContainer = $("#container").position();
	function runModeSelector(){
		if ($('#modeSelector').val()=="0"){
			plane.visible = true;
			text1.innerHTML = '';
			text1.style.top = 2000 + 'px';
			text1.style.left = 2000 + 'px';
		}
		if ($('#modeSelector').val()=="1"){
			plane.visible = false;
		}
		//console.log($('#modeSelector').val());
	}
	
	function changeEditingPlane(){
		if ($('#editplane').val()=="0"){
			$('#editplane').val("1");
			$('#editplane').attr("src", "/images/editplane12.png");
			NodeEditingPlane.rotation.x += (90*(Math.PI / 180));
			//NodeEditingPlane.visible = true;
			//console.log($('#editplane').val());
		}
		else{
			$('#editplane').val("0");
			$('#editplane').attr("src", "/images/editplane1.png");
			NodeEditingPlane.rotation.x -= (90*(Math.PI / 180));
		}
	}
	
	function updateSlider(slideAmount){
	//console.log(slideAmount)
		var indexStartNodes=maxNbComp+3;
		for (var i=0;i<segmentPts;i++){
			scene.children[indexStartNodes+2].geometry.attributes.op.array[i]=(parseFloat(slideAmount)/100);	
		}
		scene.children[indexStartNodes+2].geometry.attributes.op.needsUpdate = true;
	}
	
	function saveLayout(){
		var mlength=JSON.stringify(mtnlLayout).length;
		var nbArrays=1;
		if (mlength>524288){
			nbArrays=parseInt(Math.ceil(mlength/524288.0));
		}
		if (nbArrays==1){
			document.getElementById("layouts0").value=JSON.stringify(mtnlLayout);
			//console.log(document.getElementById("layouts"+0).value.length)
		}
		else{
			var stringSfba=JSON.stringify(mtnlLayout);
			var chunksize=524288;
			var stringChunks=[];
			//console.log(mlength)
			for (var i=0;i<nbArrays;i++){
				stringChunks.push(stringSfba.substring((i*(chunksize-1)), ((i+1)*(chunksize-1))));
				document.getElementById("layouts"+i).value=stringChunks[i];
				//console.log(((i*(chunksize-1)))  +"  "+ (((i+1)*(chunksize-1))))
				//console.log(document.getElementById("layouts"+i).value.length)
			}
			//console.log(stringChunks)
		}
	}
	
	
	var indexStartNodes=maxNbComp+3;
		nbCompartments= listCompartments.length;
		//var indSelectedComp= SELECTED
		
		
		//console.log(listCompartments.length);
		//console.log(scene.children[indexStartNodes])
		
		for (var c=indexStartNodes;c<indexStartNodes+2;c++){
			for (var h=0, hh=scene.children[c].geometry.attributes.size.array.length;h<hh;h++){
				for (var g=0;g<nbCompartments;g++){
					//if (objects[g].scale<1.0){
					//	scene.children[c].geometry
					//}
					if (scene.children[c].geometry.attributes.compartment.array[h]==g){
						//console.log(scene.children[c].geometry)
						
							scene.children[c].geometry.attributes.position.array[h*3+0]+=objects[g].position.x;//-stackCompInitialPos[cRef].x-stackCompInitialPos[cRef].x;
							scene.children[c].geometry.attributes.position.array[h*3+1]+=objects[g].position.y;//-stackCompInitialPos[cRef].y-stackCompInitialPos[cRef].y;
							scene.children[c].geometry.attributes.position.array[h*3+2]+=objects[g].position.z;//-stackCompInitialPos[cRef].z-stackCompInitialPos[cRef].z;
							
							var displacement = new THREE.Vector3(scene.children[c].geometry.attributes.position.array[h*3+0]- objects[g].position.x,
																 scene.children[c].geometry.attributes.position.array[h*3+1]- objects[g].position.y,
																 scene.children[c].geometry.attributes.position.array[h*3+2]- objects[g].position.z)
							if (objects[g].scale.x<1.0){
								scene.children[c].geometry.attributes.position.array[h*3+0]-=(displacement.x*(1-objects[g].scale.x));
								scene.children[c].geometry.attributes.position.array[h*3+1]-=(displacement.y*(1-objects[g].scale.y));
								scene.children[c].geometry.attributes.position.array[h*3+2]-=(displacement.z*(1-objects[g].scale.z));
								scene.children[c].geometry.attributes.size.array[h]*=0.417777;
							}
							if (objects[g].scale.x>1.0){
								var indLayer=-1;
								for (var ref in generalLayout["outer"]){
									if (generalLayout["outer"].hasOwnProperty(ref)){
										indLayer =generalLayout["outer"][ref].indexOf(objects[g].name);
										//if (indLayer!=-1){}
									}
								}
								if (indLayer>-1){
									var lengthV = displacement.length();
									displacement.setLength(lengthV+((indLayer+0.5)*radiusComp));
									scene.children[c].geometry.attributes.position.array[h*3+0]+=(displacement.x);
									scene.children[c].geometry.attributes.position.array[h*3+1]+=(displacement.y+radiusComp/2);
									scene.children[c].geometry.attributes.position.array[h*3+2]+=(displacement.z);
									scene.children[c].geometry.attributes.size.array[h]/=0.417777;
								}
								
								
							}
						
						
					}
				}
			}
			scene.children[c].geometry.attributes.position.needsUpdate = true;
			scene.children[c].geometry.attributes.size.needsUpdate = true;
		}
		
		if (mtnlLayout["nodes_layout"]){
			var listDisplacedNodes = Object.keys(mtnlLayout["nodes_layout"]);
			if (listDisplacedNodes.length>0){
				//console.log(mtnlLayout["nodes_layout"])
				for(var i=0, ii= listDisplacedNodes.length;i<ii;i++){
					var typeNode=idMap[listDisplacedNodes[i]][0];
					var indexNode=idMap[listDisplacedNodes[i]][1];
					if (typeNode==2){
						scene.children[indexStartNodes].geometry.attributes.position.array[indexNode*3+0]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].x;
						scene.children[indexStartNodes].geometry.attributes.position.array[indexNode*3+1]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].y;
						scene.children[indexStartNodes].geometry.attributes.position.array[indexNode*3+2]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].z;
						
					}
					if (typeNode==4){
						scene.children[indexStartNodes+1].geometry.attributes.position.array[indexNode*3+0]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].x;
						scene.children[indexStartNodes+1].geometry.attributes.position.array[indexNode*3+1]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].y;
						scene.children[indexStartNodes+1].geometry.attributes.position.array[indexNode*3+2]=mtnlLayout["nodes_layout"][listDisplacedNodes[i]].z;
					}
				}
				scene.children[indexStartNodes].geometry.attributes.position.needsUpdate = true;
				scene.children[indexStartNodes+1].geometry.attributes.position.needsUpdate = true;
				//
				//
				//if (typeNode==2){console.log(""+2)}
				//if (typeNode==4){console.log(""+4)}
				//
				
			}
			//console.log("nodes layout")
			//
		}
		
		//console.log(metabolicNodes[9802])
		
		
		var iv=0;
		for ( var i = 0; i < segments; i ++ ) {
			var t1 = metabolicNodes[metabolicEdges[i][0]][6]
			var t2 = metabolicNodes[metabolicEdges[i][1]][6]
			//console.log(t1)
			//console.log(t2)
			//var ivList=[]
			var doIt=0
			if (t1==2){
				//console.log(idMap[jsonObj2[i][0]][1])
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;					
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
				
				iv++;
			}
			else if (t1==4){
				//console.log(idMap[jsonObj2[i][0]][1])
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 0 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 1 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][0]][1] * 3) + 2 ]+0.0;
				iv++;
			}
			if (t2 ==2){
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;						
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;	
				iv++;
			}
			else if (t2 ==4){
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3)+0 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 0 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 1 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 1 ]+0.0;
				scene.children[indexStartNodes+2].geometry.attributes.position.array[ (iv * 3) + 2 ] = scene.children[indexStartNodes+1].geometry.attributes.position.array[ (idMap[metabolicEdges[i][1]][1] * 3) + 2 ]+0.0;				
				iv++;
			}
			
		}
		scene.children[indexStartNodes+2].geometry.attributes.position.needsUpdate = true;
		
		
		
		
	
	</script>	
	
	
	
	
